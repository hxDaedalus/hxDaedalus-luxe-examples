{
"version":3,
"file":"BitmapPathfinding.js",
"sourceRoot":"file:///",
"sources":["C:/HaxeToolkit/haxe/std/js/_std/EReg.hx","C:/HaxeToolkit/haxe/std/js/_std/HxOverrides.hx","C:/HaxeToolkit/haxe/std/Lambda.hx","C:/HaxeToolkit/haxe/std/List.hx","c:/HaxeToolkit/haxe/luxe/git/Luxe.hx","D:/Downloads/Dev/Haxe/hxDaedalus-luxe-examples_git/hxDaedalus-Luxe-Examples/04-BitmapPathfinding/bin/web.build/haxe/LuxeApp.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/Emitter.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/Game.hx","D:/Downloads/Dev/Haxe/hxDaedalus-luxe-examples_git/hxDaedalus-Luxe-Examples/04-BitmapPathfinding/src/Main.hx","C:/HaxeToolkit/haxe/std/js/_std/Reflect.hx","C:/HaxeToolkit/haxe/std/js/_std/Std.hx","C:/HaxeToolkit/haxe/std/StringBuf.hx","C:/HaxeToolkit/haxe/std/StringTools.hx","C:/HaxeToolkit/haxe/std/js/_std/Type.hx","C:/HaxeToolkit/haxe/std/UInt.hx","C:/HaxeToolkit/haxe/std/haxe/CallStack.hx","C:/HaxeToolkit/haxe/std/haxe/Int64.hx","C:/HaxeToolkit/haxe/std/haxe/Log.hx","C:/HaxeToolkit/haxe/std/haxe/Resource.hx","C:/HaxeToolkit/haxe/std/haxe/Timer.hx","C:/HaxeToolkit/haxe/std/haxe/Utf8.hx","C:/HaxeToolkit/haxe/std/js/_std/haxe/io/Bytes.hx","C:/HaxeToolkit/haxe/std/haxe/crypto/Base64.hx","C:/HaxeToolkit/haxe/std/haxe/crypto/BaseCode.hx","C:/HaxeToolkit/haxe/std/haxe/crypto/Crc32.hx","C:/HaxeToolkit/haxe/std/haxe/crypto/Md5.hx","C:/HaxeToolkit/haxe/std/js/_std/haxe/ds/IntMap.hx","C:/HaxeToolkit/haxe/std/js/_std/haxe/ds/ObjectMap.hx","C:/HaxeToolkit/haxe/std/js/_std/haxe/ds/StringMap.hx","C:/HaxeToolkit/haxe/std/haxe/io/BytesBuffer.hx","C:/HaxeToolkit/haxe/std/haxe/io/Input.hx","C:/HaxeToolkit/haxe/std/haxe/io/BytesInput.hx","C:/HaxeToolkit/haxe/std/haxe/io/Eof.hx","C:/HaxeToolkit/haxe/std/haxe/io/FPHelper.hx","C:/HaxeToolkit/haxe/std/haxe/io/Path.hx","d:/Downloads/Dev/Haxe/hxDaedalus_git/src/hxDaedalus/ai/AStar.hx","d:/Downloads/Dev/Haxe/hxDaedalus_git/src/hxDaedalus/ai/EntityAI.hx","d:/Downloads/Dev/Haxe/hxDaedalus_git/src/hxDaedalus/ai/Funnel.hx","d:/Downloads/Dev/Haxe/hxDaedalus_git/src/hxDaedalus/ai/PathFinder.hx","d:/Downloads/Dev/Haxe/hxDaedalus_git/src/hxDaedalus/ai/trajectory/LinearPathSampler.hx","d:/Downloads/Dev/Haxe/hxDaedalus_git/src/hxDaedalus/data/ConstraintSegment.hx","d:/Downloads/Dev/Haxe/hxDaedalus_git/src/hxDaedalus/data/ConstraintShape.hx","d:/Downloads/Dev/Haxe/hxDaedalus_git/src/hxDaedalus/data/Edge.hx","d:/Downloads/Dev/Haxe/hxDaedalus_git/src/hxDaedalus/data/Face.hx","d:/Downloads/Dev/Haxe/hxDaedalus_git/src/hxDaedalus/data/Mesh.hx","d:/Downloads/Dev/Haxe/hxDaedalus_git/src/hxDaedalus/data/Object.hx","d:/Downloads/Dev/Haxe/hxDaedalus_git/src/hxDaedalus/data/Vertex.hx","d:/Downloads/Dev/Haxe/hxDaedalus_git/src/hxDaedalus/data/graph/Graph.hx","d:/Downloads/Dev/Haxe/hxDaedalus_git/src/hxDaedalus/data/graph/GraphEdge.hx","d:/Downloads/Dev/Haxe/hxDaedalus_git/src/hxDaedalus/data/graph/GraphNode.hx","d:/Downloads/Dev/Haxe/hxDaedalus_git/src/hxDaedalus/data/math/EdgeData.hx","d:/Downloads/Dev/Haxe/hxDaedalus_git/src/hxDaedalus/data/math/Point2D.hx","d:/Downloads/Dev/Haxe/hxDaedalus_git/src/hxDaedalus/data/math/Geom2D.hx","d:/Downloads/Dev/Haxe/hxDaedalus_git/src/hxDaedalus/data/math/Matrix2D.hx","d:/Downloads/Dev/Haxe/hxDaedalus_git/src/hxDaedalus/data/math/NodeData.hx","d:/Downloads/Dev/Haxe/hxDaedalus_git/src/hxDaedalus/data/math/Potrace.hx","d:/Downloads/Dev/Haxe/hxDaedalus_git/src/hxDaedalus/data/math/RandGenerator.hx","d:/Downloads/Dev/Haxe/hxDaedalus_git/src/hxDaedalus/data/math/ShapeSimplifier.hx","d:/Downloads/Dev/Haxe/hxDaedalus_git/src/hxDaedalus/debug/Debug.hx","d:/Downloads/Dev/Haxe/hxDaedalus_git/src/hxDaedalus/factories/BitmapObject.hx","d:/Downloads/Dev/Haxe/hxDaedalus_git/src/hxDaedalus/factories/RectMesh.hx","d:/Downloads/Dev/Haxe/hxDaedalus_git/src/hxDaedalus/graphics/Pixels.hx","d:/Downloads/Dev/Haxe/hxDaedalus_git/src/hxDaedalus/graphics/luxe/SimpleDrawingContext.hx","d:/Downloads/Dev/Haxe/hxDaedalus_git/src/hxDaedalus/iterators/FromFaceToInnerEdges.hx","d:/Downloads/Dev/Haxe/hxDaedalus_git/src/hxDaedalus/iterators/FromMeshToVertices.hx","d:/Downloads/Dev/Haxe/hxDaedalus_git/src/hxDaedalus/iterators/FromVertexToHoldingFaces.hx","d:/Downloads/Dev/Haxe/hxDaedalus_git/src/hxDaedalus/iterators/FromVertexToIncomingEdges.hx","d:/Downloads/Dev/Haxe/hxDaedalus_git/src/hxDaedalus/iterators/FromVertexToOutgoingEdges.hx","d:/Downloads/Dev/Haxe/hxDaedalus_git/src/hxDaedalus/view/SimpleView.hx","C:/HaxeToolkit/haxe/std/js/Boot.hx","C:/HaxeToolkit/haxe/std/js/html/CanvasElement.hx","C:/HaxeToolkit/haxe/std/js/html/compat/ArrayBuffer.hx","C:/HaxeToolkit/haxe/std/js/html/compat/DataView.hx","C:/HaxeToolkit/haxe/std/js/html/compat/Uint8Array.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/Audio.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/Log.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/Objects.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/Entity.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/structural/OrderedMap.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/Camera.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/macros/EntityRules.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/Component.hx","c:/HaxeToolkit/haxe/snow/git/snow/App.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/Core.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/Debug.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/Draw.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/Events.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/IO.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/Input.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/Visual.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/NineSlice.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/resource/Resources.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/Parcel.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/ParcelProgress.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/Physics.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/Scene.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/Screen.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/Sprite.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/Text.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/Timer.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/components/Components.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/debug/DebugView.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/debug/BatcherDebugView.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/debug/Inspector.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/debug/ProfilerDebugView.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/debug/StatsDebugView.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/debug/TraceDebugView.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/macros/BuildVersion.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/resource/Resource.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/structural/BalancedBST.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/tween/actuators/GenericActuator.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/tween/actuators/SimpleActuator.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/tween/easing/Quad.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/tween/Actuate.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/tween/MotionPath.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/tween/actuators/MethodActuator.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/tween/actuators/MotionPathActuator.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/tween/actuators/PropertyDetails.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/utils/GeometryUtils.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/utils/Maths.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/utils/Random.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/utils/Utils.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/utils/unifill/CodePoint.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/utils/unifill/CodePointIter.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/utils/unifill/InternalEncoding.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/utils/unifill/InternalEncodingIter.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/utils/unifill/Unicode.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/utils/unifill/Unifill.hx","c:/HaxeToolkit/haxe/luxe/git/luxe/utils/unifill/Utf16.hx","c:/HaxeToolkit/haxe/luxe/git/phoenix/BatchState.hx","c:/HaxeToolkit/haxe/luxe/git/phoenix/Batcher.hx","c:/HaxeToolkit/haxe/snow/git/snow/io/typedarray/Float32Array.hx","c:/HaxeToolkit/haxe/luxe/git/phoenix/BitmapFont.hx","c:/HaxeToolkit/haxe/luxe/git/phoenix/Camera.hx","c:/HaxeToolkit/haxe/luxe/git/phoenix/Circle.hx","c:/HaxeToolkit/haxe/luxe/git/phoenix/Color.hx","c:/HaxeToolkit/haxe/luxe/git/phoenix/Matrix.hx","c:/HaxeToolkit/haxe/luxe/git/phoenix/Quaternion.hx","c:/HaxeToolkit/haxe/luxe/git/phoenix/Ray.hx","c:/HaxeToolkit/haxe/luxe/git/phoenix/Rectangle.hx","c:/HaxeToolkit/haxe/luxe/git/phoenix/RenderPath.hx","c:/HaxeToolkit/haxe/luxe/git/phoenix/RenderState.hx","c:/HaxeToolkit/haxe/luxe/git/phoenix/Texture.hx","c:/HaxeToolkit/haxe/luxe/git/phoenix/RenderTexture.hx","c:/HaxeToolkit/haxe/luxe/git/phoenix/Renderer.hx","c:/HaxeToolkit/haxe/luxe/git/phoenix/Shader.hx","c:/HaxeToolkit/haxe/luxe/git/phoenix/Transform.hx","c:/HaxeToolkit/haxe/luxe/git/phoenix/Vector.hx","c:/HaxeToolkit/haxe/luxe/git/phoenix/geometry/Geometry.hx","c:/HaxeToolkit/haxe/luxe/git/phoenix/geometry/CircleGeometry.hx","c:/HaxeToolkit/haxe/luxe/git/phoenix/geometry/RingGeometry.hx","c:/HaxeToolkit/haxe/luxe/git/phoenix/geometry/ArcGeometry.hx","c:/HaxeToolkit/haxe/luxe/git/phoenix/geometry/CompositeGeometry.hx","c:/HaxeToolkit/haxe/luxe/git/phoenix/geometry/GeometryState.hx","c:/HaxeToolkit/haxe/luxe/git/phoenix/geometry/LineGeometry.hx","c:/HaxeToolkit/haxe/luxe/git/phoenix/geometry/PlaneGeometry.hx","c:/HaxeToolkit/haxe/luxe/git/phoenix/geometry/QuadGeometry.hx","c:/HaxeToolkit/haxe/luxe/git/phoenix/geometry/QuadPackGeometry.hx","c:/HaxeToolkit/haxe/luxe/git/phoenix/geometry/RectangleGeometry.hx","c:/HaxeToolkit/haxe/luxe/git/phoenix/geometry/TextGeometry.hx","c:/HaxeToolkit/haxe/luxe/git/phoenix/geometry/TextureCoord.hx","c:/HaxeToolkit/haxe/luxe/git/phoenix/geometry/Vertex.hx","c:/HaxeToolkit/haxe/luxe/git/phoenix/utils/Rendering.hx","c:/HaxeToolkit/haxe/snow/git/snow/Core.hx","c:/HaxeToolkit/haxe/snow/git/snow/utils/AbstractClass.hx","c:/HaxeToolkit/haxe/snow/git/snow/Log.hx","c:/HaxeToolkit/haxe/snow/git/snow/Snow.hx","c:/HaxeToolkit/haxe/snow/git/snow/assets/Asset.hx","c:/HaxeToolkit/haxe/snow/git/snow/assets/AssetAudio.hx","c:/HaxeToolkit/haxe/snow/git/snow/assets/AssetBytes.hx","c:/HaxeToolkit/haxe/snow/git/snow/assets/AssetImage.hx","c:/HaxeToolkit/haxe/snow/git/snow/assets/AssetSystem.hx","c:/HaxeToolkit/haxe/snow/git/snow/assets/AssetText.hx","c:/HaxeToolkit/haxe/snow/git/snow/assets/Assets.hx","c:/HaxeToolkit/haxe/snow/git/snow/audio/Audio.hx","c:/HaxeToolkit/haxe/snow/git/snow/audio/AudioSystem.hx","c:/HaxeToolkit/haxe/snow/git/snow/audio/Sound.hx","c:/HaxeToolkit/haxe/snow/git/snow/input/Input.hx","c:/HaxeToolkit/haxe/snow/git/snow/input/InputSystem.hx","c:/HaxeToolkit/haxe/snow/git/snow/input/Keycodes.hx","c:/HaxeToolkit/haxe/snow/git/snow/io/IO.hx","c:/HaxeToolkit/haxe/snow/git/snow/io/IOSystem.hx","c:/HaxeToolkit/haxe/snow/git/snow/io/typedarray/Int32Array.hx","c:/HaxeToolkit/haxe/snow/git/snow/io/typedarray/Uint8Array.hx","c:/HaxeToolkit/haxe/snow/git/snow/platform/web/Core.hx","c:/HaxeToolkit/haxe/snow/git/snow/platform/web/assets/AssetSystem.hx","c:/HaxeToolkit/haxe/snow/git/snow/platform/web/assets/psd/PSD.hx","c:/HaxeToolkit/haxe/snow/git/snow/platform/web/audio/AudioSystem.hx","c:/HaxeToolkit/haxe/snow/git/snow/platform/web/audio/Sound.hx","c:/HaxeToolkit/haxe/snow/git/snow/platform/web/audio/howlerjs/Sound.hx","c:/HaxeToolkit/haxe/snow/git/snow/platform/web/audio/SoundStream.hx","c:/HaxeToolkit/haxe/snow/git/snow/platform/web/audio/howlerjs/AudioSystem.hx","c:/HaxeToolkit/haxe/snow/git/snow/platform/web/audio/howlerjs/SoundStream.hx","c:/HaxeToolkit/haxe/snow/git/snow/platform/web/input/DOMKeys.hx","c:/HaxeToolkit/haxe/snow/git/snow/platform/web/input/InputSystem.hx","c:/HaxeToolkit/haxe/snow/git/snow/platform/web/io/IOSystem.hx","c:/HaxeToolkit/haxe/snow/git/snow/platform/web/render/opengl/GL.hx","c:/HaxeToolkit/haxe/snow/git/snow/window/WindowSystem.hx","c:/HaxeToolkit/haxe/snow/git/snow/platform/web/window/WindowSystem.hx","c:/HaxeToolkit/haxe/snow/git/snow/utils/Libs.hx","c:/HaxeToolkit/haxe/snow/git/snow/utils/Promise.hx","c:/HaxeToolkit/haxe/snow/git/snow/utils/Timer.hx","c:/HaxeToolkit/haxe/snow/git/snow/utils/format/png/Reader.hx","c:/HaxeToolkit/haxe/snow/git/snow/utils/format/png/Tools.hx","c:/HaxeToolkit/haxe/snow/git/snow/utils/format/tools/Adler32.hx","c:/HaxeToolkit/haxe/snow/git/snow/utils/format/tools/Deflate.hx","c:/HaxeToolkit/haxe/snow/git/snow/utils/format/tools/Huffman.hx","c:/HaxeToolkit/haxe/snow/git/snow/utils/format/tools/Inflate.hx","c:/HaxeToolkit/haxe/snow/git/snow/utils/format/tools/InflateImpl.hx","c:/HaxeToolkit/haxe/snow/git/snow/window/Window.hx","c:/HaxeToolkit/haxe/snow/git/snow/window/Windowing.hx","d:/Downloads/Dev/Haxe/hxDaedalus_git/src/hxDaedalus/data/Constants.hx"],
"sourcesContent":["/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:coreApi class EReg {\n\n\tvar r : HaxeRegExp;\n\n\tpublic function new( r : String, opt : String ) : Void {\n\t\topt = opt.split(\"u\").join(\"\"); // 'u' (utf8) depends on page encoding\n\t\tthis.r = new HaxeRegExp(r, opt);\n\t}\n\n\tpublic function match( s : String ) : Bool {\n\t\tif( r.global ) r.lastIndex = 0;\n\t\tr.m = r.exec(s);\n\t\tr.s = s;\n\t\treturn (r.m != null);\n\t}\n\n\tpublic function matched( n : Int ) : String {\n\t\treturn if( r.m != null && n >= 0 && n < r.m.length ) r.m[n] else throw \"EReg::matched\";\n\t}\n\n\tpublic function matchedLeft() : String {\n\t\tif( r.m == null ) throw \"No string matched\";\n\t\treturn r.s.substr(0,r.m.index);\n\t}\n\n\tpublic function matchedRight() : String {\n\t\tif( r.m == null ) throw \"No string matched\";\n\t\tvar sz = r.m.index+r.m[0].length;\n\t\treturn r.s.substr(sz,r.s.length-sz);\n\t}\n\n\tpublic function matchedPos() : { pos : Int, len : Int } {\n\t\tif( r.m == null ) throw \"No string matched\";\n\t\treturn { pos : r.m.index, len : r.m[0].length };\n\t}\n\n\tpublic function matchSub( s : String, pos : Int, len : Int = -1):Bool {\n\t\treturn if (r.global) {\n\t\t\tr.lastIndex = pos;\n\t\t\tr.m = r.exec(len < 0 ? s : s.substr(0, pos + len));\n\t\t\tvar b = r.m != null;\n\t\t\tif (b) {\n\t\t\t\tr.s = s;\n\t\t\t}\n\t\t\tb;\n\t\t} else {\n\t\t\t// TODO: check some ^/$ related corner cases\n\t\t\tvar b = match( len < 0 ? s.substr(pos) : s.substr(pos,len) );\n\t\t\tif (b) {\n\t\t\t\tr.s = s;\n\t\t\t\tr.m.index += pos;\n\t\t\t}\n\t\t\tb;\n\t\t}\n\t}\n\n\tpublic function split( s : String ) : Array<String> {\n\t\t// we can't use directly s.split because it's ignoring the 'g' flag\n\t\tvar d = \"#__delim__#\";\n\t\treturn untyped s.replace(r,d).split(d);\n\t}\n\n\tpublic function replace( s : String, by : String ) : String {\n\t\treturn untyped s.replace(r,by);\n\t}\n\n\tpublic function map( s : String, f : EReg -> String ) : String {\n\t\tvar offset = 0;\n\t\tvar buf = new StringBuf();\n\t\tdo {\n\t\t\tif (offset >= s.length)\n\t\t\t\tbreak;\n\t\t\telse if (!matchSub(s, offset)) {\n\t\t\t\tbuf.add(s.substr(offset));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvar p = matchedPos();\n\t\t\tbuf.add(s.substr(offset, p.pos - offset));\n\t\t\tbuf.add(f(this));\n\t\t\tif (p.len == 0) {\n\t\t\t\tbuf.add(s.substr(p.pos, 1));\n\t\t\t\toffset = p.pos + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t\toffset = p.pos + p.len;\n\t\t} while (r.global);\n\t\tif (!r.global && offset > 0 && offset < s.length)\n\t\t\tbuf.add(s.substr(offset));\n\t\treturn buf.toString();\n\t}\n}\n\n@:native(\"RegExp\")\nprivate extern class HaxeRegExp extends js.RegExp {\n\tvar m:js.RegExp.RegExpMatch;\n\tvar s:String;\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:noDoc\nclass HxOverrides {\n\n\tstatic function dateStr( date :Date ) : String {\n\t\tvar m = date.getMonth() + 1;\n\t\tvar d = date.getDate();\n\t\tvar h = date.getHours();\n\t\tvar mi = date.getMinutes();\n\t\tvar s = date.getSeconds();\n\t\treturn date.getFullYear()\n\t\t\t+\"-\"+(if( m < 10 ) \"0\"+m else \"\"+m)\n\t\t\t+\"-\"+(if( d < 10 ) \"0\"+d else \"\"+d)\n\t\t\t+\" \"+(if( h < 10 ) \"0\"+h else \"\"+h)\n\t\t\t+\":\"+(if( mi < 10 ) \"0\"+mi else \"\"+mi)\n\t\t\t+\":\"+(if( s < 10 ) \"0\"+s else \"\"+s);\n\t}\n\n\tstatic function strDate( s : String ) : Date {\n\t\tswitch( s.length ) {\n\t\tcase 8: // hh:mm:ss\n\t\t\tvar k = s.split(\":\");\n\t\t\tvar d : Date = untyped __new__(Date);\n\t\t\tuntyped d[\"setTime\"](0);\n\t\t\tuntyped d[\"setUTCHours\"](k[0]);\n\t\t\tuntyped d[\"setUTCMinutes\"](k[1]);\n\t\t\tuntyped d[\"setUTCSeconds\"](k[2]);\n\t\t\treturn d;\n\t\tcase 10: // YYYY-MM-DD\n\t\t\tvar k = s.split(\"-\");\n\t\t\treturn new Date(cast k[0],cast untyped k[1] - 1,cast k[2],0,0,0);\n\t\tcase 19: // YYYY-MM-DD hh:mm:ss\n\t\t\tvar k = s.split(\" \");\n\t\t\tvar y = k[0].split(\"-\");\n\t\t\tvar t = k[1].split(\":\");\n\t\t\treturn new Date(cast y[0],cast untyped y[1] - 1,cast y[2],cast t[0],cast t[1],cast t[2]);\n\t\tdefault:\n\t\t\tthrow \"Invalid date format : \" + s;\n\t\t}\n\t}\n\n\tstatic function cca( s : String, index : Int ) : Null<Int> {\n\t\tvar x = (cast s).charCodeAt(index);\n\t\tif( x != x ) // fast isNaN\n\t\t\treturn untyped undefined; // isNaN will still return true\n\t\treturn x;\n\t}\n\n\tstatic function substr( s : String, pos : Int, ?len : Int ) : String {\n\t\tif( pos != null && pos != 0 && len != null && len < 0 ) return \"\";\n\t\tif( len == null ) len = s.length;\n\t\tif( pos < 0 ){\n\t\t\tpos = s.length + pos;\n\t\t\tif( pos < 0 ) pos = 0;\n\t\t}else if( len < 0 ){\n\t\t\tlen = s.length + len - pos;\n\t\t}\n\n\t\treturn (untyped s).substr(pos, len);\n\t}\n\n\tstatic function indexOf<T>( a : Array<T>, obj : T, i : Int) {\n\t\tvar len = a.length;\n\t\tif (i < 0) {\n\t\t\ti += len;\n\t\t\tif (i < 0) i = 0;\n\t\t}\n\t\twhile (i < len)\n\t\t{\n\t\t\tif (untyped __js__(\"a[i] === obj\"))\n\t\t\t\treturn i;\n\t\t\ti++;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic function lastIndexOf<T>( a : Array<T>, obj : T, i : Int) {\n\t\tvar len = a.length;\n\t\tif (i >= len)\n\t\t\ti = len - 1;\n\t\telse if (i < 0)\n\t\t\ti += len;\n\t\twhile (i >= 0)\n\t\t{\n\t\t\tif (untyped __js__(\"a[i] === obj\"))\n\t\t\t\treturn i;\n\t\t\ti--;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic function remove<T>( a : Array<T>, obj : T ) {\n\t\tvar i = a.indexOf(obj);\n\t\tif( i == -1 ) return false;\n\t\ta.splice(i,1);\n\t\treturn true;\n\t}\n\n\tstatic function iter<T>( a : Array<T> ) : Iterator<T> untyped {\n\t\treturn {\n\t\t\tcur : 0,\n\t\t\tarr : a,\n\t\t\thasNext : function() {\n\t\t\t\treturn __this__.cur < __this__.arr.length;\n\t\t\t},\n\t\t\tnext : function() {\n\t\t\t\treturn __this__.arr[__this__.cur++];\n\t\t\t}\n\t\t};\n\t}\n\n\tstatic function __init__() untyped {\n#if !js_es5\n\t\t__feature__('HxOverrides.indexOf', if( Array.prototype.indexOf ) __js__(\"HxOverrides\").indexOf = function(a,o,i) return Array.prototype.indexOf.call(a, o, i));\n\t\t__feature__('HxOverrides.lastIndexOf', if( Array.prototype.lastIndexOf ) __js__(\"HxOverrides\").lastIndexOf = function(a,o,i) return Array.prototype.lastIndexOf.call(a, o, i));\n#end\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\n/**\n\tThe `Lambda` class is a collection of methods to support functional\n\tprogramming. It is ideally used with 'using Lambda' and then acts as an\n\textension to Iterable types.\n\n\tOn static platforms, working with the Iterable structure might be slower\n\tthan performing the operations directly on known types, such as Array and\n\tList.\n\n\tIf the first argument to any of the methods is null, the result is\n\tunspecified.\n**/\nclass Lambda {\n\n\t/**\n\t\tCreates an Array from Iterable `it`.\n\n\t\tIf `it` is an Array, this function returns a copy of it.\n\t**/\n\tpublic static function array<A>( it : Iterable<A> ) : Array<A> {\n\t\tvar a = new Array<A>();\n\t\tfor(i in it)\n\t\t\ta.push(i);\n\t\treturn a;\n\t}\n\n\t/**\n\t\tCreates a List form Iterable `it`.\n\n\t\tIf `it` is a List, this function returns a copy of it.\n\t**/\n\tpublic static function list<A>( it : Iterable<A> ) : List<A> {\n\t\tvar l = new List<A>();\n\t\tfor(i in it)\n\t\t\tl.add(i);\n\t\treturn l;\n\t}\n\n\t/**\n\t\tCreates a new List by applying function `f` to all elements of `it`.\n\n\t\tThe order of elements is preserved.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function map<A,B>( it : Iterable<A>, f : A -> B ) : List<B> {\n\t\tvar l = new List<B>();\n\t\tfor( x in it )\n\t\t\tl.add(f(x));\n\t\treturn l;\n\t}\n\n\t/**\n\t\tSimilar to map, but also passes the index of each element to `f`.\n\n\t\tThe order of elements is preserved.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function mapi<A,B>( it : Iterable<A>, f : Int -> A -> B ) : List<B> {\n\t\tvar l = new List<B>();\n\t\tvar i = 0;\n\t\tfor( x in it )\n\t\t\tl.add(f(i++,x));\n\t\treturn l;\n\t}\n\n\t/**\n\t\tTells if `it` contains `elt`.\n\n\t\tThis function returns true as soon as an element is found which is equal\n\t\tto `elt` according to the `==` operator.\n\n\t\tIf no such element is found, the result is false.\n\t**/\n\tpublic static function has<A>( it : Iterable<A>, elt : A ) : Bool {\n\t\tfor( x in it )\n\t\t\tif( x == elt )\n\t\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\t/**\n\t\tTells if `it` contains an element for which `f` is true.\n\n\t\tThis function returns true as soon as an element is found for which a\n\t\tcall to `f` returns true.\n\n\t\tIf no such element is found, the result is false.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function exists<A>( it : Iterable<A>, f : A -> Bool ) {\n\t\tfor( x in it )\n\t\t\tif( f(x) )\n\t\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\t/**\n\t\tTells if `f` is true for all elements of `it`.\n\n\t\tThis function returns false as soon as an element is found for which a\n\t\tcall to `f` returns false.\n\n\t\tIf no such element is found, the result is true.\n\n\t\tIn particular, this function always returns true if `it` is empty.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function foreach<A>( it : Iterable<A>, f : A -> Bool ) {\n\t\tfor( x in it )\n\t\t\tif( !f(x) )\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t/**\n\t\tCalls `f` on all elements of `it`, in order.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function iter<A>( it : Iterable<A>, f : A -> Void ) {\n\t\tfor( x in it )\n\t\t\tf(x);\n\t}\n\n\t/**\n\t\tReturns a List containing those elements of `it` for which `f` returned\n\t\ttrue.\n\n\t\tIf `it` is empty, the result is the empty List even if `f` is null.\n\n\t\tOtherwise if `f` is null, the result is unspecified.\n\t**/\n\tpublic static function filter<A>( it : Iterable<A>, f : A -> Bool ) {\n\t\tvar l = new List<A>();\n\t\tfor( x in it )\n\t\t\tif( f(x) )\n\t\t\t\tl.add(x);\n\t\treturn l;\n\t}\n\n\t/**\n\t\tFunctional fold on Iterable `it`, using function `f` with start argument\n\t\t`first`.\n\n\t\tIf `it` has no elements, the result is `first`.\n\n\t\tOtherwise the first element of `it` is passed to `f` alongside `first`.\n\t\tThe result of that call is then passed to `f` with the next element of\n\t\t`it`, and so on until `it` has no more elements.\n\n\t\tIf `it` or `f` are null, the result is unspecified.\n\t**/\n\tpublic static function fold<A,B>( it : Iterable<A>, f : A -> B -> B, first : B ) : B {\n\t\tfor( x in it )\n\t\t\tfirst = f(x,first);\n\t\treturn first;\n\t}\n\n\t/**\n\t\tReturns the number of elements in `it` for which `pred` is true, or the\n\t\ttotal number of elements in `it` if `pred` is null.\n\n\t\tThis function traverses all elements.\n\t**/\n\tpublic static function count<A>( it : Iterable<A>, ?pred : A -> Bool ) {\n\t\tvar n = 0;\n\t\tif( pred == null )\n\t\t\tfor( _ in it )\n\t\t\t\tn++;\n\t\telse\n\t\t\tfor( x in it )\n\t\t\t\tif( pred(x) )\n\t\t\t\t\tn++;\n\t\treturn n;\n\t}\n\n\t/**\n\t\tTells if Iterable `it` does not contain any element.\n\t**/\n\tpublic static function empty<T>( it : Iterable<T> ) : Bool {\n\t\treturn !it.iterator().hasNext();\n\t}\n\n\t/**\n\t\tReturns the index of the first element `v` within Iterable `it`.\n\n\t\tThis function uses operator `==` to check for equality.\n\n\t\tIf `v` does not exist in `it`, the result is -1.\n\t**/\n\tpublic static function indexOf<T>( it : Iterable<T>, v : T ) : Int {\n\t\tvar i = 0;\n\t\tfor( v2 in it ) {\n\t\t\tif( v == v2 )\n\t\t\t\treturn i;\n\t\t\ti++;\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t\tReturns the first element of `it` for which `f` is true.\n\n\t\tThis function returns as soon as an element is found for which a call to\n\t\t`f` returns true.\n\n\t\tIf no such element is found, the result is null.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function find<T>( it : Iterable<T>, f : T -> Bool ) : Null<T> {\n\t\tfor( v in it ) {\n\t\t\tif(f(v)) return v;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t\tReturns a new List containing all elements of Iterable `a` followed by\n\t\tall elements of Iterable `b`.\n\n\t\tIf `a` or `b` are null, the result is unspecified.\n\t**/\n\tpublic static function concat<T>( a : Iterable<T>, b : Iterable<T> ) : List<T> {\n\t\tvar l = new List();\n\t\tfor( x in a )\n\t\t\tl.add(x);\n\t\tfor( x in b )\n\t\t\tl.add(x);\n\t\treturn l;\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n\tA linked-list of elements. The list is composed of two-elements arrays\n\tthat are chained together. It is optimized so that adding or removing an\n\telement does not imply copying the whole array content every time.\n**/\nclass List<T> {\n\n\tprivate var h : Array<Dynamic>;\n\tprivate var q : Array<Dynamic>;\n\n\t/**\n\t\tThe length of `this` List.\n\t**/\n\tpublic var length(default,null) : Int;\n\n\t/**\n\t\tCreates a new empty list.\n\t**/\n\tpublic function new() {\n\t\tlength = 0;\n\t}\n\n\t/**\n\t\tAdds element `item` at the end of `this` List.\n\n\t\t`this.length` increases by 1.\n\t**/\n\tpublic function add( item : T ) {\n\t\tvar x:Array<Dynamic> = #if neko untyped __dollar__array(item,null) #else [item] #end;\n\t\tif( h == null )\n\t\t\th = x;\n\t\telse\n\t\t\tq[1] = x;\n\t\tq = x;\n\t\tlength++;\n\t}\n\n\t/**\n\t\tAdds element `item` at the beginning of `this` List.\n\n\t\t`this.length` increases by 1.\n\t**/\n\tpublic function push( item : T ) {\n\t\tvar x : Array<Dynamic> = #if neko\n\t\t\tuntyped __dollar__array(item,h)\n\t\t#else\n\t\t\t[item,h]\n\t\t#end;\n\t\th = x;\n\t\tif( q == null )\n\t\t\tq = x;\n\t\tlength++;\n\t}\n\n\t/**\n\t\tReturns the first element of `this` List, or null if no elements exist.\n\n\t\tThis function does not modify `this` List.\n\t**/\n\tpublic function first() : Null<T> {\n\t\treturn if( h == null ) null else h[0];\n\t}\n\n\t/**\n\t\tReturns the last element of `this` List, or null if no elements exist.\n\n\t\tThis function does not modify `this` List.\n\t**/\n\tpublic function last() : Null<T> {\n\t\treturn if( q == null ) null else q[0];\n\t}\n\n\n\t/**\n\t\tReturns the first element of `this` List, or null if no elements exist.\n\n\t\tThe element is removed from `this` List.\n\t**/\n\tpublic function pop() : Null<T> {\n\t\tif( h == null )\n\t\t\treturn null;\n\t\tvar x = h[0];\n\t\th = h[1];\n\t\tif( h == null )\n\t\t\tq = null;\n\t\tlength--;\n\t\treturn x;\n\t}\n\n\t/**\n\t\tTells if `this` List is empty.\n\t**/\n\tpublic function isEmpty() : Bool {\n\t\treturn (h == null);\n\t}\n\n\t/**\n\t\tEmpties `this` List.\n\n\t\tThis function does not traverse the elements, but simply sets the\n\t\tinternal references to null and `this.length` to 0.\n\t**/\n\tpublic function clear() : Void {\n\t\th = null;\n\t\tq = null;\n\t\tlength = 0;\n\t}\n\n\t/**\n\t\tRemoves the first occurence of `v` in `this` List.\n\n\t\tIf `v` is found by checking standard equality, it is removed from `this`\n\t\tList and the function returns true.\n\n\t\tOtherwise, false is returned.\n\t**/\n\tpublic function remove( v : T ) : Bool {\n\t\tvar prev = null;\n\t\tvar l = h;\n\t\twhile( l != null ) {\n\t\t\tif( l[0] == v ) {\n\t\t\t\tif( prev == null )\n\t\t\t\t\th = l[1];\n\t\t\t\telse\n\t\t\t\t\tprev[1] = l[1];\n\t\t\t\tif( q == l )\n\t\t\t\t\tq = prev;\n\t\t\t\tlength--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tprev = l;\n\t\t\tl = l[1];\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t\tReturns an iterator on the elements of the list.\n\t**/\n\tpublic inline function iterator() : ListIterator<T> {\n\t\treturn new ListIterator<T>(h);\n\t}\n\n\t/**\n\t\tReturns a string representation of `this` List.\n\n\t\tThe result is enclosed in { } with the individual elements being\n\t\tseparated by a comma.\n\t**/\n\tpublic function toString() {\n\t\tvar s = new StringBuf();\n\t\tvar first = true;\n\t\tvar l = h;\n\t\ts.add(\"{\");\n\t\twhile( l != null ) {\n\t\t\tif( first )\n\t\t\t\tfirst = false;\n\t\t\telse\n\t\t\t\ts.add(\", \");\n\t\t\ts.add(Std.string(l[0]));\n\t\t\tl = l[1];\n\t\t}\n\t\ts.add(\"}\");\n\t\treturn s.toString();\n\t}\n\n\t/**\n\t\tReturns a string representation of `this` List, with `sep` separating\n\t\teach element.\n\t**/\n\tpublic function join(sep : String) {\n\t\tvar s = new StringBuf();\n\t\tvar first = true;\n\t\tvar l = h;\n\t\twhile( l != null ) {\n\t\t\tif( first )\n\t\t\t\tfirst = false;\n\t\t\telse\n\t\t\t\ts.add(sep);\n\t\t\ts.add(l[0]);\n\t\t\tl = l[1];\n\t\t}\n\t\treturn s.toString();\n\t}\n\n\t/**\n\t\tReturns a list filtered with `f`. The returned list will contain all\n\t\telements for which `f(x) == true`.\n\t**/\n\tpublic function filter( f : T -> Bool ) {\n\t\tvar l2 = new List();\n\t\tvar l = h;\n\t\twhile( l != null ) {\n\t\t\tvar v = l[0];\n\t\t\tl = l[1];\n\t\t\tif( f(v) )\n\t\t\t\tl2.add(v);\n\t\t}\n\t\treturn l2;\n\t}\n\n\t/**\n\t\tReturns a new list where all elements have been converted by the\n\t\tfunction `f`.\n\t**/\n\tpublic function map<X>(f : T -> X) : List<X> {\n\t\tvar b = new List();\n\t\tvar l = h;\n\t\twhile( l != null ) {\n\t\t\tvar v = l[0];\n\t\t\tl = l[1];\n\t\t\tb.add(f(v));\n\t\t}\n\t\treturn b;\n\t}\n\n}\n\nprivate class ListIterator<T> {\n\tvar head:Array<Dynamic>;\n\tvar val:Dynamic;\n\n\tpublic inline function new(head:Array<Dynamic>) {\n\t\tthis.head = head;\n\t\tthis.val = null;\n\t}\n\n\tpublic inline function hasNext():Bool {\n\t\treturn head != null;\n\t}\n\n\tpublic inline function next():T {\n\t\tval = head[0];\n\t\thead = head[1];\n\t\treturn val;\n\t}\n}\n","package ;\r\n\r\nimport phoenix.BitmapFont;\r\nimport phoenix.geometry.Geometry;\r\nimport phoenix.Texture;\r\nimport phoenix.Shader;\r\nimport phoenix.Batcher;\r\n\r\nimport luxe.resource.Resource;\r\n\r\nimport luxe.Rectangle;\r\nimport luxe.Vector;\r\nimport luxe.Screen;\r\n\r\n@:keep\r\nclass Luxe {\r\n\r\n        /** Direct access to the core engine */\r\n    public static var core      : luxe.Core;\r\n        /** Access to the core debug features */\r\n    public static var debug     : luxe.Debug;\r\n        /** Access to the io features */\r\n    public static var io        : luxe.IO;\r\n        /** Access to the drawing features */\r\n    public static var draw      : luxe.Draw;\r\n        /** Access to the audio features */\r\n    public static var audio     : luxe.Audio;\r\n        /** Access to the timing features */\r\n    public static var timer     : luxe.Timer;\r\n        /** Access to the global event system */\r\n    public static var events    : luxe.Events;\r\n        /** Access to the input features */\r\n    public static var input     : luxe.Input;\r\n        /** Access to the default luxe scene */\r\n    public static var scene     : luxe.Scene;\r\n        /** Access to the different utilities */\r\n    public static var utils     : luxe.utils.Utils;\r\n        /** Access to the physics bindings, if any */\r\n    public static var physics   : luxe.Physics;\r\n        /** Access to the default camera */\r\n    public static var camera    : luxe.Camera;\r\n        /** Access to the default resource manager  */\r\n    public static var resources : luxe.resource.Resources;\r\n        /** Access to the rendering system */\r\n    public static var renderer  : phoenix.Renderer;\r\n\r\n        /** The current time in seconds, highest precision from the platform. */\r\n    @:isVar public static var time(get, never) : Float;\r\n        /** Access to information about the game window (sizes, cursor etc) */\r\n    @:isVar public static var screen(get, never) : Screen;\r\n        /** The version of the engine  */\r\n    public static var version : String = 'dev';\r\n        /** The version + build meta information, generated at compile time from a macro (luxe.BuildVersion) */\r\n    public static var build : String = luxe.macros.BuildVersion.latest();\r\n\r\n//Timing information proxy to the snow App timing\r\n\r\n        /** the scale of time */\r\n    public static var timescale (get,set) : Float;\r\n        /** if this is non zero this will be passed in */\r\n    public static var fixed_delta (get,set) : Float;\r\n        /** if this is non zero, updates will be forced to this rate */\r\n    public static var update_rate (get,set) : Float;\r\n        /** the maximum frame time */\r\n    public static var max_frame_time (get,set) : Float;\r\n\r\n//Timing information\r\n\r\n        /** the time the last frame took to run */\r\n    public static var dt (get,set) : Float;\r\n        /** the simulated time the last frame took to run, relative to scale etc */\r\n    public static var delta_sim (get,set) : Float;\r\n        /** the start time of the last frame */\r\n    public static var last_frame_start (get,set) : Float;\r\n        /** the current simulation time */\r\n    public static var current_time (get,set) : Float;\r\n        /** the start time of this frame */\r\n    public static var cur_frame_start (get,set) : Float;\r\n        /** the alpha time for a render between frame updates */\r\n    public static var alpha (get,set) : Float;\r\n\r\n        /** listen for core events */\r\n    public static function on<T>(event:Ev, handler:T->Void ) {\r\n        core.emitter.on(event, handler);\r\n    }\r\n\r\n        /** stop listening for core events */\r\n    public static function off<T>(event:Ev, handler:T->Void ) {\r\n        return core.emitter.off(event, handler);\r\n    }\r\n\r\n    static inline function get_screen() {\r\n\r\n        return core.screen;\r\n\r\n    } //get_screen\r\n\r\n    static inline function get_time() : Float {\r\n\r\n        return core.app.time;\r\n\r\n    } //get_time\r\n\r\n        /** shutdown the engine and quit */\r\n    public static function shutdown() {\r\n\r\n        core.shutdown();\r\n\r\n    } //shutdown\r\n\r\n        /** show/hide the debug console programmatically */\r\n    public static function showConsole(_show:Bool) {\r\n\r\n        core.show_console( _show );\r\n\r\n    } //showConsole\r\n\r\n        /** Load a text resource */\r\n    public static function loadJSON( _id:String, ?_onload:JSONResource->Void ) : JSONResource {\r\n\r\n            //first check if this is already loaded\r\n            //:todo: note that this is is changing in alpha-2.0\r\n        if( Luxe.resources.json.exists(_id) ) {\r\n            luxe.Log.log('loadJSON - return existing $_id');\r\n            var res = Luxe.resources.find_json(_id);\r\n            if(_onload != null) _onload( res );\r\n            return res;\r\n        }\r\n\r\n        var res = new JSONResource( _id, null, Luxe.resources );\r\n\r\n        core.app.assets.text(_id, {\r\n            onload : function( _asset:snow.assets.AssetText) {\r\n\r\n                res.json = haxe.Json.parse(_asset.text);\r\n\r\n                if(_onload != null) {\r\n                    _onload( res );\r\n                } //_onload\r\n\r\n                Luxe.resources.cache(res);\r\n\r\n            } //onload\r\n        }); //app.assets.text\r\n\r\n        return res;\r\n\r\n    } //loadJSON\r\n\r\n    public static function loadText( _id:String, ?_onload:TextResource->Void ) : TextResource {\r\n\r\n            //first check if this is already loaded\r\n            //:todo: note that this is is changing in alpha-2.0\r\n        if( Luxe.resources.text.exists(_id) ) {\r\n            luxe.Log.log('loadText - return existing $_id');\r\n            var res = Luxe.resources.find_text(_id);\r\n            if(_onload != null) _onload( res );\r\n            return res;\r\n        }\r\n\r\n        var res = new TextResource( _id, null, Luxe.resources );\r\n\r\n        core.app.assets.text(_id, {\r\n\r\n            onload : function( _asset:snow.assets.AssetText) {\r\n\r\n                res.text = _asset.text;\r\n\r\n                if(_onload != null) {\r\n                    _onload( res );\r\n                } //_onload\r\n\r\n                Luxe.resources.cache(res);\r\n\r\n            } //onload\r\n        }); //app.assets.text\r\n\r\n        return res;\r\n\r\n    } //loadText\r\n\r\n        /** Load a bytes/data resource */\r\n    public static function loadData( _id:String, ?_onload:DataResource->Void ) : DataResource {\r\n\r\n            //first check if this is already loaded\r\n            //:todo: note that this is is changing in alpha-2.0\r\n        if( Luxe.resources.data.exists(_id) ) {\r\n            luxe.Log.log('loadData - return existing $_id');\r\n            var res = Luxe.resources.find_data(_id);\r\n            if(_onload != null) _onload( res );\r\n            return res;\r\n        }\r\n\r\n        var res = new DataResource( _id, null, Luxe.resources);\r\n\r\n        core.app.assets.bytes(_id, {\r\n            onload: function( _asset:snow.assets.AssetBytes ) {\r\n\r\n                res.data = _asset.bytes;\r\n\r\n                if(_onload != null) {\r\n                    _onload( res );\r\n                }\r\n\r\n                Luxe.resources.cache(res);\r\n\r\n            } //onload\r\n        }); //app.assets.bytes\r\n\r\n        return res;\r\n\r\n    } //loadData\r\n\r\n        /** Load a sound resource */\r\n    public static function loadSound( _name:String, _id:String, ?_is_music:Bool = false, ?_onload:SoundResource->Void ) : SoundResource {\r\n\r\n            //first check if this is already loaded\r\n            //:todo: note that this is is changing in alpha-2.0\r\n        if( Luxe.resources.sounds.exists(_id) ) {\r\n            luxe.Log.log('loadSound - return existing $_id');\r\n            var res = Luxe.resources.find_sound(_id);\r\n            if(_onload != null) _onload( res );\r\n            return res;\r\n        }\r\n\r\n        Luxe.audio.create( _id, _name, _is_music );\r\n\r\n        var res = new SoundResource( _id, _name, Luxe.resources );\r\n\r\n            if(_onload != null) {\r\n                _onload( res );\r\n            } //_onload\r\n\r\n        Luxe.resources.cache(res);\r\n\r\n        return res;\r\n\r\n    } //loadData\r\n\r\n        /** Load a texture/image resource */\r\n    public static function loadTexture( _id:String, ?_onload:Texture->Void, ?_silent:Bool=false ) : Texture {\r\n\r\n        return Texture.load( _id, _onload, _silent );\r\n\r\n    } //loadTexture\r\n\r\n        /** Load multiple texture/image resources, useful for preloading */\r\n    public static function loadTextures( _ids:Array<String>, ?_onload:Array<Texture>->Void, ?_silent:Bool=false ) : Void {\r\n\r\n        var total_count : Int = _ids.length;\r\n        var loaded_count : Int = 0;\r\n        var loaded : Array<Texture> = [];\r\n\r\n        var on_single_texture_complete = function( texture:Texture ) {\r\n\r\n            loaded.push( texture );\r\n            loaded_count++;\r\n\r\n            if(loaded_count == total_count) {\r\n                _onload(loaded);\r\n            }\r\n\r\n        }\r\n\r\n        for(_id in _ids) {\r\n            loadTexture( _id, on_single_texture_complete, _silent );\r\n        }\r\n\r\n    } //loadTextures\r\n\r\n        /** Load a font resource */\r\n    public static function loadFont( _id:String, ?_texture_path:String, ?_onload : BitmapFont->Void, ?_silent:Bool=false ) : BitmapFont {\r\n\r\n            //first check if this is already loaded\r\n            //:todo: note that this is is changing in alpha-2.0\r\n        if( Luxe.resources.fonts.exists(_id) ) {\r\n            luxe.Log.log('loadFont - return existing $_id');\r\n            var res = Luxe.resources.find_font(_id);\r\n            if(_onload != null) _onload( res );\r\n            return res;\r\n        }\r\n\r\n        return BitmapFont.load({ id:_id, texture_path:_texture_path, onload:_onload, silent:_silent });\r\n\r\n    } //loadFont\r\n\r\n        /** Load a shader resource */\r\n    public static function loadShader( ?_ps_id:String='default', ?_vs_id:String='default', ?_onload:Shader->Void, ?_silent:Bool=false ) : Shader {\r\n\r\n            //first check if this is already loaded\r\n            //:todo: note that this is is changing in alpha-2.0\r\n        var _id = '$_ps_id|$_vs_id';\r\n        if( Luxe.resources.shaders.exists(_id) ) {\r\n            luxe.Log.log('loadShader - return existing $_id');\r\n            var res = Luxe.resources.find_shader(_id);\r\n            if(_onload != null) _onload( res );\r\n            return res;\r\n        }\r\n\r\n        return Shader.load(_ps_id, _vs_id, _onload, _silent);\r\n\r\n    } //loadShader\r\n\r\n//Internal\r\n\r\n        /** the scale of time */\r\n    static inline function get_timescale() : Float {\r\n        return core.timescale;\r\n    }\r\n        /** if this is non zero this will be passed in */\r\n    static inline function get_fixed_delta() : Float {\r\n        return core.fixed_delta;\r\n    }\r\n        /** if this is non zero, updates will be forced to this rate */\r\n    static inline function get_update_rate() : Float {\r\n        return core.update_rate;\r\n    }\r\n        /** the maximum frame time */\r\n    static inline function get_max_frame_time() : Float {\r\n        return core.max_frame_time;\r\n    }\r\n        /** the time the last frame took to run */\r\n    static inline function get_dt() : Float {\r\n        return core.delta_time;\r\n    }\r\n        /** the simulated time the last frame took to run, relative to scale etc */\r\n    static inline function get_delta_sim() : Float {\r\n        return core.delta_sim;\r\n    }\r\n        /** the start time of the last frame */\r\n    static inline function get_last_frame_start() : Float {\r\n        return core.last_frame_start;\r\n    }\r\n        /** the current simulation time */\r\n    static inline function get_current_time() : Float {\r\n        return core.current_time;\r\n    }\r\n        /** the start time of this frame */\r\n    static inline function get_cur_frame_start() : Float {\r\n        return core.cur_frame_start;\r\n    }\r\n        /** the alpha time for a render between frame updates */\r\n    static inline function get_alpha() : Float {\r\n        return core.alpha;\r\n    }\r\n\r\n\r\n        /** the scale of time */\r\n    static inline function set_timescale( value:Float ) : Float {\r\n        return core.timescale = value;\r\n    }\r\n        /** if this is non zero this will be passed in */\r\n    static inline function set_fixed_delta( value:Float ) : Float {\r\n        return core.fixed_delta = value;\r\n    }\r\n        /** if this is non zero, updates will be forced to this rate */\r\n    static inline function set_update_rate( value:Float ) : Float {\r\n        return core.update_rate = value;\r\n    }\r\n        /** the maximum frame time */\r\n    static inline function set_max_frame_time( value:Float ) : Float {\r\n        return core.max_frame_time = value;\r\n    }\r\n        /** the time the last frame took to run */\r\n    static inline function set_dt( value:Float ) : Float {\r\n        return core.delta_time = value;\r\n    }\r\n        /** the simulated time the last frame took to run, relative to scale etc */\r\n    static inline function set_delta_sim( value:Float ) : Float {\r\n        return core.delta_sim = value;\r\n    }\r\n        /** the start time of the last frame */\r\n    static inline function set_last_frame_start( value:Float ) : Float {\r\n        return core.last_frame_start = value;\r\n    }\r\n        /** the current simulation time */\r\n    static inline function set_current_time( value:Float ) : Float {\r\n        return core.current_time = value;\r\n    }\r\n        /** the start time of this frame */\r\n    static inline function set_cur_frame_start( value:Float ) : Float {\r\n        return core.cur_frame_start = value;\r\n    }\r\n        /** the alpha time for a render between frame updates */\r\n    static inline function set_alpha( value:Float ) : Float {\r\n        return core.alpha = value;\r\n    }\r\n\r\n\r\n\r\n} //Luxe\r\n\r\n\r\n\r\n\r\n/** A core event enum for the core luxe events.\r\n    Used with `on` and `off` handlers, with strict types to Ev */\r\n@:keep\r\n@:enum abstract Ev(Int) from Int to Int {\r\n\r\n    var unknown         = 0;\r\n    var ready           = 1;\r\n    var init            = 2;\r\n    var reset           = 3;\r\n    var update          = 4;\r\n    var fixedupdate     = 5;\r\n    var destroy         = 6;\r\n    var prerender       = 7;\r\n    var render          = 8;\r\n    var postrender      = 9;\r\n    var keydown         = 10;\r\n    var keyup           = 11;\r\n    var textinput       = 12;\r\n    var inputdown       = 13;\r\n    var inputup         = 14;\r\n    var mousedown       = 15;\r\n    var mouseup         = 16;\r\n    var mousemove       = 17;\r\n    var mousewheel      = 18;\r\n    var touchdown       = 19;\r\n    var touchup         = 20;\r\n    var touchmove       = 21;\r\n    var gamepadaxis     = 22;\r\n    var gamepaddown     = 23;\r\n    var gamepadup       = 24;\r\n    var gamepaddevice   = 25;\r\n\r\n    var window          = 26;\r\n    var windowmoved     = 27;\r\n    var windowresized   = 28;\r\n    var windowsized     = 29;\r\n    var windowminimized = 30;\r\n    var windowrestored  = 31;\r\n        //this is not a typo, it should match\r\n    var last            = 31;\r\n\r\n} //Ev\r\n","import Main;\r\n\r\nimport luxe.Core;\r\nimport luxe.AppConfig;\r\n\r\nimport snow.Snow;\r\nimport snow.types.Types;\r\n\r\nclass LuxeApp {\r\n\r\n    public static var _game : Main;\r\n    public static var _core : Core;\r\n    public static var _snow : Snow;\r\n    public static var _conf : AppConfig;\r\n\r\n    public static function main () {\r\n\r\n        //Start with sane defaults\r\n\r\n        _conf = {\r\n            window: {\r\n                width: 960,\r\n                height: 640,\r\n                fullscreen: false,\r\n                resizable: true,\r\n                borderless: false,\r\n                title: 'luxe app'\r\n            }\r\n        } //_conf\r\n\r\n        #if mobile\r\n            _conf.window.fullscreen = true;\r\n            _conf.window.borderless = true;\r\n        #end //mobile\r\n\r\n        \r\n        //Apply the values if they are set\r\n            _conf.window.width = 1024;\r\n            _conf.window.height = 780;\r\n            _conf.window.fullscreen = false;\r\n            _conf.window.resizable = true;\r\n            _conf.window.borderless = false;\r\n            _conf.window.title = 'BitmapPathfinding';\r\n\r\n            //Create the runtime\r\n        _snow = new Snow();\r\n            //Create the app class, give it to the bootstrapper\r\n        _game = new Main();\r\n            //Create the core luxe runtime\r\n        _core = new Core( _game, _conf );\r\n\r\n        var _snow_config : SnowConfig = {\r\n            has_loop : true,\r\n            config_custom_assets : false,\r\n            config_custom_runtime : false,\r\n            config_runtime_path : 'config.json',\r\n            config_assets_path : 'manifest',\r\n            app_package : 'lib.hxDaedalus.examples'\r\n        };\r\n\r\n            //Start up, giving luxe as the host\r\n        _snow.init( _snow_config, _core );\r\n\r\n    } //main\r\n\r\n} //LuxeApp","package luxe;\r\n\r\nimport haxe.ds.IntMap;\r\nimport luxe.Log._debug;\r\nimport luxe.Log._verbose;\r\nimport luxe.Log._verboser;\r\nimport luxe.Log.log;\r\n\r\n\r\n@:noCompletion typedef EmitHandler = Dynamic->Void;\r\n@:noCompletion typedef HandlerList = Array<EmitHandler>;\r\n\r\n@:noCompletion private typedef EmitNode<T> = { event : T, handler:EmitHandler, ?pos:haxe.PosInfos }\r\n\r\n\r\n/** A simple event emitter, used as a base class for systems that want to handle direct connections to named events */\r\n\r\n// @:generic\r\nclass Emitter<ET:Int> {\r\n\r\n    @:noCompletion public var bindings : IntMap<HandlerList>;\r\n\r\n        //store connections loosely, to find connected locations\r\n    var connected : List< EmitNode<ET> >;\r\n        //store the items to remove\r\n    var _to_remove : List< EmitNode<ET> >;\r\n\r\n        /** create a new emitter instance, for binding functions easily to named events. similar to `Events` */\r\n    public function new() {\r\n\r\n        _to_remove = new List();\r\n        connected = new List();\r\n\r\n        bindings = new IntMap<HandlerList>();\r\n\r\n    } //new\r\n\r\n        /** Emit a named event */\r\n    @:noCompletion public function emit<T>( event:ET, ?data:T, ?pos:haxe.PosInfos  ) {\r\n\r\n        _check();\r\n\r\n        var list = bindings.get(event);\r\n        if(list != null && list.length > 0) {\r\n            for(handler in list) {\r\n                _verboser('emit / $event / ${pos.fileName}:${pos.lineNumber}@${pos.className}.${pos.methodName}');\r\n                handler(data);\r\n            }\r\n        }\r\n\r\n            //needed because handlers\r\n            //might disconnect listeners\r\n        _check();\r\n\r\n    } //emit\r\n\r\n        /** connect a named event to a handler */\r\n    @:noCompletion public function on<T>(event:ET, handler: T->Void, ?pos:haxe.PosInfos ) {\r\n\r\n        _check();\r\n\r\n        _verbose('on / $event / ${pos.fileName}:${pos.lineNumber}@${pos.className}.${pos.methodName}');\r\n\r\n        if(!bindings.exists(event)) {\r\n\r\n            bindings.set(event, [handler]);\r\n            connected.push({ handler:handler, event:event, pos:pos });\r\n\r\n        } else {\r\n            var list = bindings.get(event);\r\n            if(list.indexOf(handler) == -1) {\r\n                list.push(handler);\r\n                connected.push({ handler:handler, event:event, pos:pos });\r\n            }\r\n        }\r\n\r\n    } //on\r\n\r\n        /** disconnect a named event and handler. returns true on success, or false if event or handler not found */\r\n    @:noCompletion public function off<T>(event:ET, handler: T->Void, ?pos:haxe.PosInfos ) : Bool {\r\n\r\n        _check();\r\n\r\n        var success = false;\r\n\r\n        if(bindings.exists(event)) {\r\n\r\n            _verbose('off / $event / ${pos.fileName}:${pos.lineNumber}@${pos.className}.${pos.methodName}');\r\n\r\n            _to_remove.push({ event:event, handler:handler });\r\n\r\n            for(_info in connected) {\r\n                if(_info.event == event && _info.handler == handler) {\r\n                    connected.remove(_info);\r\n                }\r\n            }\r\n\r\n                //debateable :p\r\n            success = true;\r\n\r\n        } //if exists\r\n\r\n        return success;\r\n\r\n    } //off\r\n\r\n    @:noCompletion public function connections( handler:EmitHandler ) {\r\n\r\n        var list : Array<EmitNode<ET>> = [];\r\n\r\n        for(_info in connected) {\r\n            if(_info.handler == handler) {\r\n                list.push(_info);\r\n            }\r\n        }\r\n\r\n        return list;\r\n\r\n    } //connections\r\n\r\n    var _checking = false;\r\n\r\n    function _check() {\r\n\r\n        if(_checking) {\r\n            return;\r\n        }\r\n\r\n        _checking = true;\r\n\r\n        if(_to_remove.length > 0) {\r\n\r\n            for(_node in _to_remove) {\r\n\r\n                var list = bindings.get(_node.event);\r\n                list.remove( _node.handler );\r\n\r\n                    //clear the event list if there are no bindings\r\n                if(list.length == 0) {\r\n                    bindings.remove(_node.event);\r\n                }\r\n\r\n            } //each node\r\n\r\n            _to_remove = null;\r\n            _to_remove = new List();\r\n\r\n        } //_to_remove length > 0\r\n\r\n        _checking = false;\r\n\r\n    } //_check\r\n\r\n} //Emitter\r\n","package luxe;\r\n\r\nimport luxe.Core;\r\nimport luxe.Objects;\r\nimport luxe.Input;\r\nimport luxe.Screen;\r\nimport snow.App;\r\nimport luxe.AppConfig;\r\n\r\n@:noCompletion\r\n@:keepSub\r\nclass Game extends Emitter<Int> {\r\n\r\n    @:noCompletion public var app : Core;\r\n\r\n        /** Empty constructor. Use `ready` instead. */\r\n    public function new() {\r\n        super();\r\n    }\r\n\r\n        /** Called by luxe to request config changes, override this to change the defaults.\r\n            This happens before ready, so the values are available when ready is called. */\r\n    public function config( config:AppConfig ) : AppConfig  { return config; }\r\n        /** Your entry point. Called for you when you can initialize your application */\r\n    public function ready() {}\r\n        /** Your update loop. Called every frame for you. The dt value depends on the timing configuration (see the {App Guide}) */\r\n    public function update(dt:Float) {}\r\n\r\n        /** very low level event handler from snow core. Often handled by the subsystems and by luxe, so check there first! */\r\n    @:noCompletion public function onevent( event:snow.types.Types.SystemEvent ) { }\r\n\r\n       /** Your exit point. Called for you when you should shut down your application */\r\n   public function ondestroy() {}\r\n\r\n       /** Called when the application is about to render */\r\n   public function onprerender() {}\r\n       /** Called when the application is rendering */\r\n   public function onrender() {}\r\n       /** Called when the application is done rendering */\r\n   public function onpostrender() {}\r\n\r\n       /** Called when a named input down event occurs */\r\n   public function oninputdown( _name:String, e:InputEvent ) {}\r\n       /** Called when a named input up event occurs */\r\n   public function oninputup( _name:String, e:InputEvent ) {}\r\n\r\n       /** Called for you when a mouse button is pressed */\r\n   public function onmousedown( event:MouseEvent ) {}\r\n       /** Called for you when a mouse button is released */\r\n   public function onmouseup( event:MouseEvent ) {}\r\n       /** Called for you when the mouse wheel moves */\r\n   public function onmousewheel( event:MouseEvent ) {}\r\n       /** Called for you when the mouse moves */\r\n   public function onmousemove( event:MouseEvent ) {}\r\n\r\n       /** Called for you when a key is pressed down */\r\n   public function onkeydown( event:KeyEvent ) {}\r\n       /** Called for you when a key is released */\r\n   public function onkeyup( event:KeyEvent ) {}\r\n       /** Called for you when text input is happening. Use this for textfields, as it handles the complexity of unicode etc. */\r\n   public function ontextinput( event:TextEvent ) {}\r\n\r\n       /** Called for you when a touch is first pressed, use the `touch_id` to track which */\r\n   public function ontouchdown( event:TouchEvent ) {}\r\n       /** Called for you when a touch is released, use the `touch_id` to track which */\r\n   public function ontouchup( event:TouchEvent ) {}\r\n       /** Called for you when a touch is moved, use the `touch_id` to track which */\r\n   public function ontouchmove( event:TouchEvent ) {}\r\n\r\n       /** Called for you when a connected gamepad axis moves, use `gamepad` to determine gamepad id */\r\n   public function ongamepadaxis( event:GamepadEvent ) {}\r\n       /** Called for you when a connected gamepad button is pressed, use `gamepad` to determine gamepad id */\r\n   public function ongamepaddown( event:GamepadEvent ) {}\r\n       /** Called for you when a connected gamepad button is released, use `gamepad` to determine gamepad id */\r\n   public function ongamepadup( event:GamepadEvent ) {}\r\n       /** Called for you when a gamepad is connected or disconnected, use `gamepad` to determine gamepad id */\r\n   public function ongamepaddevice( event:GamepadEvent ) {}\r\n\r\n       /** Called for you when a window is moved, with the data containing the new x/y position */\r\n   public function onwindowmoved( event:WindowEvent ) {}\r\n       /** Called for you when a window is resized by the user, with the data containing the new x/y size */\r\n   public function onwindowresized( event:WindowEvent ) {}\r\n       /** Called for you when a window is resized by the system or code or the user, with the data containing the new x/y size */\r\n   public function onwindowsized( event:WindowEvent ) {}\r\n       /** Called for you when a window is minimized. */\r\n   public function onwindowminimized( event:WindowEvent ) {}\r\n       /** Called for you when a window is restored. */\r\n   public function onwindowrestored( event:WindowEvent ) {}\r\n\r\n} //Game\r\n","package;\r\n\r\nimport hxDaedalus.ai.EntityAI;\r\nimport hxDaedalus.ai.PathFinder;\r\nimport hxDaedalus.ai.trajectory.LinearPathSampler;\r\nimport hxDaedalus.data.Mesh;\r\nimport hxDaedalus.data.Object;\r\nimport hxDaedalus.factories.BitmapObject;\r\nimport hxDaedalus.factories.RectMesh;\r\nimport hxDaedalus.graphics.TargetCanvas;\r\nimport hxDaedalus.view.SimpleView;\r\nimport luxe.Input.Key;\r\nimport luxe.Input.KeyEvent;\r\nimport luxe.Input.MouseEvent;\r\nimport luxe.Parcel;\r\nimport luxe.ParcelProgress;\r\nimport luxe.Sprite;\r\nimport luxe.Vector;\r\nimport phoenix.Texture;\r\n\r\n\r\nclass Main extends luxe.Game {\r\n\r\n    var mouse:Vector = new Vector(0, 0);\r\n\r\n\tvar _inited:Bool = false;\r\n\t\r\n\tvar _mesh:Mesh;\r\n\tvar _entityAI:EntityAI;\r\n\tvar _pathfinder:PathFinder;\r\n\tvar _path:Array<Float>;\r\n\tvar _pathSampler:LinearPathSampler;\r\n\tvar _object:Object;\r\n\tvar _meshView:SimpleView;\r\n\tvar _pathView:SimpleView;\r\n\r\n    var _newPath:Bool = false;\r\n\r\n\tvar textureColor:Texture;\r\n\tvar textureBW:Texture;\r\n\t\r\n\t// entry point\r\n    override function ready() {\r\n\r\n        // fetch a list of assets to load from the json file\r\n        Luxe.loadJSON('assets/parcel.json', function (asset):Void {\r\n\r\n\t\t\t// then create a parcel to load it for us\r\n\t\t\tvar parcel = new Parcel();\r\n\t\t\tparcel.from_json(asset.json);\r\n\r\n\t\t\t// but, we also want a progress bar for the parcel,\r\n\t\t\t// this is a default one, you can do your own\r\n\t\t\tnew ParcelProgress({\r\n\t\t\t\tparcel      : parcel,\r\n\t\t\t\toncomplete  : onLoaded\r\n\t\t\t});\r\n\r\n\t\t\t// go!\r\n\t\t\tparcel.load();\r\n\t\t\t\r\n\t\t});\r\n\r\n    } // ready\r\n\r\n\tfunction onLoaded(_):Void {\r\n\t\t\r\n\t\t// load the images\r\n\t\ttextureColor = Luxe.loadTexture(\"assets/galapagosColor.png\");\r\n\t\ttextureBW = Luxe.loadTexture(\"assets/galapagosBW.png\");\r\n\t\t\r\n\t\t// build a rectangular 2 polygons mesh\r\n\t\t_mesh = RectMesh.buildRectangle( 1024, 780 );\r\n\t\t\r\n\t\t// show the image\r\n\t\tvar galapagos = new Sprite({\r\n\t\t\ttexture: textureColor,\r\n\t\t\tcentered: false,\r\n\t\t\tdepth: -1\r\n\t\t});\r\n\t\t\r\n\t\t_meshView = new SimpleView(new TargetCanvas());\r\n\t\t_pathView = new SimpleView(new TargetCanvas());\r\n\t\t\r\n\t\t// create an object from texture\r\n\t\t_object = BitmapObject.buildFromBmpData( textureBW, 1.8 );\r\n\t\t_object.x = 0;\r\n\t\t_object.y = 0;\r\n\r\n\t\t_mesh.insertObject( _object );\r\n\r\n\t\t// display result mesh\r\n\t\t\r\n\t\t// draw the mesh\r\n\t\t_meshView.drawMesh( _mesh );\r\n\t\t\r\n\t\t// we need an entity\r\n\t\t_entityAI = new EntityAI();\r\n\t\t\r\n\t\t// set radius size for your entity\r\n\t\t_entityAI.radius = 4;\r\n\t\t\r\n\t\t// set a position\r\n\t\t_entityAI.x = 50;\r\n\t\t_entityAI.y = 50;\r\n\t\t\r\n\t\t// show entity on screen\r\n\t\t_pathView.drawEntity( _entityAI, false );\r\n\t\t\r\n\t\t// now configure the pathfinder\r\n\t\t_pathfinder = new PathFinder();\r\n\t\t_pathfinder.entity = _entityAI; // set the entity\r\n\t\t_pathfinder.mesh = _mesh; // set the mesh\r\n\t\t\r\n\t\t// we need a vector to store the path\r\n\t\t_path = new Array<Float>();\r\n\t\t\r\n\t\t// then configure the path sampler\r\n\t\t_pathSampler = new LinearPathSampler();\r\n\t\t_pathSampler.entity = _entityAI;\r\n\t\t_pathSampler.samplingDistance = 10;\r\n\t\t_pathSampler.path = _path;\r\n\r\n\t\t_inited = true;\r\n\t}\r\n\t\r\n    override function onmousedown( e:MouseEvent ) {\r\n        \r\n\t\tmouse.set_xy(e.x,e.y);\r\n\t\t_newPath = true;\r\n\t\t\r\n    } //onmousedown\r\n\r\n    override function onmouseup( e:MouseEvent ) {\r\n\r\n        mouse.set_xy(e.x,e.y);\r\n\t\t_newPath = false;\r\n\t\t\r\n    } //onmouseup\r\n\r\n    override function onmousemove( e:MouseEvent ) {\r\n        \r\n\t\tmouse.set_xy(e.x,e.y);\r\n\t\t\r\n    } //onmousemove\r\n\r\n\toverride function onkeyup(e:KeyEvent) {\r\n\r\n        if (e.keycode == Key.escape) {\r\n            Luxe.shutdown();\r\n        }\r\n\r\n    } // onkeyup\r\n\r\n    override function update(dt:Float) {\r\n\t\tif (!_inited) return;\r\n\t\t\r\n\t\tif ( _newPath ) {\r\n\t\t\t\r\n\t\t\t_pathView.graphics.clear();\r\n\r\n\t\t\t// find path !\r\n            _pathfinder.findPath( mouse.x, mouse.y, _path );\r\n            \r\n\t\t\t// show path on screen\r\n            _pathView.drawPath( _path );\r\n            \r\n\t\t\t// reset the path sampler to manage new generated path\r\n            _pathSampler.reset();\r\n            \r\n\t\t\t// show entity position on screen\r\n\t\t\t_pathView.drawEntity(_entityAI);\r\n        }\r\n        \r\n        // animate !\r\n        if ( _pathSampler.hasNext ) {\r\n\t\t\t\r\n\t\t\t// move entity\r\n            _pathSampler.next();            \r\n            \r\n\t\t\t// show entity position on screen\r\n\t\t\t_pathView.drawEntity(_entityAI);\r\n        }\r\n\t\t\r\n    } // update\r\n\r\n} // Main","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:coreApi class Reflect {\n\n\tpublic inline static function hasField( o : Dynamic, field : String ) : Bool {\n\t\treturn untyped __js__('Object').prototype.hasOwnProperty.call(o, field);\n\t}\n\n\tpublic static function field( o : Dynamic, field : String ) : Dynamic {\n\t\ttry return untyped o[field] catch( e : Dynamic ) return null;\n\t}\n\n\tpublic inline static function setField( o : Dynamic, field : String, value : Dynamic ) : Void untyped {\n\t\to[field] = value;\n\t}\n\n\tpublic static inline function getProperty( o : Dynamic, field : String ) : Dynamic untyped {\n\t\tvar tmp;\n\t\treturn if( o == null ) __define_feature__(\"Reflect.getProperty\",null) else if( o.__properties__ && (tmp=o.__properties__[\"get_\"+field]) ) o[tmp]() else o[field];\n\t}\n\n\tpublic static inline function setProperty( o : Dynamic, field : String, value : Dynamic ) : Void untyped {\n\t\tvar tmp;\n\t\tif( o.__properties__ && (tmp=o.__properties__[\"set_\"+field]) ) o[tmp](value) else o[field] = __define_feature__(\"Reflect.setProperty\",value);\n\t}\n\n\tpublic inline static function callMethod( o : Dynamic, func : haxe.Constraints.Function, args : Array<Dynamic> ) : Dynamic untyped {\n\t\treturn func.apply(o,args);\n\t}\n\n\tpublic static function fields( o : Dynamic ) : Array<String> {\n\t\tvar a = [];\n\t\tif (o != null) untyped {\n\t\t\tvar hasOwnProperty = __js__('Object').prototype.hasOwnProperty;\n\t\t\t__js__(\"for( var f in o ) {\");\n\t\t\tif( f != \"__id__\" && f != \"hx__closures__\" && hasOwnProperty.call(o, f) ) a.push(f);\n\t\t\t__js__(\"}\");\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static function isFunction( f : Dynamic ) : Bool untyped {\n\t\treturn __js__(\"typeof(f)\") == \"function\" && !(js.Boot.isClass(f) || js.Boot.isEnum(f));\n\t}\n\n\tpublic static function compare<T>( a : T, b : T ) : Int {\n\t\treturn ( a == b ) ? 0 : (((cast a) > (cast b)) ? 1 : -1);\n\t}\n\n\tpublic static function compareMethods( f1 : Dynamic, f2 : Dynamic ) : Bool {\n\t\tif( f1 == f2 )\n\t\t\treturn true;\n\t\tif( !isFunction(f1) || !isFunction(f2) )\n\t\t\treturn false;\n\t\treturn f1.scope == f2.scope && f1.method == f2.method && f1.method != null;\n\t}\n\n\tpublic static function isObject( v : Dynamic ) : Bool untyped {\n\t\tif( v == null )\n\t\t\treturn false;\n\t\tvar t = __js__(\"typeof(v)\");\n\t\treturn (t == \"string\" || (t == \"object\" && v.__enum__ == null)) || (t == \"function\" && (js.Boot.isClass(v) || js.Boot.isEnum(v)) != null);\n\t}\n\n\tpublic static function isEnumValue( v : Dynamic ) : Bool {\n\t\treturn v != null && v.__enum__ != null;\n\t}\n\n\tpublic static function deleteField( o : Dynamic, field : String ) : Bool untyped {\n\t\tif( !hasField(o,field) ) return false;\n\t\t__js__(\"delete\")(o[field]);\n\t\treturn true;\n\t}\n\n\tpublic static function copy<T>( o : T ) : T {\n\t\tvar o2 : Dynamic = {};\n\t\tfor( f in Reflect.fields(o) )\n\t\t\tReflect.setField(o2,f,Reflect.field(o,f));\n\t\treturn o2;\n\t}\n\n\t@:overload(function( f : Array<Dynamic> -> Void ) : Dynamic {})\n\tpublic static function makeVarArgs( f : Array<Dynamic> -> Dynamic ) : Dynamic {\n\t\treturn function() {\n\t\t\tvar a = untyped Array.prototype.slice.call(__js__(\"arguments\"));\n\t\t\treturn f(a);\n\t\t};\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\nimport js.Boot;\n\n@:keepInit\n@:coreApi class Std {\n\n\tpublic static inline function is( v : Dynamic, t : Dynamic ) : Bool {\n\t\treturn untyped js.Boot.__instanceof(v,t);\n\t}\n\n\tpublic static inline function instance<T:{},S:T>( value : T, c : Class<S> ) : S {\n\t\treturn untyped __instanceof__(value, c) ? cast value : null;\n\t}\n\n\tpublic static function string( s : Dynamic ) : String {\n\t\treturn untyped js.Boot.__string_rec(s,\"\");\n\t}\n\n\tpublic static inline function int( x : Float ) : Int {\n\t\treturn (cast x) | 0;\n\t}\n\n\tpublic static function parseInt( x : String ) : Null<Int> {\n\t\tvar v = untyped __js__(\"parseInt\")(x, 10);\n\t\t// parse again if hexadecimal\n\t\tif( v == 0 && (x.charCodeAt(1) == 'x'.code || x.charCodeAt(1) == 'X'.code) )\n\t\t\tv = untyped __js__(\"parseInt\")(x);\n\t\tif( untyped __js__(\"isNaN\")(v) )\n\t\t\treturn null;\n\t\treturn cast v;\n\t}\n\n\tpublic static inline function parseFloat( x : String ) : Float {\n\t\treturn untyped __js__(\"parseFloat\")(x);\n\t}\n\n\tpublic static function random( x : Int ) : Int {\n\t\treturn untyped x <= 0 ? 0 : Math.floor(Math.random()*x);\n\t}\n\n\tstatic function __init__() : Void untyped {\n\t\t__feature__(\"js.Boot.getClass\",String.prototype.__class__ = __feature__(\"Type.resolveClass\",$hxClasses[\"String\"] = String,String));\n\t\t__feature__(\"js.Boot.isClass\",String.__name__ = __feature__(\"Type.getClassName\",[\"String\"],true));\n\t\t__feature__(\"Type.resolveClass\",$hxClasses[\"Array\"] = Array);\n\t\t__feature__(\"js.Boot.isClass\",Array.__name__ = __feature__(\"Type.getClassName\",[\"Array\"],true));\n\t\t__feature__(\"Date.*\", {\n\t\t\t__feature__(\"js.Boot.getClass\",__js__('Date').prototype.__class__ = __feature__(\"Type.resolveClass\",$hxClasses[\"Date\"] = __js__('Date'),__js__('Date')));\n\t\t\t__feature__(\"js.Boot.isClass\",__js__('Date').__name__ = [\"Date\"]);\n\t\t});\n\t\t__feature__(\"Int.*\",{\n\t\t\tvar Int = __feature__(\"Type.resolveClass\", $hxClasses[\"Int\"] = { __name__ : [\"Int\"] }, { __name__ : [\"Int\"] });\n\t\t});\n\t\t__feature__(\"Dynamic.*\",{\n\t\t\tvar Dynamic = __feature__(\"Type.resolveClass\", $hxClasses[\"Dynamic\"] = { __name__ : [\"Dynamic\"] }, { __name__ : [\"Dynamic\"] });\n\t\t});\n\t\t__feature__(\"Float.*\",{\n\t\t\tvar Float = __feature__(\"Type.resolveClass\", $hxClasses[\"Float\"] = __js__(\"Number\"), __js__(\"Number\"));\n\t\t\tFloat.__name__ = [\"Float\"];\n\t\t});\n\t\t__feature__(\"Bool.*\",{\n\t\t\tvar Bool = __feature__(\"Type.resolveEnum\",$hxClasses[\"Bool\"] = __js__(\"Boolean\"), __js__(\"Boolean\"));\n\t\t\tBool.__ename__ = [\"Bool\"];\n\t\t});\n\t\t__feature__(\"Class.*\",{\n\t\t\tvar Class = __feature__(\"Type.resolveClass\", $hxClasses[\"Class\"] = { __name__ : [\"Class\"] }, { __name__ : [\"Class\"] });\n\t\t});\n\t\t__feature__(\"Enum.*\",{\n\t\t\tvar Enum = {};\n\t\t});\n\t\t__feature__(\"Void.*\",{\n\t\t\tvar Void = __feature__(\"Type.resolveEnum\", $hxClasses[\"Void\"] = { __ename__ : [\"Void\"] }, { __ename__ : [\"Void\"] });\n\t\t});\n\n#if !js_es5\n\t\t__feature__(\"Array.map\",\n\t\t\tif( Array.prototype.map == null )\n\t\t\t\tArray.prototype.map = function(f) {\n\t\t\t\t\tvar a = [];\n\t\t\t\t\tfor( i in 0...__this__.length )\n\t\t\t\t\t\ta[i] = f(__this__[i]);\n\t\t\t\t\treturn a;\n\t\t\t\t}\n\t\t);\n\t\t__feature__(\"Array.filter\",\n\t\t\tif( Array.prototype.filter == null )\n\t\t\t\tArray.prototype.filter = function(f) {\n\t\t\t\t\tvar a = [];\n\t\t\t\t\tfor( i in 0...__this__.length ) {\n\t\t\t\t\t\tvar e = __this__[i];\n\t\t\t\t\t\tif( f(e) ) a.push(e);\n\t\t\t\t\t}\n\t\t\t\t\treturn a;\n\t\t\t\t}\n\t\t);\n#end\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n\tA String buffer is an efficient way to build a big string by appending small\n\telements together.\n\n\tIts cross-platform implementation uses String concatenation internally, but\n\tStringBuf may be optimized for different targets.\n\n\tUnlike String, an instance of StringBuf is not immutable in the sense that\n\tit can be passed as argument to functions which modify it by appending more\n\tvalues. However, the internal buffer cannot be modified.\n**/\nclass StringBuf {\n\n\tvar b:String;\n\n\t/**\n\t\tThe length of `this` StringBuf in characters.\n\t**/\n\tpublic var length(get,never) : Int;\n\n\t/**\n\t\tCreates a new StringBuf instance.\n\n\t\tThis may involve initialization of the internal buffer.\n\t**/\n\tpublic inline function new() {\n\t\tb = \"\";\n\t}\n\n\tinline function get_length() : Int {\n\t\treturn b.length;\n\t}\n\n\t/**\n\t\tAppends the representation of `x` to `this` StringBuf.\n\n\t\tThe exact representation of `x` may vary per platform. To get more\n\t\tconsistent behavior, this function should be called with\n\t\tStd.string(x).\n\n\t\tIf `x` is null, the String \"null\" is appended.\n\t**/\n\tpublic inline function add<T>( x : T ) : Void {\n\t\tb += x;\n\t}\n\n\t/**\n\t\tAppends the character identified by `c` to `this` StringBuf.\n\n\t\tIf `c` is negative or has another invalid value, the result is\n\t\tunspecified.\n\t**/\n\tpublic inline function addChar( c : Int ) : Void {\n\t\tb += String.fromCharCode(c);\n\t}\n\n\t/**\n\t\tAppends a substring of `s` to `this` StringBuf.\n\n\t\tThis function expects `pos` and `len` to describe a valid substring of\n\t\t`s`, or else the result is unspecified. To get more robust behavior,\n\t\t`this.add(s.substr(pos,len))` can be used instead.\n\n\t\tIf `s` or `pos` are null, the result is unspecified.\n\n\t\tIf `len` is omitted or null, the substring ranges from `pos` to the end\n\t\tof `s`.\n\t**/\n\tpublic inline function addSub( s : String, pos : Int, ?len : Int) : Void {\n\t\tb += (len == null ? s.substr(pos) : s.substr(pos, len));\n\t}\n\n\t/**\n\t\tReturns the content of `this` StringBuf as String.\n\n\t\tThe buffer is not emptied by this operation.\n\t**/\n\tpublic inline function toString() : String {\n\t\treturn b;\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n\tThis class provides advanced methods on Strings. It is ideally used with\n\t'using StringTools' and then acts as an extension to the String class.\n\n\tIf the first argument to any of the methods is null, the result is\n\tunspecified.\n**/\n#if cpp\nusing cpp.NativeString;\n#end\n#if cs\n@:keep\n#end\nclass StringTools {\n\t/**\n\t\tEncode an URL by using the standard format.\n\t**/\n\t#if (!java && !cpp) inline #end public static function urlEncode( s : String ) : String {\n\t\t#if flash\n\t\t\treturn untyped __global__[\"encodeURIComponent\"](s);\n\t\t#elseif neko\n\t\t\treturn untyped new String(_urlEncode(s.__s));\n\t\t#elseif js\n\t\t\treturn untyped encodeURIComponent(s);\n\t\t#elseif cpp\n\t\t\treturn untyped s.__URLEncode();\n\t\t#elseif java\n\t\t\ttry\n\t\t\t\treturn untyped __java__(\"java.net.URLEncoder.encode(s, \\\"UTF-8\\\")\")\n\t\t\tcatch (e:Dynamic) throw e;\n\t\t#elseif cs\n\t\t\treturn untyped cs.system.Uri.EscapeUriString(s);\n\t\t#elseif python\n\t\t\treturn python.lib.urllib.Parse.quote(s);\n\t\t#else\n\t\t\treturn null;\n\t\t#end\n\t}\n\n\t/**\n\t\tDecode an URL using the standard format.\n\t**/\n\t#if (!java && !cpp) inline #end public static function urlDecode( s : String ) : String {\n\t\t#if flash\n\t\t\treturn untyped __global__[\"decodeURIComponent\"](s.split(\"+\").join(\" \"));\n\t\t#elseif neko\n\t\t\treturn untyped new String(_urlDecode(s.__s));\n\t\t#elseif js\n\t\t\treturn untyped decodeURIComponent(s.split(\"+\").join(\" \"));\n\t\t#elseif cpp\n\t\t\treturn untyped s.__URLDecode();\n\t\t#elseif java\n\t\t\ttry\n\t\t\t\treturn untyped __java__(\"java.net.URLDecoder.decode(s, \\\"UTF-8\\\")\")\n\t\t\tcatch (e:Dynamic) throw e;\n\t\t#elseif cs\n\t\t\treturn untyped cs.system.Uri.UnescapeDataString(s);\n\t\t#elseif python\n\t\t\treturn python.lib.urllib.Parse.unquote(s);\n\t\t#else\n\t\t\treturn null;\n\t\t#end\n\t}\n\n\t/**\n\t\tEscapes HTML special characters of the string `s`.\n\n\t\tThe following replacements are made:\n\n\t\t- `&` becomes `&amp`;\n\t\t- `<` becomes `&lt`;\n\t\t- `>` becomes `&gt`;\n\n\t\tIf `quotes` is true, the following characters are also replaced:\n\n\t\t- `\"` becomes `&quot`;\n\t\t- `'` becomes `&#039`;\n\t**/\n\tpublic static function htmlEscape( s : String, ?quotes : Bool ) : String {\n\t\ts = s.split(\"&\").join(\"&amp;\").split(\"<\").join(\"&lt;\").split(\">\").join(\"&gt;\");\n\t\treturn quotes ? s.split('\"').join(\"&quot;\").split(\"'\").join(\"&#039;\") : s;\n\t}\n\n\t/**\n\t\tUnescapes HTML special characters of the string `s`.\n\n\t\tThis is the inverse operation to htmlEscape, i.e. the following always\n\t\tholds: htmlUnescape(htmlEscape(s)) == s\n\n\t\tThe replacements follow:\n\n\t\t- `&amp;` becomes `&`\n\t\t- `&lt;` becomes `<`\n\t\t- `&gt;` becomes `>`\n\t\t- `&quot;` becomes `\"`\n\t\t- `&#039;` becomes `'`\n\t**/\n\tpublic static function htmlUnescape( s : String ) : String {\n\t\treturn s.split(\"&gt;\").join(\">\").split(\"&lt;\").join(\"<\").split(\"&quot;\").join('\"').split(\"&#039;\").join(\"'\").split(\"&amp;\").join(\"&\");\n\t}\n\n\t/**\n\t\tTells if the string `s` starts with the string `start`.\n\n\t\tIf `start` is null, the result is unspecified.\n\n\t\tIf `start` is the empty String \"\", the result is true.\n\t**/\n\tpublic static #if (cs || java) inline #end function startsWith( s : String, start : String ) : Bool {\n\t\t#if java\n\t\treturn untyped s.startsWith(start);\n\t\t#elseif cs\n\t\treturn untyped s.StartsWith(start);\n\t\t#elseif cpp\n\t\tif (s.length<start.length)\n\t\t\treturn false;\n\t\tvar p0 = s.c_str();\n\t\tvar p1 = start.c_str();\n\t\tfor(i in 0...start.length)\n\t\t\tif ( p0.at(i) != p1.at(i) )\n\t\t\t\treturn false;\n\t\treturn true;\n\t\t#else\n\t\treturn( s.length >= start.length && s.substr(0, start.length) == start );\n\t\t#end\n\t}\n\n\t/**\n\t\tTells if the string `s` ends with the string `end`.\n\n\t\tIf `end` is null, the result is unspecified.\n\n\t\tIf `end` is the empty String \"\", the result is true.\n\t**/\n\tpublic static #if (cs || java) inline #end function endsWith( s : String, end : String ) : Bool {\n\t\t#if java\n\t\treturn untyped s.endsWith(end);\n\t\t#elseif cs\n\t\treturn untyped s.EndsWith(end);\n\t\t#elseif cpp\n\t\tif (s.length<end.length)\n\t\t\treturn false;\n\t\tvar p0 = s.c_str().add( s.length-end.length );\n\t\tvar p1 = end.c_str();\n\t\tfor(i in 0...end.length)\n\t\t\tif ( p0.at(i) != p1.at(i) )\n\t\t\t\treturn false;\n\t\treturn true;\n\t\t#else\n\t\tvar elen = end.length;\n\t\tvar slen = s.length;\n\t\treturn( slen >= elen && s.substr(slen - elen, elen) == end );\n\t\t#end\n\t}\n\n\t/**\n\t\tTells if the character in the string `s` at position `pos` is a space.\n\n\t\tA character is considered to be a space character if its character code\n\t\tis 9,10,11,12,13 or 32.\n\n\t\tIf `s` is the empty String \"\", or if pos is not a valid position within\n\t\t`s`, the result is false.\n\t**/\n\tpublic static function isSpace( s : String, pos : Int ) : Bool {\n\t\t#if python\n\t\tif (s.length == 0 || pos < 0 || pos >= s.length) return false;\n\t\t#end\n\t\tvar c = s.charCodeAt( pos );\n\t\treturn (c > 8 && c < 14) || c == 32;\n\t}\n\n\t/**\n\t\tRemoves leading space characters of `s`.\n\n\t\tThis function internally calls isSpace() to decide which characters to\n\t\tremove.\n\n\t\tIf `s` is the empty String \"\" or consists only of space characters, the\n\t\tresult is the empty String \"\".\n\t**/\n\tpublic #if cs inline #end static function ltrim( s : String ) : String {\n\t\t#if cs\n\t\treturn untyped s.TrimStart();\n\t\t#else\n\t\tvar l = s.length;\n\t\tvar r = 0;\n\t\twhile( r < l && isSpace(s,r) ){\n\t\t\tr++;\n\t\t}\n\t\tif( r > 0 )\n\t\t\treturn s.substr(r, l-r);\n\t\telse\n\t\t\treturn s;\n\t\t#end\n\t}\n\n\t/**\n\t\tRemoves trailing space characters of `s`.\n\n\t\tThis function internally calls isSpace() to decide which characters to\n\t\tremove.\n\n\t\tIf `s` is the empty String \"\" or consists only of space characters, the\n\t\tresult is the empty String \"\".\n\t**/\n\tpublic #if cs inline #end static function rtrim( s : String ) : String {\n\t\t#if cs\n\t\treturn untyped s.TrimEnd();\n\t\t#else\n\t\tvar l = s.length;\n\t\tvar r = 0;\n\t\twhile( r < l && isSpace(s,l-r-1) ){\n\t\t\tr++;\n\t\t}\n\t\tif( r > 0 ){\n\t\t\treturn s.substr(0, l-r);\n\t\t}else{\n\t\t\treturn s;\n\t\t}\n\t\t#end\n\t}\n\n\t/**\n\t\tRemoves leading and trailing space characters of `s`.\n\n\t\tThis is a convenience function for ltrim(rtrim(s)).\n\t**/\n\tpublic #if (cs || java) inline #end static function trim( s : String ) : String {\n\t\t#if cs\n\t\treturn untyped s.Trim();\n\t\t#elseif java\n\t\treturn untyped s.trim();\n\t\t#else\n\t\treturn ltrim(rtrim(s));\n\t\t#end\n\t}\n\n\t/**\n\t\tConcatenates `c` to `s` until `s.length` is at least `l`.\n\n\t\tIf `c` is the empty String \"\" or if `l` does not exceed `s.length`,\n\t\t`s` is returned unchanged.\n\n\t\tIf `c.length` is 1, the resulting String length is exactly `l`.\n\n\t\tOtherwise the length may exceed `l`.\n\n\t\tIf `c` is null, the result is unspecified.\n\t**/\n\tpublic static function lpad( s : String, c : String, l : Int ) : String {\n\t\tif (c.length <= 0)\n\t\t\treturn s;\n\n\t\twhile (s.length < l) {\n\t\t\ts = c + s;\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t\tAppends `c` to `s` until `s.length` is at least `l`.\n\n\t\tIf `c` is the empty String \"\" or if `l` does not exceed `s.length`,\n\t\t`s` is returned unchanged.\n\n\t\tIf `c.length` is 1, the resulting String length is exactly `l`.\n\n\t\tOtherwise the length may exceed `l`.\n\n\t\tIf `c` is null, the result is unspecified.\n\t**/\n\tpublic static function rpad( s : String, c : String, l : Int ) : String {\n\t\tif (c.length <= 0)\n\t\t\treturn s;\n\n\t\twhile (s.length < l) {\n\t\t\ts = s + c;\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t\tReplace all occurences of the String `sub` in the String `s` by the\n\t\tString `by`.\n\n\t\tIf `sub` is the empty String \"\", `by` is inserted after each character\n\t\tof `s`. If `by` is also the empty String \"\", `s` remains unchanged.\n\n\t\tThis is a convenience function for `s.split(sub).join(by)`.\n\n\t\tIf `sub` or `by` are null, the result is unspecified.\n\t**/\n\tpublic static function replace( s : String, sub : String, by : String ) : String {\n\t\t#if java\n\t\tif (sub.length == 0)\n\t\t\treturn s.split(sub).join(by);\n\t\telse\n\t\t\treturn untyped s.replace(sub, by);\n\t\t#elseif cs\n\t\tif (sub.length == 0)\n\t\t\treturn s.split(sub).join(by);\n\t\telse\n\t\t\treturn untyped s.Replace(sub, by);\n\t\t#else\n\t\treturn s.split(sub).join(by);\n\t\t#end\n\t}\n\n\t/**\n\t\tEncodes `n` into a hexadecimal representation.\n\n\t\tIf `digits` is specified, the resulting String is padded with \"0\" until\n\t\tits length equals `digits`.\n\t**/\n\tpublic static function hex( n : Int, ?digits : Int ) {\n\t\t#if flash\n\t\t\tvar n : UInt = n;\n\t\t\tvar s : String = untyped n.toString(16);\n\t\t\ts = s.toUpperCase();\n\t\t#else\n\t\t\tvar s = \"\";\n\t\t\tvar hexChars = \"0123456789ABCDEF\";\n\t\t\tdo {\n\t\t\t\ts = hexChars.charAt(n&15) + s;\n\t\t\t\tn >>>= 4;\n\t\t\t} while( n > 0 );\n\t\t#end\n\t\t#if python\n\t\tif (digits != null && s.length < digits) {\n\t\t\tvar diff = digits - s.length;\n\t\t\tfor (_ in 0...diff) {\n\t\t\t\ts = \"0\" + s;\n\t\t\t}\n\t\t}\n\t\t#else\n\t\tif( digits != null )\n\t\t\twhile( s.length < digits )\n\t\t\t\ts = \"0\"+s;\n\t\t#end\n\t\treturn s;\n\t}\n\n\t/**\n\t\tReturns the character code at position `index` of String `s`, or an\n\t\tend-of-file indicator at if `position` equals `s.length`.\n\n\t\tThis method is faster than String.charCodeAt() on some platforms, but\n\t\tthe result is unspecified if `index` is negative or greater than\n\t\t`s.length`.\n\n\t\tEnd of file status can be checked by calling `StringTools.isEof` with\n\t\tthe returned value as argument.\n\n\t\tThis operation is not guaranteed to work if `s` contains the \\0\n\t\tcharacter.\n\t**/\n\tpublic static inline function fastCodeAt( s : String, index : Int ) : Int {\n\t\t#if neko\n\t\treturn untyped __dollar__sget(s.__s, index);\n\t\t#elseif cpp\n\t\treturn untyped s.cca(index);\n\t\t#elseif flash\n\t\treturn untyped s.cca(index);\n\t\t#elseif java\n\t\treturn ( index < s.length ) ? cast(_charAt(s, index), Int) : -1;\n\t\t#elseif cs\n\t\treturn ( cast(index, UInt) < s.length ) ? cast(s[index], Int) : -1;\n\t\t#elseif js\n\t\treturn (untyped s).charCodeAt(index);\n\t\t#elseif python\n\t\treturn if (index >= s.length) -1 else python.internal.UBuiltins.ord(python.Syntax.arrayAccess(s, index));\n\t\t#else\n\t\treturn untyped s.cca(index);\n\t\t#end\n\t}\n\n\t/*\n\t\tTells if `c` represents the end-of-file (EOF) character.\n\t*/\n\t@:noUsing public static inline function isEof( c : Int ) : Bool {\n\t\t#if (flash || cpp)\n\t\treturn c == 0;\n\t\t#elseif js\n\t\treturn c != c; // fast NaN\n\t\t#elseif neko\n\t\treturn c == null;\n\t\t#elseif cs\n\t\treturn c == -1;\n\t\t#elseif java\n\t\treturn c == -1;\n\t\t#elseif python\n\t\treturn c == -1;\n\t\t#else\n\t\treturn false;\n\t\t#end\n\t}\n\n\t#if java\n\tprivate static inline function _charAt(str:String, idx:Int):java.StdTypes.Char16 return untyped str._charAt(idx);\n\t#end\n\n\t#if neko\n\tprivate static var _urlEncode = neko.Lib.load(\"std\",\"url_encode\",1);\n\tprivate static var _urlDecode = neko.Lib.load(\"std\",\"url_decode\",1);\n\t#end\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\nenum ValueType {\n\tTNull;\n\tTInt;\n\tTFloat;\n\tTBool;\n\tTObject;\n\tTFunction;\n\tTClass( c : Class<Dynamic> );\n\tTEnum( e : Enum<Dynamic> );\n\tTUnknown;\n}\n\n@:coreApi class Type {\n\n\tpublic static inline function getClass<T>( o : T ) : Class<T> {\n\t\treturn if (o == null) null else @:privateAccess js.Boot.getClass(o);\n\t}\n\n\tpublic static function getEnum( o : EnumValue ) : Enum<Dynamic> untyped {\n\t\tif( o == null )\n\t\t\treturn null;\n\t\treturn o.__enum__;\n\t}\n\n\tpublic static function getSuperClass( c : Class<Dynamic> ) : Class<Dynamic> untyped {\n\t\treturn c.__super__;\n\t}\n\n\n\tpublic static function getClassName( c : Class<Dynamic> ) : String {\n\t\tvar a : Array<String> = untyped c.__name__;\n\t\tif (a == null)\n\t\t\treturn null;\n\t\treturn a.join(\".\");\n\t}\n\n\tpublic static function getEnumName( e : Enum<Dynamic> ) : String {\n\t\tvar a : Array<String> = untyped e.__ename__;\n\t\treturn a.join(\".\");\n\t}\n\n\tpublic static function resolveClass( name : String ) : Class<Dynamic> untyped {\n\t\tvar cl : Class<Dynamic> = $hxClasses[name];\n\t\t// ensure that this is a class\n\t\tif( cl == null || !js.Boot.isClass(cl) )\n\t\t\treturn null;\n\t\treturn cl;\n\t}\n\n\tpublic static function resolveEnum( name : String ) : Enum<Dynamic> untyped {\n\t\tvar e : Dynamic = $hxClasses[name];\n\t\t// ensure that this is an enum\n\t\tif( e == null || !js.Boot.isEnum(e) )\n\t\t\treturn null;\n\t\treturn e;\n\t}\n\n\tpublic static function createInstance<T>( cl : Class<T>, args : Array<Dynamic> ) : T untyped {\n\t\tswitch( args.length ) {\n\t\tcase 0:\n\t\t\treturn __new__(cl);\n\t\tcase 1:\n\t\t\treturn __new__(cl,args[0]);\n\t\tcase 2:\n\t\t\treturn __new__(cl,args[0],args[1]);\n\t\tcase 3:\n\t\t\treturn __new__(cl,args[0],args[1],args[2]);\n\t\tcase 4:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3]);\n\t\tcase 5:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4]);\n\t\tcase 6:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4],args[5]);\n\t\tcase 7:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4],args[5],args[6]);\n\t\tcase 8:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7]);\n\t\tdefault:\n\t\t\tthrow \"Too many arguments\";\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static function createEmptyInstance<T>( cl : Class<T> ) : T untyped {\n\t\t__js__(\"function empty() {}; empty.prototype = cl.prototype\");\n\t\treturn __js__(\"new empty()\");\n\t}\n\n\tpublic static function createEnum<T>( e : Enum<T>, constr : String, ?params : Array<Dynamic> ) : T {\n\t\tvar f:Dynamic = Reflect.field(e,constr);\n\t\tif( f == null ) throw \"No such constructor \"+constr;\n\t\tif( Reflect.isFunction(f) ) {\n\t\t\tif( params == null ) throw \"Constructor \"+constr+\" need parameters\";\n\t\t\treturn Reflect.callMethod(e,f,params);\n\t\t}\n\t\tif( params != null && params.length != 0 )\n\t\t\tthrow \"Constructor \"+constr+\" does not need parameters\";\n\t\treturn f;\n\t}\n\n\tpublic static function createEnumIndex<T>( e : Enum<T>, index : Int, ?params : Array<Dynamic> ) : T {\n\t\tvar c : String = (untyped e.__constructs__)[index];\n\t\tif( c == null ) throw index+\" is not a valid enum constructor index\";\n\t\treturn createEnum(e,c,params);\n\t}\n\n\tpublic static function getInstanceFields( c : Class<Dynamic> ) : Array<String> {\n\t\tvar a = [];\n\t\tuntyped __js__(\"for(var i in c.prototype) a.push(i)\");\n\t\ta.remove(\"__class__\");\n\t\ta.remove(\"__properties__\");\n\t\treturn a;\n\t}\n\n\tpublic static function getClassFields( c : Class<Dynamic> ) : Array<String> {\n\t\tvar a = Reflect.fields(c);\n\t\ta.remove(\"__name__\");\n\t\ta.remove(\"__interfaces__\");\n\t\ta.remove(\"__properties__\");\n\t\ta.remove(\"__super__\");\n\t\ta.remove(\"__meta__\");\n\t\ta.remove(\"prototype\");\n\t\treturn a;\n\t}\n\n\tpublic static function getEnumConstructs( e : Enum<Dynamic> ) : Array<String> {\n\t\tvar a : Array<String> = untyped e.__constructs__;\n\t\treturn a.copy();\n\t}\n\n\tpublic static function typeof( v : Dynamic ) : ValueType untyped {\n\t\tswitch( __js__(\"typeof\")(v) ) {\n\t\tcase \"boolean\": return TBool;\n\t\tcase \"string\": return TClass(String);\n\t\tcase \"number\":\n\t\t\t// this should handle all cases : NaN, +/-Inf and Floats outside range\n\t\t\tif( Math.ceil(v) == v%2147483648.0 )\n\t\t\t\treturn TInt;\n\t\t\treturn TFloat;\n\t\tcase \"object\":\n\t\t\tif( v == null )\n\t\t\t\treturn TNull;\n\t\t\tvar e = v.__enum__;\n\t\t\tif( e != null )\n\t\t\t\treturn TEnum(e);\n\t\t\tvar c = js.Boot.getClass(v);\n\t\t\tif( c != null )\n\t\t\t\treturn TClass(c);\n\t\t\treturn TObject;\n\t\tcase \"function\":\n\t\t\tif( js.Boot.isClass(v) || js.Boot.isEnum(v) )\n\t\t\t\treturn TObject;\n\t\t\treturn TFunction;\n\t\tcase \"undefined\":\n\t\t\treturn TNull;\n\t\tdefault:\n\t\t\treturn TUnknown;\n\t\t}\n\t}\n\n\tpublic static function enumEq<T>( a : T, b : T ) : Bool untyped {\n\t\tif( a == b )\n\t\t\treturn true;\n\t\ttry {\n\t\t\tif( a[0] != b[0] )\n\t\t\t\treturn false;\n\t\t\tfor( i in 2...a.length )\n\t\t\t\tif( !enumEq(a[i],b[i]) )\n\t\t\t\t\treturn false;\n\t\t\tvar e = a.__enum__;\n\t\t\tif( e != b.__enum__ || e == null )\n\t\t\t\treturn false;\n\t\t} catch( e : Dynamic ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic inline static function enumConstructor( e : EnumValue ) : String {\n\t\treturn untyped e[0];\n\t}\n\n\tpublic inline static function enumParameters( e : EnumValue ) : Array<Dynamic> {\n\t\treturn untyped e.slice(2);\n\t}\n\n\tpublic inline static function enumIndex( e : EnumValue ) : Int {\n\t\treturn untyped e[1];\n\t}\n\n\tpublic static function allEnums<T>( e : Enum<T> ) : Array<T> {\n\t\treturn untyped e.__empty_constructs__;\n\t}\n\n}\n\n","/*\n * Copyright (C)2005-2013 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\n#if ((flash || flash9doc || cs) && !doc_gen)\n/**\n\tThe unsigned Int type is only defined for Flash and C#. It's currently\n\thandled the same as a normal Int.\n**/\n@:coreType\n@:notNull\n@:runtimeValue\n@:analyzer(no_const_propagation)\nabstract UInt to Int from Int\n{\n\t@:commutative @:op(A+B) private static function addI(lhs:UInt, rhs:Int):UInt;\n\t@:commutative @:op(A+B) private static function addF(lhs:UInt, rhs:Float):Float;\n\t@:op(A+B) private static function add(lhs:UInt, rhs:UInt):UInt;\n\n\t@:commutative @:op(A*B) private static function mulI(lhs:UInt, rhs:Int):UInt;\n\t@:commutative @:op(A*B) private static function mulF(lhs:UInt, rhs:Float):Float;\n\t@:op(A*B) private static function mul(lhs:UInt, rhs:UInt):UInt;\n\n\t@:op(A%B) private static function modI(lhs:UInt, rhs:Int):UInt;\n\t@:op(A%B) private static function modF(lhs:UInt, rhs:Float):Float;\n\t@:op(A%B) private static function mod(lhs:UInt, rhs:UInt):UInt;\n\n\t@:op(A-B) private static function subI(lhs:UInt, rhs:Int):UInt;\n\t@:op(A-B) private static function subF(lhs:UInt, rhs:Float):Float;\n\t@:op(A-B) private static function sub(lhs:UInt, rhs:UInt):UInt;\n\n\t@:op(A/B) private static function divI(lhs:UInt, rhs:Int):Float;\n\t@:op(A/B) private static function divF(lhs:UInt, rhs:Float):Float;\n\t@:op(A/B) private static function div(lhs:UInt, rhs:UInt):Float;\n\n\t@:commutative @:op(A|B) private static function orI(lhs:UInt, rhs:Int):UInt;\n\t@:op(A|B) private static function or(lhs:UInt, rhs:UInt):UInt;\n\n\t@:commutative @:op(A^B) private static function xorI(lhs:UInt, rhs:Int):UInt;\n\t@:op(A^B) private static function xor(lhs:UInt, rhs:UInt):UInt;\n\n\t@:commutative @:op(A&B) private static function andI(lhs:UInt, rhs:Int):UInt;\n\t@:op(A&B) private static function and(lhs:UInt, rhs:UInt):UInt;\n\n\t@:op(A<<B) private static function shl(lhs:UInt, rhs:Int):UInt;\n\t@:op(A>>B) private static function shr(lhs:UInt, rhs:Int):UInt;\n\t@:op(A>>>B) private static function ushr(lhs:UInt, rhs:Int):UInt;\n\n\t@:op(A>B) private static function gt(lhs:UInt, rhs:UInt):Bool;\n\t@:op(A>=B) private static function gte(lhs:UInt, rhs:UInt):Bool;\n\t@:op(A<B) private static function lt(lhs:UInt, rhs:UInt):Bool;\n\t@:op(A<=B) private static function lte(lhs:UInt, rhs:UInt):Bool;\n\n\t@:op(A>B) private static function gtf(lhs:UInt, rhs:Float):Bool;\n\t@:op(A>B) private static function gtf(lhs:Float, rhs:UInt):Bool;\n\t@:op(A>=B) private static function gtef(lhs:UInt, rhs:Float):Bool;\n\t@:op(A>=B) private static function gtef(lhs:Float, rhs:UInt):Bool;\n\t@:op(A<B) private static function ltf(lhs:UInt, rhs:Float):Bool;\n\t@:op(A<B) private static function ltf(lhs:Float, rhs:UInt):Bool;\n\t@:op(A<=B) private static function ltef(lhs:UInt, rhs:Float):Bool;\n\t@:op(A<=B) private static function ltef(lhs:Float, rhs:UInt):Bool;\n\n\t@:op(~A) private static function bneg(t:UInt):UInt;\n\n\t@:commutative @:op(A == B) private static function equalsInt<T:Int>(a:UInt, b:T):Bool;\n\t@:commutative @:op(A != B) private static function notEqualsInt<T:Int>(a:UInt, b:T):Bool;\n\t@:commutative @:op(A == B) private static function equalsFloat<T:Float>(a:UInt, b:T):Bool;\n\t@:commutative @:op(A != B) private static function notEqualsFloat<T:Float>(a:UInt, b:T):Bool;\n\n\t@:op(++A) private function prefixIncrement():UInt;\n\t@:op(A++) private function postfixIncrement():UInt;\n\t@:op(--A) private function prefixDecrement():UInt;\n\t@:op(A--) private function postfixDecrement():UInt;\n}\n#else\n/**\n\tThe unsigned Int type is only defined for Flash and C#.\n\tSimulate it for other platforms.\n**/\nabstract UInt(Int) from Int to Int {\n\n\t@:op(A + B) private static inline function add(a:UInt, b:UInt):UInt {\n\t\treturn a.toInt() + b.toInt();\n\t}\n\n\t@:op(A / B) private static inline function div(a:UInt, b:UInt):Float {\n\t\treturn a.toFloat() / b.toFloat();\n\t}\n\n\t@:op(A * B) private static inline function mul(a:UInt, b:UInt):UInt {\n\t\treturn a.toInt() * b.toInt();\n\t}\n\n\t@:op(A - B) private static inline function sub(a:UInt, b:UInt):UInt {\n\t\treturn a.toInt() - b.toInt();\n\t}\n\n\t@:op(A > B) private static #if !js inline #end function gt(a:UInt, b:UInt):Bool {\n\t\tvar aNeg = a.toInt() < 0;\n\t\tvar bNeg = b.toInt() < 0;\n\t\treturn\n\t\t\tif( aNeg != bNeg ) aNeg;\n\t\t\telse a.toInt() > b.toInt();\n\t}\n\n\t@:op(A >= B) private static #if !js inline #end function gte(a:UInt, b:UInt):Bool {\n\t\tvar aNeg = a.toInt() < 0;\n\t\tvar bNeg = b.toInt() < 0;\n\t\treturn\n\t\t\tif( aNeg != bNeg ) aNeg;\n\t\t\telse a.toInt() >= b.toInt();\n\t}\n\n\t@:op(A < B) private static inline function lt(a:UInt, b:UInt):Bool {\n\t\treturn gt(b, a);\n\t}\n\n\t@:op(A <= B) private static inline function lte(a:UInt, b:UInt):Bool {\n\t\treturn gte(b, a);\n\t}\n\n\t@:op(A & B) private static inline function and(a:UInt, b:UInt):UInt {\n\t\treturn a.toInt() & b.toInt();\n\t}\n\n\t@:op(A | B) private static inline function or(a:UInt, b:UInt):UInt {\n\t\treturn a.toInt() | b.toInt();\n\t}\n\n\t@:op(A ^ B) private static inline function xor(a:UInt, b:UInt):UInt {\n\t\treturn a.toInt() ^ b.toInt();\n\t}\n\n\t@:op(A << B) private static inline function shl(a:UInt, b:Int):UInt {\n\t\treturn a.toInt() << b;\n\t}\n\n\t@:op(A >> B) private static inline function shr(a:UInt, b:Int):UInt {\n\t\treturn a.toInt() >> b;\n\t}\n\n\t@:op(A >>> B) private static inline function ushr(a:UInt, b:Int):UInt {\n\t\treturn a.toInt() >>> b;\n\t}\n\n\t@:op(A % B) private static inline function mod(a:UInt, b:UInt):UInt {\n\t\treturn Std.int( a.toFloat() % b.toFloat() );\n\t}\n\n\t@:commutative @:op(A + B) private static inline function addWithFloat(a:UInt, b:Float):Float {\n\t\treturn a.toFloat() + b;\n\t}\n\n\t@:commutative @:op(A * B) private static inline function mulWithFloat(a:UInt, b:Float):Float {\n\t\treturn a.toFloat() * b;\n\t}\n\n\t@:op(A / B) private static inline function divFloat(a:UInt, b:Float):Float {\n\t\treturn a.toFloat() / b;\n\t}\n\n\t@:op(A / B) private static inline function floatDiv(a:Float, b:UInt):Float {\n\t\treturn a / b.toFloat();\n\t}\n\n\t@:op(A - B) private static inline function subFloat(a:UInt, b:Float):Float {\n\t\treturn a.toFloat() - b;\n\t}\n\n\t@:op(A - B) private static inline function floatSub(a:Float, b:UInt):Float {\n\t\treturn a - b.toFloat();\n\t}\n\n\t@:op(A > B) private static inline function gtFloat(a:UInt, b:Float):Bool {\n\t\treturn a.toFloat() > b;\n\t}\n\n\t@:commutative @:op(A == B) private static inline function equalsInt<T:Int>(a:UInt, b:T):Bool {\n\t\treturn a.toInt() == b;\n\t}\n\n\t@:commutative @:op(A != B) private static inline function notEqualsInt<T:Int>(a:UInt, b:T):Bool {\n\t\treturn a.toInt() != b;\n\t}\n\n\t@:commutative @:op(A == B) private static inline function equalsFloat<T:Float>(a:UInt, b:T):Bool {\n        return a.toFloat() == b;\n    }\n\n    @:commutative @:op(A != B) private static inline function notEqualsFloat<T:Float>(a:UInt, b:T):Bool {\n        return a.toFloat() != b;\n    }\n\n\t@:op(A >= B) private static inline function gteFloat(a:UInt, b:Float):Bool {\n\t\treturn a.toFloat() >= b;\n\t}\n\n\n\t@:op(A > B) private static inline function floatGt(a:Float, b:UInt):Bool {\n\t\treturn a > b.toFloat();\n\t}\n\n\t@:op(A >= B) private static inline function floatGte(a:Float, b:UInt):Bool {\n\t\treturn a >= b.toFloat();\n\t}\n\n\t@:op(A < B) private static inline function ltFloat(a:UInt, b:Float):Bool {\n\t\treturn a.toFloat() < b;\n\t}\n\n\t@:op(A <= B) private static inline function lteFloat(a:UInt, b:Float):Bool {\n\t\treturn a.toFloat() <= b;\n\t}\n\n\t@:op(A < B) private static inline function floatLt(a:Float, b:UInt):Bool {\n\t\treturn a < b.toFloat();\n\t}\n\n\t@:op(A <= B) private static inline function floatLte(a:Float, b:UInt):Bool {\n\t\treturn a <= b.toFloat();\n\t}\n\n\t@:op(A % B) private static inline function modFloat(a:UInt, b:Float):Float {\n\t\treturn a.toFloat() % b;\n\t}\n\n\t@:op(A % B) private static inline function floatMod(a:Float, b:UInt):Float {\n\t\treturn a % b.toFloat();\n\t}\n\n\t@:op(~A) private inline function negBits():UInt {\n\t\treturn ~this;\n\t}\n\n\t@:op(++A) private inline function prefixIncrement():UInt {\n\t\treturn ++this;\n\t}\n\n\t@:op(A++) private inline function postfixIncrement():UInt {\n\t\treturn this++;\n\t}\n\n\t@:op(--A) private inline function prefixDecrement():UInt {\n\t\treturn --this;\n\t}\n\n\t@:op(A--) private inline function postfixDecrement():UInt {\n\t\treturn this--;\n\t}\n\n\t// TODO: radix is just defined to deal with doc_gen issues\n\tprivate inline function toString(?radix:Int):String {\n\t\treturn Std.string(toFloat());\n\t}\n\n\tprivate inline function toInt():Int {\n\t\treturn this;\n\t}\n\n\t@:to private #if (!js || analyzer) inline #end function toFloat():Float {\n\t\tvar int = toInt();\n\t\tif (int < 0) {\n\t\t\treturn 4294967296.0 + int;\n\t\t}\n\t\telse {\n\t\t\t// + 0.0 here to make sure we promote to Float on some platforms\n\t\t\t// In particular, PHP was having issues when comparing to Int in the == op.\n\t\t\treturn int + 0.0;\n\t\t}\n\t}\n}\n#end\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe;\n\n/**\n\tElements return by `CallStack` methods.\n**/\nenum StackItem {\n\tCFunction;\n\tModule( m : String );\n\tFilePos( s : Null<StackItem>, file : String, line : Int );\n\tMethod( classname : String, method : String );\n\tLocalFunction( ?v : Int );\n}\n\n/**\n\tGet informations about the call stack.\n**/\nclass CallStack {\n\t#if js\n\tstatic var lastException:js.Error;\n\n\tstatic function getStack(e:js.Error):Array<StackItem> {\n\t\tif (e == null) return [];\n\t\t// https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi\n\t\tvar oldValue = (untyped Error).prepareStackTrace;\n\t\t(untyped Error).prepareStackTrace = function (error, callsites :Array<Dynamic>) {\n\t\t\tvar stack = [];\n\t\t\tfor (site in callsites) {\n\t\t\t\tif (wrapCallSite != null) site = wrapCallSite(site);\n\t\t\t\tvar method = null;\n\t\t\t\tvar fullName :String = site.getFunctionName();\n\t\t\t\tif (fullName != null) {\n\t\t\t\t\tvar idx = fullName.lastIndexOf(\".\");\n\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\tvar className = fullName.substr(0, idx);\n\t\t\t\t\t\tvar methodName = fullName.substr(idx+1);\n\t\t\t\t\t\tmethod = Method(className, methodName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstack.push(FilePos(method, site.getFileName(), site.getLineNumber()));\n\t\t\t}\n\t\t\treturn stack;\n\t\t}\n\t\tvar a = makeStack(e.stack);\n\t\t(untyped Error).prepareStackTrace = oldValue;\n\t\treturn a;\n\t}\n\n\t// support for source-map-support module\n\t@:noCompletion\n\tpublic static var wrapCallSite:Dynamic->Dynamic;\n\t#end\n\n\t/**\n\t\tReturn the call stack elements, or an empty array if not available.\n\t**/\n\tpublic static function callStack() : Array<StackItem> {\n\t\t#if neko\n\t\t\tvar a = makeStack(untyped __dollar__callstack());\n\t\t\ta.shift(); // remove Stack.callStack()\n\t\t\treturn a;\n\t\t#elseif flash\n\t\t\tvar a = makeStack( new flash.errors.Error().getStackTrace() );\n\t\t\ta.shift(); // remove Stack.callStack()\n\t\t\treturn a;\n\t\t#elseif php\n\t\t\treturn makeStack(\"%s\");\n\t\t#elseif cpp\n\t\t\tvar s:Array<String> = untyped __global__.__hxcpp_get_call_stack(true);\n\t\t\treturn makeStack(s);\n\t\t#elseif js\n\t\t\ttry {\n\t\t\t\tthrow new js.Error();\n\t\t\t} catch( e : Dynamic ) {\n\t\t\t\tvar a = getStack(e);\n\t\t\t\ta.shift(); // remove Stack.callStack()\n\t\t\t\treturn a;\n\t\t\t}\n\n\t\t#elseif java\n\t\t\tvar stack = [];\n\t\t\tfor ( el in java.lang.Thread.currentThread().getStackTrace() ) {\n\t\t\t\tvar className = el.getClassName();\n\t\t\t\tvar methodName = el.getMethodName();\n\t\t\t\tvar fileName = el.getFileName();\n\t\t\t\tvar lineNumber = el.getLineNumber();\n\t\t\t\tvar method = Method( className, methodName );\n\t\t\t\tif ( fileName != null || lineNumber >= 0 ) {\n\t\t\t\t\tstack.push( FilePos( method, fileName, lineNumber ) );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstack.push( method );\n\t\t\t\t}\n\t\t\t}\n\t\t\tstack.shift();\n\t\t\tstack.shift();\n\t\t\tstack.pop();\n\t\t\treturn stack;\n\t\t#elseif cs\n\t\t\treturn makeStack(new cs.system.diagnostics.StackTrace(1, true));\n\t\t#elseif python\n\t\t\tvar stack = [];\n\t\t\tvar infos = python.lib.Traceback.extract_stack();\n\t\t\tinfos.pop();\n\t\t\tinfos.reverse();\n\t\t\tfor (elem in infos)\n\t\t\t\tstack.push(FilePos(null, elem._1, elem._2));\n\t\t\treturn stack;\n\t\t#else\n\t\t\treturn []; // Unsupported\n\t\t#end\n\t}\n\n\t/**\n\t\tReturn the exception stack : this is the stack elements between\n\t\tthe place the last exception was thrown and the place it was\n\t\tcaught, or an empty array if not available.\n\t**/\n\t#if cpp @:noStack #end /* Do not mess up the exception stack */\n\tpublic static function exceptionStack() : Array<StackItem> {\n\t\t#if neko\n\t\t\treturn makeStack(untyped __dollar__excstack());\n\t\t#elseif as3\n\t\t\treturn new Array();\n\t\t#elseif flash\n\t\t\tvar err : flash.errors.Error = untyped flash.Boot.lastError;\n\t\t\tif( err == null ) return new Array();\n\t\t\tvar a = makeStack( err.getStackTrace() );\n\t\t\tvar c = callStack();\n\t\t\tvar i = c.length - 1;\n\t\t\twhile( i > 0 ) {\n\t\t\t\tif( Std.string(a[a.length-1]) == Std.string(c[i]) )\n\t\t\t\t\ta.pop();\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t\ti--;\n\t\t\t}\n\t\t\treturn a;\n\t\t#elseif php\n\t\t\treturn makeStack(\"%e\");\n\t\t#elseif cpp\n\t\t\tvar s:Array<String> = untyped __global__.__hxcpp_get_exception_stack();\n\t\t\treturn makeStack(s);\n\t\t#elseif java\n\t\t\tvar stack = [];\n\t\t\tfor ( el in java.internal.Exceptions.currentException().getStackTrace() ) {\n\t\t\t\tvar className = el.getClassName();\n\t\t\t\tvar methodName = el.getMethodName();\n\t\t\t\tvar fileName = el.getFileName();\n\t\t\t\tvar lineNumber = el.getLineNumber();\n\t\t\t\tvar method = Method( className, methodName );\n\t\t\t\tif ( fileName != null || lineNumber >= 0 ) {\n\t\t\t\t\tstack.push( FilePos( method, fileName, lineNumber ) );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstack.push( method );\n\t\t\t\t}\n\t\t\t}\n\t\t\t// stack.shift();\n\t\t\tstack.shift();\n\t\t\tstack.pop();\n\t\t\treturn stack;\n\t\t#elseif cs\n\t\t\treturn makeStack(new cs.system.diagnostics.StackTrace(cs.internal.Exceptions.exception, true));\n\t\t#elseif python\n\t\t\tvar stack = [];\n\t\t\tvar exc = python.lib.Sys.exc_info();\n\t\t\tif (exc._3 != null)\n\t\t\t{\n\t\t\t\tvar infos = python.lib.Traceback.extract_tb(exc._3);\n\t\t\t\tinfos.reverse();\n\t\t\t\tfor (elem in infos)\n\t\t\t\t\tstack.push(FilePos(null, elem._1, elem._2));\n\t\t\t}\n\t\t\treturn stack;\n\t\t#elseif js\n\t\t\treturn untyped __define_feature__(\"haxe.CallStack.exceptionStack\", getStack(lastException));\n\t\t#else\n\t\t\treturn []; // Unsupported\n\t\t#end\n\t}\n\n\t/**\n\t\tReturns a representation of the stack as a printable string.\n\t**/\n\tpublic static function toString( stack : Array<StackItem> ) {\n\t\tvar b = new StringBuf();\n\t\tfor( s in stack ) {\n\t\t\tb.add(\"\\nCalled from \");\n\t\t\titemToString(b,s);\n\t\t}\n\t\treturn b.toString();\n\t}\n\n\tprivate static function itemToString( b : StringBuf, s ) {\n\t\tswitch( s ) {\n\t\tcase CFunction:\n\t\t\tb.add(\"a C function\");\n\t\tcase Module(m):\n\t\t\tb.add(\"module \");\n\t\t\tb.add(m);\n\t\tcase FilePos(s,file,line):\n\t\t\tif( s != null ) {\n\t\t\t\titemToString(b,s);\n\t\t\t\tb.add(\" (\");\n\t\t\t}\n\t\t\tb.add(file);\n\t\t\tb.add(\" line \");\n\t\t\tb.add(line);\n\t\t\tif( s != null ) b.add(\")\");\n\t\tcase Method(cname,meth):\n\t\t\tb.add(cname);\n\t\t\tb.add(\".\");\n\t\t\tb.add(meth);\n\t\tcase LocalFunction(n):\n\t\t\tb.add(\"local function #\");\n\t\t\tb.add(n);\n\t\t}\n\t}\n\n\t#if cpp @:noStack #end /* Do not mess up the exception stack */\n\tprivate static function makeStack(s #if cs : cs.system.diagnostics.StackTrace #end) {\n\t\t#if neko\n\t\t\tvar a = new Array();\n\t\t\tvar l = untyped __dollar__asize(s);\n\t\t\tvar i = 0;\n\t\t\twhile( i < l ) {\n\t\t\t\tvar x = s[i++];\n\t\t\t\tif( x == null )\n\t\t\t\t\ta.unshift(CFunction);\n\t\t\t\telse if( untyped __dollar__typeof(x) == __dollar__tstring )\n\t\t\t\t\ta.unshift(Module(new String(x)));\n\t\t\t\telse\n\t\t\t\t\ta.unshift(FilePos(null,new String(untyped x[0]),untyped x[1]));\n\t\t\t}\n\t\t\treturn a;\n\t\t#elseif flash\n\t\t\tvar a = new Array();\n\t\t\tvar r = ~/at ([^\\/]+?)\\$?(\\/[^\\(]+)?\\(\\)(\\[(.*?):([0-9]+)\\])?/;\n\t\t\tvar rlambda = ~/^MethodInfo-([0-9]+)$/g;\n\t\t\twhile( r.match(s) ) {\n\t\t\t\tvar cl = r.matched(1).split(\"::\").join(\".\");\n\t\t\t\tvar meth = r.matched(2);\n\t\t\t\tvar item;\n\t\t\t\tif( meth == null ) {\n\t\t\t\t\tif( rlambda.match(cl) )\n\t\t\t\t\t\titem = LocalFunction(Std.parseInt(rlambda.matched(1)));\n\t\t\t\t\telse\n\t\t\t\t\t\titem = Method(cl,\"new\");\n\t\t\t\t} else\n\t\t\t\t\titem = Method(cl,meth.substr(1));\n\t\t\t\tif( r.matched(3) != null )\n\t\t\t\t\titem = FilePos( item, r.matched(4), Std.parseInt(r.matched(5)) );\n\t\t\t\ta.push(item);\n\t\t\t\ts = r.matchedRight();\n\t\t\t}\n\t\t\treturn a;\n\t\t#elseif php\n\t\t\tif (!untyped __call__(\"isset\", __var__(\"GLOBALS\", s)))\n\t\t\t\treturn [];\n\t\t\tvar a : Array<String> = untyped __var__(\"GLOBALS\", s);\n\t\t\tvar m = [];\n\t\t\tfor( i in 0...a.length - ((s == \"%s\") ? 2 : 0)) {\n\t\t\t\tvar d = a[i].split(\"::\");\n\t\t\t\tm.unshift(Method(d[0],d[1]));\n\t\t\t}\n\t\t\treturn m;\n\t\t#elseif cpp\n\t\t\tvar stack : Array<String> = s;\n\t\t\tvar m = new Array<StackItem>();\n\t\t\tfor(func in stack) {\n\t\t\t\tvar words = func.split(\"::\");\n\t\t\t\tif (words.length==0)\n\t\t\t\t\tm.push(CFunction)\n\t\t\t\telse if (words.length==2)\n\t\t\t\t\tm.push(Method(words[0],words[1]));\n\t\t\t\telse if (words.length==4)\n\t\t\t\t\tm.push(FilePos( Method(words[0],words[1]),words[2],Std.parseInt(words[3])));\n\t\t\t}\n\t\t\treturn m;\n\t\t#elseif js\n\t\t\tif (s == null) {\n\t\t\t\treturn [];\n\t\t\t} else if ((untyped __js__(\"typeof\"))(s) == \"string\") {\n\t\t\t\t// Return the raw lines in browsers that don't support prepareStackTrace\n\t\t\t\tvar stack : Array<String> = s.split(\"\\n\");\n\t\t\t\tif( stack[0] == \"Error\" ) stack.shift();\n\t\t\t\tvar m = [];\n\t\t\t\tvar rie10 = ~/^   at ([A-Za-z0-9_. ]+) \\(([^)]+):([0-9]+):([0-9]+)\\)$/;\n\t\t\t\tfor( line in stack ) {\n\t\t\t\t\tif( rie10.match(line) ) {\n\t\t\t\t\t\tvar path = rie10.matched(1).split(\".\");\n\t\t\t\t\t\tvar meth = path.pop();\n\t\t\t\t\t\tvar file = rie10.matched(2);\n\t\t\t\t\t\tvar line = Std.parseInt(rie10.matched(3));\n\t\t\t\t\t\tm.push(FilePos( meth == \"Anonymous function\" ? LocalFunction() : meth == \"Global code\" ? null : Method(path.join(\".\"),meth), file, line ));\n\t\t\t\t\t} else\n\t\t\t\t\t\tm.push(Module(StringTools.trim(line))); // A little weird, but better than nothing\n\t\t\t\t}\n\t\t\t\treturn m;\n\t\t\t} else {\n\t\t\t\treturn cast s;\n\t\t\t}\n\t\t#elseif cs\n\t\t\tvar stack = [];\n\t\t\tfor (i in 0...s.FrameCount)\n\t\t\t{\n\t\t\t\tvar frame = s.GetFrame(i);\n\t\t\t\tvar m = frame.GetMethod();\n\n\t\t\t\tvar method = StackItem.Method(m.ReflectedType.ToString(), m.Name);\n\n\t\t\t\tvar fileName = frame.GetFileName();\n\t\t\t\tvar lineNumber = frame.GetFileLineNumber();\n\n\t\t\t\tif (fileName != null || lineNumber >= 0)\n\t\t\t\t\tstack.push(FilePos(method, fileName, lineNumber));\n\t\t\t\telse\n\t\t\t\t\tstack.push(method);\n\t\t\t}\n\t\t\treturn stack;\n\t\t#else\n\t\t\treturn null;\n\t\t#end\n\t}\n\n}\n","/*\n * Copyright (C)2005-2013 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe;\n\nusing haxe.Int64;\n\n /**\n\tA cross-platform signed 64-bit integer.\n\tInt64 instances can be created from two 32-bit words using `Int64.make()`.\n **/\n#if flash\n@:notNull\n#end\nabstract Int64(__Int64) from __Int64 to __Int64\n{\n\tprivate inline function new( x : __Int64 )\n\t\tthis = x;\n\n\t/**\n\t\tMakes a copy of `this` Int64.\n\t**/\n\tpublic inline function copy():Int64\n\t\treturn make( high, low );\n\n\t/**\n\t\tConstruct an Int64 from two 32-bit words `high` and `low`.\n\t**/\n\tpublic static inline function make( high:Int32, low:Int32 ) : Int64\n\t\treturn new Int64( new __Int64(high, low) );\n\n\t/**\n\t\tReturns an Int64 with the value of the Int `x`.\n\t\t`x` is sign-extended to fill 64 bits.\n\t**/\n\t@:from public static inline function ofInt( x : Int ) : Int64\n\t\treturn make( x >> 31, x );\n\n\t/**\n\t\tReturns an Int with the value of the Int64 `x`.\n\t\tThrows an exception  if `x` cannot be represented in 32 bits.\n\t**/\n\tpublic static inline function toInt( x : Int64 ) : Int {\n\t\tif( x.high != x.low >> 31 )\n\t\t\tthrow \"Overflow\";\n\n\t\treturn x.low;\n\t}\n\n\t/**\n\t\tReturns whether the value `val` is of type `haxe.Int64`\n\t**/\n\tinline public static function is( val : Dynamic ) : Bool\n\t\treturn Std.is(val,__Int64);\n\n\t/**\n\t\tReturns the high 32-bit word of `x`.\n\t**/\n\t@:deprecated(\"Use high instead\")\n\tpublic static inline function getHigh( x : Int64 ) : Int32\n\t\treturn x.high;\n\n\t/**\n\t\tReturns the low 32-bit word of `x`.\n\t**/\n\t@:deprecated(\"Use low instead\")\n\tpublic static inline function getLow( x : Int64 ) : Int32\n\t\treturn x.low;\n\n\t/**\n\t\tReturns `true` if `x` is less than zero.\n\t**/\n\tpublic static inline function isNeg( x : Int64) : Bool\n\t\treturn x.high < 0;\n\n\t/**\n\t\tReturns `true` if `x` is exactly zero.\n\t**/\n\tpublic static inline function isZero( x : Int64 ) : Bool\n\t\treturn x == 0;\n\n\t/**\n\t\tCompares `a` and `b` in signed mode.\n\t\tReturns a negative value if `a < b`, positive if `a > b`,\n\t\tor 0 if `a == b`.\n\t**/\n\tpublic static inline function compare( a : Int64, b : Int64 ) : Int {\n\t\tvar v = a.high - b.high;\n\t\tv = if( v != 0 ) v else Int32.ucompare(a.low, b.low);\n\t\treturn a.high < 0 ? (b.high < 0 ? v : -1) : (b.high >= 0 ? v : 1);\n\t}\n\n\t/**\n\t\tCompares `a` and `b` in unsigned mode.\n\t\tReturns a negative value if `a < b`, positive if `a > b`,\n\t\tor 0 if `a == b`.\n\t**/\n\tpublic static inline function ucompare( a : Int64, b : Int64 ) : Int {\n\t\tvar v = Int32.ucompare(a.high, b.high);\n\t\treturn if( v != 0 ) v else Int32.ucompare(a.low, b.low);\n\t}\n\n\t/**\n\t\tReturns a signed decimal `String` representation of `x`.\n\t**/\n\tpublic static inline function toStr(x:Int64) : String\n\t\treturn x.toString();\n\n\t#if as3 public #else private #end function toString() : String\n\t{\n\t\tvar i : Int64 = cast this;\n\t\tif ( i == 0 )\n\t\t\treturn \"0\";\n\t\tvar str = \"\";\n\t\tvar neg = false;\n\t\tif( i.isNeg() ) {\n\t\t\tneg = true;\n\t\t\ti = -i;\n\t\t}\n\t\tvar ten : Int64 = 10;\n\t\twhile( i != 0 ) {\n\t\t\tvar r = i.divMod( ten );\n\t\t\tstr = r.modulus.low + str;\n\t\t\ti = r.quotient;\n\t\t}\n\t\tif( neg ) str = \"-\" + str;\n\t\treturn str;\n\t}\n\n\t/**\n\t\tPerforms signed integer divison of `dividend` by `divisor`.\n\t\tReturns `{ quotient : Int64, modulus : Int64 }`.\n\t**/\n\tpublic static function divMod( dividend : Int64, divisor : Int64 ) : { quotient : Int64, modulus : Int64 }\n\t{\n\t\t// Handle special cases of 0 and 1\n\t\tif( divisor.high == 0 )\n\t\t{\n\t\t\tswitch( divisor.low ) {\n\t\t\t\tcase 0: throw \"divide by zero\";\n\t\t\t\tcase 1: return { quotient : dividend.copy(), modulus : 0 };\n\t\t\t}\n\t\t}\n\n\t\tvar divSign = dividend.isNeg() != divisor.isNeg();\n\n\t\tvar modulus = dividend.isNeg() ? -dividend : dividend.copy();\n\t\tdivisor = divisor.isNeg() ? -divisor : divisor;\n\n\t\tvar quotient : Int64 = 0;\n\t\tvar mask : Int64 = 1;\n\n\t\twhile( !divisor.isNeg() ) {\n\t\t\tvar cmp = ucompare( divisor, modulus );\n\t\t\tdivisor <<= 1;\n\t\t\tmask <<= 1;\n\t\t\tif( cmp >= 0 ) break;\n\t\t}\n\n\t\twhile( mask != 0 ) {\n\t\t\tif( ucompare(modulus, divisor) >= 0 ) {\n\t\t\t\tquotient |= mask;\n\t\t\t\tmodulus -= divisor;\n\t\t\t}\n\t\t\tmask >>>= 1;\n\t\t\tdivisor >>>= 1;\n\t\t}\n\n\t\tif( divSign ) quotient = -quotient;\n\t\tif( dividend.isNeg() ) modulus = -modulus;\n\n\t\treturn {\n\t\t\tquotient : quotient,\n\t\t\tmodulus  : modulus\n\t\t};\n\t}\n\n\t/**\n\t\tReturns the negative of `x`.\n\t**/\n\t@:op(-A) public static inline function neg( x : Int64 ) : Int64 {\n\t\tvar high = ~x.high;\n\t\tvar low = -x.low;\n\t\tif( low == 0 )\n\t\t\thigh++;\n\t\treturn make( high, low );\n\t}\n\n\t@:op(++A) private inline function preIncrement() : Int64 {\n\t\tthis.low++;\n\t\tif( this.low == 0 ) this.high++;\n\t\treturn cast this;\n\t}\n\n\t@:op(A++) private inline function postIncrement() : Int64 {\n\t\tvar ret = copy();\n\t\tpreIncrement();\n\t\treturn ret;\n\t}\n\n\t@:op(--A) private inline function preDecrement() : Int64 {\n\t\tif( this.low == 0 ) this.high--;\n\t\tthis.low--;\n\t\treturn cast this;\n\t}\n\n\t@:op(A--) private inline function postDecrement() : Int64 {\n\t\tvar ret = copy();\n\t\tpreDecrement();\n\t\treturn ret;\n\t}\n\n\t/**\n\t\tReturns the sum of `a` and `b`.\n\t**/\n\t@:op(A + B) public static inline function add( a : Int64, b : Int64 ) : Int64 {\n\t\tvar high = a.high + b.high;\n\t\tvar low = a.low + b.low;\n\t\tif( Int32.ucompare( low, a.low ) < 0 ) high++;\n\t\treturn make( high, low );\n\t}\n\n\t@:op(A + B) @:commutative private static inline function addInt( a : Int64, b : Int ) : Int64\n\t\treturn add( a, b );\n\n\t/**\n\t\tReturns `a` minus `b`.\n\t**/\n\t@:op(A - B) public static inline function sub( a : Int64, b : Int64 ) : Int64 {\n\t\tvar high = a.high - b.high;\n\t\tvar low = a.low - b.low;\n\t\tif( Int32.ucompare( a.low, b.low ) < 0 ) high--;\n        return make( high, low );\n\t}\n\n\t@:op(A - B) private static inline function subInt( a : Int64, b : Int ) : Int64\n\t\treturn sub( a, b );\n\n\t@:op(A - B) private static inline function intSub( a : Int, b : Int64 ) : Int64\n\t\treturn sub( a, b );\n\n\t/**\n\t\tReturns the product of `a` and `b`.\n\t**/\n\t@:op(A * B) public static inline function mul( a : Int64, b : Int64 ) : Int64 {\n\t\tvar mask = 0xFFFF;\n\t\tvar al = a.low & mask, ah = a.low >>> 16;\n\t\tvar bl = b.low & mask, bh = b.low >>> 16;\n\t\tvar p00 = al * bl;\n\t\tvar p10 = ah * bl;\n\t\tvar p01 = al * bh;\n\t\tvar p11 = ah * bh;\n\t\tvar low = p00;\n\t\tvar high = p11 + (p01 >>> 16) + (p10 >>> 16);\n\t\tp01 <<= 16;\n\t\tlow += p01;\n\t\tif( Int32.ucompare(low, p01) < 0 ) high++;\n\t\tp10 <<= 16;\n\t\tlow += p10;\n\t\tif( Int32.ucompare(low, p10) < 0 ) high++;\n\t\thigh += a.low * b.high + a.high * b.low;\n\t\treturn make( high, low );\n\t}\n\n\t@:op(A * B) @:commutative private static inline function mulInt( a : Int64, b : Int ) : Int64\n\t\treturn mul( a, b );\n\n\t/**\n\t\tReturns the quotient of `a` divided by `b`.\n\t**/\n\t@:op(A / B) public static inline function div( a : Int64, b : Int64 ) : Int64\n\t\treturn divMod(a, b).quotient;\n\n\t@:op(A / B) private static inline function divInt( a : Int64, b : Int ) : Int64\n\t\treturn div( a, b );\n\n\t@:op(A / B) private static inline function intDiv( a : Int, b : Int64 ) : Int64\n\t\treturn div( a, b ).toInt();\n\n\t/**\n\t\tReturns the modulus of `a` divided by `b`.\n\t**/\n\t@:op(A % B) public static inline function mod( a : Int64, b : Int64 ) : Int64\n\t\treturn divMod(a, b).modulus;\n\n\t@:op(A % B) private static inline function modInt( a : Int64, b : Int ) : Int64\n\t\treturn mod( a, b ).toInt();\n\n\t@:op(A % B) private static inline function intMod( a : Int, b : Int64 ) : Int64\n\t\treturn mod( a, b ).toInt();\n\n\t/**\n\t\tReturns `true` if `a` is equal to `b`.\n\t**/\n\t@:op(A == B) public static inline function eq( a : Int64, b : Int64 ) : Bool\n\t\treturn a.high == b.high && a.low == b.low;\n\n\t@:op(A == B) @:commutative private static inline function eqInt( a : Int64, b : Int ) : Bool\n\t\treturn eq( a, b );\n\n\t/**\n\t\tReturns `true` if `a` is not equal to `b`.\n\t**/\n\t@:op(A != B) public static inline function neq( a : Int64, b : Int64 ) : Bool\n\t\treturn a.high != b.high || a.low != b.low;\n\n\t@:op(A != B) @:commutative private static inline function neqInt( a : Int64, b : Int ) : Bool\n\t\treturn neq(a, b);\n\n\t@:op(A < B) private static inline function lt( a : Int64, b : Int64 ) : Bool\n\t\treturn compare(a, b) < 0;\n\n\t@:op(A < B) private static inline function ltInt( a : Int64, b : Int ) : Bool\n\t\treturn lt(a, b);\n\n\t@:op(A < B) private static inline function intLt( a : Int, b : Int64 ) : Bool\n\t\treturn lt(a, b);\n\n\t@:op(A <= B) private static inline function lte( a : Int64, b : Int64 ) : Bool\n\t\treturn compare(a, b) <= 0;\n\n\t@:op(A <= B) private static inline function lteInt( a : Int64, b : Int ) : Bool\n\t\treturn lte(a, b);\n\n\t@:op(A <= B) private static inline function intLte( a : Int, b : Int64 ) : Bool\n\t\treturn lte(a, b);\n\n\t@:op(A > B) private static inline function gt( a : Int64, b : Int64 ) : Bool\n\t\treturn compare(a, b) > 0;\n\n\t@:op(A > B) private static inline function gtInt( a : Int64, b : Int ) : Bool\n\t\treturn gt(a, b);\n\n\t@:op(A > B) private static inline function intGt( a : Int, b : Int64 ) : Bool\n\t\treturn gt( a, b );\n\n\t@:op(A >= B) private static inline function gte( a : Int64, b : Int64 ) : Bool\n\t\treturn compare(a, b) >= 0;\n\n\t@:op(A >= B) private static inline function gteInt( a : Int64, b : Int ) : Bool\n\t\treturn gte(a, b);\n\n\t@:op(A >= B) private static inline function intGte( a : Int, b : Int64 ) : Bool\n\t\treturn gte(a, b);\n\n\t/**\n\t\tReturns the bitwise NOT of `a`.\n\t**/\n\t@:op(~A) private static inline function complement( a : Int64 ) : Int64\n\t\treturn make( ~a.high, ~a.low );\n\n\t/**\n\t\tReturns the bitwise AND of `a` and `b`.\n\t**/\n\t@:op(A & B) public static inline function and( a : Int64, b : Int64 ) : Int64\n\t\treturn make( a.high & b.high, a.low & b.low );\n\n\t/**\n\t\tReturns the bitwise OR of `a` and `b`.\n\t**/\n\t@:op(A | B) public static inline function or( a : Int64, b : Int64 ) : Int64\n\t\treturn make( a.high | b.high, a.low | b.low );\n\n\t/**\n\t\tReturns the bitwise XOR of `a` and `b`.\n\t**/\n\t@:op(A ^ B) public static inline function xor( a : Int64, b : Int64 ) : Int64\n\t\treturn make( a.high ^ b.high, a.low ^ b.low );\n\n\t/**\n\t\tReturns `a` left-shifted by `b` bits.\n\t**/\n\t@:op(A << B) public static inline function shl( a : Int64, b : Int ) : Int64 {\n\t\tb &= 63;\n\t\treturn if( b == 0 ) a.copy()\n\t\t\telse if( b < 32 ) make( (a.high << b) | (a.low >>> (32-b)), a.low << b)\n\t\t\telse make( a.low << (b-32), 0 );\n\t}\n\n\t/**\n\t\tReturns `a` right-shifted by `b` bits in signed mode.\n\t\t`a` is sign-extended.\n\t**/\n\t@:op(A >> B) public static inline function shr( a : Int64, b : Int) : Int64 {\n\t\tb &= 63;\n\t\treturn if( b == 0 ) a.copy()\n\t\t\telse if( b < 32 ) make( a.high >> b, (a.high << (32-b)) | (a.low >>> b) )\n\t\t\telse make( a.high >> 31, a.high >> (b - 32) );\n\t}\n\n\t/**\n\t\tReturns `a` right-shifted by `b` bits in unsigned mode.\n\t\t`a` is padded with zeroes.\n\t**/\n\t@:op(A >>> B) public static inline function ushr( a : Int64, b : Int ) : Int64 {\n\t\tb &= 63;\n\t\treturn if( b == 0 ) a.copy()\n\t\t\telse if( b < 32 ) make( a.high >>> b, (a.high << (32-b)) | (a.low >>> b) )\n\t\t\telse make( 0, a.high >>> (b - 32) );\n\t}\n\n\tpublic var high(get, never) : Int32;\n\tprivate inline function get_high() return this.high;\n\tprivate inline function set_high(x) return this.high = x;\n\n\tpublic var low(get, never) : Int32;\n\tprivate inline function get_low() return this.low;\n\tprivate inline function set_low(x) return this.low = x;\n}\n\n/**\n  * This typedef will fool @:coreApi into thinking that we are using\n  * the same underlying type, even though it might be different on\n  * specific platforms.\n  */\nprivate typedef __Int64 = ___Int64;\n\nprivate class ___Int64 {\n\tpublic var high : Int32;\n\tpublic var low : Int32;\n\n\tpublic inline function new( high, low ) {\n\t\tthis.high = high;\n\t\tthis.low = low;\n\t}\n\n\t/**\n\t\tWe also define toString here to ensure we always get a pretty string\n\t\twhen tracing or calling Std.string. This tends not to happen when\n\t\ttoString is only in the abstract.\n\t**/\n\tpublic function toString() : String\n\t\treturn Int64.toStr( cast this );\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe;\n\n/**\n\tLog primarily provides the trace() method, which is invoked upon a call to\n\ttrace() in haxe code.\n**/\nclass Log {\n\n\t/**\n\t\tOutputs `v` in a platform-dependent way.\n\n\t\tThe second parameter `infos` is injected by the compiler and contains\n\t\tinformation about the position where the trace() call was made.\n\n\t\tThis method can be rebound to a custom function:\n\t\t\tvar oldTrace = haxe.Log.trace; // store old function\n\t\t\thaxe.Log.trace = function(v,infos) { // handle trace }\n\t\t\t...\n\t\t\thaxe.Log.trace = oldTrace;\n\n\t\tIf it is bound to null, subsequent calls to trace() will cause an\n\t\texception.\n\t**/\n\tpublic static dynamic function trace( v : Dynamic, ?infos : PosInfos ) : Void {\n\t\t#if flash\n\t\t\t#if (fdb || native_trace)\n\t\t\t\tvar pstr = infos == null ? \"(null)\" : infos.fileName + \":\" + infos.lineNumber;\n\t\t\t\tvar str = flash.Boot.__string_rec(v, \"\");\n\t\t\t\tif( infos != null && infos.customParams != null ) for( v in infos.customParams ) str += \",\" + flash.Boot.__string_rec(v, \"\");\n\t\t\t\tuntyped __global__[\"trace\"](pstr+\": \"+str);\n\t\t\t#else\n\t\t\t\tuntyped flash.Boot.__trace(v,infos);\n\t\t\t#end\n\t\t#elseif neko\n\t\t\tuntyped {\n\t\t\t\t$print(infos.fileName + \":\" + infos.lineNumber + \": \", v);\n\t\t\t\tif( infos.customParams != null ) for( v in infos.customParams ) $print(\",\", v);\n\t\t\t\t$print(\"\\n\");\n\t\t\t}\n\t\t#elseif js\n\t\t\tuntyped js.Boot.__trace(v,infos);\n\t\t#elseif php\n\t\t\tif (infos!=null && infos.customParams!=null) {\n\t\t\t\tvar extra:String = \"\";\n\t\t\t\tfor( v in infos.customParams )\n\t\t\t\t\textra += \",\" + v;\n\t\t\t\tuntyped __call__('_hx_trace', v + extra, infos);\n\t\t\t}\n\t\t\telse\n\t\t\t\tuntyped __call__('_hx_trace', v, infos);\n\t\t#elseif cpp\n\t\t\tif (infos!=null && infos.customParams!=null) {\n\t\t\t\tvar extra:String = \"\";\n\t\t\t\tfor( v in infos.customParams )\n\t\t\t\t\textra += \",\" + v;\n\t\t\t\tuntyped __trace(v + extra,infos);\n\t\t\t}\n\t\t\telse\n\t\t\t\tuntyped __trace(v,infos);\n\t\t#elseif (cs || java)\n\t\t\tvar str:String = null;\n\t\t\tif (infos != null) {\n\t\t\t\tstr = infos.fileName + \":\" + infos.lineNumber + \": \" + v;\n\t\t\t\tif (infos.customParams != null)\n\t\t\t\t{\n\t\t\t\t\tstr += \",\" + infos.customParams.join(\",\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstr = v;\n\t\t\t}\n\t\t\t#if cs\n\t\t\tcs.system.Console.WriteLine(str);\n\t\t\t#elseif java\n\t\t\tuntyped __java__(\"java.lang.System.out.println(str)\");\n\t\t\t#end\n\t\t#elseif (python)\n\t\t\tvar str:String = null;\n\t\t\tif (infos != null) {\n\t\t\t\tstr = infos.fileName + \":\" + Std.string(infos.lineNumber) + \": \" + v;\n\t\t\t\tif (infos.customParams != null) {\n\t\t\t\t\tstr += \",\" + infos.customParams.join(\",\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstr = v;\n\t\t\t}\n\t\t\tpython.Lib.println(str);\n\t\t#end\n\t}\n\n\t#if (flash || js)\n\t/**\n\t\tClears the trace output.\n\t**/\n\tpublic static dynamic function clear() : Void {\n\t\t#if flash\n\t\tuntyped flash.Boot.__clear_trace();\n\t\t#elseif js\n\t\tuntyped js.Boot.__clear_trace();\n\t\t#end\n\t}\n\t#end\n\n\t#if flash\n\t/**\n\t\tSets the color of the trace output to `rgb`.\n\t**/\n\tpublic static dynamic function setColor( rgb : Int ) {\n\t\tuntyped flash.Boot.__set_trace_color(rgb);\n\t}\n\t#end\n\n}\n","/*\n * Copyright (C)2005-2013 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe;\n\n/**\n\tResource can be used to access resources that were added through the\n\t-resource file@name command line parameter.\n\n\tDepending on their type they can be obtained as String through\n\tgetString(name), or as binary data through getBytes(name).\n\n\tA list of all available resource names can be obtained from listNames().\n**/\nclass Resource {\n\n\tstatic var content : Array<{ name : String, data : String, str : String }>;\n\n\t/**\n\t\tLists all available resource names. The resource name is the name part\n\t\tof the -resource file@name command line parameter.\n\t**/\n\tpublic static function listNames() : Array<String> {\n\t\treturn [for (x in content) x.name];\n\t}\n\n\t/**\n\t\tRetrieves the resource identified by `name` as a String.\n\n\t\tIf `name` does not match any resource name, null is returned.\n\t**/\n\tpublic static function getString( name : String ) : String {\n\t\tfor( x in content )\n\t\t\tif( x.name == name ) {\n\t\t\t\t#if neko\n\t\t\t\treturn new String(x.data);\n\t\t\t\t#else\n\t\t\t\tif( x.str != null ) return x.str;\n\t\t\t\tvar b : haxe.io.Bytes = haxe.crypto.Base64.decode(x.data);\n\t\t\t\treturn b.toString();\n\t\t\t\t#end\n\t\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t\tRetrieves the resource identified by `name` as an instance of\n\t\thaxe.io.Bytes.\n\n\t\tIf `name` does not match any resource name, null is returned.\n\t**/\n\tpublic static function getBytes( name : String ) : haxe.io.Bytes {\n\t\tfor( x in content )\n\t\t\tif( x.name == name ) {\n\t\t\t\t#if neko\n\t\t\t\treturn haxe.io.Bytes.ofData(cast x.data);\n\t\t\t\t#else\n\t\t\t\tif( x.str != null ) return haxe.io.Bytes.ofString(x.str);\n\t\t\t\treturn haxe.crypto.Base64.decode(x.data);\n\t\t\t\t#end\n\t\t\t}\n\t\treturn null;\n\t}\n\n\tstatic function __init__() {\n\t\t#if neko\n\t\tvar tmp = untyped __resources__();\n\t\tcontent = untyped Array.new1(tmp,__dollar__asize(tmp));\n\t\t#elseif php\n\t\tcontent = null;\n\t\t#elseif as3\n\t\tnull;\n\t\t#else\n\t\tcontent = untyped __resources__();\n\t\t#end\n\t}\n\n}\n","/*\n * Copyright (C)2005-2013 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe;\n\n/**\n\tThe Timer class allows you to create asynchronous timers on platforms that\n\tsupport events.\n\n\tThe intended usage is to create an instance of the Timer class with a given\n\tinterval, set its run() method to a custom function to be invoked and\n\teventually call stop() to stop the Timer.\n\n\tNote that a running Timer may or may not prevent the program to exit\n\tautomatically when main() returns.\n\n\tIt is also possible to extend this class and override its run() method in\n\tthe child class.\n**/\nclass Timer {\n\t#if (flash || js || java || python)\n\n\t#if (flash || js)\n\t\tprivate var id : Null<Int>;\n\t#elseif java\n\t\tprivate var timer : java.util.Timer;\n\t\tprivate var task : java.util.TimerTask;\n\t#end\n\n\t/**\n\t\tCreates a new timer that will run every `time_ms` milliseconds.\n\n\t\tAfter creating the Timer instance, it calls `this].run` repeatedly,\n\t\twith delays of `time_ms` milliseconds, until `this.stop` is called.\n\n\t\tThe first invocation occurs after `time_ms` milliseconds, not\n\t\timmediately.\n\n\t\tThe accuracy of this may be platform-dependent.\n\t**/\n\tpublic function new( time_ms : Int ){\n\t\t#if flash\n\t\t\tvar me = this;\n\t\t\tid = untyped __global__[\"flash.utils.setInterval\"](function() { me.run(); },time_ms);\n\t\t#elseif js\n\t\t\tvar me = this;\n\t\t\tid = untyped setInterval(function() me.run(),time_ms);\n\t\t#elseif java\n\t\t\ttimer = new java.util.Timer();\n\t\t\ttimer.scheduleAtFixedRate(task = new TimerTask(this), haxe.Int64.ofInt(time_ms), haxe.Int64.ofInt(time_ms));\n\t\t#end\n\t}\n\n\t/**\n\t\tStops `this` Timer.\n\n\t\tAfter calling this method, no additional invocations of `this.run`\n\t\twill occur.\n\n\t\tIt is not possible to restart `this` Timer once stopped.\n\t**/\n\tpublic function stop() {\n\t\t#if (flash || js)\n\t\t\tif( id == null )\n\t\t\t\treturn;\n\t\t\t#if flash\n\t\t\t\tuntyped __global__[\"flash.utils.clearInterval\"](id);\n\t\t\t#elseif js\n\t\t\t\tuntyped clearInterval(id);\n\t\t\t#end\n\t\t\tid = null;\n\t\t#elseif java\n\t\t\ttimer.cancel();\n\t\t\ttimer = null;\n\t\t\ttask = null;\n\t\t#end\n\t}\n\n\t/**\n\t\tThis method is invoked repeatedly on `this` Timer.\n\n\t\tIt can be overridden in a subclass, or rebound directly to a custom\n\t\tfunction:\n\t\t\tvar timer = new haxe.Timer(1000); // 1000ms delay\n\t\t\ttimer.run = function() { ... }\n\n\t\tOnce bound, it can still be rebound to different functions until `this`\n\t\tTimer is stopped through a call to `this.stop`.\n\t**/\n\tpublic dynamic function run() {\n\n\t}\n\n\t/**\n\t\tInvokes `f` after `time_ms` milliseconds.\n\n\t\tThis is a convenience function for creating a new Timer instance with\n\t\t`time_ms` as argument, binding its run() method to `f` and then stopping\n\t\t`this` Timer upon the first invocation.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function delay( f : Void -> Void, time_ms : Int ) {\n\t\tvar t = new haxe.Timer(time_ms);\n\t\tt.run = function() {\n\t\t\tt.stop();\n\t\t\tf();\n\t\t};\n\t\treturn t;\n\t}\n\n\t#end\n\n\t/**\n\t\tMeasures the time it takes to execute `f`, in seconds with fractions.\n\n\t\tThis is a convenience function for calculating the difference between\n\t\tTimer.stamp() before and after the invocation of `f`.\n\n\t\tThe difference is passed as argument to Log.trace(), with \"s\" appended\n\t\tto denote the unit. The optional `pos` argument is passed through.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function measure<T>( f : Void -> T, ?pos : PosInfos ) : T {\n\t\tvar t0 = stamp();\n\t\tvar r = f();\n\t\tLog.trace((stamp() - t0) + \"s\", pos);\n\t\treturn r;\n\t}\n\n\t/**\n\t\tReturns a timestamp, in seconds with fractions.\n\n\t\tThe value itself might differ depending on platforms, only differences\n\t\tbetween two values make sense.\n\t**/\n\tpublic static function stamp() : Float {\n\t\t#if flash\n\t\t\treturn flash.Lib.getTimer() / 1000;\n\t\t#elseif (neko || php)\n\t\t\treturn Sys.time();\n\t\t#elseif js\n\t\t\treturn Date.now().getTime() / 1000;\n\t\t#elseif cpp\n\t\t\treturn untyped __global__.__time_stamp();\n\t\t#elseif sys\n\t\t\treturn Sys.time();\n\t\t#else\n\t\t\treturn 0;\n\t\t#end\n\t}\n\n}\n\n#if java\n@:nativeGen\nprivate class TimerTask extends java.util.TimerTask {\n\tvar timer:Timer;\n\tpublic function new(timer:Timer):Void {\n\t\tsuper();\n\t\tthis.timer = timer;\n\t}\n\n\t@:overload override public function run():Void {\n\t\ttimer.run();\n\t}\n}\n#end\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe;\n\n/**\n\tSince all platforms does not guarantee that String always uses UTF-8 encoding, you\n\tcan use this crossplatform API to perform operations on such strings.\n**/\nclass Utf8 {\n\n\tvar __b : String;\n\n\t/**\n\t\tAllocate a new Utf8 buffer using an optional bytes size.\n\t**/\n\tpublic function new( ?size : Int ) {\n\t\t__b = \"\";\n\t}\n\n\t/**\n\t\tAdd the given UTF8 character code to the buffer.\n\t**/\n\tpublic inline function addChar( c : Int ) : Void {\n\t\t__b += String.fromCharCode(c);\n\t}\n\n\t/**\n\t\tReturns the buffer converted to a String;\n\t**/\n\tpublic inline function toString() : String {\n\t\treturn __b;\n\t}\n\n\t/**\n\t\tCall the `chars` function for each UTF8 char of the string.\n\t**/\n\tpublic static function iter( s : String, chars : Int -> Void ) {\n\t\tfor( i in 0...s.length )\n\t\t\tchars(s.charCodeAt(i));\n\t}\n\n\t/**\n\t\tEncode the input ISO string into the corresponding UTF8 one.\n\t**/\n\tpublic static function encode( s : String ) : String {\n\t\tthrow \"Not implemented\";\n\t}\n\n\t/**\n\t\tDecode an UTF8 string back to an ISO string.\n\t\tThrow an exception if a given UTF8 character is not supported by the decoder.\n\t**/\n\tpublic static function decode( s : String ) : String {\n\t\tthrow \"Not implemented\";\n\t}\n\n\t/**\n\t\tSimilar to `String.charCodeAt` but uses the UTF8 character position.\n\t**/\n\tpublic static inline function charCodeAt( s : String, index : Int ) : Int {\n\t\treturn s.charCodeAt(index);\n\t}\n\n\t/**\n\t\tTells if the String is correctly encoded as UTF8.\n\t**/\n\tpublic static inline function validate( s : String ) : Bool {\n\t\treturn true;\n\t}\n\n\t/**\n\t\tReturns the number of UTF8 chars of the String.\n\t**/\n\t#if js @:extern #end\n\tpublic static inline function length( s : String ) : Int {\n\t\treturn s.length;\n\t}\n\n\t/**\n\t\tCompare two UTF8 strings, character by character.\n\t**/\n\tpublic static function compare( a : String, b : String ) : Int {\n\t\treturn a > b ? 1 : (a == b ? 0 : -1);\n\t}\n\n\t/**\n\t\tThis is similar to `String.substr` but the `pos` and `len` parts are considering UTF8 characters.\n\t**/\n\tpublic static inline function sub( s : String, pos : Int, len : Int ) : String {\n\t\treturn s.substr(pos,len);\n\t}\n\n}","/*\n * Copyright (C)2005-2014 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe.io;\nimport js.html.compat.Uint8Array;\nimport js.html.compat.DataView;\n\n@:coreApi\nclass Bytes {\n\n\tpublic var length(default,null) : Int;\n\tvar b : js.html.Uint8Array;\n\tvar data : js.html.DataView;\n\n\tfunction new(data:BytesData) {\n\t\tthis.length = data.byteLength;\n\t\tthis.b = new js.html.Uint8Array(data);\n\t\tuntyped {\n\t\t\tb.bufferValue = data; // some impl does not return the same instance in .buffer\n\t\t\tdata.hxBytes = this;\n\t\t\tdata.bytes = this.b;\n\t\t}\n\t}\n\n\tpublic inline function get( pos : Int ) : Int {\n\t\treturn b[pos];\n\t}\n\n\tpublic inline function set( pos : Int, v : Int ) : Void {\n\t\tb[pos] = v & 0xFF; // the &0xFF is necessary for js.html.compat support\n\t}\n\n\tpublic function blit( pos : Int, src : Bytes, srcpos : Int, len : Int ) : Void {\n\t\tif( pos < 0 || srcpos < 0 || len < 0 || pos + len > length || srcpos + len > src.length ) throw Error.OutsideBounds;\n\t\tif( srcpos == 0 && len == src.length )\n\t\t\tb.set(src.b,pos);\n\t\telse\n\t\t\tb.set(src.b.subarray(srcpos,srcpos+len),pos);\n\t}\n\n\tpublic function fill( pos : Int, len : Int, value : Int ) : Void {\n\t\tfor( i in 0...len )\n\t\t\tset(pos++, value);\n\t}\n\n\tpublic function sub( pos : Int, len : Int ) : Bytes {\n\t\tif( pos < 0 || len < 0 || pos + len > length ) throw Error.OutsideBounds;\n\t\treturn new Bytes(b.buffer.slice(pos+b.byteOffset,pos+b.byteOffset+len));\n\t}\n\n\tpublic function compare( other : Bytes ) : Int {\n\t\tvar b1 = b;\n\t\tvar b2 = other.b;\n\t\tvar len = (length < other.length) ? length : other.length;\n\t\tfor( i in 0...len )\n\t\t\tif( b1[i] != b2[i] )\n\t\t\t\treturn b1[i] - b2[i];\n\t\treturn length - other.length;\n\t}\n\n\tinline function initData() : Void {\n\t\tif( data == null ) data = new js.html.DataView(b.buffer, b.byteOffset, b.byteLength);\n\t}\n\n\tpublic function getDouble( pos : Int ) : Float {\n\t\tinitData();\n\t\treturn data.getFloat64(pos, true);\n\t}\n\n\tpublic function getFloat( pos : Int ) : Float {\n\t\tinitData();\n\t\treturn data.getFloat32(pos, true);\n\t}\n\n\tpublic function setDouble( pos : Int, v : Float ) : Void {\n\t\tinitData();\n\t\tdata.setFloat64(pos, v, true);\n\t}\n\n\tpublic function setFloat( pos : Int, v : Float ) : Void {\n\t\tinitData();\n\t\tdata.setFloat32(pos, v, true);\n\t}\n\n\tpublic function getUInt16( pos : Int ) : Int {\n\t\tinitData();\n\t\treturn data.getUint16(pos, true);\n\t}\n\n\tpublic function setUInt16( pos : Int, v : Int ) : Void {\n\t\tinitData();\n\t\tdata.setUint16(pos, v, true);\n\t}\n\n\tpublic function getInt32( pos : Int ) : Int {\n\t\tinitData();\n\t\treturn data.getInt32(pos, true);\n\t}\n\n\tpublic function setInt32( pos : Int, v : Int ) : Void {\n\t\tinitData();\n\t\tdata.setInt32(pos, v, true);\n\t}\n\n\tpublic function getInt64( pos : Int ) : haxe.Int64 {\n\t\treturn Int64.make(getInt32(pos + 4),getInt32(pos));\n\t}\n\n\tpublic function setInt64( pos : Int, v : haxe.Int64 ) : Void {\n\t\tsetInt32(pos, v.low);\n\t\tsetInt32(pos + 4, v.high);\n\t}\n\n\tpublic function getString( pos : Int, len : Int ) : String {\n\t\tif( pos < 0 || len < 0 || pos + len > length ) throw Error.OutsideBounds;\n\t\tvar s = \"\";\n\t\tvar b = b;\n\t\tvar fcc = String.fromCharCode;\n\t\tvar i = pos;\n\t\tvar max = pos+len;\n\t\t// utf8-decode and utf16-encode\n\t\twhile( i < max ) {\n\t\t\tvar c = b[i++];\n\t\t\tif( c < 0x80 ) {\n\t\t\t\tif( c == 0 ) break;\n\t\t\t\ts += fcc(c);\n\t\t\t} else if( c < 0xE0 )\n\t\t\t\ts += fcc( ((c & 0x3F) << 6) | (b[i++] & 0x7F) );\n\t\t\telse if( c < 0xF0 ) {\n\t\t\t\tvar c2 = b[i++];\n\t\t\t\ts += fcc( ((c & 0x1F) << 12) | ((c2 & 0x7F) << 6) | (b[i++] & 0x7F) );\n\t\t\t} else {\n\t\t\t\tvar c2 = b[i++];\n\t\t\t\tvar c3 = b[i++];\n\t\t\t\tvar u = ((c & 0x0F) << 18) | ((c2 & 0x7F) << 12) | ((c3 & 0x7F) << 6) | (b[i++] & 0x7F);\n\t\t\t\t// surrogate pair\n\t\t\t\ts += fcc( (u >> 10) + 0xD7C0 );\n\t\t\t\ts += fcc( (u & 0x3FF) | 0xDC00 );\n\t\t\t}\n\t\t}\n\t\treturn s;\n\t}\n\n\t@:deprecated(\"readString is deprecated, use getString instead\")\n\t@:noCompletion\n\tpublic inline function readString(pos:Int, len:Int):String {\n\t\treturn getString(pos, len);\n\t}\n\n\tpublic function toString() : String {\n\t\treturn getString(0,length);\n\t}\n\n\tpublic function toHex() : String {\n\t\tvar s = new StringBuf();\n\t\tvar chars = [];\n\t\tvar str = \"0123456789abcdef\";\n\t\tfor( i in 0...str.length )\n\t\t\tchars.push(str.charCodeAt(i));\n\t\tfor( i in 0...length ) {\n\t\t\tvar c = get(i);\n\t\t\ts.addChar(chars[c >> 4]);\n\t\t\ts.addChar(chars[c & 15]);\n\t\t}\n\t\treturn s.toString();\n\t}\n\n\tpublic inline function getData() : BytesData {\n\t\treturn untyped b.bufferValue;\n\t}\n\n\tpublic static function alloc( length : Int ) : Bytes {\n\t\treturn new Bytes(new BytesData(length));\n\t}\n\n\tpublic static function ofString( s : String ) : Bytes {\n\t\tvar a = new Array();\n\t\t// utf16-decode and utf8-encode\n\t\tvar i = 0;\n\t\twhile( i < s.length ) {\n\t\t\tvar c : Int = StringTools.fastCodeAt(s,i++);\n\t\t\t// surrogate pair\n\t\t\tif( 0xD800 <= c && c <= 0xDBFF )\n\t\t\t    c = (c - 0xD7C0 << 10) | (StringTools.fastCodeAt(s,i++) & 0x3FF);\n\t\t\tif( c <= 0x7F )\n\t\t\t\ta.push(c);\n\t\t\telse if( c <= 0x7FF ) {\n\t\t\t\ta.push( 0xC0 | (c >> 6) );\n\t\t\t\ta.push( 0x80 | (c & 63) );\n\t\t\t} else if( c <= 0xFFFF ) {\n\t\t\t\ta.push( 0xE0 | (c >> 12) );\n\t\t\t\ta.push( 0x80 | ((c >> 6) & 63) );\n\t\t\t\ta.push( 0x80 | (c & 63) );\n\t\t\t} else {\n\t\t\t\ta.push( 0xF0 | (c >> 18) );\n\t\t\t\ta.push( 0x80 | ((c >> 12) & 63) );\n\t\t\t\ta.push( 0x80 | ((c >> 6) & 63) );\n\t\t\t\ta.push( 0x80 | (c & 63) );\n\t\t\t}\n\t\t}\n\t\treturn new Bytes(new js.html.Uint8Array(a).buffer);\n\t}\n\n\tpublic static function ofData( b : BytesData ) : Bytes {\n\t\tvar hb = untyped b.hxBytes;\n\t\tif( hb != null ) return hb;\n\t\treturn new Bytes(b);\n\t}\n\n\tpublic inline static function fastGet( b : BytesData, pos : Int ) : Int {\n\t\t// this requires that we have wrapped it with haxe.io.Bytes beforehand\n\t\treturn untyped b.bytes[pos];\n\t}\n\n}\n","/*\n * Copyright (C)2005-2013 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe.crypto;\n\n/**\n\tAllows to encode/decode String and bytes using Base64 encoding.\n**/\nclass Base64 {\n\n\tpublic static var CHARS(default,null) = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\tpublic static var BYTES(default,null) = haxe.io.Bytes.ofString(CHARS);\n\n\tpublic static function encode( bytes : haxe.io.Bytes, complement = true ) : String {\n\t\tvar str = new BaseCode(BYTES).encodeBytes(bytes).toString();\n\t\tif( complement )\n\t\t\tswitch (bytes.length % 3) {\n\t\t\tcase 1:\n\t\t\t\tstr += \"==\";\n\t\t\tcase 2:\n\t\t\t\tstr += \"=\";\n\t\t\tdefault:\n\t\t\t}\n\t\treturn str;\n\t}\n\n\tpublic static function decode( str : String, complement = true ) : haxe.io.Bytes {\n\t\tif( complement )\n\t\t\twhile( str.charCodeAt(str.length-1) == \"=\".code )\n\t\t\t\tstr = str.substr(0,-1);\n\t\treturn new BaseCode(BYTES).decodeBytes(haxe.io.Bytes.ofString(str));\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe.crypto;\n\n/**\n\tAllows to encode/decode String and bytes using a power of two base dictionnary.\n**/\nclass BaseCode {\n\n\tvar base : haxe.io.Bytes;\n\tvar nbits : Int;\n\tvar tbl : Array<Int>;\n\n\tpublic function new( base : haxe.io.Bytes ) {\n\t\tvar len = base.length;\n\t\tvar nbits = 1;\n\t\twhile( len > 1 << nbits )\n\t\t\tnbits++;\n\t\tif( nbits > 8 || len != 1 << nbits )\n\t\t\tthrow \"BaseCode : base length must be a power of two.\";\n\t\tthis.base = base;\n\t\tthis.nbits = nbits;\n\t}\n\n\tpublic function encodeBytes( b : haxe.io.Bytes ) : haxe.io.Bytes {\n\t\t#if (neko && !interp)\n\t\treturn haxe.io.Bytes.ofData( base_encode(b.getData(),base.getData()) );\n\t\t#else\n\t\tvar nbits = this.nbits;\n\t\tvar base = this.base;\n\t\tvar size = Std.int(b.length * 8 / nbits);\n\t\tvar out = haxe.io.Bytes.alloc(size + (((b.length * 8) % nbits == 0) ? 0 : 1) );\n\t\tvar buf = 0;\n\t\tvar curbits = 0;\n\t\tvar mask = (1 << nbits) - 1;\n\t\tvar pin = 0;\n\t\tvar pout = 0;\n\t\twhile( pout < size ) {\n\t\t\twhile( curbits < nbits ) {\n\t\t\t\tcurbits += 8;\n\t\t\t\tbuf <<= 8;\n\t\t\t\tbuf |= b.get(pin++);\n\t\t\t}\n\t\t\tcurbits -= nbits;\n\t\t\tout.set(pout++,base.get((buf >> curbits) & mask));\n\t\t}\n\t\tif( curbits > 0 )\n\t\t\tout.set(pout++,base.get((buf << (nbits - curbits)) & mask));\n\t\treturn out;\n\t\t#end\n\t}\n\n\tfunction initTable() {\n\t\tvar tbl = new Array();\n\t\tfor( i in 0...256 )\n\t\t\ttbl[i] = -1;\n\t\tfor( i in 0...base.length )\n\t\t\ttbl[base.get(i)] = i;\n\t\tthis.tbl = tbl;\n\t}\n\n\tpublic function decodeBytes( b : haxe.io.Bytes ) : haxe.io.Bytes {\n\t\t#if (neko && !interp)\n\t\treturn haxe.io.Bytes.ofData( base_decode(b.getData(),base.getData()) );\n\t\t#else\n\t\tvar nbits = this.nbits;\n\t\tvar base = this.base;\n\t\tif( this.tbl == null ) initTable();\n\t\tvar tbl = this.tbl;\n\t\tvar size = (b.length * nbits) >> 3;\n\t\tvar out = haxe.io.Bytes.alloc(size);\n\t\tvar buf = 0;\n\t\tvar curbits = 0;\n\t\tvar pin = 0;\n\t\tvar pout = 0;\n\t\twhile( pout < size ) {\n\t\t\twhile( curbits < 8 ) {\n\t\t\t\tcurbits += nbits;\n\t\t\t\tbuf <<= nbits;\n\t\t\t\tvar i = tbl[b.get(pin++)];\n\t\t\t\tif( i == -1 )\n\t\t\t\t\tthrow \"BaseCode : invalid encoded char\";\n\t\t\t\tbuf |= i;\n\t\t\t}\n\t\t\tcurbits -= 8;\n\t\t\tout.set(pout++,(buf >> curbits) & 0xFF);\n\t\t}\n\t\treturn out;\n\t\t#end\n\t}\n\n\tpublic function encodeString( s : String ) {\n\t\t#if (neko && !interp)\n\t\treturn neko.NativeString.toString( base_encode(neko.NativeString.ofString(s),base.getData()) );\n\t\t#else\n\t\treturn encodeBytes(haxe.io.Bytes.ofString(s)).toString();\n\t\t#end\n\t}\n\n\tpublic function decodeString( s : String ) {\n\t\t#if (neko && !interp)\n\t\treturn neko.NativeString.toString( base_decode(neko.NativeString.ofString(s),base.getData()) );\n\t\t#else\n\t\treturn decodeBytes(haxe.io.Bytes.ofString(s)).toString();\n\t\t#end\n\t}\n\n\tpublic static function encode( s : String, base : String ) {\n\t\tvar b = new BaseCode(haxe.io.Bytes.ofString(base));\n\t\treturn b.encodeString(s);\n\t}\n\n\tpublic static function decode( s : String, base : String ) {\n\t\tvar b = new BaseCode(haxe.io.Bytes.ofString(base));\n\t\treturn b.decodeString(s);\n\t}\n\n\t#if neko\n\tprivate static var base_encode = neko.Lib.load(\"std\",\"base_encode\",2);\n\tprivate static var base_decode = neko.Lib.load(\"std\",\"base_decode\",2);\n\t#end\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe.crypto;\n\nclass Crc32 {\n\n\tvar crc : Int;\n\n\tpublic function new() {\n\t\tcrc = 0xFFFFFFFF;\n\t}\n\n\tpublic function byte( b : Int ) {\n\t\tvar tmp = (crc ^ b) & 0xFF;\n\t\tfor( j in 0...8 ) {\n\t\t\tif( tmp & 1 == 1 )\n\t\t\t\ttmp = (tmp >>> 1) ^ 0xEDB88320;\n\t\t\telse\n\t\t\t\ttmp >>>= 1;\n\t\t}\n\t\tcrc = (crc >>> 8) ^ tmp;\n\t}\n\n\tpublic function update( b : haxe.io.Bytes, pos, len ) {\n\t\tvar b = b.getData();\n\t\tfor( i in pos...pos+len ) {\n\t\t\tvar tmp = (crc ^ haxe.io.Bytes.fastGet(b,i)) & 0xFF;\n\t\t\tfor( j in 0...8 ) {\n\t\t\t\tif( tmp & 1 == 1 )\n\t\t\t\t\ttmp = (tmp >>> 1) ^ 0xEDB88320;\n\t\t\t\telse\n\t\t\t\t\ttmp >>>= 1;\n\t\t\t}\n\t\t\tcrc = (crc >>> 8) ^ tmp;\n\t\t}\n\t}\n\n\tpublic function get() {\n\t\treturn crc ^ 0xFFFFFFFF;\n\t}\n\n\t/**\n\t\tCalculates the CRC32 of the given data bytes\n\t**/\n\tpublic static function make( data : haxe.io.Bytes ) : Int {\n\t\tvar init = 0xFFFFFFFF;\n\t\tvar crc = init;\n\t\tvar b = data.getData();\n\t\tfor( i in 0...data.length ) {\n\t\t\tvar tmp = (crc ^ haxe.io.Bytes.fastGet(b,i)) & 0xFF;\n\t\t\tfor( j in 0...8 ) {\n\t\t\t\tif( tmp & 1 == 1 )\n\t\t\t\t\ttmp = (tmp >>> 1) ^ 0xEDB88320;\n\t\t\t\telse\n\t\t\t\t\ttmp >>>= 1;\n\t\t\t}\n\t\t\tcrc = (crc >>> 8) ^ tmp;\n\t\t}\n\t\treturn crc ^ init;\n\t}\n\n}","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe.crypto;\n\n/**\n\tCreates a MD5 of a String.\n**/\nclass Md5 {\n\n\tpublic static function encode( s : String ) : String {\n\t\t#if neko\n\t\t\treturn untyped new String(base_encode(make_md5(s.__s),\"0123456789abcdef\".__s));\n\t\t#elseif php\n\t\t\treturn untyped __call__(\"md5\", s);\n\t\t#else\n\t\t\tvar m = new Md5();\n\t\t\tvar h = m.doEncode(str2blks(s));\n\t\t\treturn m.hex(h);\n\t\t#end\n\t}\n\n\tpublic static function make( b : haxe.io.Bytes ) : haxe.io.Bytes {\n\t\t#if neko\n\t\t\treturn haxe.io.Bytes.ofData(make_md5(b.getData()));\n\t\t#elseif php\n\t\t\treturn haxe.io.Bytes.ofData(untyped __call__(\"md5\", b.getData(), true));\n\t\t#else\n\t\t\tvar h = new Md5().doEncode(bytes2blks(b));\n\t\t\tvar out = haxe.io.Bytes.alloc(16);\n\t\t\tvar p = 0;\n\t\t\tfor( i in 0...4 ) {\n\t\t\t\tout.set(p++,h[i]&0xFF);\n\t\t\t\tout.set(p++,(h[i]>>8)&0xFF);\n\t\t\t\tout.set(p++,(h[i]>>16)&0xFF);\n\t\t\t\tout.set(p++,h[i]>>>24);\n\t\t\t}\n\t\t\treturn out;\n\t\t#end\n\t}\n\n\t#if neko\n\tstatic var base_encode = neko.Lib.load(\"std\",\"base_encode\",2);\n\tstatic var make_md5 = neko.Lib.load(\"std\",\"make_md5\",1);\n\t#elseif !php\n\n/*\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n * Digest Algorithm, as defined in RFC 1321.\n * Copyright (C) Paul Johnston 1999 - 2000.\n * Updated by Greg Holt 2000 - 2001.\n * See http://pajhome.org.uk/site/legal.html for details.\n */\n\n\tfunction new() {\n\t}\n\n\tfunction bitOR(a, b){\n\t\tvar lsb = (a & 0x1) | (b & 0x1);\n\t\tvar msb31 = (a >>> 1) | (b >>> 1);\n\t\treturn (msb31 << 1) | lsb;\n\t}\n\n\tfunction bitXOR(a, b){\n\t\tvar lsb = (a & 0x1) ^ (b & 0x1);\n\t\tvar msb31 = (a >>> 1) ^ (b >>> 1);\n\t\treturn (msb31 << 1) | lsb;\n\t}\n\n\tfunction bitAND(a, b){\n\t\tvar lsb = (a & 0x1) & (b & 0x1);\n\t\tvar msb31 = (a >>> 1) & (b >>> 1);\n\t\treturn (msb31 << 1) | lsb;\n\t}\n\n\tfunction addme(x, y) {\n\t\tvar lsw = (x & 0xFFFF)+(y & 0xFFFF);\n\t\tvar msw = (x >> 16)+(y >> 16)+(lsw >> 16);\n\t\treturn (msw << 16) | (lsw & 0xFFFF);\n\t}\n\n\tfunction hex( a : Array<Int> ){\n\t\tvar str = \"\";\n\t\tvar hex_chr = \"0123456789abcdef\";\n\t\tfor( num in a )\n\t\t\tfor( j in 0...4 )\n\t\t\t\tstr += hex_chr.charAt((num >> (j * 8 + 4)) & 0x0F) +\n\t\t\t\t\t\t\t hex_chr.charAt((num >> (j * 8)) & 0x0F);\n\t\treturn str;\n\t}\n\n\tstatic function bytes2blks( b : haxe.io.Bytes ){\n\t\tvar nblk = ((b.length + 8) >> 6) + 1;\n\t\tvar blks = new Array();\n\n\t\t//preallocate size\n\t\tvar blksSize = nblk * 16;\n\t\t#if (neko || cs || cpp || java)\n\t\tblks[blksSize - 1] = 0;\n\t\t#end\n\n\t\t#if !(cpp || cs) //C++ and C# will already initialize them with zeroes.\n\t\tfor( i in 0...blksSize ) blks[i] = 0;\n\t\t#end\n\n\t\tvar i = 0;\n\t\twhile( i < b.length ) {\n\t\t\tblks[i >> 2] |= b.get(i) << ((((b.length << 3) + i) & 3) << 3);\n\t\t\ti++;\n\t\t}\n\t\tblks[i >> 2] |= 0x80 << (((b.length * 8 + i) % 4) * 8);\n\t\tvar l = b.length * 8;\n\t\tvar k = nblk * 16 - 2;\n\t\tblks[k] = (l & 0xFF);\n\t\tblks[k] |= ((l >>> 8) & 0xFF) << 8;\n\t\tblks[k] |= ((l >>> 16) & 0xFF) << 16;\n\t\tblks[k] |= ((l >>> 24) & 0xFF) << 24;\n\t\treturn blks;\n\t}\n\n\tstatic function str2blks( str : String ){\n\t\tvar nblk = ((str.length + 8) >> 6) + 1;\n\t\tvar blks = new Array();\n\n\t\t//preallocate size\n\t\tvar blksSize = nblk * 16;\n\t\t#if (neko || cs || cpp || java)\n\t\tblks[blksSize - 1] = 0;\n\t\t#end\n\n\t\t#if !(cpp || cs) //C++ and C# will already initialize them with zeroes.\n\t\tfor( i in 0...blksSize ) blks[i] = 0;\n\t\t#end\n\n\t\tvar i = 0;\n\t\twhile( i < str.length ) {\n\t\t\tblks[i >> 2] |= str.charCodeAt(i) << (((str.length * 8 + i) % 4) * 8);\n\t\t\ti++;\n\t\t}\n\t\tblks[i >> 2] |= 0x80 << (((str.length * 8 + i) % 4) * 8);\n\t\tvar l = str.length * 8;\n\t\tvar k = nblk * 16 - 2;\n\t\tblks[k] = (l & 0xFF);\n\t\tblks[k] |= ((l >>> 8) & 0xFF) << 8;\n\t\tblks[k] |= ((l >>> 16) & 0xFF) << 16;\n\t\tblks[k] |= ((l >>> 24) & 0xFF) << 24;\n\t\treturn blks;\n\t}\n\n\tfunction rol(num, cnt){\n\t\treturn (num << cnt) | (num >>> (32 - cnt));\n\t}\n\n\tfunction cmn(q, a, b, x, s, t){\n\t\treturn addme(rol((addme(addme(a, q), addme(x, t))), s), b);\n\t}\n\n\tfunction ff(a, b, c, d, x, s, t){\n\t\treturn cmn(bitOR(bitAND(b, c), bitAND((~b), d)), a, b, x, s, t);\n\t}\n\n\tfunction gg(a, b, c, d, x, s, t){\n\t\treturn cmn(bitOR(bitAND(b, d), bitAND(c, (~d))), a, b, x, s, t);\n\t}\n\n\tfunction hh(a, b, c, d, x, s, t){\n\t\treturn cmn(bitXOR(bitXOR(b, c), d), a, b, x, s, t);\n\t}\n\n\tfunction ii(a, b, c, d, x, s, t){\n\t\treturn cmn(bitXOR(c, bitOR(b, (~d))), a, b, x, s, t);\n\t}\n\n\tfunction doEncode( x : Array<Int> ) : Array<Int> {\n\n\t\tvar a =  1732584193;\n\t\tvar b = -271733879;\n\t\tvar c = -1732584194;\n\t\tvar d =  271733878;\n\n\t\tvar step;\n\n\t\tvar i = 0;\n\t\twhile( i < x.length )  {\n\t\t\tvar olda = a;\n\t\t\tvar oldb = b;\n\t\t\tvar oldc = c;\n\t\t\tvar oldd = d;\n\n\t\t\tstep = 0;\n\t\t\ta = ff(a, b, c, d, x[i+ 0], 7 , -680876936);\n\t\t\td = ff(d, a, b, c, x[i+ 1], 12, -389564586);\n\t\t\tc = ff(c, d, a, b, x[i+ 2], 17,  606105819);\n\t\t\tb = ff(b, c, d, a, x[i+ 3], 22, -1044525330);\n\t\t\ta = ff(a, b, c, d, x[i+ 4], 7 , -176418897);\n\t\t\td = ff(d, a, b, c, x[i+ 5], 12,  1200080426);\n\t\t\tc = ff(c, d, a, b, x[i+ 6], 17, -1473231341);\n\t\t\tb = ff(b, c, d, a, x[i+ 7], 22, -45705983);\n\t\t\ta = ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);\n\t\t\td = ff(d, a, b, c, x[i+ 9], 12, -1958414417);\n\t\t\tc = ff(c, d, a, b, x[i+10], 17, -42063);\n\t\t\tb = ff(b, c, d, a, x[i+11], 22, -1990404162);\n\t\t\ta = ff(a, b, c, d, x[i+12], 7 ,  1804603682);\n\t\t\td = ff(d, a, b, c, x[i+13], 12, -40341101);\n\t\t\tc = ff(c, d, a, b, x[i+14], 17, -1502002290);\n\t\t\tb = ff(b, c, d, a, x[i+15], 22,  1236535329);\n\t\t\ta = gg(a, b, c, d, x[i+ 1], 5 , -165796510);\n\t\t\td = gg(d, a, b, c, x[i+ 6], 9 , -1069501632);\n\t\t\tc = gg(c, d, a, b, x[i+11], 14,  643717713);\n\t\t\tb = gg(b, c, d, a, x[i+ 0], 20, -373897302);\n\t\t\ta = gg(a, b, c, d, x[i+ 5], 5 , -701558691);\n\t\t\td = gg(d, a, b, c, x[i+10], 9 ,  38016083);\n\t\t\tc = gg(c, d, a, b, x[i+15], 14, -660478335);\n\t\t\tb = gg(b, c, d, a, x[i+ 4], 20, -405537848);\n\t\t\ta = gg(a, b, c, d, x[i+ 9], 5 ,  568446438);\n\t\t\td = gg(d, a, b, c, x[i+14], 9 , -1019803690);\n\t\t\tc = gg(c, d, a, b, x[i+ 3], 14, -187363961);\n\t\t\tb = gg(b, c, d, a, x[i+ 8], 20,  1163531501);\n\t\t\ta = gg(a, b, c, d, x[i+13], 5 , -1444681467);\n\t\t\td = gg(d, a, b, c, x[i+ 2], 9 , -51403784);\n\t\t\tc = gg(c, d, a, b, x[i+ 7], 14,  1735328473);\n\t\t\tb = gg(b, c, d, a, x[i+12], 20, -1926607734);\n\t\t\ta = hh(a, b, c, d, x[i+ 5], 4 , -378558);\n\t\t\td = hh(d, a, b, c, x[i+ 8], 11, -2022574463);\n\t\t\tc = hh(c, d, a, b, x[i+11], 16,  1839030562);\n\t\t\tb = hh(b, c, d, a, x[i+14], 23, -35309556);\n\t\t\ta = hh(a, b, c, d, x[i+ 1], 4 , -1530992060);\n\t\t\td = hh(d, a, b, c, x[i+ 4], 11,  1272893353);\n\t\t\tc = hh(c, d, a, b, x[i+ 7], 16, -155497632);\n\t\t\tb = hh(b, c, d, a, x[i+10], 23, -1094730640);\n\t\t\ta = hh(a, b, c, d, x[i+13], 4 ,  681279174);\n\t\t\td = hh(d, a, b, c, x[i+ 0], 11, -358537222);\n\t\t\tc = hh(c, d, a, b, x[i+ 3], 16, -722521979);\n\t\t\tb = hh(b, c, d, a, x[i+ 6], 23,  76029189);\n\t\t\ta = hh(a, b, c, d, x[i+ 9], 4 , -640364487);\n\t\t\td = hh(d, a, b, c, x[i+12], 11, -421815835);\n\t\t\tc = hh(c, d, a, b, x[i+15], 16,  530742520);\n\t\t\tb = hh(b, c, d, a, x[i+ 2], 23, -995338651);\n\t\t\ta = ii(a, b, c, d, x[i+ 0], 6 , -198630844);\n\t\t\td = ii(d, a, b, c, x[i+ 7], 10,  1126891415);\n\t\t\tc = ii(c, d, a, b, x[i+14], 15, -1416354905);\n\t\t\tb = ii(b, c, d, a, x[i+ 5], 21, -57434055);\n\t\t\ta = ii(a, b, c, d, x[i+12], 6 ,  1700485571);\n\t\t\td = ii(d, a, b, c, x[i+ 3], 10, -1894986606);\n\t\t\tc = ii(c, d, a, b, x[i+10], 15, -1051523);\n\t\t\tb = ii(b, c, d, a, x[i+ 1], 21, -2054922799);\n\t\t\ta = ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);\n\t\t\td = ii(d, a, b, c, x[i+15], 10, -30611744);\n\t\t\tc = ii(c, d, a, b, x[i+ 6], 15, -1560198380);\n\t\t\tb = ii(b, c, d, a, x[i+13], 21,  1309151649);\n\t\t\ta = ii(a, b, c, d, x[i+ 4], 6 , -145523070);\n\t\t\td = ii(d, a, b, c, x[i+11], 10, -1120210379);\n\t\t\tc = ii(c, d, a, b, x[i+ 2], 15,  718787259);\n\t\t\tb = ii(b, c, d, a, x[i+ 9], 21, -343485551);\n\n\t\t\ta = addme(a, olda);\n\t\t\tb = addme(b, oldb);\n\t\t\tc = addme(c, oldc);\n\t\t\td = addme(d, oldd);\n\n\t\t\ti += 16;\n\t\t}\n\t\treturn [a,b,c,d];\n\t}\n\n\t#end\n\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe.ds;\n\n@:coreApi class IntMap<T> implements haxe.Constraints.IMap<Int,T> {\n\n\tprivate var h : Dynamic;\n\n\tpublic inline function new() : Void {\n\t\th = {};\n\t}\n\n\tpublic inline function set( key : Int, value : T ) : Void {\n\t\tuntyped h[key] = value;\n\t}\n\n\tpublic inline function get( key : Int ) : Null<T> {\n\t\treturn untyped h[key];\n\t}\n\n\tpublic inline function exists( key : Int ) : Bool {\n\t\treturn untyped h.hasOwnProperty(key);\n\t}\n\n\tpublic function remove( key : Int ) : Bool {\n\t\tif( untyped !h.hasOwnProperty(key) ) return false;\n\t\tuntyped  __js__(\"delete\")(h[key]);\n\t\treturn true;\n\t}\n\n\tpublic function keys() : Iterator<Int> {\n\t\tvar a = [];\n\t\tuntyped {\n\t\t\t__js__(\"for( var key in this.h ) {\");\n\t\t\t\tif( h.hasOwnProperty(key) )\n\t\t\t\t\ta.push(key|0);\n\t\t\t__js__(\"}\");\n\t\t}\n\t\treturn a.iterator();\n\t}\n\n\tpublic function iterator() : Iterator<T> {\n\t\treturn untyped {\n\t\t\tref : h,\n\t\t\tit : keys(),\n\t\t\thasNext : function() { return __this__.it.hasNext(); },\n\t\t\tnext : function() { var i = __this__.it.next(); return __this__.ref[i]; }\n\t\t};\n\t}\n\n\tpublic function toString() : String {\n\t\tvar s = new StringBuf();\n\t\ts.add(\"{\");\n\t\tvar it = keys();\n\t\tfor( i in it ) {\n\t\t\ts.add(i);\n\t\t\ts.add(\" => \");\n\t\t\ts.add(Std.string(get(i)));\n\t\t\tif( it.hasNext() )\n\t\t\t\ts.add(\", \");\n\t\t}\n\t\ts.add(\"}\");\n\t\treturn s.toString();\n\t}\n\n}\n","/*\n * Copyright (C)2005-2013 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of h software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and h permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.ds;\n\n@:coreApi\nclass ObjectMap<K:{ }, V> implements haxe.Constraints.IMap<K,V> {\n\n\tstatic var count = 0;\n\n\tstatic inline function assignId(obj: { } ):Int {\n\t\treturn untyped obj.__id__ = ++count;\n\t}\n\n\tstatic inline function getId(obj: { } ):Int {\n\t\treturn untyped obj.__id__;\n\t}\n\n\tvar h : { };\n\n\tpublic function new() : Void {\n\t\th = { };\n\t\tuntyped h.__keys__ = { };\n\t}\n\n\tpublic function set(key:K, value:V):Void untyped {\n\t\tvar id : Int = untyped key.__id__ || assignId(key);\n\t\th[id] = value;\n\t\th.__keys__[id] = key;\n\t}\n\n\tpublic inline function get(key:K):Null<V> {\n\t\treturn untyped h[getId(key)];\n\t}\n\n\tpublic inline function exists(key:K):Bool {\n\t\treturn untyped h.__keys__[getId(key)] != null;\n\t}\n\n\tpublic function remove( key : K ) : Bool {\n\t\tvar id = getId(key);\n\t\tif ( untyped h.__keys__[id] == null ) return false;\n\t\tuntyped  __js__(\"delete\")(h[id]);\n\t\tuntyped  __js__(\"delete\")(h.__keys__[id]);\n\t\treturn true;\n\t}\n\n\tpublic function keys() : Iterator<K> {\n\t\tvar a = [];\n\t\tuntyped {\n\t\t\t__js__(\"for( var key in this.h.__keys__ ) {\");\n\t\t\t\tif( h.hasOwnProperty(key) )\n\t\t\t\t\ta.push(h.__keys__[key]);\n\t\t\t__js__(\"}\");\n\t\t}\n\t\treturn a.iterator();\n\t}\n\n\tpublic function iterator() : Iterator<V> {\n\t\treturn untyped {\n\t\t\tref : h,\n\t\t\tit : keys(),\n\t\t\thasNext : function() { return __this__.it.hasNext(); },\n\t\t\tnext : function() { var i = __this__.it.next(); return __this__.ref[getId(i)]; }\n\t\t};\n\t}\n\n\tpublic function toString() : String {\n\t\tvar s = new StringBuf();\n\t\ts.add(\"{\");\n\t\tvar it = keys();\n\t\tfor( i in it ) {\n\t\t\ts.add(Std.string(i));\n\t\t\ts.add(\" => \");\n\t\t\ts.add(Std.string(get(i)));\n\t\t\tif( it.hasNext() )\n\t\t\t\ts.add(\", \");\n\t\t}\n\t\ts.add(\"}\");\n\t\treturn s.toString();\n\t}\n}","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe.ds;\n\nprivate class StringMapIterator<T> {\n\tvar map : StringMap<T>;\n\tvar keys : Array<String>;\n\tvar index : Int;\n\tvar count : Int;\n\tpublic inline function new(map:StringMap<T>, keys:Array<String>) {\n\t\tthis.map = map;\n\t\tthis.keys = keys;\n\t\tthis.index = 0;\n\t\tthis.count = keys.length;\n\t}\n\tpublic inline function hasNext() {\n\t\treturn index < count;\n\t}\n\tpublic inline function next() {\n\t\treturn map.get(keys[index++]);\n\t}\n}\n\n@:coreApi class StringMap<T> implements haxe.Constraints.IMap<String,T> {\n\n\tprivate var h : Dynamic;\n\tprivate var rh : Dynamic;\n\n\tpublic inline function new() : Void {\n\t\th = {};\n\t}\n\n\tinline function isReserved(key:String) : Bool {\n\t\treturn untyped __js__(\"__map_reserved\")[key] != null;\n\t}\n\n\tpublic inline function set( key : String, value : T ) : Void {\n\t\tif( isReserved(key) )\n\t\t\tsetReserved(key, value);\n\t\telse\n\t\t\th[cast key] = value;\n\t}\n\n\tpublic inline function get( key : String ) : Null<T> {\n\t\tif( isReserved(key) )\n\t\t\treturn getReserved(key);\n\t\treturn h[cast key];\n\t}\n\n\tpublic inline function exists( key : String ) : Bool {\n\t\tif( isReserved(key) )\n\t\t\treturn existsReserved(key);\n\t\treturn h.hasOwnProperty(key);\n\t}\n\n\tfunction setReserved( key : String, value : T ) : Void {\n\t\tif( rh == null ) rh = {};\n\t\trh[cast \"$\"+key] = value;\n\t}\n\n\tfunction getReserved( key : String ) : Null<T> {\n\t\treturn rh == null ? null : rh[cast \"$\"+key];\n\t}\n\n\tfunction existsReserved( key : String ) : Bool {\n\t\tif( rh == null ) return false;\n\t\treturn untyped rh.hasOwnProperty(\"$\"+key);\n\t}\n\n\tpublic function remove( key : String ) : Bool {\n\t\tif( isReserved(key) ) {\n\t\t\tkey = \"$\" + key;\n\t\t\tif( rh == null || !rh.hasOwnProperty(key) ) return false;\n\t\t\tuntyped __js__(\"delete\")(rh[key]);\n\t\t\treturn true;\n\t\t} else {\n\t\t\tif( !h.hasOwnProperty(key) )\n\t\t\t\treturn false;\n\t\t\tuntyped __js__(\"delete\")(h[key]);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tpublic function keys() : Iterator<String> {\n\t\treturn arrayKeys().iterator();\n\t}\n\t\n\tfunction arrayKeys() : Array<String> {\n\t\tvar out = [];\n\t\tuntyped {\n\t\t\t__js__(\"for( var key in this.h ) {\");\n\t\t\t\tif( h.hasOwnProperty(key) )\n\t\t\t\t\tout.push(key);\n\t\t\t__js__(\"}\");\n\t\t}\n\t\tif( rh != null ) untyped {\n\t\t\t__js__(\"for( var key in this.rh ) {\");\n\t\t\t\tif( key.charCodeAt(0) == \"$\".code )\n\t\t\t\t\tout.push(key.substr(1));\n\t\t\t__js__(\"}\");\n\t\t}\n\t\treturn out;\n\t}\n\n\tpublic inline function iterator() : Iterator<T> {\n\t\treturn new StringMapIterator(this, arrayKeys());\n\t}\n\n\tpublic function toString() : String {\n\t\tvar s = new StringBuf();\n\t\ts.add(\"{\");\n\t\tvar keys = arrayKeys();\n\t\tfor( i in 0...keys.length ) {\n\t\t\tvar k = keys[i];\n\t\t\ts.add(k);\n\t\t\ts.add(\" => \");\n\t\t\ts.add(Std.string(get(k)));\n\t\t\tif( i < keys.length )\n\t\t\t\ts.add(\", \");\n\t\t}\n\t\ts.add(\"}\");\n\t\treturn s.toString();\n\t}\n\n\tstatic function __init__() : Void {\n\t\tuntyped __js__(\"var __map_reserved = {}\");\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe.io;\n\nclass BytesBuffer {\n\n\t#if neko\n\tvar b : Dynamic; // neko string buffer\n\t#elseif flash\n\tvar b : flash.utils.ByteArray;\n\t#elseif php\n\tvar b : String;\n\t#elseif cpp\n\tvar b : BytesData;\n\t#elseif cs\n\tvar b : cs.system.io.MemoryStream;\n\t#elseif java\n\tvar b : java.io.ByteArrayOutputStream;\n\t#else\n\tvar b : Array<Int>;\n\t#end\n\n\t/** The length of the buffer in bytes. **/\n\tpublic var length(get,never) : Int;\n\n\tpublic function new() {\n\t\t#if neko\n\t\tb = untyped StringBuf.__make();\n\t\t#elseif flash\n\t\tb = new flash.utils.ByteArray();\n\t\tb.endian = flash.utils.Endian.LITTLE_ENDIAN;\n\t\t#elseif php\n\t\tb = \"\";\n\t\t#elseif cpp\n\t\tb = new BytesData();\n\t\t#elseif cs\n\t\tb = new cs.system.io.MemoryStream();\n\t\t#elseif java\n\t\tb = new java.io.ByteArrayOutputStream();\n\t\t#else\n\t\tb = new Array();\n\t\t#end\n\t}\n\n\tinline function get_length() : Int {\n\t\t#if neko\n\t\treturn untyped __dollar__ssize( StringBuf.__to_string(b) );\n\t\t#elseif cs\n\t\treturn haxe.Int64.toInt( b.Length );\n\t\t#elseif java\n\t\treturn b.size();\n\t\t#else\n\t\treturn b.length;\n\t\t#end\n\t}\n\n\tpublic inline function addByte( byte : Int ) {\n\t\t#if neko\n\t\tuntyped StringBuf.__add_char(b,byte);\n\t\t#elseif flash\n\t\tb.writeByte(byte);\n\t\t#elseif php\n\t\tb += untyped __call__(\"chr\", byte);\n\t\t#elseif cpp\n\t\tb.push(untyped byte);\n\t\t#elseif cs\n\t\tb.WriteByte(cast byte);\n\t\t#elseif java\n\t\tb.write(byte);\n\t\t#else\n\t\tb.push(byte);\n\t\t#end\n\t}\n\n\tpublic inline function add( src : Bytes ) {\n\t\t#if neko\n\t\tuntyped StringBuf.__add(b,src.getData());\n\t\t#elseif flash\n\t\tb.writeBytes(src.getData());\n\t\t#elseif php\n\t\tb += cast src.getData();\n\t\t#elseif cs\n\t\tb.Write(src.getData(), 0, src.length);\n\t\t#elseif java\n\t\tb.write(src.getData(), 0, src.length);\n\t\t#elseif js\n\t\tvar b1 = b;\n\t\tvar b2 = @:privateAccess src.b;\n\t\tfor( i in 0...src.length )\n\t\t\tb.push(b2[i]);\n\t\t#else\n\t\tvar b1 = b;\n\t\tvar b2 = src.getData();\n\t\tfor( i in 0...src.length )\n\t\t\tb.push(b2[i]);\n\t\t#end\n\t}\n\n\tpublic inline function addString( v : String ) {\n\t\t#if neko\n\t\tuntyped StringBuf.__add(b, v.__s);\n\t\t#elseif flash\n\t\tb.writeUTFBytes(v);\n\t\t#else\n\t\tadd(Bytes.ofString(v));\n\t\t#end\n\t}\n\n\tpublic #if flash inline #end function addInt32( v : Int ) {\n\t\t#if flash\n\t\tb.writeUnsignedInt(v);\n\t\t#else\n\t\taddByte(v&0xFF);\n\t\taddByte((v>>8)&0xFF);\n\t\taddByte((v>>16)&0xFF);\n\t\taddByte(v>>>24);\n\t\t#end\n\t}\n\n\tpublic #if flash inline #end function addInt64( v : haxe.Int64 ) {\n\t\taddInt32(v.low);\n\t\taddInt32(v.high);\n\t}\n\n\tpublic inline function addFloat( v : Float ) {\n\t\t#if flash\n\t\tb.writeFloat(v);\n\t\t#else\n\t\taddInt32(FPHelper.floatToI32(v));\n\t\t#end\n\t}\n\n\tpublic inline function addDouble( v : Float ) {\n\t\t#if flash\n\t\tb.writeDouble(v);\n\t\t#else\n\t\taddInt64(FPHelper.doubleToI64(v));\n\t\t#end\n\t}\n\n\tpublic inline function addBytes( src : Bytes, pos : Int, len : Int ) {\n\t\t#if !neko\n\t\tif( pos < 0 || len < 0 || pos + len > src.length ) throw Error.OutsideBounds;\n\t\t#end\n\t\t#if neko\n\t\ttry untyped StringBuf.__add_sub(b,src.getData(),pos,len) catch( e : Dynamic ) throw Error.OutsideBounds;\n\t\t#elseif flash\n\t\tif( len > 0 ) b.writeBytes(src.getData(),pos,len);\n\t\t#elseif php\n\t\tb += untyped __call__(\"substr\", src.b, pos, len);\n\t\t#elseif cs\n\t\tb.Write(src.getData(), pos, len);\n\t\t#elseif java\n\t\tb.write(src.getData(), pos, len);\n\t\t#elseif js\n\t\tvar b1 = b;\n\t\tvar b2 = @:privateAccess src.b;\n\t\tfor( i in pos...pos+len )\n\t\t\tb.push(b2[i]);\n\t\t#else\n\t\tvar b1 = b;\n\t\tvar b2 = src.getData();\n\t\tfor( i in pos...pos+len )\n\t\t\tb.push(b2[i]);\n\t\t#end\n\t}\n\n\t/**\n\t\tReturns either a copy or a reference of the current bytes.\n\t\tOnce called, the buffer can no longer be used.\n\t**/\n\tpublic function getBytes() : Bytes untyped {\n\t\t#if neko\n\t\tvar str = StringBuf.__to_string(b);\n\t\tvar bytes = new Bytes(__dollar__ssize(str),str);\n\t\t#elseif flash\n\t\tvar bytes = new Bytes(b.length,b);\n\t\tb.position = 0;\n\t\t#elseif php\n\t\tvar bytes = new Bytes(b.length, cast b);\n\t\t#elseif cs\n\t\tvar buf = b.GetBuffer();\n\t\tvar bytes = new Bytes(cast b.Length, buf);\n\t\t#elseif java\n\t\tvar buf = b.toByteArray();\n\t\tvar bytes = new Bytes(buf.length, buf);\n\t\t#elseif python\n\t\tvar buf = new python.Bytearray(b);\n\t\tvar bytes = new Bytes(buf.length, buf);\n\t\t#elseif js\n\t\tvar bytes = new Bytes(new js.html.Uint8Array(b).buffer);\n\t\t#else\n\t\tvar bytes = new Bytes(b.length,b);\n\t\t#end\n\t\tb = null;\n\t\treturn bytes;\n\t}\n\n}\n","/*\n * Copyright (C)2005-2014 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe.io;\n\n/**\n\tAn Input is an abstract reader. See other classes in the `haxe.io` package\n\tfor several possible implementations.\n**/\nclass Input {\n\n\t/**\n\t\tEndianness (word byte order) used when reading numbers.\n\n\t\tIf `true`, big-endian is used, otherwise `little-endian` is used.\n\t**/\n\tpublic var bigEndian(default,set) : Bool;\n\n\t#if cs\n\tprivate var helper:BytesData;\n\t#elseif java\n\tprivate var helper:java.nio.ByteBuffer;\n\t#end\n\n\t/**\n\t\tRead and return one byte.\n\t**/\n\tpublic function readByte() : Int {\n\t#if cpp\n\t\tthrow \"Not implemented\";\n\t#else\n\t\treturn throw \"Not implemented\";\n\t#end\n\t}\n\n\t/**\n\t\tRead `len` bytes and write them into `s` to the position specified by `pos`.\n\n\t\tReturns the actual length of read data that can be smaller than `len`.\n\n\t\tSee `readFullBytes` that tries to read the exact amount of specified bytes.\n\t**/\n\tpublic function readBytes( s : Bytes, pos : Int, len : Int ) : Int {\n\t\tvar k = len;\n\t\tvar b = #if js @:privateAccess s.b #else s.getData() #end;\n\t\tif( pos < 0 || len < 0 || pos + len > s.length )\n\t\t\tthrow Error.OutsideBounds;\n\t\twhile( k > 0 ) {\n\t\t\t#if neko\n\t\t\t\tuntyped __dollar__sset(b,pos,readByte());\n\t\t\t#elseif php\n\t\t\t\tb[pos] = untyped __call__(\"chr\", readByte());\n\t\t\t#elseif cpp\n\t\t\t\tb[pos] = untyped readByte();\n\t\t\t#else\n\t\t\t\tb[pos] = cast readByte();\n\t\t\t#end\n\t\t\tpos++;\n\t\t\tk--;\n\t\t}\n\t\treturn len;\n\t}\n\n\t/**\n\t\tClose the input source.\n\n\t\tBehaviour while reading after calling this method is unspecified.\n\t**/\n\tpublic function close() : Void {\n\t}\n\n\tfunction set_bigEndian( b : Bool ) : Bool {\n\t\tbigEndian = b;\n\t\treturn b;\n\t}\n\n\t/* ------------------ API ------------------ */\n\n\t/**\n\t\tRead and return all available data.\n\n\t\tThe `bufsize` optional argument specifies the size of chunks by\n\t\twhich data is read. Its default value is target-specific.\n\t**/\n\tpublic function readAll( ?bufsize : Int ) : Bytes {\n\t\tif( bufsize == null )\n\t\t#if php\n\t\t\tbufsize = 8192; // default value for PHP and max under certain circumstances\n\t\t#else\n\t\t\tbufsize = (1 << 14); // 16 Ko\n\t\t#end\n\n\t\tvar buf = Bytes.alloc(bufsize);\n\t\tvar total = new haxe.io.BytesBuffer();\n\t\ttry {\n\t\t\twhile( true ) {\n\t\t\t\tvar len = readBytes(buf,0,bufsize);\n\t\t\t\tif( len == 0 )\n\t\t\t\t\tthrow Error.Blocked;\n\t\t\t\ttotal.addBytes(buf,0,len);\n\t\t\t}\n\t\t} catch( e : Eof ) {\n\t\t}\n\t\treturn total.getBytes();\n\t}\n\n\t/**\n\t\tRead `len` bytes and write them into `s` to the position specified by `pos`.\n\n\t\tUnlike `readBytes`, this method tries to read the exact `len` amount of bytes.\n\t**/\n\tpublic function readFullBytes( s : Bytes, pos : Int, len : Int ) : Void {\n\t\twhile( len > 0 ) {\n\t\t\tvar k = readBytes(s,pos,len);\n\t\t\tpos += k;\n\t\t\tlen -= k;\n\t\t}\n\t}\n\n\t/**\n\t\tRead and return `nbytes` bytes.\n\t**/\n\tpublic function read( nbytes : Int ) : Bytes {\n\t\tvar s = Bytes.alloc(nbytes);\n\t\tvar p = 0;\n\t\twhile( nbytes > 0 ) {\n\t\t\tvar k = readBytes(s,p,nbytes);\n\t\t\tif( k == 0 ) throw Error.Blocked;\n\t\t\tp += k;\n\t\t\tnbytes -= k;\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t\tRead a string until a character code specified by `end` is occurred.\n\n\t\tThe final character is not included in the resulting string.\n\t**/\n\tpublic function readUntil( end : Int ) : String {\n\t\tvar buf = new StringBuf();\n\t\tvar last : Int;\n\t\twhile( (last = readByte()) != end )\n\t\t\tbuf.addChar( last );\n\t\treturn buf.toString();\n\t}\n\n\t/**\n\t\tRead a line of text separated by CR and/or LF bytes.\n\n\t\tThe CR/LF characters are not included in the resulting string.\n\t**/\n\tpublic function readLine() : String {\n\t\tvar buf = new StringBuf();\n\t\tvar last : Int;\n\t\tvar s;\n\t\ttry {\n\t\t\twhile( (last = readByte()) != 10 )\n\t\t\t\tbuf.addChar( last );\n\t\t\ts = buf.toString();\n\t\t\tif( s.charCodeAt(s.length-1) == 13 ) s = s.substr(0,-1);\n\t\t} catch( e : Eof ) {\n\t\t\ts = buf.toString();\n\t\t\tif( s.length == 0 )\n\t\t\t\t#if neko neko.Lib.rethrow #else throw #end (e);\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t\tRead a 32-bit floating point number.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic #if !(flash || python) inline #end function readFloat() : Float {\n\t\treturn FPHelper.i32ToFloat(readInt32());\n\t}\n\n\t/**\n\t\tRead a 64-bit double-precision floating point number.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readDouble() : Float {\n\t\tvar i1 = readInt32();\n\t\tvar i2 = readInt32();\n\t\treturn bigEndian ? FPHelper.i64ToDouble(i2,i1) : FPHelper.i64ToDouble(i1,i2);\n\t}\n\n\t/**\n\t\tRead a 8-bit signed integer.\n\t**/\n\tpublic function readInt8() : Int {\n\t\tvar n = readByte();\n\t\tif( n >= 128 )\n\t\t\treturn n - 256;\n\t\treturn n;\n\t}\n\n\t/**\n\t\tRead a 16-bit signed integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readInt16() : Int {\n\t\tvar ch1 = readByte();\n\t\tvar ch2 = readByte();\n\t\tvar n = bigEndian ? ch2 | (ch1 << 8) : ch1 | (ch2 << 8);\n\t\tif( n & 0x8000 != 0 )\n\t\t\treturn n - 0x10000;\n\t\treturn n;\n\t}\n\n\t/**\n\t\tRead a 16-bit unsigned integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readUInt16() : Int {\n\t\tvar ch1 = readByte();\n\t\tvar ch2 = readByte();\n\t\treturn bigEndian ? ch2 | (ch1 << 8) : ch1 | (ch2 << 8);\n\t}\n\n\t/**\n\t\tRead a 24-bit signed integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readInt24() : Int {\n\t\tvar ch1 = readByte();\n\t\tvar ch2 = readByte();\n\t\tvar ch3 = readByte();\n\t\tvar n = bigEndian ? ch3 | (ch2 << 8) | (ch1 << 16) : ch1 | (ch2 << 8) | (ch3 << 16);\n\t\tif( n & 0x800000 != 0 )\n\t\t\treturn n - 0x1000000;\n\t\treturn n;\n\t}\n\n\t/**\n\t\tRead a 24-bit unsigned integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readUInt24() : Int {\n\t\tvar ch1 = readByte();\n\t\tvar ch2 = readByte();\n\t\tvar ch3 = readByte();\n\t\treturn bigEndian ? ch3 | (ch2 << 8) | (ch1 << 16) : ch1 | (ch2 << 8) | (ch3 << 16);\n\t}\n\n\t/**\n\t\tRead a 32-bit signed integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readInt32() : Int {\n\t\tvar ch1 = readByte();\n\t\tvar ch2 = readByte();\n\t\tvar ch3 = readByte();\n\t\tvar ch4 = readByte();\n#if (php || python)\n        // php will overflow integers.  Convert them back to signed 32-bit ints.\n        var n = bigEndian ? ch4 | (ch3 << 8) | (ch2 << 16) | (ch1 << 24) : ch1 | (ch2 << 8) | (ch3 << 16) | (ch4 << 24);\n        if (n & 0x80000000 != 0)\n            return ( n | 0x80000000);\n        else return n;\n#else\n\t\treturn bigEndian ? ch4 | (ch3 << 8) | (ch2 << 16) | (ch1 << 24) : ch1 | (ch2 << 8) | (ch3 << 16) | (ch4 << 24);\n#end\n\t}\n\n\t/**\n\t\tRead and `len` bytes as a string.\n\t**/\n\tpublic function readString( len : Int ) : String {\n\t\tvar b = Bytes.alloc(len);\n\t\treadFullBytes(b,0,len);\n\t\t#if neko\n\t\treturn neko.Lib.stringReference(b);\n\t\t#else\n\t\treturn b.toString();\n\t\t#end\n\t}\n\n#if neko\n\tstatic var _float_of_bytes = neko.Lib.load(\"std\",\"float_of_bytes\",2);\n\tstatic var _double_of_bytes = neko.Lib.load(\"std\",\"double_of_bytes\",2);\n\tstatic function __init__() untyped {\n\t\tInput.prototype.bigEndian = false;\n\t}\n#elseif cpp\n\tstatic var _float_of_bytes = cpp.Lib.load(\"std\",\"float_of_bytes\",2);\n\tstatic var _double_of_bytes = cpp.Lib.load(\"std\",\"double_of_bytes\",2);\n#end\n\n#if (flash || js || python)\n\tfunction getDoubleSig(bytes:Array<Int>)\n    {\n        return (((bytes[1]&0xF) << 16) | (bytes[2] << 8) | bytes[3] ) * 4294967296. +\n            (bytes[4] >> 7) * 2147483648 +\n            (((bytes[4]&0x7F) << 24) | (bytes[5] << 16) | (bytes[6] << 8) | bytes[7]);\n    }\n#end\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe.io;\n\nclass BytesInput extends Input {\n\tvar b : #if js js.html.Uint8Array #else BytesData #end;\n\t#if !flash\n\tvar pos : Int;\n\tvar len : Int;\n\tvar totlen : Int;\n\t#end\n\n\t/** The current position in the stream in bytes. */\n\tpublic var position(get,set) : Int;\n\n\t/** The length of the stream in bytes. */\n\tpublic var length(get,never) : Int;\n\n\tpublic function new( b : Bytes, ?pos : Int, ?len : Int ) {\n\t\tif( pos == null ) pos = 0;\n\t\tif( len == null ) len = b.length - pos;\n\t\tif( pos < 0 || len < 0 || pos + len > b.length ) throw Error.OutsideBounds;\n\t\t#if flash\n\t\tvar ba = b.getData();\n\t\tba.position = pos;\n\t\tif( len != ba.bytesAvailable ) {\n\t\t\t// truncate\n\t\t\tthis.b = new flash.utils.ByteArray();\n\t\t\tba.readBytes(this.b,0,len);\n\t\t} else\n\t\t\tthis.b = ba;\n\t\tthis.b.endian = flash.utils.Endian.LITTLE_ENDIAN;\n\t\t#else\n\t\tthis.b = #if js @:privateAccess b.b #else b.getData() #end;\n\t\tthis.pos = pos;\n\t\tthis.len = len;\n\t\tthis.totlen = len;\n\t\t#end\n\t\t#if python\n\t\tbigEndian = false;\n\t\t#end\n\t}\n\n\tinline function get_position() : Int {\n\t\t#if flash\n\t\treturn b.position;\n\t\t#else\n\t\treturn pos;\n\t\t#end\n\t}\n\n\tinline function get_length() : Int {\n\t\t#if flash\n\t\treturn b.length;\n\t\t#else\n\t\treturn totlen;\n\t\t#end\n\t}\n\n\tfunction set_position( p : Int ) : Int {\n\t\tif( p < 0 ) p = 0;\n\t\telse if( p > length ) p = length;\n\t\t#if flash\n\t\treturn b.position = p;\n\t\t#else\n\t\tlen = totlen - p;\n\t\treturn pos = p;\n\t\t#end\n\t}\n\n\tpublic override function readByte() : Int {\n\t\t#if flash\n\t\t\treturn try b.readUnsignedByte() catch( e : Dynamic ) throw new Eof();\n\t\t#else\n\t\t\tif( this.len == 0 )\n\t\t\t\tthrow new Eof();\n\t\t\tlen--;\n\t\t\t#if neko\n\t\t\treturn untyped __dollar__sget(b,pos++);\n\t\t\t#elseif php\n\t\t\treturn untyped __call__(\"ord\", b[pos++]);\n\t\t\t#elseif cpp\n\t\t\treturn untyped b[pos++];\n\t\t\t#elseif java\n\t\t\treturn untyped b[pos++] & 0xFF;\n\t\t\t#else\n\t\t\treturn b[pos++];\n\t\t\t#end\n\t\t#end\n\t}\n\n\tpublic override function readBytes( buf : Bytes, pos, len ) : Int {\n\t\t#if !neko\n\t\t\tif( pos < 0 || len < 0 || pos + len > buf.length )\n\t\t\t\tthrow Error.OutsideBounds;\n\t\t#end\n\t\t#if flash\n\t\t\tvar avail : Int = b.bytesAvailable;\n\t\t\tif( len > avail && avail > 0 ) len = avail;\n\t\t\ttry b.readBytes(buf.getData(),pos,len) catch( e : Dynamic ) throw new Eof();\n\t\t#elseif java\n\t\t\tvar avail : Int = this.len;\n\t\t\tif ( len > avail ) len = avail;\n\t\t\tif (len == 0)\n\t\t\t\tthrow new Eof();\n\t\t\tjava.lang.System.arraycopy(this.b, this.pos, buf.getData(), pos, len);\n\t\t\tthis.pos += len;\n\t\t\tthis.len -= len;\n\t\t#elseif cs\n\t\t\tvar avail : Int = this.len;\n\t\t\tif ( len > avail ) len = avail;\n\t\t\tif (len == 0)\n\t\t\t\tthrow new Eof();\n\t\t\tcs.system.Array.Copy(this.b,this.pos, buf.getData(), pos, len);\n\t\t\tthis.pos += len;\n\t\t\tthis.len -= len;\n\t\t#else\n\t\t\tif( this.len == 0 && len > 0 )\n\t\t\t\tthrow new Eof();\n\t\t\tif( this.len < len )\n\t\t\t\tlen = this.len;\n\t\t\t#if neko\n\t\t\ttry untyped __dollar__sblit(buf.getData(),pos,b,this.pos,len) catch( e : Dynamic ) throw Error.OutsideBounds;\n\t\t\t#elseif php\n\t\t\tuntyped __php__(\"$buf->b = substr($buf->b, 0, $pos) . substr($this->b, $this->pos, $len) . substr($buf->b, $pos+$len)\");\n\t\t\t#else\n\t\t\tvar b1 = b;\n\t\t\tvar b2 = #if js @:privateAccess buf.b #else buf.getData() #end;\n\t\t\tfor( i in 0...len )\n\t\t\t\tb2[pos+i] = b1[this.pos+i];\n\t\t\t#end\n\t\t\tthis.pos += len;\n\t\t\tthis.len -= len;\n\t\t#end\n\t\treturn len;\n\t}\n\n\t#if flash\n\t@:dox(hide)\n\toverride function set_bigEndian(e) {\n\t\tbigEndian = e;\n\t\tb.endian = e ? flash.utils.Endian.BIG_ENDIAN : flash.utils.Endian.LITTLE_ENDIAN;\n\t\treturn e;\n\t}\n\n\t@:dox(hide)\n\toverride function readFloat() {\n\t\treturn try b.readFloat() catch( e : Dynamic ) throw new Eof();\n\t}\n\n\t@:dox(hide)\n\toverride function readDouble() {\n\t\treturn try b.readDouble() catch( e : Dynamic ) throw new Eof();\n\t}\n\n\t@:dox(hide)\n\toverride function readInt8() {\n\t\treturn try b.readByte() catch( e : Dynamic ) throw new Eof();\n\t}\n\n\t@:dox(hide)\n\toverride function readInt16() {\n\t\treturn try b.readShort() catch( e : Dynamic ) throw new Eof();\n\t}\n\n\t@:dox(hide)\n\toverride function readUInt16() : Int {\n\t\treturn try b.readUnsignedShort() catch( e : Dynamic ) throw new Eof();\n\t}\n\n\t@:dox(hide)\n\toverride function readInt32() : Int {\n\t\treturn try b.readInt() catch( e : Dynamic ) throw new Eof();\n\t}\n\n\t@:dox(hide)\n\toverride function readString( len : Int ) {\n\t\treturn try b.readUTFBytes(len) catch( e : Dynamic ) throw new Eof();\n\t}\n\n\t#end\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe.io;\n\n/**\n\tThis exception is raised when reading while data is no longer available in the [Input].\n**/\nclass Eof {\n\tpublic function new() {\n\t}\n\t@:keep function toString() {\n\t\treturn \"Eof\";\n\t}\n}\n","/*\n * Copyright (C)2005-2015 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe.io;\n\n/**\n\tHelper that converts between floating point and binary representation.\n\tAlways works in low-endian encoding.\n**/\nclass FPHelper {\n\n\t#if neko_v21\n\t// stored in helper\n\t#elseif neko\n\tstatic var i64tmp = new neko.vm.Tls<Int64>();\n\t#elseif !(java || cs)\n\tstatic var i64tmp = Int64.ofInt(0);\n\t#end\n\n\t#if neko\n\t\t#if neko_v21\n\t\tstatic var helpers = new neko.vm.Tls<neko.NativeArray<Dynamic>>();\n\t\t#else\n\t\tstatic var helperf = new neko.vm.Tls<neko.NativeString>();\n\t\tstatic var helperd = new neko.vm.Tls<neko.NativeString>();\n\t\tstatic var _float_of_bytes = neko.Lib.load(\"std\",\"float_of_bytes\",2);\n\t\tstatic var _double_of_bytes = neko.Lib.load(\"std\",\"double_of_bytes\",2);\n\t\tstatic var _float_bytes = neko.Lib.load(\"std\",\"float_bytes\",2);\n\t\tstatic var _double_bytes = neko.Lib.load(\"std\",\"double_bytes\",2);\n\t\t#end\n\t#elseif flash\n\t\tstatic var helper = {\n\t\t\tvar b = new flash.utils.ByteArray();\n\t\t\tb.endian = flash.utils.Endian.LITTLE_ENDIAN;\n\t\t\tb;\n\t\t}\n\t#elseif php\n\t\tstatic var isLittleEndian : Bool = untyped __call__('unpack','S','\\x01\\x00')[1] == 1;\n\t#else\n\t\tstatic inline var LN2 = 0.6931471805599453; // Math.log(2)\n\t#end\n\n\t#if neko_v21 inline #end\n\tpublic static function i32ToFloat( i : Int ) : Float {\n\t\t#if neko\n\t\t\t#if neko_v21\n\t\t\treturn untyped $itof(i,false);\n\t\t\t#else\n\t\t\tvar helper = helperf.value;\n\t\t\tif( helper == null )\n\t\t\t\thelperf.value = helper = neko.NativeString.alloc(4);\n\t\t\tuntyped $sset(helper,0,i&0xFF);\n\t\t\tuntyped $sset(helper,1,(i>>8)&0xFF);\n\t\t\tuntyped $sset(helper,2,(i>>16)&0xFF);\n\t\t\tuntyped $sset(helper,3,i>>>24);\n\t\t\treturn _float_of_bytes(helper,false);\n\t\t\t#end\n\t\t#elseif cpp\n\t\t\treturn untyped __global__.__hxcpp_reinterpret_le_int32_as_float32(i);\n\t\t#elseif cs\n\t\t\tvar helper = new SingleHelper(0);\n\t\t\tif( cs.system.BitConverter.IsLittleEndian )\n\t\t\t{\n\t\t\t\thelper.i = i;\n\t\t\t} else {\n\t\t\t\thelper.i = ((i >>> 24) & 0xFF) | (((i >> 16) & 0xFF) << 8) | (((i >> 8) & 0xFF) << 16) | ((i & 0xFF) << 24);\n\t\t\t}\n\n\t\t\treturn helper.f;\n\t\t#elseif java\n\t\t\treturn java.lang.Float.FloatClass.intBitsToFloat(i);\n\t\t#elseif php\n\t\t\treturn untyped  __call__('unpack', 'f', __call__('pack', 'l', i))[1];\n\t\t#elseif flash\n\t\t\tvar helper = helper;\n\t\t\thelper.position = 0;\n\t\t\thelper.writeUnsignedInt(i);\n\t\t\thelper.position = 0;\n\t\t\treturn helper.readFloat();\n\t\t#else\n\t\t\tvar sign = 1 - ((i >>> 31) << 1);\n\t\t\tvar exp = (i >>> 23) & 0xFF;\n\t\t\tvar sig = i & 0x7FFFFF;\n\t\t\tif( sig == 0 && exp == 0 )\n\t\t\t\treturn 0.0;\n\t\t\treturn sign*(1 + Math.pow(2, -23)*sig) * Math.pow(2, exp-127);\n\t\t#end\n\t}\n\n\t#if neko_v21 inline #end\n\tpublic static function floatToI32( f : Float ) : Int {\n\t\t#if neko\n\t\t\t#if neko_v21\n\t\t\treturn untyped $ftoi(f,false);\n\t\t\t#else\n\t\t\tvar r = _float_bytes(f,false);\n\t\t\treturn untyped $sget(r,0) | ($sget(r,1)<<8) | ($sget(r,2)<<16) | ($sget(r,3)<<24);\n\t\t\t#end\n\t\t#elseif cpp\n\t\t\treturn untyped __global__.__hxcpp_reinterpret_float32_as_le_int32(f);\n\t\t#elseif cs\n\t\t\tvar helper = new SingleHelper(f);\n\t\t\tif( cs.system.BitConverter.IsLittleEndian )\n\t\t\t{\n\t\t\t\treturn helper.i;\n\t\t\t} else {\n\t\t\t\tvar i = helper.i;\n\t\t\t\treturn ((i >>> 24) & 0xFF) | (((i >> 16) & 0xFF) << 8) | (((i >> 8) & 0xFF) << 16) | ((i & 0xFF) << 24);\n\t\t\t}\n\t\t#elseif java\n\t\t\treturn java.lang.Float.FloatClass.floatToRawIntBits(f);\n\t\t#elseif flash\n\t\t\tvar helper = helper;\n\t\t\thelper.position = 0;\n\t\t\thelper.writeFloat(f);\n\t\t\thelper.position = 0;\n\t\t\treturn helper.readUnsignedInt();\n\t\t#elseif php\n\t\t\treturn untyped __call__('unpack','l',__call__('pack', 'f', f))[1];\n\t\t#else\n\t\t\tif( f == 0 ) return 0;\n\t\t\tvar af = f < 0 ? -f : f;\n\t\t\tvar exp = Math.floor(Math.log(af) / LN2);\n\t\t\tif( exp < -127 ) exp = -127 else if( exp > 128 ) exp = 128;\n\t\t\tvar sig = Math.round((af / Math.pow(2, exp) - 1) * 0x800000) & 0x7FFFFF;\n\t\t\treturn (f < 0 ? 0x80000000 : 0) | ((exp + 127) << 23) | sig;\n\t\t#end\n\t}\n\n\t#if neko_v21 inline #end\n\tpublic static function i64ToDouble( low : Int, high : Int ) : Float {\n\t\t#if neko\n\t\t\t#if neko_v21\n\t\t\treturn untyped $itod(low,high,false);\n\t\t\t#else\n\t\t\tvar helper = helperd.value;\n\t\t\tif( helper == null )\n\t\t\t\thelperd.value = helper = neko.NativeString.alloc(8);\n\t\t\tuntyped $sset(helper,0,low&0xFF);\n\t\t\tuntyped $sset(helper,1,(low>>8)&0xFF);\n\t\t\tuntyped $sset(helper,2,(low>>16)&0xFF);\n\t\t\tuntyped $sset(helper,3,low>>>24);\n\t\t\tuntyped $sset(helper,4,high&0xFF);\n\t\t\tuntyped $sset(helper,5,(high>>8)&0xFF);\n\t\t\tuntyped $sset(helper,6,(high>>16)&0xFF);\n\t\t\tuntyped $sset(helper,7,high>>>24);\n\t\t\treturn _double_of_bytes(helper,false);\n\t\t\t#end\n\t\t#elseif cpp\n\t\t\treturn untyped __global__.__hxcpp_reinterpret_le_int32s_as_float64(low,high);\n\t\t#elseif cs\n\t\t\tvar helper = new FloatHelper(0);\n\t\t\tif( cs.system.BitConverter.IsLittleEndian )\n\t\t\t{\n\t\t\t\thelper.i = haxe.Int64.make(high,low);\n\t\t\t} else {\n\t\t\t\tvar i1 = high,\n\t\t\t\t    i2 = low;\n\t\t\t\tvar j2 = ((i1 >>> 24) & 0xFF) | (((i1 >> 16) & 0xFF) << 8) | (((i1 >> 8) & 0xFF) << 16) | ((i1 & 0xFF) << 24);\n\t\t\t\tvar j1 = ((i2 >>> 24) & 0xFF) | (((i2 >> 16) & 0xFF) << 8) | (((i2 >> 8) & 0xFF) << 16) | ((i2 & 0xFF) << 24);\n\t\t\t\thelper.i = haxe.Int64.make(j1,j2);\n\t\t\t}\n\t\t\treturn helper.f;\n\t\t#elseif java\n\t\t\treturn java.lang.Double.DoubleClass.longBitsToDouble( Int64.make(high,low) );\n\t\t#elseif flash\n\t\t\tvar helper = helper;\n\t\t\thelper.position = 0;\n\t\t\thelper.writeUnsignedInt(low);\n\t\t\thelper.writeUnsignedInt(high);\n\t\t\thelper.position = 0;\n\t\t\treturn helper.readDouble();\n\t\t#elseif php\n\t\t\treturn untyped  __call__('unpack', 'd', __call__('pack', 'ii', isLittleEndian ? low : high, isLittleEndian ? high : low))[1];\n\t\t#else\n\t\t\tvar sign = 1 - ((high >>> 31) << 1);\n\t\t\tvar exp = ((high >> 20) & 0x7FF) - 1023;\n\t\t\tvar sig = (high&0xFFFFF) * 4294967296. + (low>>>31) * 2147483648. + (low&0x7FFFFFFF);\n\t\t\tif( sig == 0 && exp == -1023 )\n\t\t\t\treturn 0.0;\n\t\t\treturn sign*(1.0 + Math.pow(2, -52)*sig) * Math.pow(2, exp);\n\t\t#end\n\t}\n\n\t/**\n\t\tReturns an Int64 representing the bytes representation of the double precision IEEE float value.\n\t\tWARNING : for performance reason, the same Int64 value might be reused every time. Copy its low/high values before calling again.\n\t\tWe still ensure that this is safe to use in a multithread environment\n\t**/\n\tpublic static function doubleToI64( v : Float ) : Int64 {\n\t\t#if neko\n\t\t\t#if neko_v21\n\t\t\tvar helper = helpers.value;\n\t\t\tif( helper == null ) {\n\t\t\t\thelpers.value = helper = neko.NativeArray.alloc(2);\n\t\t\t\thelper[0] = neko.NativeArray.alloc(2);\n\t\t\t\thelper[1] = haxe.Int64.ofInt(0);\n\t\t\t}\n\t\t\tvar i64 : haxe.Int64 = helper[1], int2 = helper[0];\n\t\t\tuntyped $dtoi(v,int2,false);\n\t\t\t@:privateAccess {\n\t\t\t\ti64.set_low(int2[0]);\n\t\t\t\ti64.set_high(int2[1]);\n\t\t\t}\n\t\t\treturn i64;\n\t\t\t#else\n\t\t\tvar r = _double_bytes(v,false), i64 = i64tmp.value;\n\t\t\tif( i64 == null )\n\t\t\t\ti64 = i64tmp.value = haxe.Int64.ofInt(0);\n\t\t\t@:privateAccess {\n\t\t\t\ti64.set_low(untyped $sget(r,0) | ($sget(r,1)<<8) | ($sget(r,2)<<16) | ($sget(r,3)<<24));\n\t\t\t\ti64.set_high(untyped $sget(r,4) | ($sget(r,5)<<8) | ($sget(r,6)<<16) | ($sget(r,7)<<24));\n\t\t\t}\n\t\t\treturn i64;\n\t\t\t#end\n\t\t#elseif cpp\n\t\t\treturn Int64.make(untyped __global__.__hxcpp_reinterpret_float64_as_le_int32_high(v),\n\t\t\t\t               untyped __global__.__hxcpp_reinterpret_float64_as_le_int32_low(v) );\n\t\t#elseif java\n\t\t\treturn java.lang.Double.DoubleClass.doubleToRawLongBits(v);\n\t\t#elseif cs\n\t\t\tvar helper = new FloatHelper(v);\n\t\t\tif( cs.system.BitConverter.IsLittleEndian )\n\t\t\t{\n\t\t\t\treturn helper.i;\n\t\t\t} else {\n\t\t\t\tvar i = helper.i;\n\t\t\t\tvar i1 = haxe.Int64.getHigh(i),\n\t\t\t\t    i2 = haxe.Int64.getLow(i);\n\t\t\t\tvar j2 = ((i1 >>> 24) & 0xFF) | (((i1 >> 16) & 0xFF) << 8) | (((i1 >> 8) & 0xFF) << 16) | ((i1 & 0xFF) << 24);\n\t\t\t\tvar j1 = ((i2 >>> 24) & 0xFF) | (((i2 >> 16) & 0xFF) << 8) | (((i2 >> 8) & 0xFF) << 16) | ((i2 & 0xFF) << 24);\n\n\t\t\t\treturn haxe.Int64.make(j1,j2);\n\t\t\t}\n\t\t#elseif flash\n\t\t\tvar helper = helper;\n\t\t\thelper.position = 0;\n\t\t\thelper.writeDouble(v);\n\t\t\thelper.position = 0;\n\t\t\tvar i64 = i64tmp;\n\t\t\t@:privateAccess {\n\t\t\t\ti64.set_low(cast helper.readUnsignedInt());\n\t\t\t\ti64.set_high(cast helper.readUnsignedInt());\n\t\t\t}\n\t\t\treturn i64;\n\t\t#elseif php\n\t\t\tvar a = untyped __call__('unpack',isLittleEndian ? 'V2' : 'N2',__call__('pack', 'd', v));\n\t\t\tvar i64 = i64tmp;\n\t\t\t@:privateAccess {\n\t\t\t\ti64.set_low(a[isLittleEndian ? 1 : 2]);\n\t\t\t\ti64.set_high(a[isLittleEndian ? 2 : 1]);\n\t\t\t}\n\t\t\treturn i64;\n\t\t#else\n\t\t\tvar i64 = i64tmp;\n\t\t\tif( v == 0 ) {\n\t\t\t\t@:privateAccess {\n\t\t\t\t\ti64.set_low(0);\n\t\t\t\t\ti64.set_high(0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar av = v < 0 ? -v : v;\n\t\t\t\tvar exp = Math.floor(Math.log(av) / LN2);\n\t\t\t\tvar sig = Math.fround(((av / Math.pow(2, exp)) - 1) * 4503599627370496.); // 2^52\n\t\t\t\tvar sig_l = Std.int(sig);\n\t\t\t\tvar sig_h = Std.int(sig / 4294967296.0);\n\t\t\t\t@:privateAccess {\n\t\t\t\t\ti64.set_low(sig_l);\n\t\t\t\t\ti64.set_high((v < 0 ? 0x80000000 : 0) | ((exp + 1023) << 20) | sig_h);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn i64;\n\t\t#end\n\t}\n\n}\n\n#if cs\n@:meta(System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit))\n@:nativeGen @:struct private class SingleHelper\n{\n\t@:meta(System.Runtime.InteropServices.FieldOffset(0))\n\tpublic var i:Int;\n\t@:meta(System.Runtime.InteropServices.FieldOffset(0))\n\tpublic var f:Single;\n\n\tpublic function new(f:Single)\n\t{\n\t\tthis.i = 0;\n\t\tthis.f = f;\n\t}\n}\n\n@:meta(System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit))\n@:nativeGen @:struct private class FloatHelper\n{\n\t@:meta(System.Runtime.InteropServices.FieldOffset(0))\n\tpublic var i:haxe.Int64;\n\t@:meta(System.Runtime.InteropServices.FieldOffset(0))\n\tpublic var f:Float;\n\n\tpublic function new(f:Float)\n\t{\n\t\tthis.i = haxe.Int64.ofInt(0);\n\t\tthis.f = f;\n\t}\n}\n\n#end\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe.io;\n\n/**\n\tThis class provides a convenient way of working with paths. It supports the\n\tcommon path formats:\n\n\t- directory1/directory2/filename.extension\n\t- directory1\\directory2\\filename.excention\n**/\nclass Path {\n\n\t/**\n\t\tThe directory.\n\n\t\tThis is the leading part of the path that is not part of the file name\n\t\tand the extension.\n\n\t\tDoes not end with a `/` or `\\` separator.\n\n\t\tIf the path has no directory, the value is null.\n\t**/\n\tpublic var dir : String;\n\n\t/**\n\t\tThe file name.\n\n\t\tThis is the part of the part between the directory and the extension.\n\n\t\tIf there is no file name, e.g. for \".htaccess\" or \"/dir/\", the value\n\t\tis the empty String \"\".\n\t**/\n\tpublic var file : String;\n\n\t/**\n\t\tThe file extension.\n\n\t\tIt is separated from the file name by a dot. This dot is not part of\n\t\tthe extension.\n\n\t\tIf the path has no extension, the value is null.\n\t**/\n\tpublic var ext : String;\n\n\t/**\n\t\tTrue if the last directory separator is a backslash, false otherwise.\n\t**/\n\tpublic var backslash : Bool;\n\n\t/**\n\t\tCreates a new Path instance by parsing `path`.\n\n\t\tPath information can be retrieved by accessing the dir, file and ext\n\t\tproperties.\n\t**/\n\tpublic function new( path : String ) {\n\t\tswitch (path) {\n\t\t\tcase \".\" | \"..\":\n\t\t\t\tdir = path;\n\t\t\t\tfile = \"\";\n\t\t\t\treturn;\n\t\t}\n\t\tvar c1 = path.lastIndexOf(\"/\");\n\t\tvar c2 = path.lastIndexOf(\"\\\\\");\n\t\tif( c1 < c2 ) {\n\t\t\tdir = path.substr(0,c2);\n\t\t\tpath = path.substr(c2+1);\n\t\t\tbackslash = true;\n\t\t} else if( c2 < c1 ) {\n\t\t\tdir = path.substr(0,c1);\n\t\t\tpath = path.substr(c1+1);\n\t\t} else\n\t\t\tdir = null;\n\t\tvar cp = path.lastIndexOf(\".\");\n\t\tif( cp != -1 ) {\n\t\t\text = path.substr(cp+1);\n\t\t\tfile = path.substr(0,cp);\n\t\t} else {\n\t\t\text = null;\n\t\t\tfile = path;\n\t\t}\n\t}\n\n\t/**\n\t\tReturns a String representation of `this` path.\n\n\t\tIf `this.backslash` is true, backslash is used as directory separator,\n\t\totherwise slash is used. This only affects the separator between\n\t\t`this.dir` and `this.file`.\n\n\t\tIf `this.directory` or `this.extension` is null, their representation\n\t\tis the empty String \"\".\n\t**/\n\tpublic function toString() {\n\t\treturn (if( dir == null ) \"\" else dir + if( backslash ) \"\\\\\" else \"/\") + file + (if( ext == null ) \"\" else \".\" + ext);\n\t}\n\n\t/**\n\t\tReturns the String representation of `path` without the file extension.\n\n\t\tIf `path` is null, the result is unspecified.\n\t**/\n\tpublic static function withoutExtension( path : String ) {\n\t\tvar s = new Path(path);\n\t\ts.ext = null;\n\t\treturn s.toString();\n\t}\n\n\t/**\n\t\tReturns the String representation of `path` without the directory.\n\n\t\tIf `path` is null, the result is unspecified.\n\t**/\n\tpublic static function withoutDirectory( path ) {\n\t\tvar s = new Path(path);\n\t\ts.dir = null;\n\t\treturn s.toString();\n\t}\n\n\t/**\n\t\tReturns the directory of `path`.\n\n\t\tIf the directory is null, the empty String \"\" is returned.\n\n\t\tIf `path` is null, the result is unspecified.\n\t**/\n\tpublic static function directory( path ) {\n\t\tvar s = new Path(path);\n\t\tif( s.dir == null )\n\t\t\treturn \"\";\n\t\treturn s.dir;\n\t}\n\n\t/**\n\t\tReturns the extension of `path`.\n\n\t\tIf the extension is null, the empty String \"\" is returned.\n\n\t\tIf `path` is null, the result is unspecified.\n\t**/\n\tpublic static function extension( path ) {\n\t\tvar s = new Path(path);\n\t\tif( s.ext == null )\n\t\t\treturn \"\";\n\t\treturn s.ext;\n\t}\n\n\t/**\n\t\tReturns a String representation of `path` where the extension is `ext`.\n\n\t\tIf `path` has no extension, `ext` is added as extension.\n\n\t\tIf `path` or `ext` are null, the result is unspecified.\n\t**/\n\tpublic static function withExtension( path, ext ) {\n\t\tvar s = new Path(path);\n\t\ts.ext = ext;\n\t\treturn s.toString();\n\t}\n\n\t/**\n\t\tJoins all paths in `paths` together.\n\n\t\tIf `paths` is empty, the empty String `\"\"` is returned. Otherwise the\n\t\tpaths are joined with a slash between them.\n\n\t\tIf `paths` is null, the result is unspecified.\n\t**/\n\tpublic static function join(paths:Array<String>) : String {\n\t\tvar paths = paths.filter(function(s) return s != null && s != \"\");\n\t\tif (paths.length == 0) {\n\t\t\treturn \"\";\n\t\t}\n\t\tvar path = paths[0];\n\t\tfor (i in 1...paths.length) {\n\t\t\tpath = addTrailingSlash(path);\n\t\t\tpath += paths[i];\n\t\t}\n\t\treturn normalize(path);\n\t}\n\n\t/**\n\t\tNormalize a given `path` (e.g. make '/usr/local/../lib' to '/usr/lib').\n\n\t\tAlso replaces backslashes \\ with slashes / and afterwards turns\n\t\tmultiple slashes into a single one.\n\n\t\tIf `path` is null, the result is unspecified.\n\t**/\n\tpublic static function normalize(path : String) : String {\n\t\tvar slash = '/';\n\t\tpath = path.split(\"\\\\\").join(\"/\");\n\t\tif( path == null || path == slash ) {\n\t\t\treturn slash;\n\t\t}\n\n\t\tvar target = [];\n\n\t\tfor( token in path.split(slash) ) {\n\t\t\tif(token == '..' && target.length > 0 && target[target.length-1] != \"..\") {\n\t\t\t\ttarget.pop();\n\t\t\t} else if(token != '.') {\n\t\t\t\ttarget.push(token);\n\t\t\t}\n\t\t}\n\n\t\tvar tmp = target.join(slash);\n\t\tvar regex = ~/([^:])\\/+/g;\n\t\tvar result = regex.replace(tmp, \"$1\" +slash);\n\t\tvar acc = new StringBuf();\n\t\tvar colon = false;\n\t\tvar slashes = false;\n\t\tfor (i in 0...tmp.length) {\n\t\t\tswitch (tmp.charCodeAt(i)) {\n\t\t\t\tcase \":\".code:\n\t\t\t\t\tacc.add(\":\");\n\t\t\t\t\tcolon = true;\n\t\t\t\tcase \"/\".code if (colon == false):\n\t\t\t\t\tslashes = true;\n\t\t\t\tcase i:\n\t\t\t\t\tcolon = false;\n\t\t\t\t\tif (slashes) {\n\t\t\t\t\t\tacc.add(\"/\");\n\t\t\t\t\t\tslashes = false;\n\t\t\t\t\t}\n\t\t\t\t\tacc.add(String.fromCharCode(i));\n\t\t\t}\n\t\t}\n\t\tvar result = acc.toString();\n\t\treturn result;\n\t}\n\n\t/**\n\t\tAdds a trailing slash to `path`, if it does not have one already.\n\n\t\tIf the last slash in `path` is a backslash, a backslash is appended to\n\t\t`path`.\n\n\t\tIf the last slash in `path` is a slash, or if no slash is found, a slash\n\t\tis appended to `path`. In particular, this applies to the empty String\n\t\t\"\".\n\n\t\tIf `path` is null, the result is unspecified.\n\t**/\n\tpublic static function addTrailingSlash( path : String ) : String {\n\t\tif (path.length == 0)\n\t\t\treturn \"/\";\n\t\tvar c1 = path.lastIndexOf(\"/\");\n\t\tvar c2 = path.lastIndexOf(\"\\\\\");\n\t\treturn if ( c1 < c2 ) {\n\t\t\tif (c2 != path.length - 1) path + \"\\\\\";\n\t\t\telse path;\n\t\t} else {\n\t\t\tif (c1 != path.length - 1) path + \"/\";\n\t\t\telse path;\n\t\t}\n\t}\n\n\t/**\n\t\tRemoves trailing slashes from `path`.\n\n\t\tIf `path` does not end with a `/` or `\\`, `path` is returned unchanged.\n\n\t\tOtherwise the substring of `path` excluding the trailing slashes or\n\t\tbackslashes is returned.\n\n\t\tIf `path` is null, the result is unspecified.\n\t**/\n\t@:require(haxe_ver >= 3.1)\n\tpublic static function removeTrailingSlashes ( path : String ) : String {\n\t\twhile (true) {\n\t\t\tswitch(path.charCodeAt(path.length - 1)) {\n\t\t\t\tcase '/'.code | '\\\\'.code: path = path.substr(0, -1);\n\t\t\t\tcase _: break;\n\t\t\t}\n\t\t}\n\t\treturn path;\n\t}\n\n\t/**\n\t\tReturns true if the path is an absolute path, and false otherwise.\n\t**/\n\t@:require(haxe_ver >= 3.2)\n\tpublic static function isAbsolute ( path : String ) : Bool {\n\t\tif (StringTools.startsWith(path, '/')) return true;\n\t\tif (path.charAt(1) == ':') return true;\n\t\treturn false;\n\t}\n\n\tprivate static function unescape( path : String ) : String {\n\t\tvar regex = ~/-x([0-9][0-9])/g;\n\t\treturn regex.map(path, function(regex) return String.fromCharCode(Std.parseInt(regex.matched(1))));\n\t}\n\n\tprivate static function escape( path : String, allowSlashes : Bool = false ) : String {\n\t\tvar regex = allowSlashes ? ~/[^A-Za-z0-9_\\/\\\\\\.]/g : ~/[^A-Za-z0-9_\\.]/g;\n\t\treturn regex.map(path, function(v) return '-x' + v.matched(0).charCodeAt(0));\n\t}\n}\n","package hxDaedalus.ai;\r\n\r\nimport hxDaedalus.data.Edge;\r\nimport hxDaedalus.data.Face;\r\nimport hxDaedalus.data.Mesh;\r\nimport hxDaedalus.data.Vertex;\r\nimport hxDaedalus.data.math.Geom2D;\r\nimport hxDaedalus.data.math.Point2D;\r\nimport hxDaedalus.iterators.FromFaceToInnerEdges;\r\nimport hxDaedalus.debug.Debug;\r\n\r\nimport haxe.ds.StringMap;\r\n\r\n\r\nclass AStar {\r\n    \r\n    public var radius(get, set) : Float;\r\n    var _radius : Float;\r\n    public var mesh(never, set) : Mesh;\r\n    var _mesh : Mesh;\r\n    \r\n    var closedFaces:  Map<Face,Bool>;\r\n    var sortedOpenedFaces : Array<Face>;\r\n    var openedFaces : Map<Face,Null<Bool>>;\r\n    var entryEdges : Map<Face,Edge>;\r\n    var entryX : Map<Face,Float>;\r\n    var entryY : Map<Face,Float>;\r\n    var scoreF : Map<Face,Float>;\r\n    var scoreG : Map<Face,Float>;\r\n    var scoreH : Map<Face,Float>;\r\n    var predecessor : Map<Face,Face>;\r\n    \r\n    var iterEdge : FromFaceToInnerEdges;\r\n    \r\n    var radiusSquared : Float;\r\n    var diameter : Float;\r\n    var diameterSquared : Float;\r\n    var fromFace : Face;\r\n    var toFace : Face;\r\n    var curFace : Face;\r\n    \r\n    public function new() {\r\n        iterEdge = new FromFaceToInnerEdges();\r\n    }\r\n    \r\n    public function dispose() : Void {\r\n        _mesh = null;\r\n        closedFaces = null;\r\n        sortedOpenedFaces = null;\r\n        openedFaces = null;\r\n        entryEdges = null;\r\n        entryX = null;\r\n        entryY = null;\r\n        scoreF = null;\r\n        scoreG = null;\r\n        scoreH = null;\r\n        predecessor = null;\r\n    }\r\n    \r\n    function get_radius() : Float {\r\n        return _radius;\r\n    }\r\n    \r\n    function set_radius(value : Float) : Float {\r\n        _radius = value;\r\n        radiusSquared = _radius * _radius;\r\n        diameter = _radius * 2;\r\n        diameterSquared = diameter * diameter;\r\n        return value;\r\n    }\r\n    \r\n    function set_mesh(value : Mesh) : Mesh {\r\n        _mesh = value;\r\n        return value;\r\n    }\r\n    \r\n    public function findPath(   fromX : Float,  fromY : Float\r\n                            ,   toX : Float,    toY : Float\r\n                            ,   resultListFaces : Array<Face>\r\n                            ,   resultListEdges : Array<Edge>) : Void {\r\n        //Debug.trace(\"findPath\");\r\n        closedFaces = new Map<Face,Bool>();\r\n        sortedOpenedFaces = new Array<Face>();\r\n        openedFaces = new Map<Face,Bool>();\r\n        entryEdges = new Map<Face,Edge>();\r\n        entryX = new Map<Face,Float>();\r\n        entryY = new Map<Face,Float>();\r\n        scoreF = new Map<Face,Float>();\r\n        scoreG = new Map<Face,Float>();\r\n        scoreH = new Map<Face,Float>();\r\n        predecessor = new Map<Face,Face>();\r\n        \r\n        var loc : Intersection;\r\n        var locEdge : Edge;\r\n        var locVertex : Vertex;\r\n        var distance : Float;\r\n        var p1 : Point2D;\r\n        var p2 : Point2D;\r\n        var p3 : Point2D;\r\n        //\r\n        loc = Geom2D.locatePosition(fromX, fromY, _mesh);\r\n        switch( loc ){\r\n            case EVertex( vertex ):\r\n                locVertex = vertex;\r\n                return;\r\n            case EEdge( edge ):\r\n                locEdge = edge;\r\n                if (locEdge.isConstrained) return;\r\n                fromFace = locEdge.leftFace;\r\n            case EFace( face ):\r\n                fromFace = face;\r\n            case ENull:\r\n                //\r\n        }\r\n\r\n        \r\n        loc = Geom2D.locatePosition(toX, toY, _mesh);\r\n        switch( loc ){\r\n            case EVertex( vertex ):\r\n                locVertex = vertex;\r\n                toFace = locVertex.edge.leftFace;\r\n            case EEdge( edge ):\r\n                locEdge = edge;\r\n                toFace = locEdge.leftFace;\r\n            case EFace( face ):\r\n                toFace = face;\r\n            case ENull:\r\n        }\r\n\t\t/*\r\n        fromFace.colorDebug = 0xFF0000;\r\n        toFace.colorDebug = 0xFF0000;\r\n        Debug.trace( \"from face: \" + fromFace );\r\n        Debug.trace( \"to face: \" + toFace );\r\n\t\t*/\r\n        \r\n        sortedOpenedFaces.push( fromFace );\r\n        entryEdges[ fromFace ] = null;\r\n        entryX[ fromFace ] = fromX;\r\n        entryY[ fromFace ] = fromY;\r\n        scoreG[ fromFace ] = 0;\r\n        var dist: Float = Math.sqrt((toX - fromX) * (toX - fromX) + (toY - fromY) * (toY - fromY));\r\n        scoreH[ fromFace ] = dist;\r\n        scoreF[ fromFace ] = dist;\r\n        \r\n        var innerEdge : Edge;\r\n        var neighbourFace : Face;\r\n        var f : Float;\r\n        var g : Float;\r\n        var h : Float;\r\n        var fromPoint = new Point2D();\r\n        var entryPoint = new Point2D();\r\n        var distancePoint = new Point2D();\r\n        var fillDatas : Bool;\r\n        while( true ){\r\n            // no path found\r\n            if( sortedOpenedFaces.length == 0 ){\r\n                Debug.trace(\"AStar no path found\");\r\n                curFace = null;\r\n                break;\r\n            }  // we reached the target face  \r\n            \r\n            curFace = sortedOpenedFaces.pop();\r\n            if( curFace == toFace ) break;\r\n            // we continue the search  \r\n            iterEdge.fromFace = curFace;\r\n            while( ( innerEdge = iterEdge.next() )!= null ) {\r\n                if( innerEdge.isConstrained ) continue;\r\n                neighbourFace = innerEdge.rightFace;\r\n                if( !closedFaces[ neighbourFace ] ) {\r\n                    if (curFace != fromFace && _radius > 0 && !isWalkableByRadius( entryEdges[ curFace ], curFace, innerEdge) ) {\r\n                        //                            Debug.trace(\"- NOT WALKABLE -\");\r\n                        //                            Debug.trace( \"from \", hxDaedalusEdge(__entryEdges[__curFace]).originVertex.id, hxDaedalusEdge(__entryEdges[__curFace]).destinationVertex.id );\r\n                        //                            Debug.trace( \"to\", innerEdge.originVertex.id, innerEdge.destinationVertex.id );\r\n                        //                            Debug.trace(\"----------------\");\r\n                        continue;\r\n                    }\r\n                    \r\n                    fromPoint.x = entryX[ curFace ];\r\n                    fromPoint.y = entryY[ curFace ];\r\n                    entryPoint.x = ( innerEdge.originVertex.pos.x + innerEdge.destinationVertex.pos.x ) / 2;\r\n                    entryPoint.y = ( innerEdge.originVertex.pos.y + innerEdge.destinationVertex.pos.y ) / 2;\r\n                    distancePoint.x = entryPoint.x - toX;\r\n                    distancePoint.y = entryPoint.y - toY;\r\n                    h = distancePoint.length;\r\n                    distancePoint.x = fromPoint.x - entryPoint.x;\r\n                    distancePoint.y = fromPoint.y - entryPoint.y;\r\n                    g = scoreG[ curFace ] + distancePoint.length;\r\n                    f = h + g;\r\n                    fillDatas = false;\r\n                    if (openedFaces[neighbourFace] == null || !openedFaces[neighbourFace])\r\n                    {\r\n                        sortedOpenedFaces.push( neighbourFace );\r\n                        openedFaces[ neighbourFace ] = true;\r\n                        fillDatas = true;\r\n                    }\r\n                    else if( scoreF[ neighbourFace ] > f ) \r\n                    {\r\n                        fillDatas = true;\r\n                    }\r\n                    if (fillDatas) \r\n                    {\r\n                        entryEdges[ neighbourFace ] = innerEdge;\r\n                        entryX[ neighbourFace ] = entryPoint.x;\r\n                        entryY[ neighbourFace ] = entryPoint.y;\r\n                        scoreF[ neighbourFace ] = f;\r\n                        scoreG[ neighbourFace ] = g;\r\n                        scoreH[ neighbourFace ] = h;\r\n                        predecessor[ neighbourFace ] = curFace;\r\n                    }\r\n                }\r\n            }  //  \r\n            \r\n            openedFaces[ curFace ] = false;\r\n            closedFaces[ curFace ] = true;\r\n            sortedOpenedFaces.sort( sortingFaces );\r\n        }  // if we didn't find a path  \r\n        \r\n        \r\n        \r\n        if (curFace == null) \r\n            return;  // else we build the path  ;\r\n        \r\n        \r\n        \r\n        resultListFaces.push( curFace );\r\n        //curFace.colorDebug = 0x0000FF;\r\n        while( curFace != fromFace ){\r\n            resultListEdges.unshift( entryEdges[ curFace ] );\r\n            //entryEdges[__curFace].colorDebug = 0xFFFF00;\r\n            //entryEdges[__curFace].oppositeEdge.colorDebug = 0xFFFF00;\r\n            curFace = predecessor[ curFace ];\r\n            //curFace.colorDebug = 0x0000FF;\r\n            resultListFaces.unshift( curFace );\r\n        }\r\n    }\r\n    \r\n    // faces with low distance value are at the end of the array\r\n     function sortingFaces( a: Face, b: Face ): Int {\r\n        if ( scoreF[ a ] == scoreF[ b ] ) {\r\n            return 0;\r\n        } else if ( scoreF[ a ] < scoreF[ b ] ) {\r\n            return 1;\r\n        } else { \r\n            return -1;\r\n        }\r\n    }\r\n    \r\n     function isWalkableByRadius( fromEdge : Edge, throughFace : Face, toEdge : Edge ) : Bool {\r\n        var vA : Vertex = null;  // the vertex on fromEdge not on toEdge  \r\n        var vB : Vertex = null;  // the vertex on toEdge not on fromEdge  \r\n        var vC : Vertex = null;  // the common vertex of the 2 edges (pivot)  \r\n        \r\n        // we identify the points\r\n\t\tif (fromEdge.originVertex == toEdge.originVertex)\r\n\t\t{\r\n\t\t\tvA = fromEdge.destinationVertex;\r\n\t\t\tvB = toEdge.destinationVertex;\r\n\t\t\tvC = fromEdge.originVertex;\r\n\t\t}\r\n\t\telse if (fromEdge.destinationVertex == toEdge.destinationVertex)\r\n\t\t{\r\n\t\t\tvA = fromEdge.originVertex;\r\n\t\t\tvB = toEdge.originVertex;\r\n\t\t\tvC = fromEdge.destinationVertex;\r\n\t\t}\r\n\t\telse if (fromEdge.originVertex == toEdge.destinationVertex)\r\n\t\t{\r\n\t\t\tvA = fromEdge.destinationVertex;\r\n\t\t\tvB = toEdge.originVertex;\r\n\t\t\tvC = fromEdge.originVertex;\r\n\t\t}\r\n\t\telse if (fromEdge.destinationVertex == toEdge.originVertex)\r\n\t\t{\r\n\t\t\tvA = fromEdge.originVertex;\r\n\t\t\tvB = toEdge.destinationVertex;\r\n\t\t\tvC = fromEdge.destinationVertex;\r\n\t\t}\r\n        \r\n        var dot : Float;\r\n        var result : Bool;\r\n        var distSquared : Float;\r\n        \r\n        // if we have a right or obtuse angle on CAB\r\n        dot = (vC.pos.x - vA.pos.x) * (vB.pos.x - vA.pos.x) + (vC.pos.y - vA.pos.y) * (vB.pos.y - vA.pos.y);\r\n        if( dot <= 0 ){\r\n            // we compare length of AC with radius\r\n            distSquared = (vC.pos.x - vA.pos.x) * (vC.pos.x - vA.pos.x) + (vC.pos.y - vA.pos.y) * (vC.pos.y - vA.pos.y);\r\n            if (distSquared >= diameterSquared) {\r\n                return true;\r\n            } else { \r\n                return false;\r\n            }\r\n        }  // if we have a right or obtuse angle on CBA  \r\n        \r\n        \r\n        \r\n        dot = (vC.pos.x - vB.pos.x) * (vA.pos.x - vB.pos.x) + (vC.pos.y - vB.pos.y) * (vA.pos.y - vB.pos.y);\r\n        if( dot <= 0 ) {\r\n            // we compare length of BC with radius\r\n            distSquared = (vC.pos.x - vB.pos.x) * (vC.pos.x - vB.pos.x) + (vC.pos.y - vB.pos.y) * (vC.pos.y - vB.pos.y);\r\n            if (distSquared >= diameterSquared) {\r\n                return true;\r\n            } else { \r\n                return false;\r\n            }\r\n        }  // we identify the adjacent edge (facing pivot vertex)  \r\n        \r\n        \r\n        \r\n        var adjEdge : Edge;\r\n        if( throughFace.edge != fromEdge && throughFace.edge.oppositeEdge != fromEdge && throughFace.edge != toEdge && throughFace.edge.oppositeEdge != toEdge) {\r\n            adjEdge = throughFace.edge;\r\n        } else if( throughFace.edge.nextLeftEdge != fromEdge && throughFace.edge.nextLeftEdge.oppositeEdge != fromEdge && throughFace.edge.nextLeftEdge != toEdge && throughFace.edge.nextLeftEdge.oppositeEdge != toEdge ){\r\n            adjEdge = throughFace.edge.nextLeftEdge;\r\n        } else { \r\n            adjEdge = throughFace.edge.prevLeftEdge;\r\n        }\r\n        // if the adjacent edge is constrained, we check the distance of orthognaly projected\r\n        if( adjEdge.isConstrained ){\r\n            var proj = new Point2D( vC.pos.x, vC.pos.y );\r\n            Geom2D.projectOrthogonaly( proj, adjEdge );\r\n            distSquared = (proj.x - vC.pos.x) * (proj.x - vC.pos.x) + (proj.y - vC.pos.y) * (proj.y - vC.pos.y);\r\n            if( distSquared >= diameterSquared ) {\r\n                return true;\r\n            } else { \r\n                return false;\r\n            }\r\n        }\r\n        // if the adjacent is not constrained\r\n        else \r\n        {\r\n            var distSquaredA : Float = (vC.pos.x - vA.pos.x) * (vC.pos.x - vA.pos.x) + (vC.pos.y - vA.pos.y) * (vC.pos.y - vA.pos.y);\r\n            var distSquaredB : Float = (vC.pos.x - vB.pos.x) * (vC.pos.x - vB.pos.x) + (vC.pos.y - vB.pos.y) * (vC.pos.y - vB.pos.y);\r\n            if( distSquaredA < diameterSquared || distSquaredB < diameterSquared ){\r\n                return false;\r\n            } else {\r\n                var vFaceToCheck = new Array<Face>();\r\n                var vFaceIsFromEdge = new Array<Edge>();\r\n                var facesDone = new Map<Face,Bool>();\r\n                vFaceIsFromEdge.push(adjEdge);\r\n                if( adjEdge.leftFace == throughFace ){\r\n                    vFaceToCheck.push(adjEdge.rightFace);\r\n                    facesDone[adjEdge.rightFace] = true;\r\n                } else {\r\n                    vFaceToCheck.push(adjEdge.leftFace);\r\n                    facesDone[ adjEdge.leftFace ] = true;\r\n                }\r\n                \r\n                var currFace : Face;\r\n                var faceFromEdge : Edge;\r\n                var currEdgeA : Edge;\r\n                var nextFaceA : Face;\r\n                var currEdgeB : Edge;\r\n                var nextFaceB : Face;\r\n                while( vFaceToCheck.length > 0 ){\r\n                    currFace = vFaceToCheck.shift();\r\n                    faceFromEdge = vFaceIsFromEdge.shift();\r\n                    \r\n                    \r\n                    if( currFace.edge == faceFromEdge || currFace.edge == faceFromEdge.oppositeEdge ){\r\n                        // we identify the 2 edges to evaluate\r\n                        currEdgeA = currFace.edge.nextLeftEdge;\r\n                        currEdgeB = currFace.edge.nextLeftEdge.nextLeftEdge;\r\n                    } else if( currFace.edge.nextLeftEdge == faceFromEdge || currFace.edge.nextLeftEdge == faceFromEdge.oppositeEdge ){   \r\n                        // we identify the faces related to the 2 edges\r\n                        currEdgeA = currFace.edge;\r\n                        currEdgeB = currFace.edge.nextLeftEdge.nextLeftEdge;\r\n                    } else {\r\n                        currEdgeA = currFace.edge;\r\n                        currEdgeB = currFace.edge.nextLeftEdge;\r\n                    }\r\n                    \r\n                    if( currEdgeA.leftFace == currFace ){ \r\n                        nextFaceA = currEdgeA.rightFace;\r\n                    } else { \r\n                        nextFaceA = currEdgeA.leftFace;\r\n                    }\r\n                    if( currEdgeB.leftFace == currFace ){\r\n                        nextFaceB = currEdgeB.rightFace;\r\n                    } else { \r\n                        nextFaceB = currEdgeB.leftFace;\r\n                    }\r\n                    // we check if the next face is not already in pipe\r\n                    // and if the edge A is close to pivot vertex\r\n                    if( !facesDone[ nextFaceA ] && Geom2D.distanceSquaredVertexToEdge( vC, currEdgeA ) < diameterSquared ){\r\n                        // if the edge is constrained\r\n                        if( currEdgeA.isConstrained ){\r\n                            // so it is not walkable\r\n                            return false;\r\n                        } else {\r\n                            // if the edge is not constrained, we continue the search\r\n                            vFaceToCheck.push(nextFaceA);\r\n                            vFaceIsFromEdge.push(currEdgeA);\r\n                            facesDone[ nextFaceA ] = true;\r\n                        }\r\n                    }  // and if the edge B is close to pivot vertex    // we check if the next face is not already in pipe  \r\n                    \r\n                    if( !facesDone[ nextFaceB ] && Geom2D.distanceSquaredVertexToEdge(vC, currEdgeB) < diameterSquared ){\r\n                        // if the edge is constrained\r\n                        if( currEdgeB.isConstrained ){\r\n                            // so it is not walkable\r\n                            return false;\r\n                        } else {\r\n                            // if the edge is not constrained, we continue the search\r\n                            vFaceToCheck.push( nextFaceB );\r\n                            vFaceIsFromEdge.push( currEdgeB );\r\n                            facesDone[ nextFaceB ] = true;\r\n                        }\r\n                    }\r\n                }  // if we didn't previously meet a constrained edge  \r\n                \r\n                return true;\r\n            }\r\n        }\r\n        \r\n        return true;\r\n    }\r\n}\r\n","package hxDaedalus.ai;\r\n\r\n\r\nimport hxDaedalus.data.Object;\r\n\r\nclass EntityAI\r\n{\r\n    public var approximateObject(get, never) : Object;\r\n    public var dirNormY : Float;\r\n    public var dirNormX : Float;\r\n    public var y : Float;\r\n    public var x : Float;\r\n    public var radius(get, set) : Float;\r\n    public var radiusSquared(get, never) : Float;\r\n\r\n    \r\n     var _radius : Float;\r\n     var _radiusSquared : Float;\r\n     var _x : Float;\r\n     var _y : Float;\r\n     var _dirNormX : Float;\r\n     var _dirNormY : Float;\r\n     var _approximateObject : Object;\r\n     static inline var NUM_SEGMENTS : Int = 6;\r\n    \r\n    public function new()\r\n    {\r\n        _radius = 10;\r\n        x = y = 0;\r\n        dirNormX = 1;\r\n        dirNormY = 0;\r\n    }\r\n    \r\n    public function buildApproximation() : Void {\r\n        _approximateObject = new Object();\r\n        _approximateObject.matrix.translate(x, y);\r\n        var coordinates  = new Array<Float>();\r\n        _approximateObject.coordinates = coordinates;\r\n        \r\n        if (_radius == 0) return;\r\n        \r\n        for (i in 0...NUM_SEGMENTS){\r\n            coordinates.push(_radius * Math.cos(2 * Math.PI * i / NUM_SEGMENTS));\r\n            coordinates.push(_radius * Math.sin(2 * Math.PI * i / NUM_SEGMENTS));\r\n            coordinates.push(_radius * Math.cos(2 * Math.PI * (i + 1) / NUM_SEGMENTS));\r\n            coordinates.push(_radius * Math.sin(2 * Math.PI * (i + 1) / NUM_SEGMENTS));\r\n        }\r\n    }\r\n    \r\n     function get_approximateObject() : Object\r\n    {\r\n        _approximateObject.matrix.identity();\r\n        _approximateObject.matrix.translate(x, y);\r\n        return _approximateObject;\r\n    }\r\n    \r\n     function get_radius() : Float\r\n    {\r\n        return _radius;\r\n    }\r\n    \r\n     function get_radiusSquared() : Float\r\n    {\r\n        return _radiusSquared;\r\n    }\r\n    \r\n     function set_radius(value : Float) : Float\r\n    {\r\n        _radius = value;\r\n        _radiusSquared = _radius * _radius;\r\n        return value;\r\n    }\r\n}\r\n","package hxDaedalus.ai;\r\n\r\n\r\nimport hxDaedalus.data.Constants;\r\nimport hxDaedalus.data.Edge;\r\nimport hxDaedalus.data.Face;\r\nimport hxDaedalus.data.math.Geom2D;\r\nimport hxDaedalus.data.Vertex;\r\nimport hxDaedalus.data.math.Point2D;\r\nimport hxDaedalus.debug.Debug;\r\n\r\nclass Funnel\r\n{\r\n    public var radius(get, set) : Float;\r\n\r\n    \r\n     var _radius : Float = 0;\r\n     var _radiusSquared : Float = 0;\r\n     var _numSamplesCircle : Int = 16;\r\n     var _sampleCircle : Array<Point2D>;\r\n     var _sampleCircleDistanceSquared : Float;\r\n    #if js\r\n    \r\n    #else\r\n     //public var debugSurface : Sprite;\r\n    #end\r\n    \r\n    public function new()\r\n    {\r\n        _poolPoints = new Array<Point2D>();\r\n        for (i in 0..._poolPointsSize){\r\n            _poolPoints.push(new Point2D());\r\n        }\r\n    }\r\n    \r\n    public function dispose() : Void\r\n    {\r\n        _sampleCircle = null;\r\n    }\r\n    \r\n    \r\n     var _poolPointsSize : Int = 3000;\r\n     var _poolPoints : Array<Point2D>;\r\n     var _currPoolPointsIndex : Int = 0;\r\n     var __point : Point2D;\r\n    public function getPoint(x : Float = 0, y : Float = 0) : Point2D\r\n    {\r\n        __point = _poolPoints[_currPoolPointsIndex];\r\n        __point.setXY(x, y);\r\n        \r\n        _currPoolPointsIndex++;\r\n        if (_currPoolPointsIndex == _poolPointsSize) \r\n        {\r\n            _poolPoints.push(new Point2D());\r\n            _poolPointsSize++;\r\n        }\r\n        \r\n        return __point;\r\n    }\r\n    public function getCopyPoint(pointToCopy : Point2D) : Point2D\r\n    {\r\n        return getPoint(pointToCopy.x, pointToCopy.y);\r\n    }\r\n    \r\n     function get_radius() : Float\r\n    {\r\n        return _radius;\r\n    }\r\n    \r\n     function set_radius(value : Float) : Float\r\n    {\r\n        _radius = Math.max( 0, value );\r\n        _radiusSquared = _radius * _radius;\r\n        _sampleCircle = new Array<Point2D>();\r\n        if( radius == 0 ) return 0;\r\n        for( i in 0..._numSamplesCircle ){\r\n            _sampleCircle.push( new Point2D(    _radius * Math.cos( -2 * Math.PI * i / _numSamplesCircle )\r\n                                            ,   _radius * Math.sin( -2 * Math.PI * i / _numSamplesCircle )\r\n                                            )\r\n                            );\r\n        }\r\n        _sampleCircleDistanceSquared = (_sampleCircle[0].x - _sampleCircle[1].x) * (_sampleCircle[0].x - _sampleCircle[1].x) + (_sampleCircle[0].y - _sampleCircle[1].y) * (_sampleCircle[0].y - _sampleCircle[1].y);\r\n        return _radius;\r\n    }\r\n    \r\n    public function findPath( fromX: Float, fromY: Float\r\n                            , toX : Float, toY : Float\r\n                            , listFaces : Array<Face>\r\n                            , listEdges : Array<Edge>\r\n                            , resultPath : Array<Float>) : Void {\r\n        _currPoolPointsIndex = 0;\r\n        \r\n        // we check the start and goal\r\n        if (_radius > 0) \r\n        {\r\n            var checkFace = listFaces[0];\r\n            var distanceSquared : Float;\r\n            var distance : Float;\r\n            var p1 : Point2D;\r\n            var p2 : Point2D;\r\n            var p3 : Point2D;\r\n            p1 = checkFace.edge.originVertex.pos;\r\n            p2 = checkFace.edge.destinationVertex.pos;\r\n            p3 = checkFace.edge.nextLeftEdge.destinationVertex.pos;\r\n            distanceSquared = (p1.x - fromX) * (p1.x - fromX) + (p1.y - fromY) * (p1.y - fromY);\r\n            if (distanceSquared <= _radiusSquared) \r\n            {\r\n                distance = Math.sqrt(distanceSquared);\r\n                fromX = _radius * 1.01 * ((fromX - p1.x) / distance) + p1.x;\r\n                fromY = _radius * 1.01 * ((fromY - p1.y) / distance) + p1.y;\r\n            }\r\n            else \r\n            {\r\n                distanceSquared = (p2.x - fromX) * (p2.x - fromX) + (p2.y - fromY) * (p2.y - fromY);\r\n                if (distanceSquared <= _radiusSquared) \r\n                {\r\n                    distance = Math.sqrt(distanceSquared);\r\n                    fromX = _radius * 1.01 * ((fromX - p2.x) / distance) + p2.x;\r\n                    fromY = _radius * 1.01 * ((fromY - p2.y) / distance) + p2.y;\r\n                }\r\n                else \r\n                {\r\n                    distanceSquared = (p3.x - fromX) * (p3.x - fromX) + (p3.y - fromY) * (p3.y - fromY);\r\n                    if (distanceSquared <= _radiusSquared) \r\n                    {\r\n                        distance = Math.sqrt(distanceSquared);\r\n                        fromX = _radius * 1.01 * ((fromX - p3.x) / distance) + p3.x;\r\n                        fromY = _radius * 1.01 * ((fromY - p3.y) / distance) + p3.y;\r\n                    }\r\n                }\r\n            }  //  \r\n            \r\n            checkFace = listFaces[listFaces.length - 1];\r\n            p1 = checkFace.edge.originVertex.pos;\r\n            p2 = checkFace.edge.destinationVertex.pos;\r\n            p3 = checkFace.edge.nextLeftEdge.destinationVertex.pos;\r\n            distanceSquared = (p1.x - toX) * (p1.x - toX) + (p1.y - toY) * (p1.y - toY);\r\n            if (distanceSquared <= _radiusSquared) \r\n            {\r\n                distance = Math.sqrt(distanceSquared);\r\n                toX = _radius * 1.01 * ((toX - p1.x) / distance) + p1.x;\r\n                toY = _radius * 1.01 * ((toY - p1.y) / distance) + p1.y;\r\n            }\r\n            else \r\n            {\r\n                distanceSquared = (p2.x - toX) * (p2.x - toX) + (p2.y - toY) * (p2.y - toY);\r\n                if (distanceSquared <= _radiusSquared) \r\n                {\r\n                    distance = Math.sqrt(distanceSquared);\r\n                    toX = _radius * 1.01 * ((toX - p2.x) / distance) + p2.x;\r\n                    toY = _radius * 1.01 * ((toY - p2.y) / distance) + p2.y;\r\n                }\r\n                else \r\n                {\r\n                    distanceSquared = (p3.x - toX) * (p3.x - toX) + (p3.y - toY) * (p3.y - toY);\r\n                    if (distanceSquared <= _radiusSquared) \r\n                    {\r\n                        distance = Math.sqrt(distanceSquared);\r\n                        toX = _radius * 1.01 * ((toX - p3.x) / distance) + p3.x;\r\n                        toY = _radius * 1.01 * ((toY - p3.y) / distance) + p3.y;\r\n                    }\r\n                }\r\n            }\r\n        }  // we build starting and ending points  \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        var startPoint : Point2D;\r\n        var endPoint :Point2D;\r\n        startPoint = new Point2D(fromX, fromY);\r\n        endPoint = new Point2D(toX, toY);\r\n        \r\n        if (listFaces.length == 1) \r\n        {\r\n            resultPath.push(startPoint.x);\r\n            resultPath.push(startPoint.y);\r\n            resultPath.push(endPoint.x);\r\n            resultPath.push(endPoint.y);\r\n            return;\r\n        }  // useful  \r\n        \r\n        \r\n        \r\n        var i : Int;\r\n        var j : Int;\r\n        var k : Int;\r\n        var currEdge : Edge = null;\r\n        var currVertex : Vertex = null;\r\n        var direction : Int;\r\n        \r\n        // first we skip the first face and first edge if the starting point lies on the first interior edge:\r\n        \r\n        \r\n        // switch on intersection \r\n\t\t//TODO: check if this needs ENull (/not EEdge) checks\r\n        switch( Geom2D.isInFace(fromX, fromY, listFaces[0]) )\r\n        {\r\n            case EEdge( edge ):\r\n                if( listEdges[0] == edge )\r\n                {\r\n                    listEdges.shift();\r\n                    listFaces.shift();\r\n                }\r\n            case _:\r\n                // \r\n        }\r\n        // our funnels, inited with starting point  \r\n        \r\n        \r\n        \r\n        var funnelLeft = new Array<Point2D>();\r\n        var funnelRight = new Array<Point2D>();\r\n        funnelLeft.push(startPoint);\r\n        funnelRight.push(startPoint);\r\n        \r\n        // useful to keep track of done vertices and compare the sides\r\n        var verticesDoneSide = new Map<Vertex,Int>();\r\n        \r\n        // we extract the vertices positions and sides from the edges list\r\n        var pointsList = new Array<Point2D>();\r\n        var pointSides = new Map<Point2D,Int>();\r\n        // we keep the successor relation in a dictionnary\r\n        var pointSuccessor = new Map<Point2D,Point2D>();\r\n        //\r\n        pointSides[ startPoint ] = 0;\r\n        // we begin with the vertices in first edge\r\n        currEdge = listEdges[0];\r\n        var relativPos : Int = Geom2D.getRelativePosition2(fromX, fromY, currEdge);\r\n        var prevPoint : Point2D;\r\n        var newPointA : Point2D;\r\n        var newPointB : Point2D;\r\n        newPointA = getCopyPoint( currEdge.destinationVertex.pos );\r\n        newPointB = getCopyPoint( currEdge.originVertex.pos );\r\n        \r\n        pointsList.push(newPointA);\r\n        pointsList.push(newPointB);\r\n        pointSuccessor[ startPoint ] = newPointA;\r\n        pointSuccessor[ newPointA ] = newPointB;\r\n        prevPoint = newPointB;\r\n        if( relativPos == 1 ){\r\n            pointSides[ newPointA ] = 1;\r\n            pointSides[ newPointB ] = -1;\r\n            verticesDoneSide[ currEdge.destinationVertex ] = 1;\r\n            verticesDoneSide[ currEdge.originVertex ] = -1;\r\n        }else if (relativPos == -1) {// then we iterate through the edges\r\n            pointSides[ newPointA ] = -1;\r\n            pointSides[ newPointB ] = 1;\r\n            verticesDoneSide[ currEdge.destinationVertex ] = -1;\r\n            verticesDoneSide[ currEdge.originVertex ] = 1;\r\n        }\r\n        \r\n        \r\n        \r\n        var fromVertex = listEdges[ 0 ].originVertex;\r\n        var fromFromVertex = listEdges[ 0 ].destinationVertex;\r\n        for (i in 1...listEdges.length ){\r\n            // we identify the current vertex and his origin vertex\r\n            currEdge = listEdges[ i ];\r\n            if (currEdge.originVertex == fromVertex) \r\n            {\r\n                currVertex = currEdge.destinationVertex;\r\n            }\r\n            else if (currEdge.destinationVertex == fromVertex) \r\n            {\r\n                currVertex = currEdge.originVertex;\r\n            }\r\n            else if (currEdge.originVertex == fromFromVertex) \r\n            {\r\n                currVertex = currEdge.destinationVertex;\r\n                fromVertex = fromFromVertex;\r\n            }\r\n            else if (currEdge.destinationVertex == fromFromVertex) \r\n            {\r\n                currVertex = currEdge.originVertex;\r\n                fromVertex = fromFromVertex;\r\n            }\r\n            else \r\n            {\r\n                Debug.trace(\"IMPOSSIBLE TO IDENTIFY THE VERTEX !!!\");\r\n            }\r\n            \r\n            newPointA = getCopyPoint(currVertex.pos);\r\n            pointsList.push(newPointA);\r\n            direction = - verticesDoneSide[ fromVertex ];\r\n            pointSides[ newPointA ] = direction;\r\n            pointSuccessor[ prevPoint ] = newPointA;\r\n            verticesDoneSide[ currVertex ] = direction;\r\n            prevPoint = newPointA;\r\n            fromFromVertex = fromVertex;\r\n            fromVertex = currVertex;\r\n        }  // we then we add the end point  \r\n        \r\n        pointSuccessor[ prevPoint ] = endPoint;\r\n        pointSides[ endPoint ] = 0;\r\n        \r\n        /*\r\n        debugSurface.graphics.clear();\r\n        debugSurface.graphics.lineStyle(1, 0x0000FF);\r\n        var ppp1:Point = startPoint;\r\n        var ppp2:Point = pointSuccessor[ppp1];\r\n        while (ppp2)\r\n        {\r\n        debugSurface.graphics.moveTo(ppp1.x, ppp1.y+2);\r\n        debugSurface.graphics.lineTo(ppp2.x, ppp2.y+2);\r\n        debugSurface.graphics.drawCircle(ppp2.x, ppp2.y, 3);\r\n        ppp1 = ppp2;\r\n        ppp2 = pointSuccessor[ppp2];\r\n        }\r\n        \r\n        debugSurface.graphics.lineStyle(1, 0x00FF00);\r\n        for (i=1 ; i<pointsList.length ; i++)\r\n        {\r\n        debugSurface.graphics.moveTo(pointsList[i-1].x+2, pointsList[i-1].y);\r\n        debugSurface.graphics.lineTo(pointsList[i].x+2, pointsList[i].y);\r\n        }\r\n        */\r\n        \r\n        // we will keep the points and funnel sides of the optimized path\r\n        var pathPoints = new Array<Point2D>();\r\n        var pathSides = new Map<Point2D,Int>();\r\n        pathPoints.push( startPoint );\r\n        pathSides[ startPoint ] = 0;\r\n        \r\n        // now we process the points by order\r\n        var currPos : Point2D;\r\n        for (i in 0...pointsList.length){\r\n            currPos = pointsList[i];\r\n            \r\n            // we identify the current vertex funnel's position by the position of his origin vertex\r\n            if ( pointSides[ currPos ] == -1 ) {\r\n                // current vertex is at right\r\n                //Debug.trace(\"current vertex is at right\");\r\n                j = funnelLeft.length - 2;\r\n                while (j >= 0){\r\n                    direction = Geom2D.getDirection(funnelLeft[j].x, funnelLeft[j].y, funnelLeft[j + 1].x, funnelLeft[j + 1].y, currPos.x, currPos.y);\r\n                    if (direction != -1) \r\n                    {\r\n                        //Debug.trace(\"funnels are crossing\");\r\n                        \r\n                        funnelLeft.shift();\r\n                        for (k in 0...j){\r\n                            pathPoints.push(funnelLeft[0]);\r\n                            pathSides[ funnelLeft[0] ] = 1;\r\n                            funnelLeft.shift();\r\n                        }\r\n                        pathPoints.push(funnelLeft[0]);\r\n                        pathSides[ funnelLeft[0]] = 1;\r\n                        funnelRight.splice(0, funnelRight.length);\r\n                        funnelRight.push(funnelLeft[0] );\r\n                        funnelRight.push( currPos );\r\n                        break;\r\n                    }\r\n                    j--;\r\n                }\r\n                \r\n                funnelRight.push(currPos);\r\n                j = funnelRight.length - 3;\r\n                while (j >= 0){\r\n                    direction = Geom2D.getDirection(funnelRight[j].x, funnelRight[j].y, funnelRight[j + 1].x, funnelRight[j + 1].y, currPos.x, currPos.y);\r\n                    if (direction == -1) \r\n                        break\r\n                    else \r\n                    {\r\n                        funnelRight.splice(j + 1, 1);\r\n                    }\r\n                    j--;\r\n                }\r\n            }\r\n            else \r\n            {\r\n                // current vertex is at left\r\n                j = funnelRight.length - 2;\r\n                while (j >= 0){\r\n                    direction = Geom2D.getDirection(funnelRight[j].x, funnelRight[j].y, funnelRight[j + 1].x, funnelRight[j + 1].y, currPos.x, currPos.y);\r\n                    if (direction != 1) \r\n                    {\r\n                        funnelRight.shift();\r\n                        for (k in 0...j){\r\n                            pathPoints.push(funnelRight[0]);\r\n                            pathSides[funnelRight[0] ] = -1;\r\n                            funnelRight.shift();\r\n                        }\r\n                        pathPoints.push(funnelRight[0]);\r\n                        pathSides[funnelRight[0] ]= -1;\r\n                        funnelLeft.splice(0, funnelLeft.length);\r\n                        funnelLeft.push(funnelRight[0] );\r\n                        funnelLeft.push( currPos );\r\n                        break;\r\n                    }\r\n                    j--;\r\n                }\r\n                \r\n                funnelLeft.push(currPos);\r\n                j = funnelLeft.length - 3;\r\n                while (j >= 0){\r\n                    direction = Geom2D.getDirection(funnelLeft[j].x, funnelLeft[j].y, funnelLeft[j + 1].x, funnelLeft[j + 1].y, currPos.x, currPos.y);\r\n                    if (direction == 1) \r\n                        break\r\n                    else \r\n                    {\r\n                        funnelLeft.splice(j + 1, 1);\r\n                    }\r\n                    j--;\r\n                }\r\n            }\r\n        }  // check if the goal is blocked by one funnel's right vertex  \r\n        \r\n        \r\n        \r\n        var blocked = false;\r\n        //Debug.trace(\"check if the goal is blocked by one funnel right vertex\");\r\n        j = funnelRight.length - 2;\r\n        while (j >= 0){\r\n            direction = Geom2D.getDirection(funnelRight[j].x, funnelRight[j].y, funnelRight[j + 1].x, funnelRight[j + 1].y, toX, toY);\r\n            //Debug.trace(\"dir\" + funnelRight[j].x + \",\" + funnelRight[j].y + \" \" + funnelRight[j+1].x + \",\" + funnelRight[j+1].y + \" \" + toX + \",\" + toY);\r\n            if (direction != 1) \r\n            {\r\n                //Debug.trace(\"goal access right blocked\");\r\n                // access blocked\r\n                funnelRight.shift();\r\n                for (k in 0...j + 1){\r\n                    pathPoints.push(funnelRight[0]);\r\n                    pathSides[ funnelRight[0] ] = -1;\r\n                    funnelRight.shift();\r\n                }\r\n                pathPoints.push(endPoint);\r\n                pathSides[ endPoint ] = 0;\r\n                blocked = true;\r\n                break;\r\n            }\r\n            j--;\r\n        }\r\n        \r\n        if (!blocked) \r\n        {\r\n            // check if the goal is blocked by one funnel's left vertex\r\n            //Debug.trace(\"check if the goal is blocked by one funnel left vertex\");\r\n            j = funnelLeft.length - 2;\r\n            while (j >= 0){\r\n                direction = Geom2D.getDirection(funnelLeft[j].x, funnelLeft[j].y, funnelLeft[j + 1].x, funnelLeft[j + 1].y, toX, toY);\r\n                //Debug.trace(\"dir \" + funnelLeft[j].x + \",\" + funnelLeft[j].y + \" \" + funnelLeft[j+1].x + \",\" + funnelLeft[j+1].y + \" \" + toX + \",\" + toY);\r\n                if (direction != -1) \r\n                {\r\n                    //Debug.trace(\"goal access left blocked\");\r\n                    // access blocked\r\n                    funnelLeft.shift();\r\n                    for (k in 0...j + 1){\r\n                        pathPoints.push(funnelLeft[0]);\r\n                        pathSides[ funnelLeft[0] ] = 1;\r\n                        funnelLeft.shift();\r\n                    }\r\n                    \r\n                    pathPoints.push(endPoint);\r\n                    pathSides[ endPoint ] = 0;\r\n                    blocked = true;\r\n                    break;\r\n                }\r\n                j--;\r\n            }\r\n        }  // if not blocked, we consider the direct path  \r\n        \r\n        \r\n        \r\n        if (!blocked) \r\n        {\r\n            pathPoints.push(endPoint);\r\n            pathSides[ endPoint ] = 0;\r\n            blocked = true;\r\n        }  // if radius is non zero  \r\n        \r\n        \r\n        var adjustedPoints= new Array<Point2D>();\r\n        if (radius > 0) \r\n        {\r\n            \r\n            var newPath : Array<Point2D> = new Array<Point2D>();\r\n            \r\n            if (pathPoints.length == 2) \r\n            {\r\n                adjustWithTangents(pathPoints[0], false, pathPoints[1], false, pointSides, pointSuccessor, newPath, adjustedPoints);\r\n            }\r\n            else if (pathPoints.length > 2) \r\n            {\r\n                // tangent from start point to 2nd point\r\n                adjustWithTangents(pathPoints[0], false, pathPoints[1], true, pointSides, pointSuccessor, newPath, adjustedPoints);\r\n                \r\n                // tangents for intermediate points\r\n                if (pathPoints.length > 3) \r\n                {\r\n                    for (i in 1...pathPoints.length - 3 + 1){\r\n                        adjustWithTangents(pathPoints[i], true, pathPoints[i + 1], true, pointSides, pointSuccessor, newPath, adjustedPoints);\r\n                    }\r\n                }  // tangent from last-1 point to end point  \r\n                \r\n                \r\n                \r\n                var pathLength : Int = pathPoints.length;\r\n                adjustWithTangents(pathPoints[pathLength - 2], true, pathPoints[pathLength - 1], false, pointSides, pointSuccessor, newPath, adjustedPoints);\r\n            }\r\n            \r\n            newPath.push(endPoint);\r\n            \r\n            // adjusted path can have useless tangents, we check it\r\n            checkAdjustedPath(newPath, adjustedPoints, pointSides);\r\n            \r\n            var smoothPoints = new Array<Point2D>();\r\n            i = newPath.length - 2;\r\n            while (i >= 1){\r\n                smoothAngle(adjustedPoints[i * 2 - 1], newPath[i], adjustedPoints[i * 2], pointSides[ newPath[i] ], smoothPoints);\r\n                while (smoothPoints.length != 0 )\r\n                {\r\n                    var temp = i * 2;\r\n                    adjustedPoints.splice(temp, 0 );\r\n                    adjustedPoints.insert( temp, smoothPoints.pop());\r\n                }\r\n                i--;\r\n            }\r\n        }\r\n        else \r\n        {\r\n            adjustedPoints = pathPoints;\r\n        }  // extract coordinates  \r\n        \r\n        \r\n        \r\n        for (i in 0...adjustedPoints.length){\r\n            resultPath.push(adjustedPoints[i].x);\r\n            resultPath.push(adjustedPoints[i].y);\r\n        }\r\n    }\r\n    \r\n     function adjustWithTangents(p1 : Point2D, applyRadiusToP1 : Bool, p2 : Point2D, applyRadiusToP2 : Bool, pointSides : Map<Point2D,Int>, pointSuccessor : Map<Point2D,Point2D>, newPath : Array<Point2D>, adjustedPoints : Array<Point2D>) : Void\r\n    {\r\n        // we find the tangent T between the points pathPoints[i] - pathPoints[i+1]\r\n        // then we check the unused intermediate points between pathPoints[i] and pathPoints[i+1]\r\n        // if a point P is too close from the segment, we replace T by 2 tangents T1, T2, between the points pathPoints[i] P and P - pathPoints[i+1]\r\n        \r\n        //Debug.trace(\"adjustWithTangents\");\r\n        \r\n        var tangentsResult : Array<Float> = new Array<Float>();\r\n        \r\n        var side1 : Int = pointSides[ p1 ];\r\n        var side2 : Int = pointSides[ p2 ];\r\n        \r\n        var pTangent1 : Point2D = null;\r\n        var pTangent2 : Point2D = null;\r\n        \r\n        // if no radius application\r\n        if (!applyRadiusToP1 && !applyRadiusToP2) \r\n        {\r\n            //Debug.trace(\"no radius applied\");\r\n            pTangent1 = p1;\r\n            pTangent2 = p2;\r\n        }\r\n        // we apply radius to p2 only\r\n        else if (!applyRadiusToP1) \r\n        {\r\n            //Debug.trace(\"! applyRadiusToP1\");\r\n            if (Geom2D.tangentsPointToCircle(p1.x, p1.y, p2.x, p2.y, _radius, tangentsResult)) {\r\n\t\t\t\t// p2 lies on the left funnel\r\n\t\t\t\tif (side2 == 1) \r\n\t\t\t\t{\r\n\t\t\t\t\tpTangent1 = p1;\r\n\t\t\t\t\tpTangent2 = getPoint(tangentsResult[2], tangentsResult[3]);\r\n\t\t\t\t}\r\n\t\t\t\t// p2 lies on the right funnel\r\n\t\t\t\telse \r\n\t\t\t\t{\r\n\t\t\t\t\tpTangent1 = p1;\r\n\t\t\t\t\tpTangent2 = getPoint(tangentsResult[0], tangentsResult[1]);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tDebug.trace(\"NO TANGENT\");\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n        }\r\n        // we apply radius to p1 only\r\n        else if (!applyRadiusToP2) \r\n        {\r\n            //Debug.trace(\"! applyRadiusToP2\");\r\n            if (Geom2D.tangentsPointToCircle(p2.x, p2.y, p1.x, p1.y, _radius, tangentsResult)) {\r\n\t\t\t\tif (tangentsResult.length > 0)\r\n\t\t\t\t{\r\n\t\t\t\t\t// p1 lies on the left funnel\r\n\t\t\t\t\tif (side1 == 1) \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tpTangent1 = getPoint(tangentsResult[0], tangentsResult[1]);\r\n\t\t\t\t\t\tpTangent2 = p2;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// p1 lies on the right funnel\r\n\t\t\t\t\telse \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tpTangent1 = getPoint(tangentsResult[2], tangentsResult[3]);\r\n\t\t\t\t\t\tpTangent2 = p2;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tDebug.trace(\"NO TANGENT\");\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n        }\r\n        // we apply radius to both points\r\n        else \r\n        {\r\n            //Debug.trace(\"we apply radius to both points\");\r\n            // both points lie on left funnel\r\n            if (side1 == 1 && side2 == 1) \r\n            {\r\n                Geom2D.tangentsParalCircleToCircle(_radius, p1.x, p1.y, p2.x, p2.y, tangentsResult);\r\n                // we keep the points of the right tangent\r\n                pTangent1 = getPoint(tangentsResult[2], tangentsResult[3]);\r\n                pTangent2 = getPoint(tangentsResult[4], tangentsResult[5]);\r\n            }\r\n            // both points lie on right funnel\r\n            else if (side1 == -1 && side2 == -1) \r\n            {\r\n                Geom2D.tangentsParalCircleToCircle(_radius, p1.x, p1.y, p2.x, p2.y, tangentsResult);\r\n                // we keep the points of the left tangent\r\n                pTangent1 = getPoint(tangentsResult[0], tangentsResult[1]);\r\n                pTangent2 = getPoint(tangentsResult[6], tangentsResult[7]);\r\n            }\r\n            // 1st point lies on left funnel, 2nd on right funnel\r\n            else if (side1 == 1 && side2 == -1) \r\n            {\r\n                if (Geom2D.tangentsCrossCircleToCircle(_radius, p1.x, p1.y, p2.x, p2.y, tangentsResult)) \r\n                {\r\n                    // we keep the points of the right-left tangent\r\n                    pTangent1 = getPoint(tangentsResult[2], tangentsResult[3]);\r\n                    pTangent2 = getPoint(tangentsResult[6], tangentsResult[7]);\r\n                }\r\n                else \r\n                {\r\n                    // NO TANGENT BECAUSE POINTS TOO CLOSE\r\n                    // A* MUST CHECK THAT !\r\n                    Debug.trace(\"NO TANGENT, points are too close for radius\");\r\n                    return;\r\n                }\r\n            }\r\n            // 1st point lies on right funnel, 2nd on left funnel\r\n            else \r\n            {\r\n                if (Geom2D.tangentsCrossCircleToCircle(_radius, p1.x, p1.y, p2.x, p2.y, tangentsResult)) \r\n                {\r\n                    // we keep the points of the left-right tangent\r\n                    pTangent1 = getPoint(tangentsResult[0], tangentsResult[1]);\r\n                    pTangent2 = getPoint(tangentsResult[4], tangentsResult[5]);\r\n                }\r\n                else \r\n                {\r\n                    // NO TANGENT BECAUSE POINTS TOO CLOSE\r\n                    // A* MUST CHECK THAT !\r\n                    Debug.trace(\"NO TANGENT, points are too close for radius\");\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        \r\n        var successor = pointSuccessor[ p1 ];\r\n        var distance : Float;\r\n        while (successor != p2)\r\n        {\r\n            distance = Geom2D.distanceSquaredPointToSegment(successor.x, successor.y, pTangent1.x, pTangent1.y, pTangent2.x, pTangent2.y);\r\n            if (distance < _radiusSquared) \r\n            {\r\n                adjustWithTangents(p1, applyRadiusToP1, successor, true, pointSides, pointSuccessor, newPath, adjustedPoints);\r\n                adjustWithTangents(successor, true, p2, applyRadiusToP2, pointSides, pointSuccessor, newPath, adjustedPoints);\r\n                return;\r\n            }\r\n            else \r\n            {\r\n                successor = pointSuccessor[successor];\r\n            }\r\n        }  /*if ( adjustedPoints.length > 0 )\r\n        {\r\n        var distanceSquared:Number;\r\n        var lastPoint:Point = adjustedPoints[adjustedPoints.length-1];\r\n        distanceSquared = (lastPoint.x - pTangent1.x)*(lastPoint.x - pTangent1.x) + (lastPoint.y - pTangent1.y)*(lastPoint.y - pTangent1.y);\r\n        if (distanceSquared <= QEConstants.EPSILON_SQUARED)\r\n        {\r\n        adjustedPoints.pop();\r\n        adjustedPoints.push(pTangent2);\r\n        return;\r\n        }\r\n        }*/    // we check distance in order to remove useless close points due to straight line subdivision  \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        adjustedPoints.push( pTangent1 );\r\n        adjustedPoints.push( pTangent2 );\r\n        newPath.push( p1 );\r\n    }\r\n    \r\n     function checkAdjustedPath( newPath : Array<Point2D>, adjustedPoints : Array<Point2D>, pointSides : Map<Point2D,Int> ) : Void\r\n    {\r\n        \r\n        var needCheck = true;\r\n        \r\n        var point0 : Point2D;\r\n        var point0Side : Int;\r\n        var point1 : Point2D;\r\n        var point1Side : Int;\r\n        var point2 : Point2D;\r\n        var point2Side : Int;\r\n        \r\n        var pt1 : Point2D;\r\n        var pt2 : Point2D;\r\n        var pt3 : Point2D;\r\n        var dot : Float;\r\n        \r\n        var tangentsResult = new Array<Float>();\r\n        var pTangent1 : Point2D = null;\r\n        var pTangent2 : Point2D = null;\r\n        \r\n        while (needCheck)\r\n        {\r\n            needCheck = false;\r\n            var i = 2;\r\n            while(i < newPath.length ){\r\n                point2 = newPath[i];\r\n                point2Side = pointSides[ point2 ];\r\n                point1 = newPath[i - 1];\r\n                point1Side = pointSides[ point1 ];\r\n                point0 = newPath[i - 2];\r\n                point0Side = pointSides[ point0 ];\r\n                \r\n                if( point1Side == point2Side ) \r\n                {\r\n                    pt1 = adjustedPoints[(i - 2) * 2];\r\n                    pt2 = adjustedPoints[(i - 1) * 2 - 1];\r\n                    pt3 = adjustedPoints[(i - 1) * 2];\r\n                    dot = (pt1.x - pt2.x) * (pt3.x - pt2.x) + (pt1.y - pt2.y) * (pt3.y - pt2.y);\r\n                    if (dot > 0) \r\n                    {\r\n                        //needCheck = true;\r\n                        //Debug.trace(\"dot > 0\");\r\n                        // rework the tangent\r\n                        if (i == 2) \r\n                        {\r\n                            // tangent from start point\r\n                            Geom2D.tangentsPointToCircle(point0.x, point0.y, point2.x, point2.y, _radius, tangentsResult);\r\n                            // p2 lies on the left funnel\r\n                            if (point2Side == 1) \r\n                            {\r\n                                pTangent1 = point0;\r\n                                pTangent2 = getPoint(tangentsResult[2], tangentsResult[3]);\r\n                            }\r\n                            else \r\n                            {\r\n                                pTangent1 = point0;\r\n                                pTangent2 = getPoint(tangentsResult[0], tangentsResult[1]);\r\n                            }\r\n                        }\r\n                        else if (i == newPath.length - 1) \r\n                        {\r\n                            // tangent to end point\r\n                            Geom2D.tangentsPointToCircle(point2.x, point2.y, point0.x, point0.y, _radius, tangentsResult);\r\n                            // p1 lies on the left funnel\r\n                            if (point0Side == 1) \r\n                            {\r\n                                pTangent1 = getPoint(tangentsResult[0], tangentsResult[1]);\r\n                                pTangent2 = point2;\r\n                            }\r\n                            // p1 lies on the right funnel\r\n                            else \r\n                            {\r\n                                pTangent1 = getPoint(tangentsResult[2], tangentsResult[3]);\r\n                                pTangent2 = point2;\r\n                            }\r\n                        }\r\n                        else \r\n                        {\r\n                            // 1st point lies on left funnel, 2nd on right funnel\r\n                            if (point0Side == 1 && point2Side == -1) \r\n                            {\r\n                                //Debug.trace(\"point0Side == 1 && point2Side == -1\");\r\n                                Geom2D.tangentsCrossCircleToCircle(_radius, point0.x, point0.y, point2.x, point2.y, tangentsResult);  // we keep the points of the right-left tangent  ;\r\n                                \r\n                                pTangent1 = getPoint(tangentsResult[2], tangentsResult[3]);\r\n                                pTangent2 = getPoint(tangentsResult[6], tangentsResult[7]);\r\n                            }\r\n                            // 1st point lies on right funnel, 2nd on left funnel\r\n                            else if (point0Side == -1 && point2Side == 1) \r\n                            {\r\n                                //Debug.trace(\"point0Side == -1 && point2Side == 1\");\r\n                                Geom2D.tangentsCrossCircleToCircle(_radius, point0.x, point0.y, point2.x, point2.y, tangentsResult);  // we keep the points of the right-left tangent  ;\r\n                                \r\n                                pTangent1 = getPoint(tangentsResult[0], tangentsResult[1]);\r\n                                pTangent2 = getPoint(tangentsResult[4], tangentsResult[5]);\r\n                            }\r\n                            // both points lie on left funnel\r\n                            else if (point0Side == 1 && point2Side == 1) \r\n                            {\r\n                                //Debug.trace(\"point0Side == 1 && point2Side == 1\");\r\n                                Geom2D.tangentsParalCircleToCircle(_radius, point0.x, point0.y, point2.x, point2.y, tangentsResult);\r\n                                // we keep the points of the right tangent\r\n                                pTangent1 = getPoint(tangentsResult[2], tangentsResult[3]);\r\n                                pTangent2 = getPoint(tangentsResult[4], tangentsResult[5]);\r\n                            }\r\n                            // both points lie on right funnel\r\n                            else if (point0Side == -1 && point2Side == -1) \r\n                            {\r\n                                //Debug.trace(\"point0Side == -1 && point2Side == -1\");\r\n                                Geom2D.tangentsParalCircleToCircle(_radius, point0.x, point0.y, point2.x, point2.y, tangentsResult);\r\n                                // we keep the points of the right tangent\r\n                                pTangent1 = getPoint(tangentsResult[0], tangentsResult[1]);\r\n                                pTangent2 = getPoint(tangentsResult[6], tangentsResult[7]);\r\n                            }\r\n                        }\r\n                        var temp = ( i - 2) * 2;\r\n                        adjustedPoints.splice( temp, 1 );\r\n                        adjustedPoints.insert( temp, pTangent1 );\r\n                        temp = i * 2 - 1;\r\n                        adjustedPoints.splice( temp, 1 );\r\n                        adjustedPoints.insert( temp, pTangent2);\r\n                        \r\n                        // delete useless point\r\n                        newPath.splice(i - 1, 1);\r\n                        adjustedPoints.splice((i - 1) * 2 - 1, 2);\r\n                        \r\n                        tangentsResult.splice(0, tangentsResult.length);\r\n                        i--;\r\n                    }\r\n                }\r\n\t\t\t\ti++;\r\n            }\r\n        }\r\n    }\r\n    \r\n     function smoothAngle(prevPoint : Point2D, pointToSmooth : Point2D, nextPoint : Point2D, side : Int, encirclePoints : Array<Point2D>) : Void\r\n    {\r\n        var angleType = Geom2D.getDirection(prevPoint.x, prevPoint.y, pointToSmooth.x, pointToSmooth.y, nextPoint.x, nextPoint.y);\r\n        \r\n        /*\r\n        Debug.trace(\"smoothAngle\");\r\n        Debug.trace(\"angleType \" + angleType);\r\n        Debug.trace(\"prevPoint \" + prevPoint);\r\n        Debug.trace(\"pointToSmooth \" + pointToSmooth);\r\n        Debug.trace(\"nextPoint \" + nextPoint);\r\n        */\r\n        \r\n        var distanceSquared = (prevPoint.x - nextPoint.x) * (prevPoint.x - nextPoint.x) + (prevPoint.y - nextPoint.y) * (prevPoint.y - nextPoint.y);\r\n        if (distanceSquared <= _sampleCircleDistanceSquared) \r\n            return;\r\n        \r\n        var index : Int = 0;\r\n        var side1 : Int;\r\n        var side2 : Int;\r\n        var pointInArea : Bool;\r\n        var xToCheck : Float;\r\n        var yToCheck : Float;\r\n        for (i in 0..._numSamplesCircle){\r\n            pointInArea = false;\r\n            xToCheck = pointToSmooth.x + _sampleCircle[i].x;\r\n            yToCheck = pointToSmooth.y + _sampleCircle[i].y;\r\n            side1 = Geom2D.getDirection(prevPoint.x, prevPoint.y, pointToSmooth.x, pointToSmooth.y, xToCheck, yToCheck);\r\n            side2 = Geom2D.getDirection(pointToSmooth.x, pointToSmooth.y, nextPoint.x, nextPoint.y, xToCheck, yToCheck);\r\n            \r\n            // if funnel left\r\n            if (side == 1) \r\n            {\r\n                //Debug.trace(\"funnel side is 1\");\r\n                // if angle is < 180\r\n                if (angleType == -1) \r\n                {\r\n                    //Debug.trace(\"angle type is -1\");\r\n                    if (side1 == -1 && side2 == -1) \r\n                        pointInArea = true;\r\n                }\r\n                // if angle is >= 180\r\n                else \r\n                {\r\n                    //Debug.trace(\"angle type is 1\")\r\n                    if (side1 == -1 || side2 == -1) \r\n                        pointInArea = true;\r\n                }\r\n            }\r\n            // if funnel right\r\n            else \r\n            {\r\n                // if angle is < 180\r\n                if (angleType == 1) \r\n                {\r\n                    if (side1 == 1 && side2 == 1) \r\n                        pointInArea = true;\r\n                }\r\n                // if angle is >= 180\r\n                else \r\n                {\r\n                    if (side1 == 1 || side2 == 1) \r\n                        pointInArea = true;\r\n                }\r\n            }\r\n            if (pointInArea) \r\n            {\r\n                encirclePoints.splice(index, 0);\r\n                encirclePoints.insert(index, new Point2D(xToCheck, yToCheck));\r\n                index++;\r\n            }\r\n            else \r\n            index = 0;\r\n        }\r\n        if (side == -1) \r\n            encirclePoints.reverse();\r\n    }\r\n}\r\n","package hxDaedalus.ai;\r\n\r\nimport hxDaedalus.data.Edge;\r\nimport hxDaedalus.data.Face;\r\nimport hxDaedalus.data.Mesh;\r\nimport hxDaedalus.data.math.Geom2D;\r\nimport hxDaedalus.debug.Debug;\r\n\r\n\r\nclass PathFinder {\r\n    \r\n    public var entity: EntityAI;\r\n    public var mesh( get, set ) : Mesh;\r\n    var _mesh : Mesh;\r\n    var astar : AStar;\r\n    var funnel : Funnel;\r\n    var radius : Float;\r\n    var listFaces : Array<Face>;\r\n    var listEdges : Array<Edge>;\r\n    \r\n    public function new(){\r\n        astar = new AStar();\r\n        funnel = new Funnel();\r\n        listFaces = new Array<Face>();\r\n        listEdges = new Array<Edge>();\r\n    }\r\n    \r\n    public function dispose() : Void {\r\n        _mesh = null;\r\n        astar.dispose();\r\n        astar = null;\r\n        funnel.dispose();\r\n        funnel = null;\r\n        listEdges = null;\r\n        listFaces = null;\r\n    }\r\n    \r\n     function get_mesh() : Mesh {\r\n        return _mesh;\r\n    }\r\n    \r\n     function set_mesh(value : Mesh) : Mesh\r\n    {\r\n        _mesh = value;\r\n        astar.mesh = _mesh;\r\n        return value;\r\n    }\r\n    \r\n    public function findPath(toX : Float, toY : Float, resultPath : Array<Float>) : Void {\r\n        resultPath.splice( 0, resultPath.length );\r\n        Debug.assertFalse(_mesh == null, \"Mesh missing\");\r\n        Debug.assertFalse(entity == null, \"Entity missing\");\r\n        \r\n        if( Geom2D.isCircleIntersectingAnyConstraint( toX, toY, entity.radius, _mesh ) ) return;\r\n        \r\n        astar.radius = entity.radius;\r\n        funnel.radius = entity.radius;\r\n        \r\n        listFaces.splice( 0, listFaces.length );\r\n        listEdges.splice( 0, listEdges.length );\r\n        astar.findPath( entity.x, entity.y, toX, toY, listFaces, listEdges );\r\n        if( listFaces.length == 0 ){\r\n            Debug.trace(\"PathFinder listFaces.length == 0\");\r\n            return;\r\n        }\r\n\r\n        funnel.findPath( entity.x, entity.y, toX, toY, listFaces, listEdges, resultPath );\r\n    }\r\n}\r\n","package hxDaedalus.ai.trajectory;\r\n\r\n\r\nimport hxDaedalus.debug.Debug;\r\nimport hxDaedalus.ai.EntityAI;\r\n\r\nclass LinearPathSampler{\r\n    public var entity: EntityAI;\r\n    public var x( get, never ): Float;\r\n    public var y( get, never ): Float;\r\n    public var hasPrev( get, never ): Bool;\r\n    public var hasNext( get, never ): Bool;\r\n    public var count( get, set ): Int;\r\n    public var countMax( get, never ): Int;\r\n    public var samplingDistance( get, set ): Float;\r\n    public var path( never, set ): Array<Float>;\r\n    var _entity: EntityAI;\r\n    var _currentX: Float;\r\n    var _currentY: Float;\r\n    var _hasPrev: Bool;\r\n    var _hasNext: Bool;\r\n    var _samplingDistance: Float = 1;\r\n    var _samplingDistanceSquared: Float = 1;\r\n    var _path: Array<Float>;\r\n    var _iPrev: Int;\r\n    var _iNext: Int;\r\n    var _preComputed: Bool;\r\n    var _count: Int;\r\n    var _preCompX: Array<Float>;\r\n    var _preCompY: Array<Float>;\r\n    \r\n    public function new(){\r\n        _preCompX = new Array<Float>();\r\n        _preCompY = new Array<Float>();\r\n    }\r\n    \r\n    public function dispose(): Void {\r\n        entity = null;\r\n        _path = null;\r\n        _preCompX = null;\r\n        _preCompY = null;\r\n    }\r\n    \r\n    function get_x(): Float {\r\n        return _currentX;\r\n    }\r\n    \r\n    function get_y(): Float {\r\n        return _currentY;\r\n    }\r\n    \r\n    function get_hasPrev(): Bool {\r\n        return _hasPrev;\r\n    }\r\n    \r\n    function get_hasNext(): Bool {\r\n        return _hasNext;\r\n    }\r\n    \r\n    function get_count(): Int {\r\n        return _count;\r\n    }\r\n    \r\n    function set_count( value: Int ): Int {\r\n        _count = value;\r\n        if( _count < 0 ) _count = 0;\r\n        if( _count > countMax - 1 ) _count = countMax - 1;\r\n        _hasPrev = ( _count == 0 )? false: true;\r\n        _hasNext = ( _count == countMax - 1 )? false: true;\r\n        _currentX = _preCompX[ _count ];\r\n        _currentY = _preCompY[ _count ];\r\n        updateEntity();\r\n        \r\n\t\treturn _count;\r\n    }\r\n    \r\n    function get_countMax(): Int {\r\n        return _preCompX.length - 1;\r\n    }\r\n    \r\n    function get_samplingDistance(): Float {\r\n        return _samplingDistance;\r\n    }\r\n    \r\n    function set_samplingDistance( value: Float ): Float {\r\n        _samplingDistance = value;\r\n        _samplingDistanceSquared = _samplingDistance * _samplingDistance;\r\n        return value;\r\n    }\r\n    \r\n    function set_path( value: Array<Float> ): Array<Float>{\r\n        _path = value;\r\n        _preComputed = false;\r\n        reset();\r\n        return value;\r\n    }\r\n    \r\n    public function reset(): Void {\r\n        if ( _path.length > 0 ) {\r\n\t\t\tDebug.assertTrue((_path.length & 1) == 0, \"Wrong length\");\r\n\t\t\t\r\n            _currentX = _path[ 0 ];\r\n            _currentY = _path[ 1 ];\r\n            _iPrev = 0;\r\n            _iNext = 2;\r\n            _hasPrev = false;\r\n            _hasNext = true;\r\n            _count = 0;\r\n            updateEntity();\r\n        } else {\r\n            _hasPrev = false;\r\n            _hasNext = false;\r\n            _count = 0;\r\n        }\r\n    }\r\n    \r\n    public function preCompute(): Void {\r\n        _preCompX.splice( 0, _preCompX.length );\r\n        _preCompY.splice( 0, _preCompY.length );\r\n        _count = 0;\r\n        _preCompX.push(_currentX);\r\n        _preCompY.push(_currentY);\r\n        _preComputed = false;\r\n        while( next() ){\r\n            _preCompX.push( _currentX );\r\n            _preCompY.push( _currentY );\r\n        }\r\n        reset();\r\n        _preComputed = true;\r\n    }\r\n    \r\n    inline static function pythag( a: Float, b: Float ): Float\r\n    {\r\n        return Math.sqrt( a*a + b*b );\r\n    }\r\n    \r\n    public function prev(): Bool {\r\n        if( !_hasPrev ) return false;\r\n        _hasNext = true;\r\n        if( _preComputed ) {\r\n            _count--;\r\n            if( _count == 0 ) _hasPrev = false;\r\n            _currentX = _preCompX[ _count ];\r\n            _currentY = _preCompY[ _count ];\r\n            updateEntity();\r\n            return true;\r\n        }\r\n        var remainingDist : Float;\r\n        var dist : Float = 1;\r\n        remainingDist = _samplingDistance;\r\n        while( true ){\r\n            var pathPrev = _path[ _iPrev ];\r\n            var pathPrev1 = _path[ _iPrev + 1 ];\r\n            dist = pythag( _currentX - pathPrev, _currentY - pathPrev1 );\r\n            if( dist < remainingDist ) {\r\n                remainingDist -= dist;\r\n                _iPrev -= 2;\r\n                _iNext -= 2;\r\n                if( _iNext == 0 ) break;\r\n            } else { \r\n                break;\r\n            }\r\n        }\r\n        if( _iNext == 0 ){\r\n            _currentX = _path[ 0 ];\r\n            _currentY = _path[ 1 ];\r\n            _hasPrev = false;\r\n            _iNext = 2;\r\n            _iPrev = 0;\r\n            updateEntity();\r\n            return true;\r\n        } else {\r\n            _currentX = _currentX + ( _path[ _iPrev ] - _currentX) * remainingDist / dist;\r\n            _currentY = _currentY + ( _path[ _iPrev + 1 ] - _currentY) * remainingDist / dist;\r\n            updateEntity();\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    public function next(): Bool {\r\n        if (!_hasNext) return false;\r\n        _hasPrev = true;\r\n        if( _preComputed ){\r\n            _count++;\r\n            if( _count == _preCompX.length - 1 ) \r\n                _hasNext = false;\r\n            _currentX = _preCompX[ _count ];\r\n            _currentY = _preCompY[ _count ];\r\n            updateEntity();\r\n            return true;\r\n        }\r\n        var remainingDist : Float;\r\n        var dist : Float = 1;\r\n        remainingDist = _samplingDistance;\r\n        while (true)\r\n        {\r\n            var pathNext = _path[ _iNext ];\r\n            var pathNext1 = _path[ _iNext + 1 ];\r\n            dist = pythag( _currentX - pathNext, _currentY - pathNext1 );\r\n            if( dist < remainingDist ) {\r\n                remainingDist -= dist;\r\n                _currentX = _path[_iNext];\r\n                _currentY = _path[_iNext + 1];\r\n                _iPrev += 2;\r\n                _iNext += 2;\r\n                if( _iNext == _path.length ) break;\r\n            }\r\n            else break;\r\n        }\r\n        if( _iNext == _path.length ) {\r\n            _currentX = _path[_iPrev];\r\n            _currentY = _path[_iPrev + 1];\r\n            _hasNext = false;\r\n            _iNext = _path.length - 2;\r\n            _iPrev = _iNext - 2;\r\n            updateEntity();\r\n            return true;\r\n        } else {\r\n            _currentX = _currentX + (_path[_iNext] - _currentX) * remainingDist / dist;\r\n            _currentY = _currentY + (_path[_iNext + 1] - _currentY) * remainingDist / dist;\r\n            updateEntity();\r\n            return true;\r\n        }\r\n    }\r\n    \r\n     function updateEntity() : Void {\r\n        if( entity == null ) return;\r\n        Debug.assertFalse(Math.isNaN(_currentX) && Math.isNaN(_currentY));\r\n\t\tentity.x = _currentX;\r\n        entity.y = _currentY;\r\n    }\r\n}\r\n","package hxDaedalus.data;\r\n\r\nimport hxDaedalus.data.ConstraintShape;\r\nimport hxDaedalus.data.Edge;\r\n\r\nclass ConstraintSegment\r\n{\r\n    public var id(get, never) : Int;\r\n    public var fromShape: ConstraintShape;\r\n    public var edges(get, never) : Array<Edge>;\r\n    static var INC : Int = 0;\r\n    var _id : Int;\r\n    var _edges : Array<Edge>;\r\n    \r\n    public function new(){\r\n        _id = INC;\r\n        INC++;\r\n        _edges = new Array<Edge>();\r\n    }\r\n    \r\n    function get_id() : Int {\r\n        return _id;\r\n    }\r\n    \r\n    \r\n    public function addEdge( edge :Edge ) : Void {\r\n        if( _edges.indexOf(edge) == -1 && _edges.indexOf( edge.oppositeEdge ) == -1 ) _edges.push( edge );\r\n    }\r\n    \r\n    public function removeEdge( edge :Edge ) : Void {\r\n        var index : Int;\r\n        index = _edges.indexOf(edge);\r\n        if (index == -1) index = _edges.indexOf( edge.oppositeEdge );\r\n        if (index != -1) _edges.splice( index, 1 );\r\n    }\r\n    \r\n    function get_edges() : Array<Edge> {\r\n        return _edges;\r\n    }\r\n    \r\n    public function dispose() : Void {\r\n        _edges = null;\r\n        fromShape = null;\r\n    }\r\n    \r\n    public function toString() : String {\r\n        return \"seg_id \" + _id;\r\n    }\r\n}\r\n","package hxDaedalus.data;\r\n\r\n\r\nclass ConstraintShape{\r\n    public var id( get, never ) : Int;\r\n    public var segments : Array<ConstraintSegment>;\r\n    static var INC : Int = 0;\r\n    var _id : Int;\r\n    \r\n    public function new(){\r\n        _id = INC;\r\n        INC++;\r\n        segments = new Array<ConstraintSegment>();\r\n    }\r\n    \r\n     function get_id(): Int {\r\n        return _id;\r\n    }\r\n    \r\n    public function dispose(): Void {\r\n        while ( segments.length > 0 ) segments.pop().dispose();\r\n        segments = null;\r\n    }\r\n}\r\n","package hxDaedalus.data;\r\nimport hxDaedalus.data.Face;\r\nimport hxDaedalus.data.Vertex;\r\n\r\nclass Edge\r\n{\r\n    public var id(get, never) : Int;\r\n    public var isReal(get, never) : Bool;\r\n    public var isConstrained(get, set) : Bool;\r\n    public var originVertex(get, set) : Vertex;\r\n    public var nextLeftEdge(get, set) : Edge;\r\n    public var leftFace(get, set) : Face;\r\n    public var fromConstraintSegments: Array<ConstraintSegment>;\r\n    public var destinationVertex(get, never) : Vertex;\r\n    public var oppositeEdge(get, never) : Edge;\r\n    public var prevLeftEdge(get, never) : Edge;\r\n    public var nextRightEdge(get, never) : Edge;\r\n    public var prevRightEdge(get, never) : Edge;\r\n    public var rotLeftEdge(get, never) : Edge;\r\n    public var rotRightEdge(get, never) : Edge;\r\n    public var rightFace(get, never) : Face;\r\n\r\n    \r\n     static var INC : Int = 0;\r\n     var _id : Int;\r\n    \r\n    // root datas\r\n     var _isReal : Bool;\r\n     var _isConstrained : Bool;\r\n     var _originVertex : Vertex;\r\n     var _oppositeEdge : Edge;\r\n     var _nextLeftEdge : Edge;\r\n     var _leftFace : Face;\r\n    \r\n    public var colorDebug : Int = -1;\r\n    \r\n    public function new(){\r\n        _id = INC;\r\n        INC++;\r\n        fromConstraintSegments = new Array<ConstraintSegment>();\r\n    }\r\n    \r\n     function get_id(): Int {\r\n        return _id;\r\n    }\r\n    \r\n     function get_isReal(): Bool {\r\n        return _isReal;\r\n    }\r\n    \r\n     function get_isConstrained(): Bool {\r\n        return _isConstrained;\r\n    }\r\n    \r\n    public function setDatas( originVertex :    Vertex\r\n                            , oppositeEdge :    Edge\r\n                            , nextLeftEdge :    Edge\r\n                            , leftFace :        Face\r\n                            , isReal :          Bool = true\r\n                            , isConstrained :   Bool = false\r\n                            ): Void\r\n    {\r\n        _isConstrained = isConstrained;\r\n        _isReal = isReal;\r\n        _originVertex = originVertex;\r\n        _oppositeEdge = oppositeEdge;\r\n        _nextLeftEdge = nextLeftEdge;\r\n        _leftFace = leftFace;\r\n    }\r\n    \r\n    public function addFromConstraintSegment( segment: ConstraintSegment ): Void {\r\n        if( fromConstraintSegments.indexOf( segment ) == -1 ) fromConstraintSegments.push( segment );\r\n    }\r\n    \r\n    public function removeFromConstraintSegment( segment: ConstraintSegment ): Void {\r\n        var index : Int = fromConstraintSegments.indexOf( segment );\r\n        if( index != -1 ) fromConstraintSegments.splice(index, 1);\r\n    }\r\n    \r\n     function set_originVertex( value: Vertex ): Vertex {\r\n        _originVertex = value;\r\n        return value;\r\n    }\r\n    \r\n     function set_nextLeftEdge( value: Edge ): Edge {\r\n        _nextLeftEdge = value;\r\n        return value;\r\n    }\r\n    \r\n     function set_leftFace( value: Face ): Face {\r\n        _leftFace = value;\r\n        return value;\r\n    }\r\n    \r\n     function set_isConstrained( value: Bool ) : Bool {\r\n        _isConstrained = value;\r\n        return value;\r\n    }\r\n    \r\n    public function dispose() : Void\r\n    {\r\n        _originVertex = null;\r\n        _oppositeEdge = null;\r\n        _nextLeftEdge = null;\r\n        _leftFace = null;\r\n        fromConstraintSegments = null;\r\n    }\r\n    \r\n     function get_originVertex() : Vertex{return _originVertex;\r\n    }\r\n     function get_destinationVertex() : Vertex{return oppositeEdge.originVertex;\r\n    }\r\n\r\n     function get_oppositeEdge() : Edge{return _oppositeEdge;\r\n    }\r\n     function get_nextLeftEdge() : Edge{return _nextLeftEdge;\r\n    }\r\n     function get_prevLeftEdge() : Edge{return _nextLeftEdge.nextLeftEdge;\r\n    }\r\n     function get_nextRightEdge() : Edge{return _oppositeEdge.nextLeftEdge.nextLeftEdge.oppositeEdge;\r\n    }\r\n     function get_prevRightEdge() : Edge{return _oppositeEdge.nextLeftEdge.oppositeEdge;\r\n    }\r\n     function get_rotLeftEdge() : Edge{return _nextLeftEdge.nextLeftEdge.oppositeEdge;\r\n    }\r\n     function get_rotRightEdge() : Edge{return _oppositeEdge.nextLeftEdge;\r\n    }\r\n     function get_leftFace() : Face{return _leftFace;\r\n    }\r\n     function get_rightFace() : Face{return _oppositeEdge.leftFace;\r\n    }\r\n    \r\n    \r\n    public function toString() : String\r\n    {\r\n        return \"edge \" + originVertex.id + \" - \" + destinationVertex.id;\r\n    }\r\n}\r\n\r\n","package hxDaedalus.data;\r\n\r\n\r\nclass Face\r\n{\r\n    public var id(get, never) : Int;\r\n    public var isReal(get, never) : Bool;\r\n    public var edge(get, never) : Edge;\r\n\r\n    \r\n     static var INC : Int = 0;\r\n     var _id : Int;\r\n    \r\n     var _isReal : Bool;\r\n     var _edge : Edge;\r\n    \r\n    public var colorDebug : Int = -1;\r\n    \r\n    public function new(){\r\n        _id = INC;\r\n        INC++;\r\n    }\r\n    \r\n     function get_id(): Int {\r\n        return _id;\r\n    }\r\n    \r\n     function get_isReal(): Bool {\r\n        return _isReal;\r\n    }\r\n    \r\n     function set_datas( edge : Edge ): Void {\r\n        _isReal = true;\r\n        _edge = edge;\r\n    }\r\n    \r\n    // must use this if you want te set isReal to false\r\n    public function setDatas( edge : Edge, isReal: Bool = true ): Void {\r\n        _isReal = isReal;\r\n        _edge = edge;\r\n    }\r\n    \r\n    public function dispose(): Void {\r\n        _edge = null;\r\n    }\r\n    \r\n     function get_edge(): Edge {\r\n        return _edge;\r\n    }\r\n}\r\n","package hxDaedalus.data;\r\n\r\nimport hxDaedalus.data.Object;\r\nimport hxDaedalus.data.Vertex;\r\nimport hxDaedalus.data.math.Geom2D;\r\nimport hxDaedalus.data.math.Matrix2D;\r\nimport hxDaedalus.data.math.Point2D;\r\nimport hxDaedalus.iterators.FromMeshToVertices;\r\nimport hxDaedalus.iterators.FromVertexToIncomingEdges;\r\nimport hxDaedalus.iterators.FromVertexToOutgoingEdges;\r\nimport hxDaedalus.debug.Debug;\r\n\r\n\r\nclass Mesh\r\n{\r\n    public var height(get, never) : Float;\r\n    public var width(get, never) : Float;\r\n    public var clipping(get, set) : Bool;\r\n    public var id(get, never) : Int;\r\n    public var __constraintShapes(get, never) : Array<ConstraintShape>;\r\n\r\n    \r\n     static var INC : Int = 0;\r\n     var _id : Int;\r\n    \r\n     var _width : Float = 0;\r\n     var _height : Float = 0;\r\n     var _clipping : Bool = false;\r\n    \r\n    public var _vertices : Array<Vertex>= null;\r\n    public var _edges : Array<Edge>= null;\r\n    public var _faces : Array<Face>= null;\r\n     var _constraintShapes : Array<ConstraintShape>= null;\r\n     var _objects : Array<Object>= null;\r\n    \r\n    // keep references of center vertex and bounding edges when split, useful to restore edges as Delaunay\r\n     var __centerVertex : Vertex= null;\r\n     var __edgesToCheck : Array<Edge>= null;\r\n    \r\n    public function new( width: Float, height: Float )\r\n    {\r\n        _id = INC;\r\n        INC++;\r\n        \r\n        _width = width;\r\n        _height = height;\r\n        _clipping = true;\r\n        \r\n        _vertices = new Array<Vertex>();\r\n        _edges = new Array<Edge>();\r\n        _faces = new Array<Face>();\r\n        _constraintShapes = new Array<ConstraintShape>();\r\n        _objects = new Array<Object>();\r\n        \r\n        __edgesToCheck = new Array<Edge>();\r\n    }\r\n    \r\n     function get_height() : Float\r\n    {\r\n        return _height;\r\n    }\r\n    \r\n     function get_width() : Float\r\n    {\r\n        return _width;\r\n    }\r\n    \r\n     function get_clipping() : Bool\r\n    {\r\n        return _clipping;\r\n    }\r\n    \r\n     function set_clipping(value : Bool) : Bool\r\n    {\r\n        _clipping = value;\r\n        return value;\r\n    }\r\n    \r\n     function get_id() : Int\r\n    {\r\n        return _id;\r\n    }\r\n    \r\n    public function dispose() : Void\r\n    {\r\n        while (_vertices.length > 0) _vertices.pop().dispose();\r\n        _vertices = null;\r\n        while (_edges.length > 0) _edges.pop().dispose();\r\n        _edges = null;\r\n        while (_faces.length > 0) _faces.pop().dispose();\r\n        _faces = null;\r\n        while (_constraintShapes.length > 0) _constraintShapes.pop().dispose();\r\n        _constraintShapes = null;\r\n        while (_objects.length > 0) _objects.pop().dispose();\r\n        _objects = null;\r\n        \r\n        __edgesToCheck = null;\r\n        __centerVertex = null;\r\n    }\r\n    \r\n     function get___constraintShapes() : Array<ConstraintShape>\r\n    {\r\n        return _constraintShapes;\r\n    }\r\n    \r\n    public function buildFromRecord(rec : String) : Void\r\n    {\r\n        var positions : Array<Dynamic> = rec.split(\";\");\r\n        var i : Int = 0;\r\n        while (i < positions.length){\r\n            insertConstraintSegment(Std.parseFloat(positions[i]), Std.parseFloat(positions[i + 1]), Std.parseFloat(positions[i + 2]), Std.parseFloat(positions[i + 3]));\r\n            i += 4;\r\n        }\r\n    }\r\n    \r\n    public function insertObject(object : Object) : Void\r\n    {\r\n        if (object.constraintShape!=null) deleteObject(object);\r\n        \r\n        var shape : ConstraintShape = new ConstraintShape();\r\n        var segment : ConstraintSegment;\r\n        var coordinates : Array<Float> = object.coordinates;\r\n        var m : Matrix2D = object.matrix;\r\n        \r\n        object.updateMatrixFromValues();\r\n        var x1 : Float;\r\n        var y1 : Float;\r\n        var x2 : Float;\r\n        var y2 : Float;\r\n        var transfx1 : Float;\r\n        var transfy1 : Float;\r\n        var transfx2 : Float;\r\n        var transfy2 : Float;\r\n        \r\n        var i : Int = 0;\r\n        while (i < coordinates.length){\r\n            x1 = coordinates[i];\r\n            y1 = coordinates[i + 1];\r\n            x2 = coordinates[i + 2];\r\n            y2 = coordinates[i + 3];\r\n            transfx1 = m.transformX(x1, y1);\r\n            transfy1 = m.transformY(x1, y1);\r\n            transfx2 = m.transformX(x2, y2);\r\n            transfy2 = m.transformY(x2, y2);\r\n            \r\n            segment = insertConstraintSegment(transfx1, transfy1, transfx2, transfy2);\r\n            if( segment != null ) \r\n            {\r\n                segment.fromShape = shape;\r\n                shape.segments.push(segment);\r\n            }\r\n            i += 4;\r\n        }\r\n        \r\n        _constraintShapes.push( shape );\r\n        object.constraintShape = shape;\r\n        \r\n        if (!__objectsUpdateInProgress) {\r\n            _objects.push(object);\r\n        }\r\n    }\r\n    \r\n    public function deleteObject(object : Object) : Void\r\n    {\r\n        if (object.constraintShape == null ) return;\r\n            \r\n        \r\n        deleteConstraintShape(object.constraintShape);\r\n        object.constraintShape = null;\r\n        \r\n        if (!__objectsUpdateInProgress) \r\n        {\r\n            var index : Int = _objects.indexOf(object);\r\n            _objects.splice(index, 1);\r\n        }\r\n    }\r\n    \r\n     var __objectsUpdateInProgress : Bool = false;\r\n    public function updateObjects() : Void\r\n    {\r\n        __objectsUpdateInProgress = true;\r\n        for (i in 0..._objects.length){\r\n            if (_objects[i].hasChanged) \r\n            {\r\n                deleteObject(_objects[i]);\r\n                insertObject(_objects[i]);\r\n                _objects[i].hasChanged = false;\r\n            }\r\n        }\r\n        __objectsUpdateInProgress = false;\r\n    }\r\n    \r\n    // insert a new collection of constrained edges.\r\n    // Coordinates parameter is a list with form [x0, y0, x1, y1, x2, y2, x3, y3, x4, y4, ....]\r\n    // where each 4-uple sequence (xi, yi, xi+1, yi+1) is a constraint segment (with i % 4 == 0)\r\n    // and where each couple sequence (xi, yi) is a point.\r\n    // Segments are not necessary connected.\r\n    // Segments can overlap (then they will be automaticaly subdivided).\r\n    public function insertConstraintShape(coordinates : Array<Float>) : ConstraintShape\r\n    {\r\n        var shape : ConstraintShape = new ConstraintShape();\r\n        var segment : ConstraintSegment = null;\r\n        \r\n        var i : Int = 0;\r\n        while (i < coordinates.length){\r\n            segment = insertConstraintSegment(coordinates[i], coordinates[i + 1], coordinates[i + 2], coordinates[i + 3]);\r\n            if (segment != null) \r\n            {\r\n                segment.fromShape = shape;\r\n                shape.segments.push(segment);\r\n            }\r\n            i += 4;\r\n        }\r\n        \r\n        _constraintShapes.push(shape);\r\n        \r\n        return shape;\r\n    }\r\n    \r\n    public function deleteConstraintShape(shape : ConstraintShape) : Void\r\n    {\r\n        for( i in 0...shape.segments.length ) deleteConstraintSegment(shape.segments[i]);\r\n        shape.dispose();\r\n        _constraintShapes.splice( _constraintShapes.indexOf( shape ), 1);\r\n    }\r\n    \r\n    public function insertConstraintSegment(x1 : Float, y1 : Float, x2 : Float, y2 : Float) : ConstraintSegment\r\n    {\r\n        //Debug.trace(\"insertConstraintSegment\");\r\n        \r\n        /* point positions relative to bounds\r\n        1 | 2 | 3\r\n        ------------\r\n        8 | 0 | 4\r\n        ------------\r\n        7 | 6 | 5\r\n        */\r\n        var p1pos : Int = findPositionFromBounds(x1, y1);\r\n        var p2pos : Int = findPositionFromBounds(x2, y2);\r\n        \r\n        var newX1 : Float = x1;\r\n        var newY1 : Float = y1;\r\n        var newX2 : Float = x2;\r\n        var newY2 : Float = y2;\r\n        // need clipping if activated and if one end point is outside bounds\r\n        if (_clipping && (p1pos != 0 || p2pos != 0)) \r\n        {\r\n            var intersectPoint : Point2D = new Point2D();\r\n            \r\n            // if both end points are outside bounds\r\n            if (p1pos != 0 && p2pos != 0) \r\n            {\r\n                // if both end points are on same side\r\n                if ((x1 <= 0 && x2 <= 0) || (x1 >= _width && x2 >= _width) || (y1 <= 0 && y2 <= 0) || (y1 >= _height && y2 >= _height)) \r\n                    return null;  // if end points are in separated left and right areas  ;\r\n                \r\n                \r\n                \r\n                if ((p1pos == 8 && p2pos == 4) || (p1pos == 4 && p2pos == 8)) \r\n                {\r\n                    // intersection with left bound\r\n                    Geom2D.intersections2segments(x1, y1, x2, y2, 0, 0, 0, _height, intersectPoint);\r\n                    newX1 = intersectPoint.x;\r\n                    newY1 = intersectPoint.y;\r\n                    // intersection with right bound\r\n                    Geom2D.intersections2segments(x1, y1, x2, y2, _width, 0, _width, _height, intersectPoint);\r\n                    newX2 = intersectPoint.x;\r\n                    newY2 = intersectPoint.y;\r\n                }\r\n                // if end points are in separated top and bottom areas\r\n                else if ((p1pos == 2 && p2pos == 6) || (p1pos == 6 && p2pos == 2)) \r\n                {\r\n                    // intersection with top bound\r\n                    Geom2D.intersections2segments(x1, y1, x2, y2, 0, 0, _width, 0, intersectPoint);\r\n                    newX1 = intersectPoint.x;\r\n                    newY1 = intersectPoint.y;\r\n                    // intersection with bottom bound\r\n                    Geom2D.intersections2segments(x1, y1, x2, y2, 0, _height, _width, _height, intersectPoint);\r\n                    newX2 = intersectPoint.x;\r\n                    newY2 = intersectPoint.y;\r\n                }\r\n                // if ends points are apart of the top-left corner\r\n                else if ((p1pos == 2 && p2pos == 8) || (p1pos == 8 && p2pos == 2)) \r\n                {\r\n                    // check if intersection with top bound\r\n                    if (Geom2D.intersections2segments(x1, y1, x2, y2, 0, 0, _width, 0, intersectPoint)) \r\n                    {\r\n                        newX1 = intersectPoint.x;\r\n                        newY1 = intersectPoint.y;\r\n                        \r\n                        // must have intersection with left bound\r\n                        Geom2D.intersections2segments(x1, y1, x2, y2, 0, 0, 0, _height, intersectPoint);\r\n                        newX2 = intersectPoint.x;\r\n                        newY2 = intersectPoint.y;\r\n                    }\r\n                    else return null;\r\n                }\r\n                // if ends points are apart of the top-right corner\r\n                else if ((p1pos == 2 && p2pos == 4) || (p1pos == 4 && p2pos == 2)) \r\n                {\r\n                    // check if intersection with top bound\r\n                    if (Geom2D.intersections2segments(x1, y1, x2, y2, 0, 0, _width, 0, intersectPoint)) \r\n                    {\r\n                        newX1 = intersectPoint.x;\r\n                        newY1 = intersectPoint.y;\r\n                        \r\n                        // must have intersection with right bound\r\n                        Geom2D.intersections2segments(x1, y1, x2, y2, _width, 0, _width, _height, intersectPoint);\r\n                        newX2 = intersectPoint.x;\r\n                        newY2 = intersectPoint.y;\r\n                    }\r\n                    else return null;\r\n                }\r\n                // if ends points are apart of the bottom-right corner\r\n                else if ((p1pos == 6 && p2pos == 4) || (p1pos == 4 && p2pos == 6)) \r\n                {\r\n                    // check if intersection with bottom bound\r\n                    if (Geom2D.intersections2segments(x1, y1, x2, y2, 0, _height, _width, _height, intersectPoint)) \r\n                    {\r\n                        newX1 = intersectPoint.x;\r\n                        newY1 = intersectPoint.y;\r\n                        \r\n                        // must have intersection with right bound\r\n                        Geom2D.intersections2segments(x1, y1, x2, y2, _width, 0, _width, _height, intersectPoint);\r\n                        newX2 = intersectPoint.x;\r\n                        newY2 = intersectPoint.y;\r\n                    }\r\n                    else return null;\r\n                }\r\n                // if ends points are apart of the bottom-left corner\r\n                else if ((p1pos == 8 && p2pos == 6) || (p1pos == 6 && p2pos == 8)) \r\n                {\r\n                    // check if intersection with bottom bound\r\n                    if (Geom2D.intersections2segments(x1, y1, x2, y2, 0, _height, _width, _height, intersectPoint)) \r\n                    {\r\n                        newX1 = intersectPoint.x;\r\n                        newY1 = intersectPoint.y;\r\n                        \r\n                        // must have intersection with left bound\r\n                        Geom2D.intersections2segments(x1, y1, x2, y2, 0, 0, 0, _height, intersectPoint);\r\n                        newX2 = intersectPoint.x;\r\n                        newY2 = intersectPoint.y;\r\n                    }\r\n                    else return null;\r\n                }\r\n                // other cases (could be optimized)\r\n                else \r\n                {\r\n                    var firstDone : Bool = false;\r\n                    var secondDone : Bool = false;\r\n                    // check top bound\r\n                    if (Geom2D.intersections2segments(x1, y1, x2, y2, 0, 0, _width, 0, intersectPoint)) \r\n                    {\r\n                        newX1 = intersectPoint.x;\r\n                        newY1 = intersectPoint.y;\r\n                        firstDone = true;\r\n                    }  // check right bound  \r\n                    \r\n                    if (Geom2D.intersections2segments(x1, y1, x2, y2, _width, 0, _width, _height, intersectPoint)) \r\n                    {\r\n                        if (!firstDone) \r\n                        {\r\n                            newX1 = intersectPoint.x;\r\n                            newY1 = intersectPoint.y;\r\n                            firstDone = true;\r\n                        }\r\n                        else \r\n                        {\r\n                            newX2 = intersectPoint.x;\r\n                            newY2 = intersectPoint.y;\r\n                            secondDone = true;\r\n                        }\r\n                    }  // check bottom bound  \r\n                    \r\n                    if (!secondDone && Geom2D.intersections2segments(x1, y1, x2, y2, 0, _height, _width, _height, intersectPoint)) \r\n                    {\r\n                        if (!firstDone) \r\n                        {\r\n                            newX1 = intersectPoint.x;\r\n                            newY1 = intersectPoint.y;\r\n                            firstDone = true;\r\n                        }\r\n                        else \r\n                        {\r\n                            newX2 = intersectPoint.x;\r\n                            newY2 = intersectPoint.y;\r\n                            secondDone = true;\r\n                        }\r\n                    }  // check left bound  \r\n                    \r\n                    if (!secondDone && Geom2D.intersections2segments(x1, y1, x2, y2, 0, 0, 0, _height, intersectPoint)) {\r\n                        newX2 = intersectPoint.x;\r\n                        newY2 = intersectPoint.y;\r\n                    }\r\n                    \r\n                    if (!firstDone) return null;\r\n                }\r\n            }\r\n            // one end point of segment is outside bounds and one is inside\r\n            else \r\n            {\r\n                // if one point is outside top\r\n                if (p1pos == 2 || p2pos == 2){\r\n                    // intersection with top bound\r\n                    Geom2D.intersections2segments(x1, y1, x2, y2, 0, 0, _width, 0, intersectPoint);\r\n                }\r\n                // if one point is outside right\r\n                else if (p1pos == 4 || p2pos == 4){\r\n                    // intersection with right bound\r\n                    Geom2D.intersections2segments(x1, y1, x2, y2, _width, 0, _width, _height, intersectPoint);\r\n                }\r\n                // if one point is outside bottom\r\n                else if (p1pos == 6 || p2pos == 6){\r\n                    // intersection with bottom bound\r\n                    Geom2D.intersections2segments(x1, y1, x2, y2, 0, _height, _width, _height, intersectPoint);\r\n                }\r\n                // if one point is outside left\r\n                else if (p1pos == 8 || p2pos == 8){\r\n                    // intersection with left bound\r\n                    Geom2D.intersections2segments(x1, y1, x2, y2, 0, 0, 0, _height, intersectPoint);\r\n                }\r\n                // other cases (could be optimized)\r\n                else \r\n                {\r\n                    // check top bound\r\n                    if (!Geom2D.intersections2segments(x1, y1, x2, y2, 0, 0, _width, 0, intersectPoint)) \r\n                    {\r\n                        // check right bound\r\n                        if (!Geom2D.intersections2segments(x1, y1, x2, y2, _width, 0, _width, _height, intersectPoint)) \r\n                        {\r\n                            // check bottom bound\r\n                            if (!Geom2D.intersections2segments(x1, y1, x2, y2, 0, _height, _width, _height, intersectPoint)) \r\n                            {\r\n                                // check left bound\r\n                                Geom2D.intersections2segments(x1, y1, x2, y2, 0, 0, 0, _height, intersectPoint);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                \r\n                if( p1pos == 0 ) {\r\n                    newX1 = x1;\r\n                    newY1 = y1;\r\n                } else {\r\n                    newX1 = x2;\r\n                    newY1 = y2;\r\n                }\r\n                newX2 = intersectPoint.x;\r\n                newY2 = intersectPoint.y;\r\n            }\r\n        }  // we check the vertices insertions  \r\n        \r\n        \r\n        \r\n        var vertexDown = insertVertex( newX1, newY1 );\r\n        if( vertexDown == null ) return null;\r\n        var vertexUp = insertVertex( newX2, newY2 );\r\n        if( vertexUp == null ) return null;\r\n        if( vertexDown == vertexUp ) return null; \r\n        // useful    //Debug.trace(\"vertices \" + vertexDown.id + \" \" + vertexUp.id)  \r\n        var iterVertexToOutEdges : FromVertexToOutgoingEdges = new FromVertexToOutgoingEdges();\r\n        var currVertex : Vertex;\r\n        var currEdge : Edge;\r\n        var i : Int;\r\n        \r\n        // the new constraint segment\r\n        var segment = new ConstraintSegment();\r\n        \r\n        var tempEdgeDownUp : Edge = new Edge();\r\n        var tempSdgeUpDown : Edge = new Edge();\r\n        tempEdgeDownUp.setDatas(vertexDown, tempSdgeUpDown, null, null, true, true);\r\n        tempSdgeUpDown.setDatas(vertexUp, tempEdgeDownUp, null, null, true, true);\r\n        \r\n        var intersectedEdges = new Array<Edge>();\r\n        var leftBoundingEdges = new Array<Edge>();\r\n        var rightBoundingEdges = new Array<Edge>();\r\n        \r\n        var currObjet : Intersection;\r\n        var pIntersect : Point2D = new Point2D();\r\n        var edgeLeft : Edge;\r\n        var newEdgeDownUp : Edge;\r\n        var newEdgeUpDown : Edge;\r\n        var done : Bool;\r\n        currVertex = vertexDown;\r\n        currObjet = EVertex(currVertex);\r\n        while (true)\r\n        {\r\n            done = false;\r\n            \r\n            switch( currObjet ){\r\n                case EVertex( vertex ):\r\n///////////////////////////\r\n                        //Debug.trace(\"case vertex\");\r\n                        currVertex = vertex;\r\n                        iterVertexToOutEdges.fromVertex = currVertex;\r\n                        while ((currEdge = iterVertexToOutEdges.next())!=null)\r\n                        {\r\n                            // if we meet directly the end vertex\r\n                            if (currEdge.destinationVertex == vertexUp) \r\n                            {\r\n                                //Debug.trace(\"we met the end vertex\");\r\n                                if (!currEdge.isConstrained) \r\n                                {\r\n                                    currEdge.isConstrained = true;\r\n                                    currEdge.oppositeEdge.isConstrained = true;\r\n                                }\r\n                                currEdge.addFromConstraintSegment(segment);\r\n                                currEdge.oppositeEdge.fromConstraintSegments = currEdge.fromConstraintSegments;\r\n                                vertexDown.addFromConstraintSegment(segment);\r\n                                vertexUp.addFromConstraintSegment(segment);\r\n                                segment.addEdge(currEdge);\r\n                                return segment;\r\n                            }  // if we meet a vertex  \r\n\r\n                            if (Geom2D.distanceSquaredVertexToEdge(currEdge.destinationVertex, tempEdgeDownUp) <= Constants.EPSILON_SQUARED) \r\n                            {\r\n                                //Debug.trace(\"we met a vertex\");\r\n                                if (!currEdge.isConstrained) \r\n                                {\r\n                                    //Debug.trace(\"edge is not constrained\");\r\n                                    currEdge.isConstrained = true;\r\n                                    currEdge.oppositeEdge.isConstrained = true;\r\n                                }\r\n                                currEdge.addFromConstraintSegment(segment);\r\n                                currEdge.oppositeEdge.fromConstraintSegments = currEdge.fromConstraintSegments;\r\n                                vertexDown.addFromConstraintSegment(segment);\r\n                                segment.addEdge(currEdge);\r\n                                vertexDown = currEdge.destinationVertex;\r\n                                tempEdgeDownUp.originVertex = vertexDown;\r\n                                currObjet = EVertex(vertexDown);\r\n                                done = true;\r\n                                break;\r\n                            }\r\n                        }\r\n\r\n                        if (done) \r\n                            continue;\r\n\r\n                        iterVertexToOutEdges.fromVertex = currVertex;\r\n                        while ((currEdge = iterVertexToOutEdges.next())!=null)\r\n                        {\r\n                            currEdge = currEdge.nextLeftEdge;\r\n                            if (Geom2D.intersections2edges(currEdge, tempEdgeDownUp, pIntersect)) \r\n                            {\r\n                                //Debug.trace(\"edge intersection\");\r\n                                if (currEdge.isConstrained) \r\n                                {\r\n                                    //Debug.trace(\"edge is constrained\");\r\n                                    vertexDown = splitEdge(currEdge, pIntersect.x, pIntersect.y);\r\n                                    iterVertexToOutEdges.fromVertex = currVertex;\r\n                                    while ((currEdge = iterVertexToOutEdges.next())!=null )\r\n                                    {\r\n                                        if (currEdge.destinationVertex == vertexDown) \r\n                                        {\r\n                                            currEdge.isConstrained = true;\r\n                                            currEdge.oppositeEdge.isConstrained = true;\r\n                                            currEdge.addFromConstraintSegment(segment);\r\n                                            currEdge.oppositeEdge.fromConstraintSegments = currEdge.fromConstraintSegments;\r\n                                            segment.addEdge(currEdge);\r\n                                            break;\r\n                                        }\r\n                                    }\r\n                                    currVertex.addFromConstraintSegment(segment);\r\n                                    tempEdgeDownUp.originVertex = vertexDown;\r\n                                    currObjet = EVertex(vertexDown);\r\n                                }\r\n                                else \r\n                                {\r\n                                    //Debug.trace(\"edge is not constrained\");\r\n                                    intersectedEdges.push(currEdge);\r\n                                    leftBoundingEdges.unshift(currEdge.nextLeftEdge);\r\n                                    rightBoundingEdges.push(currEdge.prevLeftEdge);\r\n                                    currEdge = currEdge.oppositeEdge;  // we keep the edge from left to right  \r\n                                    currObjet = EEdge(currEdge);\r\n                                }\r\n                                break;\r\n                            }\r\n                        }\r\n                    \r\n////////////////////////////////////////////\r\n                case EEdge( edge ):\r\n                    currEdge = edge;\r\n                        //Debug.trace(\"case edge\");\r\n                        edgeLeft = currEdge.nextLeftEdge;\r\n                        if (edgeLeft.destinationVertex == vertexUp) \r\n                        {\r\n                            //Debug.trace(\"end point reached\");\r\n                            leftBoundingEdges.unshift(edgeLeft.nextLeftEdge);\r\n                            rightBoundingEdges.push(edgeLeft);\r\n\r\n                            newEdgeDownUp = new Edge();\r\n                            newEdgeUpDown = new Edge();\r\n                            newEdgeDownUp.setDatas(vertexDown, newEdgeUpDown, null, null, true, true);\r\n                            newEdgeUpDown.setDatas(vertexUp, newEdgeDownUp, null, null, true, true);\r\n                            leftBoundingEdges.push(newEdgeDownUp);\r\n                            rightBoundingEdges.push(newEdgeUpDown);\r\n                            insertNewConstrainedEdge(segment, newEdgeDownUp, intersectedEdges, leftBoundingEdges, rightBoundingEdges);\r\n\r\n                            return segment;\r\n                        }\r\n                        else if (Geom2D.distanceSquaredVertexToEdge(edgeLeft.destinationVertex, tempEdgeDownUp) <= Constants.EPSILON_SQUARED) \r\n                        {\r\n                            //Debug.trace(\"we met a vertex\");\r\n                            leftBoundingEdges.unshift(edgeLeft.nextLeftEdge);\r\n                            rightBoundingEdges.push(edgeLeft);\r\n\r\n                            newEdgeDownUp = new Edge();\r\n                            newEdgeUpDown = new Edge();\r\n                            newEdgeDownUp.setDatas(vertexDown, newEdgeUpDown, null, null, true, true);\r\n                            newEdgeUpDown.setDatas(edgeLeft.destinationVertex, newEdgeDownUp, null, null, true, true);\r\n                            leftBoundingEdges.push(newEdgeDownUp);\r\n                            rightBoundingEdges.push(newEdgeUpDown);\r\n                            insertNewConstrainedEdge(segment, newEdgeDownUp, intersectedEdges, leftBoundingEdges, rightBoundingEdges);\r\n\r\n                            intersectedEdges.splice(0, intersectedEdges.length);\r\n                            leftBoundingEdges.splice(0, leftBoundingEdges.length);\r\n                            rightBoundingEdges.splice(0, rightBoundingEdges.length);\r\n\r\n                            vertexDown = edgeLeft.destinationVertex;\r\n                            tempEdgeDownUp.originVertex = vertexDown;\r\n                            currObjet = EVertex(vertexDown);\r\n                        }\r\n                        else \r\n                        {\r\n                            if (Geom2D.intersections2edges(edgeLeft, tempEdgeDownUp, pIntersect)) \r\n                            {\r\n                                //Debug.trace(\"1st left edge intersected\");\r\n                                if (edgeLeft.isConstrained) \r\n                                {\r\n                                    //Debug.trace(\"edge is constrained\");\r\n                                    currVertex = splitEdge(edgeLeft, pIntersect.x, pIntersect.y);\r\n\r\n                                    iterVertexToOutEdges.fromVertex = currVertex;\r\n                                    while ((currEdge = iterVertexToOutEdges.next())!=null)\r\n                                    {\r\n                                        if (currEdge.destinationVertex == leftBoundingEdges[0].originVertex) \r\n                                        {\r\n                                            leftBoundingEdges.unshift(currEdge);\r\n                                        }\r\n                                        if (currEdge.destinationVertex == rightBoundingEdges[rightBoundingEdges.length - 1].destinationVertex) \r\n                                        {\r\n                                            rightBoundingEdges.push(currEdge.oppositeEdge);\r\n                                        }\r\n                                    }\r\n\r\n                                    newEdgeDownUp = new Edge();\r\n                                    newEdgeUpDown = new Edge();\r\n                                    newEdgeDownUp.setDatas(vertexDown, newEdgeUpDown, null, null, true, true);\r\n                                    newEdgeUpDown.setDatas(currVertex, newEdgeDownUp, null, null, true, true);\r\n                                    leftBoundingEdges.push(newEdgeDownUp);\r\n                                    rightBoundingEdges.push(newEdgeUpDown);\r\n                                    insertNewConstrainedEdge(segment, newEdgeDownUp, intersectedEdges, leftBoundingEdges, rightBoundingEdges);\r\n\r\n                                    intersectedEdges.splice(0, intersectedEdges.length);\r\n                                    leftBoundingEdges.splice(0, leftBoundingEdges.length);\r\n                                    rightBoundingEdges.splice(0, rightBoundingEdges.length);\r\n                                    vertexDown = currVertex;\r\n                                    tempEdgeDownUp.originVertex = vertexDown;\r\n                                    currObjet = EVertex(vertexDown);\r\n                                }\r\n                                else \r\n                                {\r\n                                    //Debug.trace(\"edge is not constrained\");\r\n                                    intersectedEdges.push(edgeLeft);\r\n                                    leftBoundingEdges.unshift(edgeLeft.nextLeftEdge);\r\n                                    currEdge = edgeLeft.oppositeEdge;  // we keep the edge from left to right  \r\n                                    currObjet = EEdge(currEdge);\r\n                                }\r\n                            }\r\n                            else \r\n                            {\r\n                                //Debug.trace(\"2nd left edge intersected\");\r\n                                edgeLeft = edgeLeft.nextLeftEdge;\r\n                                Geom2D.intersections2edges(edgeLeft, tempEdgeDownUp, pIntersect);\r\n                                if (edgeLeft.isConstrained) \r\n                                {\r\n                                    //Debug.trace(\"edge is constrained\");\r\n                                    currVertex = splitEdge(edgeLeft, pIntersect.x, pIntersect.y);\r\n\r\n                                    iterVertexToOutEdges.fromVertex = currVertex;\r\n                                    while ((currEdge = iterVertexToOutEdges.next())!=null )\r\n                                    {\r\n                                        if (currEdge.destinationVertex == leftBoundingEdges[0].originVertex) \r\n                                        {\r\n                                            leftBoundingEdges.unshift(currEdge);\r\n                                        }\r\n                                        if (currEdge.destinationVertex == rightBoundingEdges[rightBoundingEdges.length - 1].destinationVertex) \r\n                                        {\r\n                                            rightBoundingEdges.push(currEdge.oppositeEdge);\r\n                                        }\r\n                                    }\r\n\r\n                                    newEdgeDownUp = new Edge();\r\n                                    newEdgeUpDown = new Edge();\r\n                                    newEdgeDownUp.setDatas(vertexDown, newEdgeUpDown, null, null, true, true);\r\n                                    newEdgeUpDown.setDatas(currVertex, newEdgeDownUp, null, null, true, true);\r\n                                    leftBoundingEdges.push(newEdgeDownUp);\r\n                                    rightBoundingEdges.push(newEdgeUpDown);\r\n                                    insertNewConstrainedEdge(segment, newEdgeDownUp, intersectedEdges, leftBoundingEdges, rightBoundingEdges);\r\n\r\n                                    intersectedEdges.splice(0, intersectedEdges.length);\r\n                                    leftBoundingEdges.splice(0, leftBoundingEdges.length);\r\n                                    rightBoundingEdges.splice(0, rightBoundingEdges.length);\r\n                                    vertexDown = currVertex;\r\n                                    tempEdgeDownUp.originVertex = vertexDown;\r\n                                    currObjet = EVertex(vertexDown);\r\n                                }\r\n                                else \r\n                                {\r\n                                    //Debug.trace(\"edge is not constrained\");\r\n                                    intersectedEdges.push(edgeLeft);\r\n                                    rightBoundingEdges.push(edgeLeft.prevLeftEdge);\r\n                                    currEdge = edgeLeft.oppositeEdge;  // we keep the edge from left to right  \r\n                                    currObjet = EEdge(currEdge);\r\n                                }\r\n                            }\r\n                        }\r\n                    \r\n                case EFace( face ):\r\n                    //\r\n                case ENull:\r\n                    //\r\n            }\r\n     \r\n        }\r\n        \r\n        return segment;\r\n    }\r\n    \r\n     function insertNewConstrainedEdge(fromSegment : ConstraintSegment, edgeDownUp : Edge, intersectedEdges : Array<Edge>, leftBoundingEdges : Array<Edge>, rightBoundingEdges : Array<Edge>) : Void\r\n    {\r\n        //Debug.trace(\"insertNewConstrainedEdge\");\r\n        _edges.push(edgeDownUp);\r\n        _edges.push(edgeDownUp.oppositeEdge);\r\n        \r\n        edgeDownUp.addFromConstraintSegment(fromSegment);\r\n        edgeDownUp.oppositeEdge.fromConstraintSegments = edgeDownUp.fromConstraintSegments;\r\n        \r\n        fromSegment.addEdge(edgeDownUp);\r\n        \r\n        edgeDownUp.originVertex.addFromConstraintSegment(fromSegment);\r\n        edgeDownUp.destinationVertex.addFromConstraintSegment(fromSegment);\r\n        \r\n        untriangulate(intersectedEdges);\r\n        \r\n        triangulate(leftBoundingEdges, true);\r\n        triangulate(rightBoundingEdges, true);\r\n    }\r\n    \r\n    public function deleteConstraintSegment(segment : ConstraintSegment) : Void\r\n    {\r\n        //Debug.trace(\"deleteConstraintSegment id \" + segment.id);\r\n        var i : Int;\r\n        var vertexToDelete : Array<Vertex> = new Array<Vertex>();\r\n        var edge : Edge = null;\r\n        var vertex : Vertex;\r\n        var fromConstraintSegment : Array<ConstraintSegment>;\r\n        for (i in 0...segment.edges.length){\r\n            edge = segment.edges[i];\r\n            //Debug.trace(\"unconstrain edge \" + edge);\r\n            edge.removeFromConstraintSegment(segment);\r\n            if (edge.fromConstraintSegments.length == 0) \r\n            {\r\n                edge.isConstrained = false;\r\n                edge.oppositeEdge.isConstrained = false;\r\n            }\r\n            \r\n            vertex = edge.originVertex;\r\n            vertex.removeFromConstraintSegment(segment);\r\n            vertexToDelete.push(vertex);\r\n        }\r\n\t\t\r\n\t\t//if (edge != null) {\r\n\t\t\tvertex = edge.destinationVertex;\r\n\t\t\tvertex.removeFromConstraintSegment(segment);\r\n\t\t\tvertexToDelete.push(vertex);\r\n        //}\r\n\t\t\r\n        //Debug.trace(\"clean the useless vertices\");\r\n        for (i in 0...vertexToDelete.length){\r\n            deleteVertex(vertexToDelete[i]);\r\n        }  //Debug.trace(\"clean done\");  \r\n        \r\n        \r\n        \r\n        segment.dispose();\r\n    }\r\n    \r\n     function check() : Void\r\n    {\r\n        for (i in 0..._edges.length){\r\n            if( _edges[i].nextLeftEdge == null ) \r\n            {\r\n                Debug.trace(\"!!! missing nextLeftEdge\");\r\n                return;\r\n            }\r\n        }\r\n        Debug.trace(\"check OK\");\r\n    }\r\n    \r\n    public function insertVertex(x : Float, y : Float) : Vertex\r\n    {\r\n        //Debug.trace(\"insertVertex \" + x + \",\" + y);\r\n        if (x < 0 || y < 0 || x > _width || y > _height) return null;\r\n        \r\n        __edgesToCheck.splice(0, __edgesToCheck.length);\r\n        \r\n        var inObject = Geom2D.locatePosition(x, y, this);\r\n        var newVertex : Vertex = null;\r\n        \r\n        switch( inObject ){\r\n            case EVertex( vertex ):\r\n                //Debug.trace(\"inVertex \" + vertex.id);\r\n                newVertex = vertex;\r\n            case EEdge( edge ):\r\n                //Debug.trace(\"inEdge \" + edge);\r\n                newVertex = splitEdge(edge, x, y);\r\n            case EFace( face ):\r\n                //Debug.trace(\"inFace \" + face );\r\n                newVertex = splitFace(face, x, y);\r\n            case ENull:\r\n                //Debug.trace('nothing!');\r\n        }\r\n        \r\n        restoreAsDelaunay();\r\n        \r\n        return newVertex;\r\n    }\r\n    \r\n    public function flipEdge(edge : Edge) : Edge\r\n    {\r\n        // retrieve and create useful objets\r\n        var eBot_Top = edge;\r\n        var eTop_Bot  = edge.oppositeEdge;\r\n        var eLeft_Right = new Edge();\r\n        var eRight_Left = new Edge();\r\n        var eTop_Left = eBot_Top.nextLeftEdge;\r\n        var eLeft_Bot= eTop_Left.nextLeftEdge;\r\n        var eBot_Right = eTop_Bot.nextLeftEdge;\r\n        var eRight_Top = eBot_Right.nextLeftEdge;\r\n        \r\n        var vBot  = eBot_Top.originVertex;\r\n        var vTop  = eTop_Bot.originVertex;\r\n        var vLeft  = eLeft_Bot.originVertex;\r\n        var vRight = eRight_Top.originVertex;\r\n        \r\n        var fLeft = eBot_Top.leftFace;\r\n        var fRight  = eTop_Bot.leftFace;\r\n        var fBot  = new Face();\r\n        var fTop = new Face();\r\n        \r\n        // add the new edges\r\n        _edges.push(eLeft_Right);\r\n        _edges.push(eRight_Left);\r\n        \r\n        // add the new faces\r\n        _faces.push(fTop);\r\n        _faces.push(fBot);\r\n        \r\n        // set vertex, edge and face references for the new LEFT_RIGHT and RIGHT-LEFT edges\r\n        eLeft_Right.setDatas(vLeft, eRight_Left, eRight_Top, fTop, edge.isReal, edge.isConstrained);\r\n        eRight_Left.setDatas(vRight, eLeft_Right, eLeft_Bot, fBot, edge.isReal, edge.isConstrained);\r\n        \r\n        // set edge references for the new TOP and BOTTOM faces\r\n        fTop.setDatas(eLeft_Right);\r\n        fBot.setDatas(eRight_Left);\r\n        \r\n        // check the edge references of TOP and BOTTOM vertices\r\n        if (vTop.edge == eTop_Bot) {\r\n            vTop.setDatas(eTop_Left);\r\n        }\r\n        if (vBot.edge == eBot_Top) {\r\n            vBot.setDatas(eBot_Right) ; // set the new edge and face references for the 4 bouding edges  ;\r\n        }\r\n        \r\n        \r\n        eTop_Left.nextLeftEdge = eLeft_Right;\r\n        eTop_Left.leftFace = fTop;\r\n        eLeft_Bot.nextLeftEdge = eBot_Right;\r\n        eLeft_Bot.leftFace = fBot;\r\n        eBot_Right.nextLeftEdge = eRight_Left;\r\n        eBot_Right.leftFace = fBot;\r\n        eRight_Top.nextLeftEdge = eTop_Left;\r\n        eRight_Top.leftFace = fTop;\r\n        \r\n        // remove the old TOP-BOTTOM and BOTTOM-TOP edges\r\n        eBot_Top.dispose();\r\n        eTop_Bot.dispose();\r\n        _edges.splice(_edges.indexOf(eBot_Top), 1);\r\n        _edges.splice(_edges.indexOf(eTop_Bot), 1);\r\n        \r\n        // remove the old LEFT and RIGHT faces\r\n        fLeft.dispose();\r\n        fRight.dispose();\r\n        _faces.splice(_faces.indexOf(fLeft), 1);\r\n        _faces.splice(_faces.indexOf(fRight), 1);\r\n        \r\n        return eRight_Left;\r\n    }\r\n    \r\n    public function splitEdge(edge : Edge, x : Float, y : Float) : Vertex\r\n    {\r\n        // empty old references\r\n        __edgesToCheck.splice(0, __edgesToCheck.length);\r\n        \r\n        // retrieve useful objets\r\n        var eLeft_Right = edge;\r\n        var eRight_Left= eLeft_Right.oppositeEdge;\r\n        var eRight_Top  = eLeft_Right.nextLeftEdge;\r\n        var eTop_Left  = eRight_Top.nextLeftEdge;\r\n        var eLeft_Bot  = eRight_Left.nextLeftEdge;\r\n        var eBot_Right = eLeft_Bot.nextLeftEdge;\r\n        \r\n        var vTop  = eTop_Left.originVertex;\r\n        var vLeft  = eLeft_Right.originVertex;\r\n        var vBot  = eBot_Right.originVertex;\r\n        var vRight = eRight_Left.originVertex;\r\n        \r\n        var fTop = eLeft_Right.leftFace;\r\n        var fBot = eRight_Left.leftFace;\r\n        \r\n        // check distance from the position to edge end points\r\n        if ((vLeft.pos.x - x) * (vLeft.pos.x - x) + (vLeft.pos.y - y) * (vLeft.pos.y - y) <= Constants.EPSILON_SQUARED) \r\n            return vLeft;\r\n        if ((vRight.pos.x - x) * (vRight.pos.x - x) + (vRight.pos.y - y) * (vRight.pos.y - y) <= Constants.EPSILON_SQUARED) \r\n            return vRight; // create new objects  ;\r\n        \r\n        \r\n        \r\n        var vCenter = new Vertex();\r\n        \r\n        var eTop_Center  = new Edge();\r\n        var eCenter_Top  = new Edge();\r\n        var eBot_Center = new Edge();\r\n        var eCenter_Bot = new Edge();\r\n        \r\n        var eLeft_Center  = new Edge();\r\n        var eCenter_Left  = new Edge();\r\n        var eRight_Center  = new Edge();\r\n        var eCenter_Right = new Edge();\r\n        \r\n        var fTopLeft  = new Face();\r\n        var fBotLeft  = new Face();\r\n        var fBotRight  = new Face();\r\n        var fTopRight  = new Face();\r\n        \r\n        // add the new vertex\r\n        _vertices.push(vCenter);\r\n        \r\n        // add the new edges\r\n        _edges.push(eCenter_Top);\r\n        _edges.push(eTop_Center);\r\n        _edges.push(eCenter_Left);\r\n        _edges.push(eLeft_Center);\r\n        _edges.push(eCenter_Bot);\r\n        _edges.push(eBot_Center);\r\n        _edges.push(eCenter_Right);\r\n        _edges.push(eRight_Center);\r\n        \r\n        // add the new faces\r\n        _faces.push(fTopRight);\r\n        _faces.push(fBotRight);\r\n        _faces.push(fBotLeft);\r\n        _faces.push(fTopLeft);\r\n        \r\n        // set pos and edge reference for the new CENTER vertex\r\n        vCenter.setDatas((fTop.isReal) ? eCenter_Top : eCenter_Bot);\r\n        vCenter.pos.x = x;\r\n        vCenter.pos.y = y;\r\n        Geom2D.projectOrthogonaly(vCenter.pos, eLeft_Right);\r\n        \r\n        // set the new vertex, edge and face references for the new 8 center crossing edges\r\n        eCenter_Top.setDatas(vCenter, eTop_Center, eTop_Left, fTopLeft, fTop.isReal);\r\n        eTop_Center.setDatas(vTop, eCenter_Top, eCenter_Right, fTopRight, fTop.isReal);\r\n        eCenter_Left.setDatas(vCenter, eLeft_Center, eLeft_Bot, fBotLeft, edge.isReal, edge.isConstrained);\r\n        eLeft_Center.setDatas(vLeft, eCenter_Left, eCenter_Top, fTopLeft, edge.isReal, edge.isConstrained);\r\n        eCenter_Bot.setDatas(vCenter, eBot_Center, eBot_Right, fBotRight, fBot.isReal);\r\n        eBot_Center.setDatas(vBot, eCenter_Bot, eCenter_Left, fBotLeft, fBot.isReal);\r\n        eCenter_Right.setDatas(vCenter, eRight_Center, eRight_Top, fTopRight, edge.isReal, edge.isConstrained);\r\n        eRight_Center.setDatas(vRight, eCenter_Right, eCenter_Bot, fBotRight, edge.isReal, edge.isConstrained);\r\n        \r\n        // set the new edge references for the new 4 faces\r\n        fTopLeft.setDatas(eCenter_Top, fTop.isReal);\r\n        fBotLeft.setDatas(eCenter_Left, fBot.isReal);\r\n        fBotRight.setDatas(eCenter_Bot, fBot.isReal);\r\n        fTopRight.setDatas(eCenter_Right, fTop.isReal);\r\n        \r\n        // check the edge references of LEFT and RIGHT vertices\r\n        if( vLeft.edge == eLeft_Right ) vLeft.setDatas(eLeft_Center);\r\n        if( vRight.edge == eRight_Left ) vRight.setDatas(eRight_Center);  // set the new edge and face references for the 4 bounding edges  ;\r\n        \r\n        \r\n        \r\n        eTop_Left.nextLeftEdge = eLeft_Center;\r\n        eTop_Left.leftFace = fTopLeft;\r\n        eLeft_Bot.nextLeftEdge = eBot_Center;\r\n        eLeft_Bot.leftFace = fBotLeft;\r\n        eBot_Right.nextLeftEdge = eRight_Center;\r\n        eBot_Right.leftFace = fBotRight;\r\n        eRight_Top.nextLeftEdge = eTop_Center;\r\n        eRight_Top.leftFace = fTopRight;\r\n        \r\n        // if the edge was constrained, we must:\r\n        // - add the segments the edge is from to the 2 new\r\n        // - update the segments the edge is from by deleting the old edge and inserting the 2 new\r\n        // - add the segments the edge is from to the new vertex\r\n        if (eLeft_Right.isConstrained) \r\n        {\r\n            var fromSegments  = eLeft_Right.fromConstraintSegments;\r\n            eLeft_Center.fromConstraintSegments = fromSegments.slice(0);\r\n            eCenter_Left.fromConstraintSegments = eLeft_Center.fromConstraintSegments;\r\n            eCenter_Right.fromConstraintSegments = fromSegments.slice(0);\r\n            eRight_Center.fromConstraintSegments = eCenter_Right.fromConstraintSegments;\r\n            \r\n            var edges : Array<Edge>;\r\n            var index : Int;\r\n            for (i in 0...eLeft_Right.fromConstraintSegments.length){\r\n                edges = eLeft_Right.fromConstraintSegments[i].edges;\r\n                index = edges.indexOf(eLeft_Right);\r\n                if (index != -1) {\r\n                    //TODO: check logic of insert\r\n                    edges.splice( index, 1 );\r\n                    edges.insert( index, eLeft_Center );\r\n                    edges.insert( index+1, eCenter_Right );\r\n                } else { \r\n                    var index2 = edges.indexOf(eRight_Left );\r\n                    //TODO: check logic of insert\r\n                    edges.splice( index2, 1);\r\n                    edges.insert( index2, eRight_Center );\r\n                    edges.insert( index2, eCenter_Left );\r\n                }\r\n            }\r\n            \r\n            vCenter.fromConstraintSegments = fromSegments.slice(0);\r\n        }  // remove the old LEFT-RIGHT and RIGHT-LEFT edges  \r\n        \r\n        \r\n        \r\n        eLeft_Right.dispose();\r\n        eRight_Left.dispose();\r\n        _edges.splice(_edges.indexOf(eLeft_Right), 1);\r\n        _edges.splice(_edges.indexOf(eRight_Left), 1);\r\n        \r\n        // remove the old TOP and BOTTOM faces\r\n        fTop.dispose();\r\n        fBot.dispose();\r\n        _faces.splice(_faces.indexOf(fTop), 1);\r\n        _faces.splice(_faces.indexOf(fBot), 1);\r\n        \r\n        // add new bounds references for Delaunay restoring\r\n        __centerVertex = vCenter;\r\n        __edgesToCheck.push(eTop_Left);\r\n        __edgesToCheck.push(eLeft_Bot);\r\n        __edgesToCheck.push(eBot_Right);\r\n        __edgesToCheck.push(eRight_Top);\r\n        \r\n        return vCenter;\r\n    }\r\n    \r\n    public function splitFace(face : Face, x : Float, y : Float) : Vertex\r\n    {\r\n        // empty old references\r\n        __edgesToCheck.splice(0, __edgesToCheck.length);\r\n        \r\n        // retrieve useful objects\r\n        var eTop_Left  = face.edge;\r\n        var eLeft_Right  = eTop_Left.nextLeftEdge;\r\n        var eRight_Top = eLeft_Right.nextLeftEdge;\r\n        \r\n        var vTop = eTop_Left.originVertex;\r\n        var vLeft  = eLeft_Right.originVertex;\r\n        var vRight = eRight_Top.originVertex;\r\n        \r\n        // create new objects\r\n        var vCenter = new Vertex();\r\n        \r\n        var eTop_Center = new Edge();\r\n        var eCenter_Top = new Edge();\r\n        var eLeft_Center  = new Edge();\r\n        var eCenter_Left  = new Edge();\r\n        var eRight_Center  = new Edge();\r\n        var eCenter_Right  = new Edge();\r\n        \r\n        var fTopLeft = new Face();\r\n        var fBot = new Face();\r\n        var fTopRight = new Face();\r\n        \r\n        // add the new vertex\r\n        _vertices.push(vCenter);\r\n        \r\n        // add the new edges\r\n        _edges.push(eTop_Center);\r\n        _edges.push(eCenter_Top);\r\n        _edges.push(eLeft_Center);\r\n        _edges.push(eCenter_Left);\r\n        _edges.push(eRight_Center);\r\n        _edges.push(eCenter_Right);\r\n        \r\n        // add the new faces\r\n        _faces.push(fTopLeft);\r\n        _faces.push(fBot);\r\n        _faces.push(fTopRight);\r\n        \r\n        // set pos and edge reference for the new CENTER vertex\r\n        vCenter.setDatas(eCenter_Top);\r\n        vCenter.pos.x = x;\r\n        vCenter.pos.y = y;\r\n        \r\n        // set the new vertex, edge and face references for the new 6 center crossing edges\r\n        eTop_Center.setDatas(vTop, eCenter_Top, eCenter_Right, fTopRight);\r\n        eCenter_Top.setDatas(vCenter, eTop_Center, eTop_Left, fTopLeft);\r\n        eLeft_Center.setDatas(vLeft, eCenter_Left, eCenter_Top, fTopLeft);\r\n        eCenter_Left.setDatas(vCenter, eLeft_Center, eLeft_Right, fBot);\r\n        eRight_Center.setDatas(vRight, eCenter_Right, eCenter_Left, fBot);\r\n        eCenter_Right.setDatas(vCenter, eRight_Center, eRight_Top, fTopRight);\r\n        \r\n        // set the new edge references for the new 3 faces\r\n        fTopLeft.setDatas(eCenter_Top);\r\n        fBot.setDatas(eCenter_Left);\r\n        fTopRight.setDatas(eCenter_Right);\r\n        \r\n        // set the new edge and face references for the 3 bounding edges\r\n        eTop_Left.nextLeftEdge = eLeft_Center;\r\n        eTop_Left.leftFace = fTopLeft;\r\n        eLeft_Right.nextLeftEdge = eRight_Center;\r\n        eLeft_Right.leftFace = fBot;\r\n        eRight_Top.nextLeftEdge = eTop_Center;\r\n        eRight_Top.leftFace = fTopRight;\r\n        \r\n        // we remove the old face\r\n        face.dispose();\r\n        _faces.splice(_faces.indexOf(face), 1);\r\n        \r\n        // add new bounds references for Delaunay restoring\r\n        __centerVertex = vCenter;\r\n        __edgesToCheck.push(eTop_Left);\r\n        __edgesToCheck.push(eLeft_Right);\r\n        __edgesToCheck.push(eRight_Top);\r\n        \r\n        return vCenter;\r\n    }\r\n    \r\n    public function restoreAsDelaunay() : Void\r\n    {\r\n        var edge : Edge;\r\n        while( __edgesToCheck.length > 0 )\r\n        {\r\n            edge = __edgesToCheck.shift();\r\n            if (edge.isReal && !edge.isConstrained && !Geom2D.isDelaunay(edge)) \r\n            {\r\n                if (edge.nextLeftEdge.destinationVertex == __centerVertex) \r\n                {\r\n                    __edgesToCheck.push(edge.nextRightEdge);\r\n                    __edgesToCheck.push(edge.prevRightEdge);\r\n                }\r\n                else \r\n                {\r\n                    __edgesToCheck.push(edge.nextLeftEdge);\r\n                    __edgesToCheck.push(edge.prevLeftEdge);\r\n                }\r\n                flipEdge(edge);\r\n            }\r\n        }\r\n    }\r\n    \r\n    // Delete a vertex IF POSSIBLE and then fill the hole with a new triangulation.\r\n    // A vertex can be deleted if:\r\n    // - it is free of constraint segment (no adjacency to any constrained edge)\r\n    // - it is adjacent to exactly 2 contrained edges and is not an end point of any constraint segment\r\n    public function deleteVertex(vertex : Vertex) : Bool\r\n    {\r\n        //Debug.trace(\"tryToDeleteVertex id \" + vertex.id);\r\n        var i : Int;\r\n        var freeOfConstraint : Bool;\r\n        var iterEdges : FromVertexToOutgoingEdges = new FromVertexToOutgoingEdges();\r\n        iterEdges.fromVertex = vertex;\r\n        iterEdges.realEdgesOnly = false;\r\n        var edge : Edge;\r\n        var outgoingEdges = new Array<Edge>();\r\n        \r\n        freeOfConstraint = vertex.fromConstraintSegments.length == 0;\r\n        \r\n        //Debug.trace(\"  -> freeOfConstraint \" + freeOfConstraint);\r\n        \r\n        var bound  = new Array<Edge>();\r\n        \r\n        // declares moved out of if loop so haxe compiler knows they exist?\r\n        var realA : Bool = false;\r\n        var realB : Bool = false;\r\n        var boundA: Array<Edge> = [];\r\n        var boundB: Array<Edge> = [];\r\n        \r\n        if (freeOfConstraint) \r\n        {\r\n            while ((edge = iterEdges.next())!=null)\r\n            {\r\n                outgoingEdges.push(edge);\r\n                bound.push(edge.nextLeftEdge);\r\n            }\r\n        }\r\n        else \r\n        {\r\n            // we check if the vertex is an end point of a constraint segment\r\n            var edges : Array<Edge>;\r\n            for (i in 0...vertex.fromConstraintSegments.length){\r\n                edges = vertex.fromConstraintSegments[i].edges;\r\n                if (edges[0].originVertex == vertex || edges[edges.length - 1].destinationVertex == vertex) \r\n                {\r\n                    //Debug.trace(\"  -> is end point of a constraint segment\");\r\n                    return false;\r\n                }\r\n            }  // we check the count of adjacent constrained edges  \r\n            \r\n            \r\n            \r\n            var count : Int = 0;\r\n            while ((edge = iterEdges.next())!=null)\r\n            {\r\n                outgoingEdges.push(edge);\r\n                \r\n                if (edge.isConstrained) \r\n                {\r\n                    count++;\r\n                    if (count > 2) \r\n                    {\r\n                        //Debug.trace(\"  -> count of adjacent constrained edges \" + count);\r\n                        return false;\r\n                    }\r\n                }\r\n            }  //Debug.trace(\"process vertex deletion\");    // if not disqualified, then we can process  \r\n            \r\n            \r\n            \r\n            \r\n            /// TODO: Moved out of if loop so can be referenced later, not sure of full consequence\r\n            boundA = new Array<Edge>();\r\n            boundB = new Array<Edge>();\r\n            var constrainedEdgeA : Edge = null;\r\n            var constrainedEdgeB : Edge = null;\r\n            var edgeA = new Edge();\r\n            var edgeB = new Edge();\r\n            /// TODO: Moved out of if loop so can be referenced later, not sure of full consequence\r\n            ///var realA : Bool;\r\n            ///var realB : Bool;\r\n            _edges.push(edgeA);\r\n            _edges.push(edgeB);\r\n            for (i in 0...outgoingEdges.length){\r\n                edge = outgoingEdges[i];\r\n                if (edge.isConstrained) \r\n                {\r\n                    if (constrainedEdgeA == null) \r\n                    {\r\n                        edgeB.setDatas(edge.destinationVertex, edgeA, null, null, true, true);\r\n                        boundA.push(edgeA);\r\n                        boundA.push(edge.nextLeftEdge);\r\n                        boundB.push(edgeB);\r\n                        constrainedEdgeA = edge;\r\n                    }\r\n                    else if (constrainedEdgeB == null) \r\n                    {\r\n                        edgeA.setDatas(edge.destinationVertex, edgeB, null, null, true, true);\r\n                        boundB.push(edge.nextLeftEdge);\r\n                        constrainedEdgeB = edge;\r\n                    }\r\n                }\r\n                else \r\n                {\r\n                    if (constrainedEdgeA == null) \r\n                        boundB.push(edge.nextLeftEdge)\r\n                    else if (constrainedEdgeB == null) \r\n                        boundA.push(edge.nextLeftEdge)\r\n                    else \r\n                    boundB.push(edge.nextLeftEdge);\r\n                }\r\n            }  // keep infos about reality  \r\n            \r\n            \r\n            \r\n            realA = constrainedEdgeA.leftFace.isReal;\r\n            realB = constrainedEdgeB.leftFace.isReal;\r\n            \r\n            // we update the segments infos\r\n            edgeA.fromConstraintSegments = constrainedEdgeA.fromConstraintSegments.slice(0);\r\n            edgeB.fromConstraintSegments = edgeA.fromConstraintSegments;\r\n            var index : Int;\r\n            for (i in 0...vertex.fromConstraintSegments.length){\r\n                edges = vertex.fromConstraintSegments[i].edges;\r\n                index = edges.indexOf(constrainedEdgeA);\r\n                if (index != -1) \r\n                {\r\n                    edges.splice(index - 1, 2);\r\n                    //TODO: check logic of insert\r\n                    edges.insert(index - 1, edgeA);\r\n                }\r\n                else \r\n                {\r\n                    var index2 = edges.indexOf(constrainedEdgeB) - 1;\r\n                    edges.splice(index2, 2);\r\n                    edges.insert(index2, edgeB);\r\n                }\r\n            }\r\n        }  // Deletion of old faces and edges  \r\n        \r\n        \r\n        \r\n        var faceToDelete : Face;\r\n        for (i in 0...outgoingEdges.length){\r\n            edge = outgoingEdges[i];\r\n            \r\n            faceToDelete = edge.leftFace;\r\n            _faces.splice(_faces.indexOf(faceToDelete), 1);\r\n            faceToDelete.dispose();\r\n            \r\n            edge.destinationVertex.edge = edge.nextLeftEdge;\r\n            \r\n            _edges.splice(_edges.indexOf(edge.oppositeEdge), 1);\r\n            edge.oppositeEdge.dispose();\r\n            _edges.splice(_edges.indexOf(edge), 1);\r\n            edge.dispose();\r\n        }\r\n        \r\n        _vertices.splice(_vertices.indexOf(vertex), 1);\r\n        vertex.dispose();\r\n        \r\n        // finally we triangulate\r\n        if (freeOfConstraint) \r\n        {\r\n            //Debug.trace(\"trigger single hole triangulation\");\r\n            triangulate(bound, true);\r\n        }\r\n        else \r\n        {\r\n            //Debug.trace(\"trigger dual holes triangulation\");\r\n            triangulate(boundA, realA);\r\n            triangulate(boundB, realB);\r\n        }  //check();  \r\n        \r\n        \r\n        \r\n        return true;\r\n    }\r\n    \r\n    ///// PRIVATE\r\n    \r\n    \r\n    \r\n    // untriangulate is usually used while a new edge insertion in order to delete the intersected edges\r\n    // edgesList is a list of chained edges oriented from right to left\r\n     function untriangulate(edgesList : Array<Edge>) : Void\r\n    {\r\n        // we clean useless faces and adjacent vertices\r\n        var i : Int;\r\n        var verticesCleaned = new Map<Vertex,Bool>();\r\n        var currEdge : Edge;\r\n        var outEdge : Edge;\r\n        for (i in 0...edgesList.length){\r\n            currEdge = edgesList[i];\r\n            //\r\n            if (verticesCleaned[currEdge.originVertex]== null) \r\n            {\r\n                currEdge.originVertex.edge = currEdge.prevLeftEdge.oppositeEdge;\r\n                verticesCleaned[currEdge.originVertex] = true;\r\n            }\r\n            if (verticesCleaned[currEdge.destinationVertex]==null) \r\n            {\r\n                currEdge.destinationVertex.edge = currEdge.nextLeftEdge;\r\n                verticesCleaned[currEdge.destinationVertex] = true;\r\n            }  //  \r\n            \r\n            _faces.splice(_faces.indexOf(currEdge.leftFace), 1);\r\n            currEdge.leftFace.dispose();\r\n            if (i == edgesList.length - 1) \r\n            {\r\n                _faces.splice(_faces.indexOf(currEdge.rightFace), 1);\r\n                currEdge.rightFace.dispose();\r\n            }  //  \r\n        }  // finally we delete the intersected edges  \r\n        \r\n        \r\n        \r\n        for (i in 0...edgesList.length){\r\n            currEdge = edgesList[i];\r\n            _edges.splice(_edges.indexOf(currEdge.oppositeEdge), 1);\r\n            _edges.splice(_edges.indexOf(currEdge), 1);\r\n            currEdge.oppositeEdge.dispose();\r\n            currEdge.dispose();\r\n        }\r\n    }\r\n    \r\n    // triangulate is usually used to fill the hole after deletion of a vertex from mesh or after untriangulation\r\n    // - bounds is the list of edges in CCW bounding the surface to retriangulate,\r\n     function triangulate(bound : Array<Edge>, isReal : Bool) : Void\r\n    {\r\n        if (bound.length < 2) \r\n        {\r\n            Debug.trace(\"BREAK ! the hole has less than 2 edges\");\r\n            return;\r\n        }\r\n        // if the hole is a 2 edges polygon, we have a big problem\r\n        else if (bound.length == 2) \r\n        {\r\n            //throw new Error(\"BREAK ! the hole has only 2 edges! \" + \"  - edge0: \" + bound[0].originVertex.id + \" -> \" + bound[0].destinationVertex.id + \"  - edge1: \" +  bound[1].originVertex.id + \" -> \" + bound[1].destinationVertex.id);\r\n            Debug.trace(\"BREAK ! the hole has only 2 edges\");\r\n            Debug.trace(\"  - edge0: \" + bound[0].originVertex.id + \" -> \" + bound[0].destinationVertex.id);\r\n            Debug.trace(\"  - edge1: \" +  bound[1].originVertex.id + \" -> \" + bound[1].destinationVertex.id);\r\n            return;\r\n        }\r\n        // if the hole is a 3 edges polygon:\r\n        else if (bound.length == 3) \r\n        {\r\n            /*Debug.trace(\"the hole is a 3 edges polygon\");\r\n            Debug.trace(\"  - edge0: \" + bound[0].originVertex.id + \" -> \" + bound[0].destinationVertex.id);\r\n            Debug.trace(\"  - edge1: \" + bound[1].originVertex.id + \" -> \" + bound[1].destinationVertex.id);\r\n            Debug.trace(\"  - edge2: \" + bound[2].originVertex.id + \" -> \" + bound[2].destinationVertex.id);*/\r\n            var f = new Face();\r\n            f.setDatas(bound[0], isReal);\r\n            _faces.push(f);\r\n            bound[0].leftFace = f;\r\n            bound[1].leftFace = f;\r\n            bound[2].leftFace = f;\r\n            bound[0].nextLeftEdge = bound[1];\r\n            bound[1].nextLeftEdge = bound[2];\r\n            bound[2].nextLeftEdge = bound[0];\r\n        }\r\n        // if more than 3 edges, we process recursively:\r\n        else \r\n        {\r\n            //Debug.trace(\"the hole has \" + bound.length + \" edges\");\r\n            /*for (i in 0...bound.length){\r\n                //Debug.trace(\"  - edge \" + i + \": \" + bound[i].originVertex.id + \" -> \" + bound[i].destinationVertex.id);\r\n                \r\n            }*/\r\n            \r\n            var baseEdge = bound[0];\r\n            var vertexA = baseEdge.originVertex;\r\n            var vertexB = baseEdge.destinationVertex;\r\n            var vertexC : Vertex;\r\n            var vertexCheck : Vertex;\r\n            var circumcenter  = new Point2D();\r\n            var radiusSquared : Float;\r\n            var distanceSquared : Float;\r\n            var isDelaunay : Bool = false;\r\n            var index : Int = 0;\r\n            var i : Int;\r\n            for (i in 2...bound.length){\r\n                vertexC = bound[i].originVertex;\r\n                if (Geom2D.getRelativePosition2(vertexC.pos.x, vertexC.pos.y, baseEdge) == 1) \r\n                {\r\n                    index = i;\r\n                    isDelaunay = true;\r\n                    Geom2D.getCircumcenter(vertexA.pos.x, vertexA.pos.y, vertexB.pos.x, vertexB.pos.y, vertexC.pos.x, vertexC.pos.y, circumcenter);\r\n                    radiusSquared = (vertexA.pos.x - circumcenter.x) * (vertexA.pos.x - circumcenter.x) + (vertexA.pos.y - circumcenter.y) * (vertexA.pos.y - circumcenter.y);\r\n                    // for perfect regular n-sides polygons, checking strict delaunay circumcircle condition is not possible, so we substract EPSILON to circumcircle radius:\r\n                    radiusSquared -= Constants.EPSILON_SQUARED;\r\n                    for (j in 2...bound.length){\r\n                        if (j != i) \r\n                        {\r\n                            vertexCheck = bound[j].originVertex;\r\n                            distanceSquared = (vertexCheck.pos.x - circumcenter.x) * (vertexCheck.pos.x - circumcenter.x) + (vertexCheck.pos.y - circumcenter.y) * (vertexCheck.pos.y - circumcenter.y);\r\n                            if (distanceSquared < radiusSquared) \r\n                            {\r\n                                isDelaunay = false;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    \r\n                    if (isDelaunay) \r\n                        break;\r\n                }\r\n            }\r\n            \r\n            if (!isDelaunay) \r\n            {\r\n                // for perfect regular n-sides polygons, checking delaunay circumcircle condition is not possible\r\n                Debug.trace(\"NO DELAUNAY FOUND\");\r\n                var s : String = \"\";\r\n                for (i in 0...bound.length){\r\n                    s += bound[i].originVertex.pos.x + \" , \";\r\n                    s += bound[i].originVertex.pos.y + \" , \";\r\n                    s += bound[i].destinationVertex.pos.x + \" , \";\r\n                    s += bound[i].destinationVertex.pos.y + \" , \";\r\n                }  //Debug.trace(s);  \r\n                \r\n                \r\n                index = 2;\r\n            }  //Debug.trace(\"index \" + index + \" on \" + bound.length);  \r\n            \r\n            \r\n            var edgeA : Edge = null;\r\n            var edgeAopp : Edge = null;\r\n            var edgeB : Edge = null;\r\n            var edgeBopp : Edge;\r\n            var boundA : Array<Edge>;\r\n            var boundM : Array<Edge>;\r\n            \r\n            //TODO: is this correct??? should it be at **\r\n            var boundB : Array<Edge>;\r\n            \r\n            if (index < (bound.length - 1)) \r\n            {\r\n                edgeA = new Edge();\r\n                edgeAopp = new Edge();\r\n                _edges.push(edgeA);\r\n                _edges.push(edgeAopp);\r\n                edgeA.setDatas(vertexA, edgeAopp, null, null, isReal, false);\r\n                edgeAopp.setDatas(bound[index].originVertex, edgeA, null, null, isReal, false);\r\n                boundA = bound.slice(index);\r\n                boundA.push(edgeA);\r\n                triangulate(boundA, isReal);\r\n            }\r\n            \r\n            if (index > 2) \r\n            {\r\n                edgeB = new Edge();\r\n                edgeBopp = new Edge();\r\n                _edges.push(edgeB);\r\n                _edges.push(edgeBopp);\r\n                edgeB.setDatas(bound[1].originVertex, edgeBopp, null, null, isReal, false);\r\n                edgeBopp.setDatas(bound[index].originVertex, edgeB, null, null, isReal, false);\r\n                boundB = bound.slice(1, index);\r\n                boundB.push(edgeBopp);\r\n                triangulate(boundB, isReal);\r\n            }\r\n            // **\r\n            if( index == 2 ) {\r\n                boundM = [ baseEdge, bound[1], edgeAopp ];\r\n            } else if ( index == (bound.length - 1) ){ \r\n                boundM = [ baseEdge, edgeB, bound[index] ];\r\n            } else {  \r\n                boundM = [ baseEdge, edgeB, edgeAopp ];\r\n            }\r\n            \r\n            triangulate(boundM, isReal);\r\n        }\r\n    }\r\n    \r\n    \r\n     function findPositionFromBounds(x : Float, y : Float) : Int\r\n    {\r\n        /* point positions relative to bounds\r\n        1 | 2 | 3\r\n        ------------\r\n        8 | 0 | 4\r\n        ------------\r\n        7 | 6 | 5\r\n        */\r\n        \r\n        if( x <= 0 ) {\r\n            if( y <= 0 )             return 1\r\n            else if( y >= _height )  return 7\r\n            else                     return 8;\r\n        } else if( x >= _width ) {\r\n            if( y <= 0 )             return 3\r\n            else if( y >= _height )  return 5\r\n            else                     return 4;\r\n        } else {\r\n            if( y <= 0 )             return 2\r\n            else if( y >= _height )  return 6\r\n            else                     return 0;\r\n        }\r\n    }\r\n    \r\n    public function debug() : Void\r\n    {\r\n        var i : Int;\r\n        for (i in 0..._vertices.length){\r\n            Debug.trace(\"-- vertex \" + _vertices[i].id);\r\n            Debug.trace(\"  edge \" + _vertices[i].edge.id + \" - \" + _vertices[i].edge);\r\n            Debug.trace(\"  edge isReal: \" + _vertices[i].edge.isReal);\r\n        }\r\n        for (i in 0..._edges.length){\r\n            Debug.trace(\"-- edge \" + _edges[i]);\r\n            Debug.trace(\"  isReal \" + _edges[i].id + \" - \" + _edges[i].isReal);\r\n            Debug.trace(\"  nextLeftEdge \" + _edges[i].nextLeftEdge);\r\n            Debug.trace(\"  oppositeEdge \" + _edges[i].oppositeEdge);\r\n        }\r\n    }\r\n\t\r\n\tpublic function traverse(onVertex : Vertex->Void, onEdge : Edge->Void) : Void \r\n\t{\r\n        var vertex : Vertex;\r\n        var incomingEdge : Edge;\r\n        var holdingFace : Face;\r\n        \r\n        var iterVertices : FromMeshToVertices;\r\n        iterVertices = new FromMeshToVertices();\r\n        iterVertices.fromMesh = this;\r\n        \r\n        var iterEdges : FromVertexToIncomingEdges;\r\n        iterEdges = new FromVertexToIncomingEdges();\r\n        var dictVerticesDone = new Map<Vertex,Bool>();\r\n        \r\n        while ((vertex = iterVertices.next()) != null)\r\n        {\r\n            dictVerticesDone[vertex] = true;\r\n            if (!vertexIsInsideAABB(vertex, this)) \r\n                continue;  \r\n            \r\n\t\t\tonVertex(vertex);\r\n            \r\n            iterEdges.fromVertex = vertex;\r\n            while ((incomingEdge = iterEdges.next()) != null)\r\n            {\r\n                if (!dictVerticesDone[incomingEdge.originVertex]) \r\n                {\r\n\t\t\t\t\tonEdge(incomingEdge);\r\n                }\r\n            }\r\n        }\r\n\t}\r\n    \r\n    public function vertexIsInsideAABB(vertex : Vertex, mesh : Mesh) : Bool \r\n\t{\r\n        if (vertex.pos.x < 0 || vertex.pos.x > mesh.width || vertex.pos.y < 0 || vertex.pos.y > mesh.height) \r\n            return false\r\n        else \r\n\t\t\treturn true;\r\n    }\r\n}\r\n\r\n","package hxDaedalus.data;\r\n\r\n\r\nimport hxDaedalus.data.math.Matrix2D;\r\n\r\nclass Object {\r\n    public var id(get, never) : Int;\r\n    public var pivotX(get, set) : Float;\r\n    public var pivotY(get, set) : Float;\r\n    public var scaleX(get, set) : Float;\r\n    public var scaleY(get, set) : Float;\r\n    public var rotation(get, set) : Float;\r\n    public var x(get, set) : Float;\r\n    public var y(get, set) : Float;\r\n    public var matrix(get, set) : Matrix2D;\r\n    public var coordinates(get, set) : Array<Float>;\r\n    public var constraintShape(get, set) : ConstraintShape;\r\n    public var hasChanged(get, set) : Bool;\r\n    public var edges(get, never) : Array<Edge>;\r\n\r\n    \r\n     static var INC : Int = 0;\r\n     var _id : Int;\r\n    \r\n     var _matrix : Matrix2D;\r\n     var _coordinates : Array<Float>;\r\n     var _constraintShape : ConstraintShape;\r\n    \r\n     var _pivotX : Float;\r\n     var _pivotY : Float;\r\n    \r\n     var _scaleX : Float;\r\n     var _scaleY : Float;\r\n     var _rotation : Float;\r\n     var _x : Float;\r\n     var _y : Float;\r\n    \r\n     var _hasChanged : Bool;\r\n    \r\n    public function new(){\r\n        _id = INC;\r\n        INC++;\r\n        \r\n        _pivotX = 0;\r\n        _pivotY = 0;\r\n        \r\n        _matrix = new Matrix2D();\r\n        _scaleX = 1;\r\n        _scaleY = 1;\r\n        _rotation = 0;\r\n        _x = 0;\r\n        _y = 0;\r\n        \r\n        _coordinates = new Array<Float>();\r\n        \r\n        _hasChanged = false;\r\n    }\r\n    \r\n     function get_id(): Int {\r\n        return _id;\r\n    }\r\n    \r\n    public function dispose(): Void {\r\n        _matrix = null;\r\n        _coordinates = null;\r\n        _constraintShape = null;\r\n    }\r\n    \r\n    public function updateValuesFromMatrix(): Void {\r\n        \r\n        \r\n    }\r\n    \r\n    public function updateMatrixFromValues(): Void {\r\n        _matrix.identity();\r\n        _matrix.translate(-_pivotX, -_pivotY);\r\n        _matrix.scale(_scaleX, _scaleY);\r\n        _matrix.rotate(_rotation);\r\n        _matrix.translate(_x, _y);\r\n    }\r\n    \r\n     function get_pivotX(): Float {\r\n        return _pivotX;\r\n    }\r\n    \r\n     function set_pivotX( value: Float ): Float {\r\n        _pivotX = value;\r\n        _hasChanged = true;\r\n        return value;\r\n    }\r\n    \r\n     function get_pivotY(): Float {\r\n        return _pivotY;\r\n    }\r\n    \r\n     function set_pivotY( value: Float ): Float {\r\n        _pivotY = value;\r\n        _hasChanged = true;\r\n        return value;\r\n    }\r\n    \r\n     function get_scaleX(): Float {\r\n        return _scaleX;\r\n    }\r\n    \r\n     function set_scaleX( value: Float ): Float {\r\n        if( _scaleX != value ){\r\n            _scaleX = value;\r\n            _hasChanged = true;\r\n        }\r\n        return value;\r\n    }\r\n    \r\n     function get_scaleY(): Float {\r\n        return _scaleY;\r\n    }\r\n    \r\n     function set_scaleY( value: Float ): Float {\r\n        if( _scaleY != value ){\r\n            _scaleY = value;\r\n            _hasChanged = true;\r\n        }\r\n        return value;\r\n    }\r\n    \r\n     function get_rotation(): Float {\r\n        return _rotation;\r\n    }\r\n    \r\n     function set_rotation( value: Float ): Float {\r\n        if( _rotation != value ){\r\n            _rotation = value;\r\n            _hasChanged = true;\r\n        }\r\n        return value;\r\n    }\r\n    \r\n     function get_x(): Float {\r\n        return _x;\r\n    }\r\n    \r\n     function set_x( value : Float ): Float {\r\n        if( _x != value ){\r\n            _x = value;\r\n            _hasChanged = true;\r\n        }\r\n        return value;\r\n    }\r\n    \r\n     function get_y() : Float {\r\n        return _y;\r\n    }\r\n    \r\n     function set_y( value: Float ): Float {\r\n        if( _y != value ) {\r\n            _y = value;\r\n            _hasChanged = true;\r\n        }\r\n        return value;\r\n    }\r\n    \r\n     function get_matrix(): Matrix2D {\r\n        return _matrix;\r\n    }\r\n    \r\n     function set_matrix( value: Matrix2D ): Matrix2D {\r\n        _matrix = value;\r\n        _hasChanged = true;\r\n        return value;\r\n    }\r\n    \r\n     function get_coordinates(): Array<Float> {\r\n        return _coordinates;\r\n    }\r\n    \r\n     function set_coordinates( value: Array<Float> ): Array<Float> {\r\n        _coordinates = value;\r\n        _hasChanged = true;\r\n        return value;\r\n    }\r\n    \r\n     function get_constraintShape(): ConstraintShape\r\n    {\r\n        return _constraintShape;\r\n    }\r\n    \r\n     function set_constraintShape( value: ConstraintShape ): ConstraintShape {\r\n        _constraintShape = value;\r\n        _hasChanged = true;\r\n        return value;\r\n    }\r\n    \r\n     function get_hasChanged(): Bool {\r\n        return _hasChanged;\r\n    }\r\n    \r\n     function set_hasChanged( value: Bool ): Bool {\r\n        _hasChanged = value;\r\n        return value;\r\n    }\r\n    \r\n     function get_edges(): Array<Edge> {\r\n        \r\n        var res = new Array<Edge>();\r\n        var seg = _constraintShape.segments;\r\n        for( i in 0...seg.length ){\r\n            for( j in 0...seg[ i ].edges.length ){\r\n                res.push( seg[ i ].edges[ j ] );\r\n            }\r\n        }\r\n        \r\n        return res;\r\n    }\r\n}\r\n","package hxDaedalus.data;\r\nimport hxDaedalus.data.math.Point2D;\r\n\r\nclass Vertex\r\n{\r\n    public var id(get, never) : Int;\r\n    public var isReal(get, never) : Bool;\r\n    public var pos(get, never) : Point2D;\r\n    public var fromConstraintSegments(get, set) : Array<ConstraintSegment>;\r\n    public var edge(get, set) : Edge;\r\n\r\n    \r\n     static var INC : Int = 0;\r\n     var _id : Int;\r\n    \r\n     var _pos : Point2D;\r\n    \r\n     var _isReal : Bool;\r\n     var _edge : Edge;\r\n    \r\n     var _fromConstraintSegments : Array<ConstraintSegment>;\r\n    \r\n    public var colorDebug : Int = -1;\r\n    \r\n    public function new()\r\n    {\r\n        _id = INC;\r\n        INC++;\r\n        \r\n        _pos = new Point2D();\r\n        \r\n        _fromConstraintSegments = new Array<ConstraintSegment>();\r\n    }\r\n    \r\n     function get_id() : Int\r\n    {\r\n        return _id;\r\n    }\r\n    \r\n     function get_isReal() : Bool\r\n    {\r\n        return _isReal;\r\n    }\r\n    \r\n     function get_pos() : Point2D\r\n    {\r\n        return _pos;\r\n    }\r\n    \r\n     function get_fromConstraintSegments():Array<ConstraintSegment>{\r\n        return _fromConstraintSegments;\r\n    }\r\n    \r\n     function set_fromConstraintSegments(value:Array<ConstraintSegment>):Array<ConstraintSegment> {\r\n        return _fromConstraintSegments = value;\r\n    }\r\n    \r\n    public function setDatas(edge : Edge, isReal : Bool = true) : Void\r\n    {\r\n        _isReal = isReal;\r\n        _edge = edge;\r\n    }\r\n    \r\n    public function addFromConstraintSegment(segment : ConstraintSegment): Void {\r\n        if (_fromConstraintSegments.indexOf(segment) == -1) _fromConstraintSegments.push(segment);\r\n    }\r\n    \r\n    public function removeFromConstraintSegment(segment : ConstraintSegment) : Void\r\n    {\r\n        var index : Int = _fromConstraintSegments.indexOf(segment);\r\n        if (index != -1) \r\n            _fromConstraintSegments.splice(index, 1);\r\n    }\r\n    \r\n    public function dispose() : Void\r\n    {\r\n        _pos = null;\r\n        _edge = null;\r\n        _fromConstraintSegments = null;\r\n    }\r\n    \r\n     function get_edge():Edge {\r\n        return _edge;\r\n    }\r\n    \r\n     function set_edge(value:Edge):Edge {\r\n        return _edge = value;\r\n    }\r\n\r\n    public function toString(): String {\r\n        return \"ver_id \" + _id;\r\n    }\r\n}\r\n","package hxDaedalus.data.graph;\r\n\r\nimport hxDaedalus.data.graph.GraphEdge;\r\nimport hxDaedalus.data.graph.GraphNode;\r\n\r\nclass Graph\r\n{\r\n    public var id( get, never ) : Int;\r\n    function get_id(): Int { return _id; }\r\n    public var edge( get, never ) : GraphEdge;\r\n    function get_edge(): GraphEdge { return _edge; }\r\n    public var node( get, never ) : GraphNode;\r\n    function get_node(): GraphNode { return _node; }\r\n    static var INC : Int = 0;\r\n    var _id: Int;\r\n    var _node: GraphNode;\r\n    var _edge: GraphEdge;\r\n    \r\n    public function new(){\r\n        _id = INC;\r\n        INC++;\r\n    }\r\n    \r\n    public function dispose(): Void {\r\n        while( _node != null ) deleteNode( _node );\r\n    }\r\n    \r\n    public function insertNode(): GraphNode {\r\n        var node = new GraphNode();\r\n        if( _node != null ){\r\n            node.next = _node;\r\n            _node.prev = node;\r\n        }\r\n        _node = node;\r\n        return node;\r\n    }\r\n    \r\n    public function deleteNode( node: GraphNode ): Void {\r\n        while( node.outgoingEdge != null ){\r\n            if( node.outgoingEdge.oppositeEdge != null ) deleteEdge( node.outgoingEdge.oppositeEdge );\r\n            deleteEdge(node.outgoingEdge);\r\n        }\r\n        \r\n        var otherNode = _node;\r\n        var incomingEdge : GraphEdge;\r\n        while ( otherNode != null ){\r\n            incomingEdge = otherNode.successorNodes[ node ];\r\n            if( incomingEdge != null ) deleteEdge( incomingEdge );\r\n            otherNode = otherNode.next;\r\n        }\r\n        \r\n        if( _node == node ){\r\n            if( node.next != null ){\r\n                node.next.prev = null;\r\n                _node = node.next;\r\n            } else {\r\n                _node = null;\r\n            }\r\n        } else {\r\n            if( node.next != null ) {\r\n                node.prev.next = node.next;\r\n                node.next.prev = node.prev;\r\n            } else {\r\n                node.prev.next = null;\r\n            }\r\n        }\r\n        \r\n        node.dispose();\r\n    }\r\n    \r\n    public function insertEdge( fromNode: GraphNode, toNode: GraphNode ): GraphEdge {\r\n        if( fromNode.successorNodes[ toNode ] != null ) return null;\r\n        \r\n        var edge = new GraphEdge();\r\n        if( _edge != null ){\r\n            _edge.prev = edge;\r\n            edge.next = _edge;\r\n        }\r\n        _edge = edge;\r\n        \r\n        edge.sourceNode = fromNode;\r\n        edge.destinationNode = toNode;\r\n        fromNode.successorNodes[ toNode ] = edge;\r\n        if( fromNode.outgoingEdge != null ) {\r\n            fromNode.outgoingEdge.rotPrevEdge = edge;\r\n            edge.rotNextEdge = fromNode.outgoingEdge;\r\n            fromNode.outgoingEdge = edge;\r\n        } else {\r\n            fromNode.outgoingEdge = edge;\r\n        }\r\n        \r\n        var oppositeEdge = toNode.successorNodes[ fromNode ];\r\n        if( oppositeEdge != null ){\r\n            edge.oppositeEdge = oppositeEdge;\r\n            oppositeEdge.oppositeEdge = edge;\r\n        }\r\n        \r\n        return edge;\r\n    }\r\n    \r\n    public function deleteEdge( edge: GraphEdge ): Void {\r\n        if( _edge == edge ){\r\n            if( edge.next != null ){\r\n                edge.next.prev = null;\r\n                _edge = edge.next;\r\n            } else {\r\n                _edge = null;\r\n            }\r\n        } else {\r\n            if( edge.next != null ){\r\n                edge.prev.next = edge.next;\r\n                edge.next.prev = edge.prev;\r\n            } else {\r\n                edge.prev.next = null;\r\n            }\r\n        }\r\n        \r\n        if( edge.sourceNode.outgoingEdge == edge ) {\r\n            if( edge.rotNextEdge != null ){\r\n                edge.rotNextEdge.rotPrevEdge = null;\r\n                edge.sourceNode.outgoingEdge = edge.rotNextEdge;\r\n            } else {\r\n                edge.sourceNode.outgoingEdge = null;\r\n            }\r\n        } else {\r\n            if( edge.rotNextEdge != null ){\r\n                edge.rotPrevEdge.rotNextEdge = edge.rotNextEdge;\r\n                edge.rotNextEdge.rotPrevEdge = edge.rotPrevEdge;\r\n            } else {\r\n                edge.rotPrevEdge.rotNextEdge = null;\r\n            }\r\n        }\r\n        edge.dispose();\r\n    }\r\n}\r\n","package hxDaedalus.data.graph;\r\n\r\nimport hxDaedalus.data.graph.GraphNode;\r\nimport hxDaedalus.data.math.EdgeData;\r\n\r\nclass GraphEdge\r\n{\r\n    public var id( get, never ): Int;\r\n    function get_id(): Int { return _id; }\r\n    public var prev( get, set ): GraphEdge;\r\n    public var next( get, set ): GraphEdge;\r\n    public var rotPrevEdge( get, set ): GraphEdge;\r\n    public var rotNextEdge( get, set ): GraphEdge;\r\n    public var oppositeEdge( get, set ): GraphEdge;\r\n    public var sourceNode( get, set ): GraphNode;\r\n    public var destinationNode( get, set ): GraphNode;\r\n    public var data( get, set ): EdgeData;\r\n    static var INC: Int = 0;\r\n    var _id: Int;\r\n    var _prev: GraphEdge;\r\n    var _next: GraphEdge;\r\n    var _rotPrevEdge: GraphEdge;\r\n    var _rotNextEdge: GraphEdge;\r\n    var _oppositeEdge: GraphEdge;\r\n    var _sourceNode: GraphNode;\r\n    var _destinationNode: GraphNode;\r\n    var _data: EdgeData;\r\n    \r\n    public function new(){\r\n        _id = INC;\r\n        INC++;\r\n    }\r\n    \r\n    public function dispose(): Void {}\r\n    \r\n    function get_prev(): GraphEdge {\r\n        return _prev;\r\n    }\r\n    \r\n    function set_prev( value: GraphEdge ): GraphEdge {\r\n        _prev = value;\r\n        return value;\r\n    }\r\n    \r\n     function get_next(): GraphEdge {\r\n        return _next;\r\n    }\r\n    \r\n    function set_next( value: GraphEdge ): GraphEdge {\r\n        _next = value;\r\n        return value;\r\n    }\r\n    \r\n    function get_rotPrevEdge(): GraphEdge {\r\n        return _rotPrevEdge;\r\n    }\r\n    \r\n     function set_rotPrevEdge( value: GraphEdge ) : GraphEdge\r\n    {\r\n        _rotPrevEdge = value;\r\n        return value;\r\n    }\r\n    \r\n     function get_rotNextEdge(): GraphEdge {\r\n        return _rotNextEdge;\r\n    }\r\n    \r\n     function set_rotNextEdge( value: GraphEdge ): GraphEdge {\r\n        _rotNextEdge = value;\r\n        return value;\r\n    }\r\n    \r\n     function get_oppositeEdge(): GraphEdge {\r\n        return _oppositeEdge;\r\n    }\r\n    \r\n     function set_oppositeEdge( value: GraphEdge ): GraphEdge\r\n    {\r\n        _oppositeEdge = value;\r\n        return value;\r\n    }\r\n    \r\n     function get_sourceNode(): GraphNode\r\n    {\r\n        return _sourceNode;\r\n    }\r\n    \r\n     function set_sourceNode( value: GraphNode): GraphNode\r\n    {\r\n        _sourceNode = value;\r\n        return value;\r\n    }\r\n    \r\n     function get_destinationNode(): GraphNode\r\n    {\r\n        return _destinationNode;\r\n    }\r\n    \r\n     function set_destinationNode( value: GraphNode ): GraphNode {\r\n        _destinationNode = value;\r\n        return value;\r\n    }\r\n    \r\n    //TODO: Dynamic == Dynamite :(  must look at this\r\n    \r\n     function get_data() : EdgeData\r\n    {\r\n        return _data;\r\n    }\r\n    \r\n     function set_data( value: EdgeData ) : EdgeData\r\n    {\r\n        _data = value;\r\n        return value;\r\n    }\r\n}\r\n","package hxDaedalus.data.graph;\r\n\r\nimport hxDaedalus.data.Edge;\r\nimport hxDaedalus.data.math.NodeData;\r\n\r\nclass GraphNode\r\n{\r\n    public var id(get, never) : Int;\r\n    public var prev(get, set) : GraphNode;\r\n    public var next(get, set) : GraphNode;\r\n    public var outgoingEdge(get, set) : GraphEdge;\r\n    public var successorNodes(get, set) : Map<GraphNode,GraphEdge>;\r\n    public var data(get, set) : NodeData;\r\n\r\n    \r\n     static var INC : Int = 0;\r\n     var _id : Int;\r\n    \r\n     var _prev : GraphNode;\r\n     var _next : GraphNode;\r\n    \r\n     var _outgoingEdge : GraphEdge;\r\n     var _successorNodes : Map<GraphNode,GraphEdge>;\r\n    \r\n     var _data : NodeData;\r\n    \r\n    public function new()\r\n    {\r\n        _id = INC;\r\n        INC++;\r\n        \r\n        _successorNodes = new Map<GraphNode,GraphEdge>();\r\n    }\r\n    \r\n     function get_id(): Int {\r\n        return _id;\r\n    }\r\n    \r\n    public function dispose(): Void\r\n    {\r\n        _prev = null;\r\n        _next = null;\r\n        _outgoingEdge = null;\r\n        _successorNodes = null;\r\n        _data = null;\r\n    }\r\n    \r\n     function get_prev() : GraphNode\r\n    {\r\n        return _prev;\r\n    }\r\n    \r\n     function set_prev(value : GraphNode) : GraphNode\r\n    {\r\n        _prev = value;\r\n        return value;\r\n    }\r\n    \r\n     function get_next() : GraphNode\r\n    {\r\n        return _next;\r\n    }\r\n    \r\n     function set_next(value : GraphNode) : GraphNode\r\n    {\r\n        _next = value;\r\n        return value;\r\n    }\r\n    \r\n     function get_outgoingEdge(): GraphEdge\r\n    {\r\n        return _outgoingEdge;\r\n    }\r\n    \r\n     function set_outgoingEdge( value: GraphEdge ): GraphEdge\r\n    {\r\n        _outgoingEdge = value;\r\n        return value;\r\n    }\r\n    \r\n     function get_successorNodes(): Map<GraphNode,GraphEdge>\r\n    {\r\n        return _successorNodes;\r\n    }\r\n    \r\n     function set_successorNodes( value: Map<GraphNode,GraphEdge> ): Map<GraphNode,GraphEdge>\r\n    {\r\n        _successorNodes = value;\r\n        return value;\r\n    }\r\n    \r\n    //TODO: Dynamic oh dear :( must try to change!\r\n    \r\n     function get_data(): NodeData\r\n    {\r\n        return _data;\r\n    }\r\n    \r\n     function set_data( value: NodeData ) : NodeData\r\n    {\r\n        _data = value;\r\n        return value;\r\n    }\r\n}\r\n","package hxDaedalus.data.math;\r\nclass EdgeData\r\n{\r\n    public var sumDistancesSquared : Float;\r\n    public var length : Float;\r\n    public var nodesCount : Int;\r\n    \r\n    public function new(){}\r\n}","package hxDaedalus.data.math;\r\nclass Point2D{\r\n    public var length(get, never) : Float;\r\n    public var x: Float;\r\n    public var y: Float;\r\n    \r\n    public function new( x_: Float = 0, y_: Float = 0 ){\r\n        x = x_;\r\n        y = y_;\r\n    }\r\n    \r\n    public function transform( matrix: Matrix2D ): Void {\r\n        matrix.tranform( this );\r\n    }\r\n    \r\n    public function setXY( x_: Float, y_: Float ): Void {\r\n        x = x_;\r\n        y = y_;\r\n    }\r\n    \r\n    public function clone(): Point2D {\r\n        return new Point2D( x, y );\r\n    }\r\n    \r\n    public function substract( p: Point2D ): Void {\r\n        x -= p.x;\r\n        y -= p.y;\r\n    }\r\n    \r\n     function get_length(): Float {\r\n        return Math.sqrt( x*x + y*y );\r\n    }\r\n    \r\n    public function normalize(): Void {\r\n        var norm : Float = length;\r\n        x = x / norm;\r\n        y = y / norm;\r\n    }\r\n    \r\n    public function scale(s : Float): Void {\r\n        x = x * s;\r\n        y = y * s;\r\n    }\r\n    \r\n    public function distanceTo( p: Point2D ): Float {\r\n        var diffX : Float = x - p.x;\r\n        var diffY : Float = y - p.y;\r\n        return Math.sqrt( diffX*diffX + diffY*diffY );\r\n    }\r\n}\r\n","package hxDaedalus.data.math;\r\n\r\nimport hxDaedalus.data.math.Point2D;\r\nimport hxDaedalus.data.math.RandGenerator;\r\nimport hxDaedalus.data.Constants;\r\nimport hxDaedalus.data.Edge;\r\nimport hxDaedalus.data.Face;\r\nimport hxDaedalus.data.Mesh;\r\nimport hxDaedalus.data.Vertex;\r\nimport hxDaedalus.iterators.FromFaceToInnerEdges;\r\nimport hxDaedalus.iterators.FromVertexToHoldingFaces;\r\nimport hxDaedalus.debug.Debug;\r\n\r\n \r\nenum Intersection {\r\n    EVertex( vertex: Vertex );\r\n    EEdge( edge: Edge );\r\n    EFace( face: Face );\r\n    ENull( );\r\n}\r\n/*\r\nuse \r\nswitch( loc ){\r\n    case EVertex( vertex ):\r\n        locVertex = vertex;\r\n    case EEdge( edge ):\r\n        locEdge = edge;\r\n    case EFace( face ):\r\n        locFace = face;\r\n    case ENull( isnull ):\r\n        //\r\n}\r\n*/\r\n\r\nclass Geom2D\r\n{\r\n    \r\n    \r\n     static var _randGen: RandGenerator;\r\n    \r\n    // return one the following, in priority order:\r\n    // - an existant vertex (if (x, y) lies on this vertex)\r\n    // or\r\n    // - an existant edge (if (x, y) lies on this edge )\r\n    // or\r\n    // - an existant face (if (x, y) lies on this face )\r\n    // or\r\n    // - null if outside mesh\r\n    // YOU SHOULD USE THIS FUNCTION ONLY FOR COORDINATES INSIDE SAFE AREA\r\n     static var __samples: Array<Vertex> = new Array<Vertex>();\r\n    public static function locatePosition( x: Float, y: Float, mesh: Mesh ): Intersection\r\n    {\r\n        // jump and walk algorithm\r\n        \r\n        if (_randGen == null) _randGen = new RandGenerator();\r\n        _randGen.seed = Std.int( x * 10 + 4 * y );\r\n        \r\n        var i : Int;\r\n        \r\n        __samples.splice(0, __samples.length);\r\n        var numSamples : Int = Std.int( Math.pow(mesh._vertices.length, 1 / 3) );\r\n        _randGen.rangeMin = 0;\r\n        _randGen.rangeMax = mesh._vertices.length - 1;\r\n        for (i in 0...numSamples){\r\n            var _rnd:Int = _randGen.next();\r\n\r\n            Debug.assertFalse(_rnd < 0 || _rnd > mesh._vertices.length - 1, '_rnd: $_rnd');\r\n\t\t\tDebug.assertFalse(mesh._vertices == null, 'vertices: ${mesh._vertices.length}');\r\n            __samples.push(mesh._vertices[_rnd]);\r\n        }\r\n        \r\n        var currVertex : Vertex;\r\n        var currVertexPos : Point2D;\r\n        var distSquared : Float;\r\n        var minDistSquared : Float = Math.POSITIVE_INFINITY;\r\n        var closedVertex : Vertex = null;\r\n        for (i in 0...numSamples){\r\n            currVertex = __samples[i];\r\n            currVertexPos = currVertex.pos;\r\n            distSquared = (currVertexPos.x - x) * (currVertexPos.x - x) + (currVertexPos.y - y) * (currVertexPos.y - y);\r\n            if (distSquared < minDistSquared) \r\n            {\r\n                minDistSquared = distSquared;\r\n                closedVertex = currVertex;\r\n            }\r\n        }\r\n        \r\n        var currFace : Face;\r\n        var iterFace : FromVertexToHoldingFaces = new FromVertexToHoldingFaces();\r\n        iterFace.fromVertex = closedVertex;\r\n        currFace = iterFace.next();\r\n        \r\n        var faceVisited = new Map<Face,Bool>();\r\n        var currEdge : Edge;\r\n        var iterEdge : FromFaceToInnerEdges = new FromFaceToInnerEdges();\r\n        var objectContainer : Intersection = ENull;\r\n        var relativPos : Int;\r\n        var numIter : Int = 0;\r\n        //while ( faceVisited[ currFace ] || !(objectContainer = isInFace(x, y, currFace)) )\r\n        while ( faceVisited[ currFace ] || (objectContainer = isInFace(x, y, currFace)).match(ENull) )\r\n        {\r\n            faceVisited[ currFace ];\r\n            \r\n            numIter++;\r\n            if (numIter == 50) \r\n            {\r\n                Debug.trace(\"WALK TAKE MORE THAN 50 LOOP\");\r\n            }\r\n            iterEdge.fromFace = currFace;\r\n            do\r\n            {\r\n                currEdge = iterEdge.next();\r\n                if (currEdge == null) \r\n                {\r\n                    Debug.trace(\"KILL PATH\");\r\n                    return ENull;\r\n                }\r\n                relativPos = getRelativePosition(x, y, currEdge);\r\n            } while ((relativPos == 1 || relativPos == 0));\r\n            \r\n            currFace = currEdge.rightFace;\r\n        }\r\n        \r\n        return objectContainer;\r\n    }\r\n    \r\n    public static function isCircleIntersectingAnyConstraint(x : Float, y : Float, radius : Float, mesh : Mesh) : Bool\r\n    {\r\n        if (x <= 0 || x >= mesh.width || y <= 0 || y >= mesh.height) return true;\r\n        \r\n        var loc = Geom2D.locatePosition(x, y, mesh);\r\n        var face : Face;\r\n        switch( loc ){\r\n            case EVertex( vertex ):\r\n                face = vertex.edge.leftFace;\r\n            case EEdge( edge ):\r\n                face = edge.leftFace;\r\n            case EFace( face_ ):\r\n                face = face_;\r\n            case ENull:\r\n                face = null;\r\n        }\r\n        \r\n        // if a vertex is in the circle, a contrainst must intersect the circle\r\n        // because a vertex always belongs to a contrained edge\r\n        var radiusSquared : Float = radius * radius;\r\n        var pos : Point2D;\r\n        var distSquared : Float;\r\n        pos = face.edge.originVertex.pos;\r\n        distSquared = (pos.x - x) * (pos.x - x) + (pos.y - y) * (pos.y - y);\r\n        if (distSquared <= radiusSquared) \r\n        {\r\n            return true;\r\n        }\r\n        pos = face.edge.nextLeftEdge.originVertex.pos;\r\n        distSquared = (pos.x - x) * (pos.x - x) + (pos.y - y) * (pos.y - y);\r\n        if (distSquared <= radiusSquared) \r\n        {\r\n            return true;\r\n        }\r\n        pos = face.edge.nextLeftEdge.nextLeftEdge.originVertex.pos;\r\n        distSquared = (pos.x - x) * (pos.x - x) + (pos.y - y) * (pos.y - y);\r\n        if (distSquared <= radiusSquared) \r\n        {\r\n            return true;\r\n        }  // check if edge intersects  \r\n        \r\n        \r\n        \r\n        var edgesToCheck = new Array<Edge>();\r\n        edgesToCheck.push(face.edge);\r\n        edgesToCheck.push(face.edge.nextLeftEdge);\r\n        edgesToCheck.push(face.edge.nextLeftEdge.nextLeftEdge);\r\n        \r\n        var edge : Edge;\r\n        var pos1 : Point2D;\r\n        var pos2 : Point2D;\r\n        var checkedEdges = new Map<Edge,Bool>();\r\n        var intersecting : Bool;\r\n        while (edgesToCheck.length > 0)\r\n        {\r\n            edge = edgesToCheck.pop();\r\n            checkedEdges[ edge ] = true;\r\n            pos1 = edge.originVertex.pos;\r\n            pos2 = edge.destinationVertex.pos;\r\n            intersecting = intersectionsSegmentCircle(pos1.x, pos1.y, pos2.x, pos2.y, x, y, radius);\r\n            if (intersecting) \r\n            {\r\n                if (edge.isConstrained) {\r\n                    return true;\r\n                }else {\r\n                    edge = edge.oppositeEdge.nextLeftEdge;\r\n                    if (!checkedEdges[edge] && !checkedEdges[edge.oppositeEdge] && edgesToCheck.indexOf(edge) == -1 && edgesToCheck.indexOf(edge.oppositeEdge) == -1) \r\n                    {\r\n                        edgesToCheck.push(edge);\r\n                    }\r\n                    edge = edge.nextLeftEdge;\r\n                    if (!checkedEdges[edge] && !checkedEdges[edge.oppositeEdge] && edgesToCheck.indexOf(edge) == -1 && edgesToCheck.indexOf(edge.oppositeEdge) == -1) \r\n                    {\r\n                        edgesToCheck.push(edge);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        return false;\r\n    }\r\n    \r\n    // return the relative direction from (x1,y1), to (x3,y3) through (x2, y2)\r\n    // the function returns:\r\n    // 0 if the path is a straight line\r\n    // 1 if the path goes to the left\r\n    // -1 if the path goes to the right\r\n    public static function getDirection(x1 : Float, y1 : Float, x2 : Float, y2 : Float, x3 : Float, y3 : Float) : Int\r\n    {\r\n        \r\n        // dot product with the orthogonal vector pointing left vector of eUp:\r\n        var dot : Float = (x3 - x1) * (y2 - y1) + (y3 - y1) * (-x2 + x1);\r\n        \r\n        // check sign\r\n        return ((dot == 0)) ? 0 : (((dot > 0)) ? 1 : -1);\r\n    }\r\n    \r\n    // second version of getDirection. More accurate and safer version\r\n    // return the relative direction from (x1,y1), to (x3,y3) through (x2, y2)\r\n    // the function returns:\r\n    // 0 if the path is a straight line\r\n    // 1 if the path goes to the left\r\n    // -1 if the path goes to the right\r\n    public static function getDirection2(x1 : Float, y1 : Float, x2 : Float, y2 : Float, x3 : Float, y3 : Float) : Int\r\n    {\r\n        // dot product with the orthogonal vector pointing left vector of eUp:\r\n        var dot : Float = (x3 - x1) * (y2 - y1) + (y3 - y1) * (-x2 + x1);\r\n        \r\n        // check sign\r\n        if (dot == 0) \r\n        {\r\n            return 0;\r\n        }\r\n        else if (dot > 0) \r\n        {\r\n            if (distanceSquaredPointToLine(x3, y3, x1, y1, x2, y2) <= Constants.EPSILON_SQUARED) {\r\n                return 0;\r\n            } else { \r\n                return 1;\r\n            }\r\n        }\r\n        else \r\n        {\r\n            if (distanceSquaredPointToLine(x3, y3, x1, y1, x2, y2) <= Constants.EPSILON_SQUARED) {\r\n                return 0;\r\n            } else { \r\n                return -1;\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n    \r\n    // eUp seen as an infinite line splits the 2D space in 2 parts (left and right),\r\n    // the function returns:\r\n    //   0 if the (x, y) lies on the line\r\n    //   1 if the (x, y) lies at left\r\n    //   -1 if the (x, y) lies at right\r\n    public static function getRelativePosition(x : Float, y : Float, eUp : Edge) : Int\r\n    {\r\n        return getDirection(eUp.originVertex.pos.x, eUp.originVertex.pos.y, eUp.destinationVertex.pos.x, eUp.destinationVertex.pos.y, x, y);\r\n    }\r\n    \r\n    public static function getRelativePosition2(x : Float, y : Float, eUp : Edge) : Int\r\n    {\r\n        return getDirection2(eUp.originVertex.pos.x, eUp.originVertex.pos.y, eUp.destinationVertex.pos.x, eUp.destinationVertex.pos.y, x, y);\r\n    }\r\n    \r\n    // the function checks by priority:\r\n    // - if the (x, y) lies on a vertex of the polygon, it will return this vertex\r\n    // - if the (x, y) lies on a edge of the polygon, it will return this edge\r\n    // - if the (x, y) lies inside the polygon, it will return the polygon\r\n    // - if the (x, y) lies outside the polygon, it will return null\r\n    public static function isInFace(x : Float, y : Float, polygon : Face) : Intersection\r\n    {\r\n        // remember polygons are triangle only,\r\n        // and we suppose we have not degenerated flat polygons !\r\n        \r\n        var result : Intersection = ENull;\r\n        \r\n        var e1_2 = polygon.edge;\r\n        var e2_3 = e1_2.nextLeftEdge;\r\n        var e3_1 = e2_3.nextLeftEdge;\r\n        if (getRelativePosition(x, y, e1_2) >= 0 && getRelativePosition(x, y, e2_3) >= 0 && getRelativePosition(x, y, e3_1) >= 0) \r\n        {\r\n            var v1= e1_2.originVertex;\r\n            var v2= e2_3.originVertex;\r\n            var v3= e3_1.originVertex;\r\n            \r\n            var x1= v1.pos.x;\r\n            var y1= v1.pos.y;\r\n            var x2= v2.pos.x;\r\n            var y2= v2.pos.y;\r\n            var x3= v3.pos.x;\r\n            var y3= v3.pos.y;\r\n            \r\n            var v_v1squaredLength= (x1 - x) * (x1 - x) + (y1 - y) * (y1 - y);\r\n            var v_v2squaredLength= (x2 - x) * (x2 - x) + (y2 - y) * (y2 - y);\r\n            var v_v3squaredLength= (x3 - x) * (x3 - x) + (y3 - y) * (y3 - y);\r\n            var v1_v2squaredLength= (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\r\n            var v2_v3squaredLength= (x3 - x2) * (x3 - x2) + (y3 - y2) * (y3 - y2);\r\n            var v3_v1squaredLength= (x1 - x3) * (x1 - x3) + (y1 - y3) * (y1 - y3);\r\n            \r\n            var dot_v_v1v2= (x - x1) * (x2 - x1) + (y - y1) * (y2 - y1);\r\n            var dot_v_v2v3 = (x - x2) * (x3 - x2) + (y - y2) * (y3 - y2);\r\n            var dot_v_v3v1 = (x - x3) * (x1 - x3) + (y - y3) * (y1 - y3);\r\n            \r\n            var v_e1_2squaredLength = v_v1squaredLength - dot_v_v1v2 * dot_v_v1v2 / v1_v2squaredLength;\r\n            var v_e2_3squaredLength = v_v2squaredLength - dot_v_v2v3 * dot_v_v2v3 / v2_v3squaredLength;\r\n            var v_e3_1squaredLength = v_v3squaredLength - dot_v_v3v1 * dot_v_v3v1 / v3_v1squaredLength;\r\n            \r\n            var closeTo_e1_2  = v_e1_2squaredLength <= Constants.EPSILON_SQUARED;\r\n            var closeTo_e2_3  = v_e2_3squaredLength <= Constants.EPSILON_SQUARED;\r\n            var closeTo_e3_1  = v_e3_1squaredLength <= Constants.EPSILON_SQUARED;\r\n            \r\n            if( closeTo_e1_2 ){\r\n                if( closeTo_e3_1 ){\r\n                    result = EVertex( v1 );\r\n                } else if( closeTo_e2_3 ){ \r\n                    result = EVertex( v2 );\r\n                } else { \r\n                    result = EEdge( e1_2 );\r\n                }\r\n            } else if( closeTo_e2_3 ){\r\n                if( closeTo_e3_1 ){\r\n                    result = EVertex( v3 );\r\n                } else { \r\n                    result = EEdge( e2_3 );\r\n                }\r\n            } else if( closeTo_e3_1 ){ \r\n                result = EEdge( e3_1 );\r\n            } else {\r\n                result = EFace( polygon );\r\n            }\r\n        }\r\n        \r\n        return result;\r\n    }\r\n    \r\n    // return:\r\n    // - true if the segment is totally or partially in the triangle\r\n    // - false if the segment is totally outside the triangle\r\n    public static function clipSegmentByTriangle( s1x : Float, s1y : Float\r\n                                                , s2x : Float, s2y : Float\r\n                                                , t1x : Float, t1y : Float\r\n                                                , t2x : Float, t2y : Float\r\n                                                , t3x : Float, t3y : Float\r\n                                                , pResult1 : Point2D = null, pResult2 : Point2D = null\r\n                                                ) : Bool\r\n    {\r\n        var side1_1 : Int;\r\n        var side1_2 : Int;\r\n        side1_1 = getDirection(t1x, t1y, t2x, t2y, s1x, s1y);\r\n        side1_2 = getDirection(t1x, t1y, t2x, t2y, s2x, s2y);\r\n        // if both segment points are on right side\r\n        if (side1_1 <= 0 && side1_2 <= 0) \r\n            return false;\r\n        \r\n        var side2_1 : Int;\r\n        var side2_2 : Int;\r\n        side2_1 = getDirection(t2x, t2y, t3x, t3y, s1x, s1y);\r\n        side2_2 = getDirection(t2x, t2y, t3x, t3y, s2x, s2y);\r\n        // if both segment points are on right side\r\n        if (side2_1 <= 0 && side2_2 <= 0) \r\n            return false;\r\n        \r\n        var side3_1 : Int;\r\n        var side3_2 : Int;\r\n        side3_1 = getDirection(t3x, t3y, t1x, t1y, s1x, s1y);\r\n        side3_2 = getDirection(t3x, t3y, t1x, t1y, s2x, s2y);\r\n        // if both segment points are on right side\r\n        if (side3_1 <= 0 && side3_2 <= 0) \r\n            return false;  // both segment points are in triangle  ;\r\n        \r\n        \r\n        \r\n        if ((side1_1 >= 0 && side2_1 >= 0 && side3_1 >= 0) && (side1_2 >= 0 && side2_2 >= 0 && side3_2 >= 0)) \r\n        {\r\n            pResult1.x = s1x;\r\n            pResult1.y = s1y;\r\n            pResult2.x = s2x;\r\n            pResult2.y = s2y;\r\n            return true;\r\n        }\r\n        \r\n        var n : Int = 0;\r\n        // check intersection between segment and 1st side triangle\r\n        if (intersections2segments(s1x, s1y, s2x, s2y, t1x, t1y, t2x, t2y, pResult1, null)) \r\n        {\r\n            n++;\r\n        }  // if no intersection with 1st side triangle  \r\n        \r\n        \r\n        \r\n        if (n == 0) \r\n        {\r\n            // check intersection between segment and 1st side triangle\r\n            if (intersections2segments(s1x, s1y, s2x, s2y, t2x, t2y, t3x, t3y, pResult1, null)) \r\n            {\r\n                n++;\r\n            }\r\n        }\r\n        else \r\n        {\r\n            if (intersections2segments(s1x, s1y, s2x, s2y, t2x, t2y, t3x, t3y, pResult2, null)) \r\n            {\r\n                // we check if the segment is not on t2 triangle point\r\n                if (-Constants.EPSILON > pResult1.x - pResult2.x || pResult1.x - pResult2.x > Constants.EPSILON || -Constants.EPSILON > pResult1.y - pResult2.y || pResult1.y - pResult2.y > Constants.EPSILON) \r\n                {\r\n                    n++;\r\n                }\r\n            }\r\n        }  // if intersection neither 1st nor 2nd side triangle  \r\n        \r\n        \r\n        \r\n        if (n == 0) \r\n        {\r\n            if (intersections2segments(s1x, s1y, s2x, s2y, t3x, t3y, t1x, t1y, pResult1, null)) \r\n            {\r\n                n++;\r\n            }\r\n        }\r\n        // if one intersection, we identify the segment point in the triangle\r\n        else if (n == 1) \r\n        {\r\n            if (intersections2segments(s1x, s1y, s2x, s2y, t3x, t3y, t1x, t1y, pResult2, null)) \r\n            {\r\n                if (-Constants.EPSILON > pResult1.x - pResult2.x || pResult1.x - pResult2.x > Constants.EPSILON || -Constants.EPSILON > pResult1.y - pResult2.y || pResult1.y - pResult2.y > Constants.EPSILON) \r\n                {\r\n                    n++;\r\n                }\r\n            }\r\n        }\r\n        \r\n        \r\n        \r\n        if (n == 1) \r\n        {\r\n            if (side1_1 >= 0 && side2_1 >= 0 && side3_1 >= 0) \r\n            {\r\n                pResult2.x = s1x;\r\n                pResult2.y = s1y;\r\n            }\r\n            else if (side1_2 >= 0 && side2_2 >= 0 && side3_2 >= 0) \r\n            {\r\n                pResult2.x = s2x;\r\n                pResult2.y = s2y;\r\n            }\r\n            else \r\n            {\r\n                // 1 intersection and none point in triangle : degenerate case\r\n                n = 0;\r\n            }\r\n        }\r\n        \r\n        if (n > 0) \r\n            return true\r\n        else \r\n        return false;\r\n    }\r\n    \r\n    // test if the segment intersects or lies inside the triangle\r\n    public static function isSegmentIntersectingTriangle(s1x : Float, s1y : Float, s2x : Float, s2y : Float, t1x : Float, t1y : Float, t2x : Float, t2y : Float, t3x : Float, t3y : Float) : Bool\r\n    {\r\n        // check sides\r\n        \r\n        var side1_1 : Int;\r\n        var side1_2 : Int;\r\n        side1_1 = getDirection(t1x, t1y, t2x, t2y, s1x, s1y);\r\n        side1_2 = getDirection(t1x, t1y, t2x, t2y, s2x, s2y);\r\n        // if both segment points are on right side\r\n        if (side1_1 <= 0 && side1_2 <= 0) \r\n            return false;\r\n        \r\n        var side2_1 : Int;\r\n        var side2_2 : Int;\r\n        side2_1 = getDirection(t2x, t2y, t3x, t3y, s1x, s1y);\r\n        side2_2 = getDirection(t2x, t2y, t3x, t3y, s2x, s2y);\r\n        // if both segment points are on right side\r\n        if (side2_1 <= 0 && side2_2 <= 0) \r\n            return false;\r\n        \r\n        var side3_1 : Int;\r\n        var side3_2 : Int;\r\n        side3_1 = getDirection(t3x, t3y, t1x, t1y, s1x, s1y);\r\n        side3_2 = getDirection(t3x, t3y, t1x, t1y, s2x, s2y);\r\n        // if both segment points are on right side\r\n        if (side3_1 <= 0 && side3_2 <= 0) \r\n            return false;  // if 1st segment point is inside triangle  ;\r\n        \r\n        \r\n        \r\n        if (side1_1 == 1 && side2_1 == 1 && side3_1 == 1) \r\n            return true;  // if 2st segment point is inside triangle  ;\r\n        \r\n        \r\n        \r\n        if (side1_1 == 1 && side2_1 == 1 && side3_1 == 1) \r\n            return true;\r\n        \r\n        var side1 : Int;\r\n        var side2 : Int;\r\n        // if both segment points are on different sides of the 1st triangle side\r\n        if ((side1_1 == 1 && side1_2 <= 0) || (side1_1 <= 0 && side1_2 == 1)) \r\n        {\r\n            side1 = getDirection(s1x, s1y, s2x, s2y, t1x, t1y);\r\n            side2 = getDirection(s1x, s1y, s2x, s2y, t2x, t2y);\r\n            if (side1 == 1 && side2 <= 0 || side1 <= 0 && side2 == 1) \r\n            {\r\n                return true;\r\n            }\r\n        }  // if both segment points are on different sides of the 2nd triangle side  \r\n        \r\n        if ((side2_1 == 1 && side2_2 <= 0) || (side2_1 <= 0 && side2_2 == 1)) \r\n        {\r\n            side1 = getDirection(s1x, s1y, s2x, s2y, t2x, t2y);\r\n            side2 = getDirection(s1x, s1y, s2x, s2y, t3x, t3y);\r\n            if (side1 == 1 && side2 <= 0 || side1 <= 0 && side2 == 1) \r\n            {\r\n                return true;\r\n            }\r\n        }  // if both segment points are on different sides of the 3rd triangle side  \r\n        \r\n        if ((side3_1 == 1 && side3_2 <= 0) || (side3_1 <= 0 && side3_2 == 1)) \r\n        {\r\n            side1 = getDirection(s1x, s1y, s2x, s2y, t3x, t3y);\r\n            side2 = getDirection(s1x, s1y, s2x, s2y, t1x, t1y);\r\n            if (side1 == 1 && side2 <= 0 || side1 <= 0 && side2 == 1) \r\n            {\r\n                return true;\r\n            }\r\n        }\r\n        \r\n        return false;\r\n    }\r\n    \r\n     static var __circumcenter : Point2D = new Point2D();\r\n    public static function isDelaunay(edge : Edge) : Bool\r\n    {\r\n        var vLeft : Vertex = edge.originVertex;\r\n        var vRight : Vertex = edge.destinationVertex;\r\n        var vCorner : Vertex = edge.nextLeftEdge.destinationVertex;\r\n        var vOpposite : Vertex = edge.nextRightEdge.destinationVertex;\r\n        /*\r\n        // middle points\r\n        var vMidLeft:Point = new Point();\r\n        vMidLeft.x = (vCorner.pos.x + vLeft.pos.x) / 2;\r\n        vMidLeft.y = (vCorner.pos.y + vLeft.pos.y) / 2;\r\n        \r\n        var vMidRight:Point = new Point();\r\n        vMidRight.x = (vCorner.pos.x + vRight.pos.x) / 2;\r\n        vMidRight.y = (vCorner.pos.y + vRight.pos.y) / 2;\r\n        */\r\n        /*\r\n        - parametric expression of orthogonal segments\r\n        segOrthoLeftX(t1) = vMidLeft.x + t1 * (vLeft.y - vCorner.y)\r\n        segOrthoLeftY(t1) = vMidLeft.y - t1 * (vLeft.x - vCorner.x)\r\n        \r\n        segOrthoRightX(t2) = vMidRight.x + t2 * (vRight.y - vCorner.y)\r\n        segOrthoRightY(t2) = vMidRight.y - t2 * (vRight.x - vCorner.x)\r\n        \r\n        - the center of circle passing by vLeft, vRight, vCorner will lead to:\r\n        segOrthoLeftX(t1) = segOrthoRightX(t2)\r\n        segOrthoLeftY(t1) = segOrthoRightY(t2)\r\n        */\r\n        /*\r\n        // set alias letters\r\n        var a:Number = vMidLeft.x;\r\n        var b:Number = vLeft.pos.y;\r\n        var c:Number = vCorner.pos.y;\r\n        var d:Number = vMidRight.x;\r\n        var e:Number = vRight.pos.y;\r\n        var f:Number = vCorner.pos.y;\r\n        var g:Number = vMidLeft.y;\r\n        var h:Number = vLeft.pos.x;\r\n        var i:Number = vCorner.pos.x;\r\n        var j:Number = vMidRight.y;\r\n        var k:Number = vRight.pos.x;\r\n        var l:Number = vCorner.pos.x;\r\n        */\r\n        /*\r\n        system to solve:\r\n        a + t1 (b - c) = d + t2 (e - f)\r\n        g - t1 (h - i) = j - t2 (k - l)\r\n        */\r\n        \r\n        //giving to wolfram: Solve[{a + t1 (b - c) = d + t2 (e - f) , g - t1 (h - i) = j - t2 (k - l)}, {t1, t2}]\r\n        //we get:\r\n        //var t1:Number = (-(a-d)*(k-l) + e*(j-g) + f*(g-j)) / ((b-c)*(k-l) + e*(i-h) + f*(h-i));\r\n        /*\r\n        __barycenter.x = a + t1 * (b - c);\r\n        __barycenter.y = g - t1 * (h - i);\r\n        */\r\n        getCircumcenter(vCorner.pos.x, vCorner.pos.y, vLeft.pos.x, vLeft.pos.y, vRight.pos.x, vRight.pos.y, __circumcenter);\r\n        \r\n        // check if the opposite vertex lies outside the circle\r\n        var squaredRadius : Float = (vCorner.pos.x - __circumcenter.x) * (vCorner.pos.x - __circumcenter.x) + (vCorner.pos.y - __circumcenter.y) * (vCorner.pos.y - __circumcenter.y);\r\n        var squaredDistance : Float = (vOpposite.pos.x - __circumcenter.x) * (vOpposite.pos.x - __circumcenter.x) + (vOpposite.pos.y - __circumcenter.y) * (vOpposite.pos.y - __circumcenter.y);\r\n        \r\n        return squaredDistance >= squaredRadius;\r\n    }\r\n    \r\n    public static function getCircumcenter(x1 : Float, y1 : Float, x2 : Float, y2 : Float, x3 : Float, y3 : Float, result : Point2D = null) : Point2D\r\n    {\r\n        if (result == null) \r\n        {\r\n            result = new Point2D();\r\n        }  // middle points  \r\n        \r\n        \r\n        \r\n        var m1 : Float = (x1 + x2) / 2;\r\n        var m2 : Float = (y1 + y2) / 2;\r\n        var m3 : Float = (x1 + x3) / 2;\r\n        var m4 : Float = (y1 + y3) / 2;\r\n        /*\r\n        - parametric expression of orthogonal segments\r\n        segOrtho1X(t1) = m1 + t1 * (y2 - y1)\r\n        segOrtho1Y(t1) = m2 - t1 * (x2 - x1)\r\n        \r\n        segOrtho2X(t2) = m3 + t2 * (y3 - y1)\r\n        segOrtho2Y(t2) = m4 - t2 * (x3 - x1)\r\n        \r\n        - the center of circle passing by vLeft, vRight, vCorner will lead to:\r\n        segOrtho1X(t1) = segOrtho2X(t2)\r\n        segOrtho1Y(t1) = segOrtho2Y(t2)\r\n        \r\n        system to solve:\r\n        m1 + t1 (y2 - y1) = m3 + t2 (y3 - y1)\r\n        m2 - t1 (x2 - x1) = m4 - t2 (x3 - x1)\r\n        \r\n        giving to wolfram: Solve[{m1 + t1 (y2 - y1) = m3 + t2 (y3 - y1) , m2 - t1 (x2 - x1) = m4 - t2 (x3 - x1)}, {t1, t2}]\r\n        we get:\r\n        */\r\n        var t1 : Float = (m1 * (x1 - x3) + (m2 - m4) * (y1 - y3) + m3 * (x3 - x1)) / (x1 * (y3 - y2) + x2 * (y1 - y3) + x3 * (y2 - y1));\r\n        \r\n        result.x = m1 + t1 * (y2 - y1);\r\n        result.y = m2 - t1 * (x2 - x1);\r\n        \r\n        return result;\r\n    }\r\n    \r\n    public static function intersections2segments(s1p1x : Float, s1p1y : Float, s1p2x : Float, s1p2y : Float, s2p1x : Float, s2p1y : Float, s2p2x : Float, s2p2y : Float, posIntersection : Point2D = null, paramIntersection : Array<Float> = null, infiniteLineMode : Bool = false) : Bool\r\n    {\r\n        var t1 : Float = 0;\r\n        var t2 : Float = 0;\r\n        \r\n        var result : Bool;\r\n        var divisor : Float = (s1p1x - s1p2x) * (s2p1y - s2p2y) + (s1p2y - s1p1y) * (s2p1x - s2p2x);\r\n        if (divisor == 0) \r\n        {\r\n            result = false;\r\n        }\r\n        else \r\n        {\r\n            result = true;\r\n            \r\n            if (!infiniteLineMode || posIntersection != null || paramIntersection != null) \r\n            {\r\n                // if we consider edges as finite segments, we must check t1 and t2 values\r\n                t1 = (s1p1x * (s2p1y - s2p2y) + s1p1y * (s2p2x - s2p1x) + s2p1x * s2p2y - s2p1y * s2p2x) / divisor;\r\n                t2 = (s1p1x * (s2p1y - s1p2y) + s1p1y * (s1p2x - s2p1x) - s1p2x * s2p1y + s1p2y * s2p1x) / divisor;\r\n                if (!infiniteLineMode && !(0 <= t1 && t1 <= 1 && 0 <= t2 && t2 <= 1)) \r\n                    result = false;\r\n            }\r\n        }\r\n        \r\n        if (result) \r\n        {\r\n            if (posIntersection != null) \r\n            {\r\n                posIntersection.x = s1p1x + t1 * (s1p2x - s1p1x);\r\n                posIntersection.y = s1p1y + t1 * (s1p2y - s1p1y);\r\n            }\r\n            if (paramIntersection != null) \r\n            {\r\n                paramIntersection.push(t1);\r\n                paramIntersection.push(t2);\r\n            }\r\n        }\r\n        \r\n        return result;\r\n    }\r\n    \r\n    public static function intersections2edges(edge1 : Edge, edge2 : Edge, posIntersection :Point2D = null, paramIntersection : Array<Float> = null, infiniteLineMode : Bool = false) : Bool\r\n    {\r\n        return intersections2segments(edge1.originVertex.pos.x, edge1.originVertex.pos.y, edge1.destinationVertex.pos.x, edge1.destinationVertex.pos.y, edge2.originVertex.pos.x, edge2.originVertex.pos.y, edge2.destinationVertex.pos.x, edge2.destinationVertex.pos.y, posIntersection, paramIntersection, infiniteLineMode);\r\n    }\r\n    \r\n    // a edge is convex if the polygon formed by the 2 faces at left and right of this edge is convex\r\n    public static function isConvex(edge : Edge) : Bool\r\n    {\r\n        var result : Bool = true;\r\n        \r\n        var eLeft : Edge;\r\n        var vRight : Vertex;\r\n        \r\n        eLeft = edge.nextLeftEdge.oppositeEdge;\r\n        vRight = edge.nextRightEdge.destinationVertex;\r\n        if (getRelativePosition(vRight.pos.x, vRight.pos.y, eLeft) != -1) \r\n        {\r\n            result = false;\r\n        }\r\n        else \r\n        {\r\n            eLeft = edge.prevRightEdge;\r\n            vRight = edge.prevLeftEdge.originVertex;\r\n            if (getRelativePosition(vRight.pos.x, vRight.pos.y, eLeft) != -1) \r\n            {\r\n                result = false;\r\n            }\r\n        }\r\n        \r\n        return result;\r\n    }\r\n    \r\n    public static function projectOrthogonaly(vertexPos : Point2D, edge : Edge) : Void\r\n    {\r\n        // parametric expression of edge\r\n        // x(t1) = edge.originVertex.pos.x + t1*(edge.destinationVertex.pos.x - edge.originVertex.pos.x)\r\n        // y(t1) = edge.originVertex.pos.y + t1*(edge.destinationVertex.pos.y - edge.originVertex.pos.y)\r\n        \r\n        // parametric expression of the segment orthogonal to edge and lying by vertex\r\n        // x(t2) = vertexPos.x + t2*(edge.destinationVertex.pos.y - edge.originVertex.pos.y)\r\n        // y(t2) = vertexPos.y - t2*(edge.destinationVertex.pos.x - edge.originVertex.pos.x)\r\n        \r\n        // the orthogonal projection of vertex on edge will lead to:\r\n        // x(t1) = x(t2)\r\n        // y(t1) = y(t2)\r\n        \r\n        // set alias letters\r\n        var a = edge.originVertex.pos.x;\r\n        var b = edge.originVertex.pos.y;\r\n        var c  = edge.destinationVertex.pos.x;\r\n        var d  = edge.destinationVertex.pos.y;\r\n        var e  = vertexPos.x;\r\n        var f = vertexPos.y;\r\n        \r\n        // system to solve:\r\n        // a + t1 (c - a) = e + t2 (d - b)\r\n        // b + t1 (d - b) = f - t2 (c - a)\r\n        \r\n        // solution:\r\n        var t1  = (a * a - a * c - a * e + b * b - b * d - b * f + c * e + d * f) / (a * a - 2 * a * c + b * b - 2 * b * d + c * c + d * d);\r\n        \r\n        // set position:\r\n        vertexPos.x = a + t1 * (c - a);\r\n        vertexPos.y = b + t1 * (d - b);\r\n    }\r\n    \r\n    // fill the result vector with 4 elements, with the form:\r\n    // [intersect0.x, intersect0.y, intersect1.x, intersect1.y]\r\n    // empty if no intersection\r\n    public static function intersections2Circles(cx1 : Float, cy1 : Float, r1 : Float, cx2 : Float, cy2 : Float, r2 : Float, result : Array<Float> = null) : Bool\r\n    {\r\n        var distRadiusSQRD = ((cx2 - cx1) * (cx2 - cx1) + (cy2 - cy1) * (cy2 - cy1));\r\n        \r\n        if ((cx1 != cx2 || cy1 != cy2)\r\n            && distRadiusSQRD <= ((r1 + r2) * (r1 + r2))\r\n            && distRadiusSQRD >= ((r1 - r2) * (r1 - r2))) \r\n        {\r\n            var transcendPart : Float = Math.sqrt(((r1 + r2) * (r1 + r2) - distRadiusSQRD)\r\n                    * (distRadiusSQRD - (r2 - r1) * (r2 - r1)));\r\n            var xFirstPart : Float = (cx1 + cx2) / 2 + (cx2 - cx1) * (r1 * r1 - r2 * r2) / (2 * distRadiusSQRD);\r\n            var yFirstPart : Float = (cy1 + cy2) / 2 + (cy2 - cy1) * (r1 * r1 - r2 * r2) / (2 * distRadiusSQRD);\r\n            var xFactor : Float = (cy2 - cy1) / (2 * distRadiusSQRD);\r\n            var yFactor : Float = (cx2 - cx1) / (2 * distRadiusSQRD);\r\n            \r\n            if (result != null) \r\n            {\r\n                for (f in [ xFirstPart + xFactor * transcendPart, yFirstPart - yFactor * transcendPart, xFirstPart - xFactor * transcendPart, yFirstPart + yFactor * transcendPart])\r\n\t\t\t\t\tresult.push(f);\r\n            }\r\n            \r\n            return true;\r\n        }\r\n        else \r\n        return false;\r\n    }\r\n    \r\n    public static function intersectionsSegmentCircle(p0x : Float, p0y : Float, p1x : Float, p1y : Float, cx : Float, cy : Float, r : Float, result : Array<Float> = null) : Bool\r\n    {\r\n        \r\n        var p0xSQD  = p0x * p0x;\r\n        var p0ySQD  = p0y * p0y;\r\n        var a  = p1y * p1y - 2 * p1y * p0y + p0ySQD + p1x * p1x - 2 * p1x * p0x + p0xSQD;\r\n        var b = 2 * p0y * cy - 2 * p0xSQD + 2 * p1y * p0y - 2 * p0ySQD + 2 * p1x * p0x - 2 * p1x * cx + 2 * p0x * cx - 2 * p1y * cy;\r\n        var c = p0ySQD + cy * cy + cx * cx - 2 * p0y * cy - 2 * p0x * cx + p0xSQD - r * r;\r\n        var delta  = b * b - 4 * a * c;\r\n        var deltaSQRT : Float;\r\n        \r\n        var t0 : Float;\r\n        var t1 : Float;\r\n        if (delta < 0) \r\n        {\r\n            // no solution\r\n            return false;\r\n        }\r\n        else if (delta == 0) \r\n        {\r\n            // unique solution\r\n            t0 = -b / (2 * a);\r\n            if (t0 < 0 || t0 > 1) \r\n                return false;  //  [intersect0.x, intersect0.y, t0]    // we return a 3 elements array, under the form:  ;\r\n            \r\n            \r\n            \r\n            if (result != null) \r\n                for (f in [ p0x + t0 * (p1x - p0x), p0y + t0 * (p1y - p0y), t0 ] )\r\n\t\t\t\t\tresult.push(f);\r\n            \r\n            return true;\r\n        }\r\n        // (delta > 0)\r\n        else \r\n        {\r\n            deltaSQRT = Math.sqrt(delta);\r\n            t0 = (-b + deltaSQRT) / (2 * a);\r\n            t1 = (-b - deltaSQRT) / (2 * a);\r\n            // we return a n elements array, under the form:\r\n            //  [intersect0.x, intersect0.y, t0\r\n            //    , intersect1.x, intersect1.y, t1]\r\n            var intersecting : Bool = false;\r\n            if (0 <= t0 && t0 <= 1) \r\n            {\r\n                if (result != null)\r\n\t\t\t\t\tfor (f in [p0x + t0 * (p1x - p0x), p0y + t0 * (p1y - p0y), t0] )\r\n\t\t\t\t\t\tresult.push(f);\r\n                intersecting = true;\r\n            }\r\n            if (0 <= t1 && t1 <= 1) \r\n            {\r\n                if (result != null) \r\n                    for (f in [p0x + t1 * (p1x - p0x), p0y + t1 * (p1y - p0y), t1])\r\n\t\t\t\t\t\tresult.push(f);\r\n                intersecting = true;\r\n            }\r\n            \r\n            return intersecting;\r\n        }\r\n    }\r\n    \r\n    public static function intersectionsLineCircle(p0x : Float, p0y : Float, p1x : Float, p1y : Float, cx : Float, cy : Float, r : Float, result : Array<Float>) : Bool\r\n    {\r\n        var p0xSQD  = p0x * p0x;\r\n        var p0ySQD  = p0y * p0y;\r\n        var a  = p1y * p1y - 2 * p1y * p0y + p0ySQD + p1x * p1x - 2 * p1x * p0x + p0xSQD;\r\n        var b  = 2 * p0y * cy - 2 * p0xSQD + 2 * p1y * p0y - 2 * p0ySQD + 2 * p1x * p0x - 2 * p1x * cx + 2 * p0x * cx - 2 * p1y * cy;\r\n        var c  = p0ySQD + cy * cy + cx * cx - 2 * p0y * cy - 2 * p0x * cx + p0xSQD - r * r;\r\n        var delta  = b * b - 4 * a * c;\r\n        var deltaSQRT : Float;\r\n        \r\n        var t0 : Float;\r\n        var t1 : Float;\r\n        if (delta < 0) \r\n        {\r\n            // no solution\r\n            return false;\r\n        }\r\n        else if (delta == 0) \r\n        {\r\n            // unique solution\r\n            t0 = -b / (2 * a);\r\n            // we return a 3 elements array, under the form:\r\n            //  [intersect0.x, intersect0.y, t0]\r\n            for (f in [p0x + t0 * (p1x - p0x), p0y + t0 * (p1y - p0y), t0])\r\n\t\t\t\tresult.push(f);\r\n        }\r\n        else if (delta > 0) \r\n        {\r\n            deltaSQRT = Math.sqrt(delta);\r\n            t0 = (-b + deltaSQRT) / (2 * a);\r\n            t1 = (-b - deltaSQRT) / (2 * a);\r\n            // we return a 6 elements array, under the form:\r\n            //  [intersect0.x, intersect0.y, t0\r\n            //    , intersect1.x, intersect1.y, t1]\r\n            for (f in [p0x + t0 * (p1x - p0x), p0y + t0 * (p1y - p0y), t0, p0x + t1 * (p1x - p0x), p0y + t1 * (p1y - p0y), t1])\r\n\t\t\t\tresult.push(f);\r\n        }\r\n        \r\n        return true;\r\n    }\r\n    \r\n    // based on intersections2Circles method\r\n    // fill the result vector with 4 elements, with the form:\r\n    // [point_tangent1.x, point_tangent1.y, point_tangent2.x, point_tangent2.y]\r\n    // empty if no tangent\r\n    public static function tangentsPointToCircle(px : Float, py : Float, cx : Float, cy : Float, r : Float, result : Array<Float>) : Bool\r\n    {\r\n        var c2x  = (px + cx) / 2;\r\n        var c2y  = (py + cy) / 2;\r\n        var r2 = 0.5 * Math.sqrt((px - cx) * (px - cx) + (py - cy) * (py - cy));\r\n        \r\n        return intersections2Circles(c2x, c2y, r2, cx, cy, r, result);\r\n    }\r\n    \r\n    // <!!!> CIRCLES MUST HAVE SAME RADIUS\r\n    public static function tangentsCrossCircleToCircle(r : Float, c1x : Float, c1y : Float, c2x : Float, c2y : Float, result : Array<Float>) : Bool\r\n    {\r\n        var distance  = Math.sqrt((c1x - c2x) * (c1x - c2x) + (c1y - c2y) * (c1y - c2y));\r\n        \r\n        // new circle\r\n        var radius  = distance / 4;\r\n        var centerX  = c1x + (c2x - c1x) / 4;\r\n        var centerY = c1y + (c2y - c1y) / 4;\r\n        \r\n        if (intersections2Circles(c1x, c1y, r, centerX, centerY, radius, result)) \r\n        {\r\n            var t1x  = result[0];\r\n            var t1y  = result[1];\r\n            var t2x  = result[2];\r\n            var t2y  = result[3];\r\n            \r\n            var midX  = (c1x + c2x) / 2;\r\n            var midY  = (c1y + c2y) / 2;\r\n            var dotProd = (t1x - midX) * (c2y - c1y) + (t1y - midY) * (-c2x + c1x);\r\n            var tproj = dotProd / (distance * distance);\r\n            var projx = midX + tproj * (c2y - c1y);\r\n            var projy  = midY - tproj * (c2x - c1x);\r\n            \r\n            \r\n            var t4x  = 2 * projx - t1x;\r\n            var t4y  = 2 * projy - t1y;\r\n            \r\n            var t3x  = t4x + t2x - t1x;\r\n            var t3y = t2y + t4y - t1y;\r\n            \r\n            for (f in [ t3x, t3y, t4x, t4y ]) result.push(f);\r\n            \r\n            return true;\r\n        }\r\n        else \r\n        {\r\n            // no tangent because cicles are intersecting\r\n            return false;\r\n        }\r\n    }\r\n    \r\n    // <!!!> CIRCLES MUST HAVE SAME RADIUS\r\n    public static function tangentsParalCircleToCircle(r : Float, c1x : Float, c1y : Float, c2x : Float, c2y : Float, result : Array<Float>) : Void\r\n    {\r\n        var distance  = Math.sqrt((c1x - c2x) * (c1x - c2x) + (c1y - c2y) * (c1y - c2y));\r\n        var t1x  = c1x + r * (c2y - c1y) / distance;\r\n        var t1y = c1y + r * (-c2x + c1x) / distance;\r\n        var t2x  = 2 * c1x - t1x;\r\n        var t2y  = 2 * c1y - t1y;\r\n        var t3x  = t2x + c2x - c1x;\r\n        var t3y  = t2y + c2y - c1y;\r\n        var t4x  = t1x + c2x - c1x;\r\n        var t4y  = t1y + c2y - c1y;\r\n        for (f in [t1x, t1y, t2x, t2y, t3x, t3y, t4x, t4y])\r\n\t\t\tresult.push(f);\r\n    }\r\n    \r\n    // squared distance from point p to infinite line (a, b)\r\n    public static function distanceSquaredPointToLine(px : Float, py : Float, ax : Float, ay : Float, bx : Float, by : Float) : Float\r\n    {\r\n        var a_b_squaredLength  = (bx - ax) * (bx - ax) + (by - ay) * (by - ay);\r\n        var dotProduct  = (px - ax) * (bx - ax) + (py - ay) * (by - ay);\r\n        var p_a_squaredLength  = (ax - px) * (ax - px) + (ay - py) * (ay - py);\r\n        return p_a_squaredLength - dotProduct * dotProduct / a_b_squaredLength;\r\n    }\r\n    \r\n    // squared distance from point p to finite segment [a, b]\r\n    public static function distanceSquaredPointToSegment(px : Float, py : Float, ax : Float, ay : Float, bx : Float, by : Float) : Float\r\n    {\r\n        var a_b_squaredLength = (bx - ax) * (bx - ax) + (by - ay) * (by - ay);\r\n        var dotProduct  = ((px - ax) * (bx - ax) + (py - ay) * (by - ay)) / a_b_squaredLength;\r\n        if (dotProduct < 0) \r\n        {\r\n            return (px - ax) * (px - ax) + (py - ay) * (py - ay);\r\n        }\r\n        else if (dotProduct <= 1) \r\n        {\r\n            var p_a_squaredLength = (ax - px) * (ax - px) + (ay - py) * (ay - py);\r\n            return p_a_squaredLength - dotProduct * dotProduct * a_b_squaredLength;\r\n        }\r\n        else \r\n        {\r\n            return (px - bx) * (px - bx) + (py - by) * (py - by);\r\n        }\r\n    }\r\n    \r\n    public static function distanceSquaredVertexToEdge(vertex : Vertex, edge : Edge) : Float\r\n    {\r\n        return distanceSquaredPointToSegment(vertex.pos.x, vertex.pos.y, edge.originVertex.pos.x, edge.originVertex.pos.y, edge.destinationVertex.pos.x, edge.destinationVertex.pos.y);\r\n    }\r\n    \r\n    public static function pathLength(path : Array<Float>): Float {\r\n        var sumDistance = 0.;\r\n        var fromX = path[ 0 ];\r\n        var fromY = path[ 1 ];\r\n        var nextX : Float;\r\n        var nextY : Float;\r\n        var x : Float;\r\n        var y : Float;\r\n        var distance : Float;\r\n        var i = 2;\r\n        while( i < path.length ){\r\n            nextX = path[ i ];\r\n            nextY = path[ i + 1 ];\r\n            x = nextX - fromX;\r\n            y = nextY - fromY;\r\n            distance = Math.sqrt(x * x + y * y);\r\n            sumDistance += distance;\r\n            fromX = nextX;\r\n            fromY = nextY;\r\n            i += 2;\r\n        }\r\n        \r\n        return sumDistance;\r\n    }\r\n    \r\n    public function new(){}\r\n    \r\n}\r\n","package hxDaedalus.data.math;\r\nimport hxDaedalus.data.math.Point2D;\r\nclass Matrix2D {\r\n    public var a: Float;\r\n    public var b: Float;\r\n    public var c: Float;\r\n    public var d: Float;\r\n    public var e: Float;\r\n    public var f: Float;\r\n\r\n    /*    \r\n    hxDaedalusPoint2D represents row vector in homogeneous coordinates:\r\n    [x, y, 1]\r\n    \r\n    hxDaedalusMatrix2D represents transform matrix in homogeneous coordinates:\r\n    [a, b, 0]\r\n    [c, d, 0]\r\n    [e, f, 1]\r\n    */\r\n    \r\n    \r\n    public function new( a_: Float = 1, b_: Float = 0, c_: Float = 0, d_: Float = 1, e_: Float = 0, f_: Float = 0 ){\r\n        a = a_;\r\n        b = b_;\r\n        c = c_;\r\n        d = d_;\r\n        e = e_;\r\n        f = f_;\r\n    }\r\n    \r\n    public function identity(): Void {\r\n        /*\r\n        [1, 0, 0]\r\n        [0, 1, 0]\r\n        [0, 0, 1]\r\n        */\r\n        \r\n        a = 1;\r\n        b = 0;\r\n        c = 0;\r\n        d = 1;\r\n        e = 0;\r\n        f = 0;\r\n    }\r\n    \r\n    public function translate( tx: Float, ty: Float ): Void {\r\n        /*\r\n        [1,  0,  0]\r\n        [0,  1,  0]\r\n        [tx, ty, 1]\r\n        \r\n        */\r\n        e = e + tx;\r\n        f = f + ty;\r\n    }\r\n    \r\n    public function scale( sx : Float, sy : Float ): Void {\r\n        /*\r\n        [sx, 0, 0]\r\n        [0, sy, 0]\r\n        [0,  0, 1]\r\n        */\r\n        a = a * sx;\r\n        b = b * sy;\r\n        c = c * sx;\r\n        d = d * sy;\r\n        e = e * sx;\r\n        f = f * sy;\r\n    }\r\n    \r\n    public function rotate( rad : Float ): Void {\r\n        /*\r\n        [ cos, sin, 0]\r\n        [-sin, cos, 0]\r\n        [   0,   0, 1]\r\n        \r\n        [a, b, 0]\r\n        [c, d, 0]\r\n        [e, f, 1]\r\n        */\r\n        var cos : Float = Math.cos(rad);\r\n        var sin : Float = Math.sin(rad);\r\n        var a_ : Float = a * cos + b * -sin;\r\n        var b_ : Float = a * sin + b * cos;\r\n        var c_ : Float = c * cos + d * -sin;\r\n        var d_ : Float = c * sin + d * cos;\r\n        var e_ : Float = e * cos + f * -sin;\r\n        var f_ : Float = e * sin + f * cos;\r\n        a = a_;\r\n        b = b_;\r\n        c = c_;\r\n        d = d_;\r\n        e = e_;\r\n        f = f_;\r\n    }\r\n    \r\n    public function clone(): Matrix2D {\r\n        return new Matrix2D(a, b, c, d, e, f);\r\n    }\r\n    \r\n    public function tranform( point: Point2D ): Void {\r\n        /*\r\n        [a, b, 0]\r\n        [c, d, 0]\r\n        [e, f, 1]\r\n        [x, y, 1]\r\n        */\r\n        var x : Float = a * point.x + c * point.y + e;\r\n        var y : Float = b * point.x + d * point.y + f;\r\n        point.x = x;\r\n        point.y = y;\r\n    }\r\n    \r\n    public function transformX( x: Float, y: Float ): Float {\r\n        return a * x + c * y + e;\r\n    }\r\n    \r\n    public function transformY( x : Float, y: Float): Float {\r\n        return b * x + d * y + f;\r\n    }\r\n    \r\n    public function concat( matrix: Matrix2D ): Void {\r\n        var a_ : Float = a * matrix.a + b * matrix.c;\r\n        var b_ : Float = a * matrix.b + b * matrix.d;\r\n        var c_ : Float = c * matrix.a + d * matrix.c;\r\n        var d_ : Float = c * matrix.b + d * matrix.d;\r\n        var e_ : Float = e * matrix.a + f * matrix.c + matrix.e;\r\n        var f_ : Float = e * matrix.b + f * matrix.d + matrix.f;\r\n        a = a_;\r\n        b = b_;\r\n        c = c_;\r\n        d = d_;\r\n        e = e_;\r\n        f = f_;\r\n    }\r\n    \r\n}\r\n","package hxDaedalus.data.math;\r\nclass NodeData\r\n{\r\n    public var index : Int;\r\n    public var point : Point2D;\r\n    \r\n    public function new()\r\n    {\r\n        \r\n        \r\n    }\r\n}","package hxDaedalus.data.math;\r\n\r\n\r\nimport hxDaedalus.data.Constants;\r\nimport hxDaedalus.data.graph.Graph;\r\nimport hxDaedalus.data.graph.GraphEdge;\r\nimport hxDaedalus.data.graph.GraphNode;\r\nimport hxDaedalus.data.math.Point2D;\r\nimport hxDaedalus.graphics.SimpleDrawingContext;\r\nimport hxDaedalus.graphics.Pixels;\r\n\t\r\nclass Potrace\r\n{\r\n\tinline  static var MAX_INT:Int = 0x7FFFFFFF;\r\n    \r\n    public static var maxDistance : Float = 1;\r\n    \r\n    public static function buildShapes( bmpData: Pixels, debugBmp: Pixels = null, debugShape: SimpleDrawingContext = null ) : Array<Array<Float>>\r\n    {\r\n        // OUTLINES STEP-LIKE SHAPES GENERATION\r\n        var shapes = new Array<Array<Float>>();\r\n        var dictPixelsDone = new Map<String,Bool>();\r\n        for (row in 1...bmpData.height - 1){\r\n            for (col in 0...bmpData.width - 1){\r\n                if (bmpData.getPixel(col, row) == 0xFFFFFF && bmpData.getPixel(col + 1, row) < 0xFFFFFF) \r\n                {\r\n                    if (!dictPixelsDone[(col + 1) + \"_\" + row]) \r\n                        shapes.push(buildShape(bmpData, row, col + 1, dictPixelsDone, debugBmp, debugShape));\r\n                }\r\n            }\r\n        }\r\n        \r\n        return shapes;\r\n    }\r\n    \r\n    public static function buildShape(bmpData : Pixels, fromPixelRow : Int, fromPixelCol : Int, dictPixelsDone : Map<String,Bool>, debugBmp : Pixels = null, debugShape : SimpleDrawingContext = null) : Array<Float>\r\n    {\r\n        var newX : Float = fromPixelCol;\r\n        var newY : Float = fromPixelRow;\r\n        var path = [ newX, newY ];\r\n        dictPixelsDone[newX + \"_\" + newY] = true;\r\n        \r\n        var curDir = new Point2D(0, 1);\r\n        var newDir = new Point2D();\r\n        var newPixelRow : Int;\r\n        var newPixelCol : Int;\r\n        var count = -1;\r\n        while (true)\r\n        {\r\n            if (debugBmp != null) \r\n            {\r\n                debugBmp.setPixel32(fromPixelCol, fromPixelRow, 0xFFFF0000);\r\n            }  // take the pixel at right  \r\n            \r\n            \r\n            \r\n            newPixelRow = Std.int( fromPixelRow + curDir.x + curDir.y );\r\n            newPixelCol = Std.int( fromPixelCol + curDir.x - curDir.y );\r\n\t\t\t\r\n            // if the pixel is not white\r\n            if (bmpData.getPixel(newPixelCol, newPixelRow) < 0xFFFFFF) \r\n            {\r\n                // turn the direction right\r\n                newDir.x = -curDir.y;\r\n                newDir.y = curDir.x;\r\n            }\r\n            // if the pixel is white\r\n            else \r\n            {\r\n                // take the pixel straight\r\n                newPixelRow = Std.int( fromPixelRow + curDir.y );\r\n                newPixelCol = Std.int( fromPixelCol + curDir.x );\r\n                // if the pixel is not white\r\n                if (bmpData.getPixel(newPixelCol, newPixelRow) < 0xFFFFFF) \r\n                {\r\n                    // the direction stays the same\r\n                    newDir.x = curDir.x;\r\n                    newDir.y = curDir.y;\r\n                }\r\n                // if the pixel is white\r\n                else \r\n                {\r\n                    // pixel stays the same\r\n                    newPixelRow = fromPixelRow;\r\n                    newPixelCol = fromPixelCol;\r\n                    // turn the direction left\r\n                    newDir.x = curDir.y;\r\n                    newDir.y = -curDir.x;\r\n                }\r\n            }\r\n            newX = newX + curDir.x;\r\n            newY = newY + curDir.y;\r\n            \r\n            if (newX == path[0] && newY == path[1]) \r\n            {\r\n                break;\r\n            }\r\n            else \r\n            {\r\n                path.push(newX);\r\n                path.push(newY);\r\n                dictPixelsDone[newX + \"_\" + newY] = true;\r\n                fromPixelRow = newPixelRow;\r\n                fromPixelCol = newPixelCol;\r\n                curDir.x = newDir.x;\r\n                curDir.y = newDir.y;\r\n            }\r\n            \r\n            count--;\r\n            if (count == 0) \r\n            {\r\n                break;\r\n            }\r\n        }\r\n        \r\n        if (debugShape != null) \r\n        {\r\n            debugShape.lineStyle(0.5, 0x00FF00);\r\n            debugShape.moveTo(path[0], path[1]);\r\n            var i : Int = 2;\r\n            while (i < path.length){\r\n                debugShape.lineTo(path[i], path[i + 1]);\r\n                i += 2;\r\n            }\r\n            debugShape.lineTo(path[0], path[1]);\r\n        }\r\n        \r\n        return path;\r\n    }\r\n    \r\n    public static function buildGraph(shape : Array<Float>) : Graph\r\n    {\r\n        var i : Int;\r\n        var graph : Graph = new Graph();\r\n        var node : GraphNode;\r\n        i = 0;\r\n        while (i < shape.length){\r\n            node = graph.insertNode();\r\n            node.data = new NodeData();\r\n            (node.data).index = i;\r\n            (node.data).point = new Point2D(shape[i], shape[i + 1]);\r\n            i += 2;\r\n        }\r\n        \r\n        var node1 : GraphNode;\r\n        var node2 : GraphNode;\r\n        var subNode : GraphNode;\r\n        var distSqrd : Float;\r\n        var sumDistSqrd : Float;\r\n        var count : Int;\r\n        var isValid : Bool;\r\n        var edge : GraphEdge;\r\n        var edgeData : EdgeData;\r\n        node1 = graph.node;\r\n        while (node1 != null )\r\n        {\r\n            node2 = ( node1.next != null ) ? node1.next : graph.node;\r\n            while (node2 != node1)\r\n            {\r\n                isValid = true;\r\n                subNode = ( node1.next != null ) ? node1.next : graph.node;\r\n                count = 2;\r\n                sumDistSqrd = 0;\r\n                while (subNode != node2)\r\n                {\r\n                    distSqrd = Geom2D.distanceSquaredPointToSegment((subNode.data).point.x, (subNode.data).point.y, (node1.data).point.x, (node1.data).point.y, (node2.data).point.x, (node2.data).point.y);\r\n                    if (distSqrd < 0) \r\n                        distSqrd = 0;\r\n                    if (distSqrd >= maxDistance) \r\n                    {\r\n                        //subNode not valid\r\n                        isValid = false;\r\n                        break;\r\n                    }\r\n                    \r\n                    count++;\r\n                    sumDistSqrd += distSqrd;\r\n                    subNode = ( subNode.next != null ) ? subNode.next : graph.node;\r\n                }\r\n                \r\n                if (!isValid) \r\n                {\r\n                    //segment not valid\r\n                    break;\r\n                }\r\n                \r\n                edge = graph.insertEdge(node1, node2);\r\n                edgeData = new EdgeData();\r\n                edgeData.sumDistancesSquared = sumDistSqrd;\r\n                edgeData.length = (node1.data).point.distanceTo((node2.data).point);\r\n                edgeData.nodesCount = count;\r\n                edge.data = edgeData;\r\n                \r\n                node2 = ( node2.next != null ) ? node2.next : graph.node;\r\n            }\r\n            \r\n            node1 = node1.next;\r\n        }\r\n        \r\n        return graph;\r\n    }\r\n    \r\n    public static function buildPolygon(graph : Graph, debugShape : Dynamic = null) : Array<Float>\r\n    {\r\n        var polygon : Array<Float> = new Array<Float>();\r\n        \r\n        var currNode : GraphNode;\r\n        // TODO: check if Int.MAX_VALUE below is suitable.\r\n        var minNodeIndex : Int = MAX_INT;\r\n        var edge : GraphEdge;\r\n        var score : Float;\r\n        var higherScore : Float;\r\n        var lowerScoreEdge : GraphEdge = null;\r\n        currNode = graph.node;\r\n        while( (currNode.data).index < minNodeIndex ){\r\n            \r\n            minNodeIndex = (currNode.data).index;\r\n            \r\n            polygon.push((currNode.data).point.x);\r\n            polygon.push((currNode.data).point.y);\r\n            \r\n            higherScore = 0;\r\n            \r\n            edge = currNode.outgoingEdge;\r\n            while( edge!= null )\r\n            {\r\n                score = (edge.data).nodesCount - (edge.data).length * Math.sqrt((edge.data).sumDistancesSquared / (edge.data).nodesCount);\r\n                if (score > higherScore) \r\n                {\r\n                    higherScore = score;\r\n                    lowerScoreEdge = edge;\r\n                }\r\n                \r\n                edge = edge.rotNextEdge;\r\n            }\r\n            \r\n            currNode = lowerScoreEdge.destinationNode;\r\n        }\r\n        \r\n        if (Geom2D.getDirection(polygon[polygon.length - 2], polygon[polygon.length - 1], polygon[0], polygon[1], polygon[2], polygon[3]) == 0) \r\n        {\r\n            polygon.shift();\r\n            polygon.shift();\r\n        }\r\n        \r\n        if (debugShape != null) \r\n        {\r\n            debugShape.graphics.lineStyle(0.5, 0x0000FF);\r\n            debugShape.graphics.moveTo(polygon[0], polygon[1]);\r\n            var i : Int = 2;\r\n            while (i < polygon.length){\r\n                debugShape.graphics.lineTo(polygon[i], polygon[i + 1]);\r\n                i += 2;\r\n            }\r\n            debugShape.graphics.lineTo(polygon[0], polygon[1]);\r\n        }\r\n        \r\n        return polygon;\r\n    }\r\n\r\n    public function new()\r\n    {\r\n    }\r\n}\r\n","package hxDaedalus.data.math;\r\n\r\nclass RandGenerator\r\n{\r\n    public var seed(get, set) : Int;\r\n    public var rangeMin: Int;\r\n    public var rangeMax: Int;\r\n\r\n    \r\n     var _originalSeed : Int;\r\n     var _currSeed : Int;\r\n     var _rangeMin : Int;\r\n     var _rangeMax : Int;\r\n    \r\n     var _numIter : Int;\r\n     var _tempString : String;\r\n    \r\n    public function new( seed: Int = 1234, rangeMin_: Int = 0, rangeMax_: Int = 1 )\r\n    {\r\n        _originalSeed = _currSeed = seed;\r\n        rangeMin = rangeMin_;\r\n        rangeMax = rangeMax_;\r\n        \r\n        _numIter = 0;\r\n    }\r\n    \r\n     function set_seed(value : Int) : Int{_originalSeed = _currSeed = value;\r\n        return value;\r\n    }\r\n\r\n    \r\n     function get_seed() : Int{return _originalSeed;\r\n    }\r\n\r\n    \r\n    public function reset() : Void\r\n    {\r\n        _currSeed = _originalSeed;\r\n        _numIter = 0;\r\n    }\r\n    \r\n    public function next() : Int\r\n    {\r\n        var _floatSeed:Float = _currSeed * 1.0;\t// TODO: remove `* 1.0` if haxe issue #3552 is fixed\r\n        _tempString = Std.string((_floatSeed * _floatSeed));\r\n        while (_tempString.length < 8) _tempString = \"0\" + _tempString; \r\n        _currSeed = Std.parseInt(_tempString.substr(1, 5));\r\n        var res : Int = Math.round(rangeMin + (_currSeed / 99999) * (rangeMax - rangeMin));\r\n        if( _currSeed == 0 ) _currSeed = _originalSeed + _numIter;\r\n        _numIter++;\r\n        if( _numIter == 200 ) reset();\r\n        return res;\r\n    }\r\n\t\r\n\tpublic function nextInRange(rangeMin:Int, rangeMax:Int):Int\r\n\t{\r\n\t\tthis.rangeMin = rangeMin;\r\n\t\tthis.rangeMax = rangeMax;\r\n\t\treturn next();\r\n\t}\r\n\t\r\n\t// Knuth shuffle\r\n\tpublic function shuffle<T>(array:Array<T>):Void {\r\n\t\tvar currIdx = array.length;\r\n\t\t\r\n\t\twhile (currIdx > 0) {\r\n\t\t\tvar rndIdx = nextInRange(0, currIdx-1);\r\n\t\t\tcurrIdx--;\r\n\t\t\t\r\n\t\t\tvar tmp = array[currIdx];\r\n\t\t\tarray[currIdx] = array[rndIdx];\r\n\t\t\tarray[rndIdx] = tmp;\r\n\t\t}\r\n\t}\r\n}\r\n","package hxDaedalus.data.math;\r\n\r\nimport hxDaedalus.debug.Debug;\r\n\r\nclass ShapeSimplifier\r\n{\r\n\r\n\t/**\r\n\t * Simplify polyline (Ramer-Douglas-Peucker).\r\n\t * \r\n\t * @param\tcoords\t\tArray of coords defining the polyline.\r\n\t * @param\tepsilon\t\tPerpendicular distance threshold (typically in the range [1..2]).\r\n\t * @return\tAn array of coords defining the simplified polyline.\r\n\t */\r\n\tstatic public function simplify(coords:Array<Float>, epsilon:Float = 1):Array<Float> \r\n\t{\r\n\t\tvar len = coords.length;\r\n\t\tDebug.assertFalse((len & 1) != 0, \"Wrong size\");\r\n\t\t\r\n\t\tif (len <= 4) {\r\n\t\t\treturn [].concat(coords);\r\n\t\t}\r\n\t\t\r\n\t\tvar firstPointX = coords[0];\r\n\t\tvar firstPointY = coords[1];\r\n\t\tvar lastPointX = coords[len - 2];\r\n\t\tvar lastPointY = coords[len - 1];\r\n\t\t\r\n\t\tvar index = -1;\r\n\t\tvar dist = 0.;\r\n\t\tfor (i in 1...len >> 1) {\r\n\t\t\tvar currDist = Geom2D.distanceSquaredPointToSegment(coords[i << 1], coords[(i << 1) + 1], firstPointX, firstPointY, lastPointX, lastPointY);\r\n\t\t\tif (currDist > dist) {\r\n\t\t\t\tdist = currDist;\r\n\t\t\t\tindex = i;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (dist > epsilon * epsilon) {\r\n\t\t\t// recurse\r\n\t\t\tvar l1 = coords.slice(0, (index << 1) + 2);\r\n\t\t\tvar l2 = coords.slice(index << 1);\r\n\t\t\tvar r1 = simplify(l1, epsilon);\r\n\t\t\tvar r2 = simplify(l2, epsilon);\r\n\t\t\t// concat r2 to r1 minus the end/startpoint that will be the same\r\n\t\t\tvar rs = r1.slice(0, r1.length - 2).concat(r2);\r\n\t\t\treturn rs;\r\n\t\t} else {\r\n\t\t\treturn [firstPointX, firstPointY, lastPointX, lastPointY];\r\n\t\t}\r\n\t}\r\n}","package hxDaedalus.debug;\r\n\r\nimport haxe.PosInfos;\r\n\r\n\r\n/**\r\n * Used for sanity-checks throughout the code when in debug mode (or if -D DAEDALUS_CHECKS is passed to the compiler).\r\n * Should be automatically stripped out by the compiler in release mode (or if -D NO_DAEDALUS_CHECKS is passed to the compiler).\r\n * Same applies to -D DAEDALUS_TRACE and -D NO_DAEDALUS_TRACE.\r\n */\r\nclass Debug\r\n{\r\n\t\r\n#if ((debug && !NO_DAEDALUS_CHECKS) || DAEDALUS_CHECKS)\r\n\r\n\tstatic public function assertTrue(cond:Bool, ?message:String, ?pos:PosInfos) {\r\n\t\tif (!cond) {\r\n\t\t\tthrow pos.fileName + \":\" + pos.lineNumber + \": Expected true but was false! \" + (message != null ? message : \"\");\r\n\t\t}\r\n\t}\r\n\t\r\n\tstatic public function assertFalse(cond:Bool, ?message:String, ?pos:PosInfos) {\r\n\t\tif (cond) {\r\n\t\t\tthrow pos.fileName + \":\" + pos.lineNumber + \": Expected false but was true! \" + (message != null ? message : \"\");\r\n\t\t}\r\n\t}\r\n\t\r\n\tstatic public function assertEquals<T>(expected:T, actual:T, ?message:String, ?pos:PosInfos) {\r\n\t\tif (actual != expected) {\r\n\t\t\tthrow pos.fileName + \":\" + pos.lineNumber + \": Expected '\" + expected + \"' but was '\" + actual + \"' \" + (message != null ? message : \"\");\r\n\t\t}\r\n\t}\r\n\t\r\n#elseif (!debug || NO_DAEDALUS_CHECKS)\r\n\r\n\tinline static public function assertTrue(cond:Bool, ?message:String, ?pos:PosInfos) {\r\n\t\treturn;\r\n\t}\r\n\t\r\n\tinline static public function assertFalse(cond:Bool, ?message:String, ?pos:PosInfos) {\r\n\t\treturn;\r\n\t}\r\n\t\r\n\tinline static public function assertEquals<T>(expected:T, actual:T, ?message:String, ?pos:PosInfos) {\r\n\t\treturn;\r\n\t}\r\n\r\n#end\r\n\r\n\r\n#if ((debug && !NO_DAEDALUS_TRACE) || DAEDALUS_TRACE)\r\n\r\n\tinline static public function trace(value:Dynamic, ?pos:PosInfos) {\r\n\t\thaxe.Log.trace(value, pos);\r\n\t}\r\n\r\n#elseif (!debug || NO_DAEDALUS_TRACE)\r\n\r\n\tinline static public function trace(value:Dynamic, ?pos:PosInfos) {\r\n\t\treturn;\r\n\t}\r\n\r\n#end\r\n}","package hxDaedalus.factories;\r\n\r\n\r\nimport hxDaedalus.data.math.ShapeSimplifier;\r\nimport hxDaedalus.data.Object;\r\nimport hxDaedalus.data.graph.Graph;\r\nimport hxDaedalus.data.math.Potrace;\r\nimport hxDaedalus.debug.Debug;\r\nimport hxDaedalus.graphics.SimpleDrawingContext;\r\nimport hxDaedalus.graphics.Pixels;\r\n\r\nclass BitmapObject\r\n{\r\n    public function new(){}\r\n    public static function buildFromBmpData(    bmpData: Pixels\r\n\t\t\t\t\t\t\t\t\t\t\t,\tsimplificationEpsilon:Float = 1\r\n                                            ,   debugBmp: Pixels = null\r\n                                            ,   debugShape : SimpleDrawingContext = null\r\n                                            ) : Object\r\n    {\r\n        var i : Int;\r\n        var j : Int;\r\n        \r\n\t\tDebug.assertTrue(bmpData.width > 0 && bmpData.height > 0, 'Invalid `bmpData` size (${bmpData.width}, ${bmpData.height})');\r\n\t\t\r\n        // OUTLINES STEP-LIKE SHAPES GENERATION\r\n        var shapes : Array<Array<Float>> = Potrace.buildShapes(bmpData, debugBmp, debugShape);\r\n        \r\n\t\t// SIMPLIFY SHAPES (REDUCE NUMBER OF POINTS)\r\n\t\tif (simplificationEpsilon >= 1) {\r\n\t\t\tfor (i in 0...shapes.length) {\r\n\t\t\t\tshapes[i] = ShapeSimplifier.simplify(shapes[i], simplificationEpsilon);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n        // GRAPHS OF POTENTIAL SEGMENTS GENERATION\r\n        var graphs = new Array<Graph>();\r\n        for (i in 0...shapes.length){\r\n            graphs.push( Potrace.buildGraph(shapes[i]) );\r\n        }  \r\n\t\t\r\n        // OPTIMIZED POLYGONS GENERATION  \r\n        var polygons : Array<Array<Float>> = new Array<Array<Float>>();\r\n        for (i in 0...graphs.length){\r\n            polygons.push(Potrace.buildPolygon(graphs[i], debugShape));\r\n        }   \r\n        \r\n        // OBJECT GENERATION  \r\n        var obj : Object = new Object();\r\n        for (i in 0...polygons.length){\r\n            j = 0;\r\n            while (j < polygons[i].length - 2)\r\n            {   \r\n                obj.coordinates.push(polygons[i][j]);\r\n                obj.coordinates.push(polygons[i][j + 1]);\r\n                obj.coordinates.push(polygons[i][j + 2]);\r\n                obj.coordinates.push(polygons[i][j + 3]);\r\n                j += 2;\r\n            }\r\n            obj.coordinates.push(polygons[i][0]);\r\n            obj.coordinates.push(polygons[i][1]);\r\n            obj.coordinates.push(polygons[i][j]);\r\n            obj.coordinates.push(polygons[i][j + 1]);        \r\n        }\r\n        return obj;\r\n    }\r\n    \r\n}\r\n","package hxDaedalus.factories;\r\n\r\n\r\nimport hxDaedalus.data.Constants;\r\nimport hxDaedalus.data.ConstraintSegment;\r\nimport hxDaedalus.data.ConstraintShape;\r\nimport hxDaedalus.data.Edge;\r\nimport hxDaedalus.data.Face;\r\nimport hxDaedalus.data.Mesh;\r\nimport hxDaedalus.data.Vertex;\r\n\r\nclass RectMesh\r\n{\r\n    \r\n    public static function buildRectangle( width: Float, height: Float) : Mesh\r\n    {\r\n        /*\r\n           TL\r\n             ----+-----+ TR\r\n        \\   |    /|\r\n        \\   |   / |\r\n        \\   |  /  |\r\n        \\   | /   |\r\n        \\   |/    |\r\n        \\   +-----+ BR\r\n        \\  BL     \\\r\n        \\----------\r\n        */\r\n        \r\n        var vTL = new Vertex();\r\n        var vTR = new Vertex();\r\n        var vBR = new Vertex();\r\n        var vBL = new Vertex();\r\n        \r\n        var eTL_TR = new Edge();\r\n        var eTR_TL = new Edge();\r\n        var eTR_BR = new Edge();\r\n        var eBR_TR = new Edge();\r\n        var eBR_BL = new Edge();\r\n        var eBL_BR = new Edge();\r\n        var eBL_TL = new Edge();\r\n        var eTL_BL = new Edge();\r\n        var eTR_BL = new Edge();\r\n        var eBL_TR = new Edge();\r\n        var eTL_BR = new Edge();\r\n        var eBR_TL = new Edge();\r\n        \r\n        var fTL_BL_TR = new Face();\r\n        var fTR_BL_BR = new Face();\r\n        var fTL_BR_BL = new Face();\r\n        var fTL_TR_BR = new Face();\r\n        \r\n        var boundShape : ConstraintShape = new ConstraintShape();\r\n        var segTop : ConstraintSegment = new ConstraintSegment();\r\n        var segRight : ConstraintSegment = new ConstraintSegment();\r\n        var segBot : ConstraintSegment = new ConstraintSegment();\r\n        var segLeft : ConstraintSegment = new ConstraintSegment();\r\n        \r\n        var mesh : Mesh = new Mesh(width, height);\r\n        \r\n        //\r\n        \r\n        var offset : Float = Constants.EPSILON * 1000;\r\n        vTL.pos.setXY( 0 - offset, 0 - offset);\r\n        vTR.pos.setXY( width + offset, 0 - offset);\r\n        vBR.pos.setXY( width + offset, height + offset);\r\n        vBL.pos.setXY( 0 - offset, height + offset);\r\n        \r\n        vTL.setDatas(eTL_TR);\r\n        vTR.setDatas(eTR_BR);\r\n        vBR.setDatas(eBR_BL);\r\n        vBL.setDatas(eBL_TL);\r\n        \r\n        eTL_TR.setDatas(vTL, eTR_TL, eTR_BR, fTL_TR_BR, true, true);\r\n        eTR_TL.setDatas(vTR, eTL_TR, eTL_BL, fTL_BL_TR, true, true);\r\n        eTR_BR.setDatas(vTR, eBR_TR, eBR_TL, fTL_TR_BR, true, true);\r\n        eBR_TR.setDatas(vBR, eTR_BR, eTR_BL, fTR_BL_BR, true, true);\r\n        eBR_BL.setDatas(vBR, eBL_BR, eBL_TL, fTL_BR_BL, true, true);\r\n        eBL_BR.setDatas(vBL, eBR_BL, eBR_TR, fTR_BL_BR, true, true);\r\n        eBL_TL.setDatas(vBL, eTL_BL, eTL_BR, fTL_BR_BL, true, true);\r\n        eTL_BL.setDatas(vTL, eBL_TL, eBL_TR, fTL_BL_TR, true, true);\r\n        eTR_BL.setDatas(vTR, eBL_TR, eBL_BR, fTR_BL_BR, true, false);  // diagonal edge  \r\n        eBL_TR.setDatas(vBL, eTR_BL, eTR_TL, fTL_BL_TR, true, false);  // diagonal edge  \r\n        eTL_BR.setDatas(vTL, eBR_TL, eBR_BL, fTL_BR_BL, false, false);  // imaginary edge  \r\n        eBR_TL.setDatas(vBR, eTL_BR, eTL_TR, fTL_TR_BR, false, false);  // imaginary edge  \r\n        \r\n        fTL_BL_TR.setDatas(eBL_TR);\r\n        fTR_BL_BR.setDatas(eTR_BL);\r\n        fTL_BR_BL.setDatas(eBR_BL, false);\r\n        fTL_TR_BR.setDatas(eTR_BR, false);\r\n        \r\n        // constraint relations datas\r\n        vTL.fromConstraintSegments = [ segTop, segLeft ];\r\n        vTR.fromConstraintSegments = [ segTop, segRight ];\r\n        vBR.fromConstraintSegments = [ segRight, segBot ];\r\n        vBL.fromConstraintSegments = [ segBot, segLeft ];\r\n        \r\n        eTL_TR.fromConstraintSegments.push(segTop);\r\n        eTR_TL.fromConstraintSegments.push(segTop);\r\n        eTR_BR.fromConstraintSegments.push(segRight);\r\n        eBR_TR.fromConstraintSegments.push(segRight);\r\n        eBR_BL.fromConstraintSegments.push(segBot);\r\n        eBL_BR.fromConstraintSegments.push(segBot);\r\n        eBL_TL.fromConstraintSegments.push(segLeft);\r\n        eTL_BL.fromConstraintSegments.push(segLeft);\r\n        \r\n        segTop.edges.push(eTL_TR);\r\n        segRight.edges.push(eTR_BR);\r\n        segBot.edges.push(eBR_BL);\r\n        segLeft.edges.push(eBL_TL);\r\n        segTop.fromShape = boundShape;\r\n        segRight.fromShape = boundShape;\r\n        segBot.fromShape = boundShape;\r\n        segLeft.fromShape = boundShape;\r\n        \r\n        for(f in [segTop, segRight, segBot, segLeft]) boundShape.segments.push(f);\r\n        for(f in [vTL, vTR, vBR, vBL]) mesh._vertices.push(f);\r\n        for(f in [eTL_TR, eTR_TL, eTR_BR, eBR_TR, eBR_BL, eBL_BR, eBL_TL, eTL_BL, eTR_BL, eBL_TR, eTL_BR, eBR_TL]) mesh._edges.push(f);\r\n        for( f in [fTL_BL_TR, fTR_BL_BR, fTL_BR_BL, fTL_TR_BR]) mesh._faces.push(f);\r\n        mesh.__constraintShapes.push(boundShape);\r\n        var securityRect = new Array<Float>();\r\n        for( f in [0, 0, width, 0]) securityRect.push(f);\r\n        for( f in [width, 0, width, height]) securityRect.push(f);\r\n        for( f in [width, height, 0, height]) securityRect.push(f);\r\n        for( f in [0, height, 0, 0]) securityRect.push(f);\r\n        \r\n        mesh.clipping = false;\r\n        mesh.insertConstraintShape(securityRect);\r\n        mesh.clipping = true;\r\n        \r\n        return mesh;\r\n    }\r\n\r\n    public function new()\r\n    {\r\n    }\r\n}\r\n","package hxDaedalus.graphics;\r\n\r\nimport haxe.io.Bytes;\r\n\r\n\r\n/**\r\n * Class abstracting pixels for various libs/targets (for easier manipulation).\r\n * \r\n * The exposed get/set methods will transparently work in ARGB format, while\r\n * the underlying bytes' pixel format will be automatically inferenced when one \r\n * of the `from_` methods is called.\r\n * \r\n * You can still override the channel mapping by setting `format` afterwards.\r\n * \r\n * @author azrafe7\r\n */\r\n@:forward\r\nabstract Pixels(PixelsData)\r\n{\r\n\tstatic inline var CHANNEL_MASK:Int = 3;\r\n\t\r\n\t/** \r\n\t * Constructor. If `alloc` is false no memory will be allocated for `bytes`, \r\n\t * but the other properties (width, height, count) will still be set.\r\n\t */\r\n\tinline public function new(width:Int, height:Int, alloc:Bool = true) \r\n\t{\r\n\t\tthis = new PixelsData(width, height, alloc);\r\n\t}\r\n\t\r\n\t/** Byte value at `i` position, as if the data were in ARGB format. */\r\n\tinline public function getByte(i:Int) {\r\n\t\treturn this.bytes.get((i & ~CHANNEL_MASK) + this.format.channelMap[i & CHANNEL_MASK]);\r\n\t}\r\n\t\r\n\t/** Pixel value (without alpha) at `x`,`y`, as if the data were in ARGB format. */\r\n\tinline public function getPixel(x:Int, y:Int) {\r\n\t\tvar pos = (y * this.width + x) << 2;\r\n\t\t\r\n\t\tvar r = this.bytes.get(pos + this.format.R) << 16;\r\n\t\tvar g = this.bytes.get(pos + this.format.G) << 8;\r\n\t\tvar b = this.bytes.get(pos + this.format.B);\r\n\t\t\r\n\t\treturn r | g | b;\r\n\t}\r\n\t\r\n\t/** Pixel value (with alpha) at `x`,`y`, as if the data were in ARGB format. */\r\n\tinline public function getPixel32(x:Int, y:Int) {\r\n\t\tvar pos = (y * this.width + x) << 2;\r\n\t\t\r\n\t\tvar a = this.bytes.get(pos + this.format.A) << 24;\r\n\t\tvar r = this.bytes.get(pos + this.format.R) << 16;\r\n\t\tvar g = this.bytes.get(pos + this.format.G) << 8;\r\n\t\tvar b = this.bytes.get(pos + this.format.B);\r\n\t\t\r\n\t\treturn a | r | g | b;\r\n\t}\r\n\t\r\n\t/** Sets the byte value at `i` pos, as if the data were in ARGB format. */\r\n\tinline public function setByte(i:Int, value:Int) {\r\n\t\tthis.bytes.set((i & ~CHANNEL_MASK) + this.format.channelMap[i & CHANNEL_MASK], value);\r\n\t}\r\n\t\r\n\t/** Sets the pixel value (without alpha) at `x`,`y`, with `value` expressed in RGB format. */\r\n\tinline public function setPixel(x:Int, y:Int, value:Int) {\r\n\t\tvar pos = (y * this.width + x) << 2;\r\n\t\t\r\n\t\tvar r = (value >> 16) & 0xFF;\r\n\t\tvar g = (value >> 8) & 0xFF;\r\n\t\tvar b = (value) & 0xFF;\r\n\r\n\t\tthis.bytes.set(pos + this.format.R, r);\r\n\t\tthis.bytes.set(pos + this.format.G, g);\r\n\t\tthis.bytes.set(pos + this.format.B, b);\r\n\t}\r\n\t\r\n\t/** Sets the pixel value (with alpha) at `x`,`y`, with `value` expressed in ARGB format. */\r\n\tinline public function setPixel32(x:Int, y:Int, value:Int) {\r\n\t\tvar pos = (y * this.width + x) << 2;\r\n\t\t\r\n\t\tvar a = (value >> 24) & 0xFF;\r\n\t\tvar r = (value >> 16) & 0xFF;\r\n\t\tvar g = (value >> 8) & 0xFF;\r\n\t\tvar b = (value) & 0xFF;\r\n\r\n\t\tthis.bytes.set((pos + this.format.A), a);\r\n\t\tthis.bytes.set((pos + this.format.R), r);\r\n\t\tthis.bytes.set((pos + this.format.G), g);\r\n\t\tthis.bytes.set((pos + this.format.B), b);\r\n\t}\r\n\t\r\n\tpublic function clone():Pixels {\r\n\t\tvar clone:Pixels = new Pixels(this.width, this.height, true);\r\n\t\tclone.bytes.blit(0, this.bytes, 0, this.bytes.length);\r\n\t\treturn clone;\r\n\t}\r\n\t\r\n#if (flambe) // in flambe texture bytes are in RGBA format\r\n\r\n\t@:from static public function fromFlambeTexture(texture:flambe.display.Texture) {\r\n\t\tvar pixels = new Pixels(texture.width, texture.height, false);\r\n\t\tpixels.format = PixelFormat.RGBA;\r\n\t\t\r\n\t\tpixels.bytes = texture.readPixels(0, 0, texture.width, texture.height);\r\n\t\t\r\n\t\treturn pixels;\r\n\t}\r\n\t\r\n\t#if (flambe && html) // not possible in (flambe && flash) due to Stage3D limitations\r\n\tpublic function applyToFlambeTexture(texture:flambe.display.Texture) {\r\n\t\ttexture.writePixels(this.bytes, 0, 0, this.width, this.height);\r\n\t}\r\n\t#end\r\n\r\n#end\r\n\r\n#if (snow || luxe) // in snow/luxe texture bytes are in RGBA format (and must account for power_of_two sizes)\r\n\t\r\n\t@:from static public function fromLuxeTexture(texture:phoenix.Texture) {\r\n\t\tvar pixels = new Pixels(texture.width, texture.height, true);\r\n\t\tpixels.format = PixelFormat.RGBA;\r\n\t\t\r\n\t\tvar pot_w = texture.width_actual;\r\n\t\tvar data:snow.io.typedarray.Uint8Array = texture.asset.image.data;\r\n\t\t\r\n\t\tvar i = 0;\r\n\t\tfor (y in 0...pixels.height) {\r\n\t\t\tfor (x in 0...pixels.width) {\r\n\t\t\t\tvar pos:Int = (x << 2) + (y << 2) * pot_w;\r\n\t\t\t\tpixels.bytes.set(i++, data[pos + 0]);\r\n\t\t\t\tpixels.bytes.set(i++, data[pos + 1]);\r\n\t\t\t\tpixels.bytes.set(i++, data[pos + 2]);\r\n\t\t\t\tpixels.bytes.set(i++, data[pos + 3]);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn pixels;\r\n\t}\r\n\t\r\n\tpublic function applyToLuxeTexture(texture:phoenix.Texture) {\r\n\t\t\r\n\t\tvar pot_w = texture.width_actual;\r\n\t\tvar data:snow.io.typedarray.Uint8Array = texture.asset.image.data;\r\n\t\t\r\n\t\tvar i = 0;\r\n\t\tfor (y in 0...this.height) {\r\n\t\t\tfor (x in 0...this.width) {\r\n\t\t\t\tvar pos:Int = (x << 2) + (y << 2) * pot_w;\r\n\t\t\t\tdata[pos + 0] = this.bytes.get(i++);\r\n\t\t\t\tdata[pos + 1] = this.bytes.get(i++);\r\n\t\t\t\tdata[pos + 2] = this.bytes.get(i++);\r\n\t\t\t\tdata[pos + 3] = this.bytes.get(i++);\r\n\t\t\t}\r\n\t\t}\r\n\t\ttexture.reset();  // rebind texture\r\n\t}\r\n#end\r\n\r\n#if (flash || openfl || nme || (flambe && flash))\r\n\r\n\t@:from static public function fromBitmapData(bmd:flash.display.BitmapData) {\r\n\t#if js\t\r\n\t\r\n\t\tvar pixels = new Pixels(bmd.width, bmd.height);\r\n\t\tpixels.format = PixelFormat.ARGB;\r\n\t\t\r\n\t\t// this seems faster than other alternatives using getPixels/getVector\r\n\t\tfor (y in 0...pixels.height) {\r\n\t\t\tfor (x in 0...pixels.width) {\r\n\t\t\t\tpixels.setPixel32(x, y, bmd.getPixel32(x, y));\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t#else\r\n\t\t\r\n\t\tvar pixels = new Pixels(bmd.width, bmd.height, false);\r\n\t\tpixels.format = PixelFormat.ARGB;\r\n\t\t\r\n\t\tvar ba = bmd.getPixels(bmd.rect);\r\n\t\t\r\n\t\t#if flash\r\n\t\t\tpixels.bytes = Bytes.ofData(ba);\r\n\t\t#else\r\n\t\t\tpixels.bytes = Bytes.ofData(ba.getData());\r\n\t\t#end\r\n\t\r\n\t#end\r\n\t\r\n\t\treturn pixels;\r\n\t}\r\n\t\r\n\tpublic function applyToBitmapData(bmd:flash.display.BitmapData) {\r\n\t#if js\r\n\t\t\r\n\t\tfor (y in 0...this.height) {\r\n\t\t\tfor (x in 0...this.width) {\r\n\t\t\t\tbmd.setPixel32(x, y, getPixel32(x, y));\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t#else\r\n\t\r\n\t\tvar ba = bmd.getPixels(bmd.rect);\r\n\t\t\r\n\t\t#if (openfl && !flash)\r\n\t\t\tba.blit(0, this.bytes, 0, this.bytes.length);\r\n\t\t#else\r\n\t\t\tba.position = 0;\r\n\t\t\tba.writeBytes(this.bytes.getData());\r\n\t\t#end\r\n\t\t\r\n\t\tba.position = 0;\r\n\t\tbmd.setPixels(bmd.rect, ba);\r\n\t\t\r\n\t#end\r\n\t}\r\n\r\n#end\r\n\r\n#if java\r\n\r\n\t@:from static public function fromBufferedImage(image:java.awt.image.BufferedImage) {\r\n\t\tvar pixels = new Pixels(image.getWidth(), image.getHeight(), true);\r\n\t\tpixels.format = PixelFormat.RGBA;\r\n\t\t\r\n\t\tvar buffer = new java.NativeArray<Int>(pixels.bytes.length);\r\n\t\tbuffer = image.getRaster().getPixels(0, 0, pixels.width, pixels.height, buffer);\r\n\t\t\r\n\t\tfor (i in 0...buffer.length) pixels.bytes.set(i, buffer[i]);\r\n\t\t\r\n\t\treturn pixels;\r\n\t}\r\n\t\r\n\tpublic function applyToBufferedImage(image:java.awt.image.BufferedImage) {\r\n\t\tvar imageType = image.getType();\r\n\t\t\r\n\t\tvar buffer = new java.NativeArray<Int>(this.bytes.length);\r\n\t\tfor (i in 0...buffer.length) buffer[i] = this.bytes.get(i);\r\n\t\t\r\n\t\timage.getRaster().setPixels(0, 0, this.width, this.height, buffer);\r\n\t}\r\n\r\n#end\r\n\r\n#if js\t// plain js - conversion from ImageData\r\n\r\n\t@:from static public function fromImageData(image:js.html.ImageData) {\r\n\t\tvar pixels = new Pixels(image.width, image.height, true);\r\n\t\tpixels.format = PixelFormat.ARGB;\r\n\t\t\r\n\t\tvar data = image.data;\r\n\t\t\r\n\t\tfor (i in 0...data.byteLength) {\r\n\t\t\tpixels.bytes.set(i, data[i]);\r\n\t\t}\r\n\t\t\r\n\t\treturn pixels;\r\n\t}\r\n\r\n#end\r\n}\r\n\r\n@:allow(hxDaedalus.graphics.Pixels)\r\nprivate class PixelsData\r\n{\r\n\tinline static public var BYTES_PER_PIXEL:Int = 4;\r\n\t\r\n\t/** Total number of pixels. */\r\n\tpublic var count(default, null):Int;\r\n\t\r\n\t/** Bytes representing the pixels (in `format` pixel format). */\r\n\tpublic var bytes(default, null):Bytes;\r\n\t\r\n\t/** Width of the source image. */\r\n\tpublic var width(default, null):Int;\r\n\t\r\n\t/** Height of the source image. */\r\n\tpublic var height(default, null):Int;\r\n\t\r\n\t/** Internal pixel format. */\r\n\tpublic var format:PixelFormat;\r\n\t\r\n\t/** \r\n\t * Constructor. If `alloc` is false no memory will be allocated for `bytes`, \r\n\t * but the other properties (width, height, count) will still be set.\r\n\t * \r\n\t * `format` defaults to ARGB.\r\n\t */\r\n\tpublic function new(width:Int, height:Int, alloc:Bool = true, format:PixelFormat = null)\r\n\t{\r\n\t\tthis.count = width * height;\r\n\t\t\r\n\t\tif (alloc) bytes = Bytes.alloc(this.count << 2);\r\n\t\t\r\n\t\tthis.width = width;\r\n\t\tthis.height = height;\r\n\t\tthis.format = format != null ? format : PixelFormat.ARGB;\r\n\t}\r\n}\r\n\r\nclass PixelFormat {\r\n\t\r\n\tstatic public var ARGB(default, null):PixelFormat;\r\n\tstatic public var RGBA(default, null):PixelFormat;\r\n\t\r\n\tpublic var channelMap(default, null):Array<Channel>;\r\n\t\r\n\tvar name:String;\r\n\t\r\n\tstatic function __init__():Void {\r\n\t\tARGB = new PixelFormat(CH_0, CH_1, CH_2, CH_3, \"ARGB\");\r\n\t\tRGBA = new PixelFormat(CH_3, CH_0, CH_1, CH_2, \"RGBA\");\r\n\t}\r\n\t\r\n\tpublic function new(a:Channel, r:Channel, g:Channel, b:Channel, name:String = \"PixelFormat\"):Void {\r\n\t\tthis.channelMap = [a, r, g, b];\r\n\t\tthis.name = name;\r\n\t}\r\n\t\r\n\tpublic var A(get, null):Int;\r\n\tinline private function get_A():Int {\r\n\t\treturn channelMap[0];\r\n\t}\r\n\t\r\n\tpublic var R(get, null):Int;\r\n\tinline private function get_R():Int {\r\n\t\treturn channelMap[1];\r\n\t}\r\n\t\r\n\tpublic var G(get, null):Int;\r\n\tinline private function get_G():Int {\r\n\t\treturn channelMap[2];\r\n\t}\r\n\t\r\n\tpublic var B(get, null):Int;\r\n\tinline private function get_B():Int {\r\n\t\treturn channelMap[3];\r\n\t}\r\n\t\r\n\tpublic function toString():String {\r\n\t\treturn name;\r\n\t}\r\n}\r\n\r\n@:enum abstract Channel(Int) to Int {\r\n\tvar CH_0 = 0;\r\n\tvar CH_1 = 1;\r\n\tvar CH_2 = 2;\r\n\tvar CH_3 = 3;\r\n\t\r\n\t@:op(A + B) static function add(a:Int, b:Channel):Int;\r\n}\r\n\r\nclass Converter\r\n{\r\n\t/** Converts from ARGB to RGBA. If `outBytesRGBA` is null then `inBytesARGB` will be converted in place. */\r\n\tstatic public function ARGB2RGBA(inBytesARGB:Bytes, ?outBytesRGBA:Bytes):Void {\r\n\t\tvar convertInPlace = outBytesRGBA == null;\r\n\t\t\r\n\t\tif (!convertInPlace) {\r\n\t\t\tfor (i in 0...inBytesARGB.length) {\r\n\t\t\t\tvar pos = (i % 4) != 0 ? i - 1 : i + 3;\r\n\t\t\t\toutBytesRGBA.set(pos, inBytesARGB.get(i));\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\toutBytesRGBA = inBytesARGB;\r\n\t\t\t\r\n\t\t\tfor (i in 0...inBytesARGB.length >> 2) {\r\n\t\t\t\tvar pos = i << 2;\r\n\t\t\t\tvar a = inBytesARGB.get(pos + 0);\r\n\t\t\t\tvar r = inBytesARGB.get(pos + 1);\r\n\t\t\t\tvar g = inBytesARGB.get(pos + 2);\r\n\t\t\t\tvar b = inBytesARGB.get(pos + 3);\r\n\t\t\t\t\r\n\t\t\t\toutBytesRGBA.set(pos + 3, a);\r\n\t\t\t\toutBytesRGBA.set(pos + 0, r);\r\n\t\t\t\toutBytesRGBA.set(pos + 1, g);\r\n\t\t\t\toutBytesRGBA.set(pos + 2, b);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t/** Converts from ARGB to RGBA. If `outBytesARGB` is null then `inBytesRGBA` will be converted in place. */\r\n\tstatic public function RGBA2ARGB(inBytesRGBA:Bytes, ?outBytesARGB:Bytes):Void {\r\n\t\tvar convertInPlace = outBytesARGB == null;\r\n\t\t\r\n\t\tif (!convertInPlace) {\r\n\t\t\tfor (i in 0...inBytesRGBA.length) {\r\n\t\t\t\tvar pos = (i % 4) <= 3 ? i + 1 : i - 3;\r\n\t\t\t\toutBytesARGB.set(pos, inBytesRGBA.get(i));\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\toutBytesARGB = inBytesRGBA;\r\n\t\t\t\r\n\t\t\tfor (i in 0...inBytesRGBA.length >> 2) {\r\n\t\t\t\tvar pos = i << 2;\r\n\t\t\t\tvar a = inBytesRGBA.get(pos + 3);\r\n\t\t\t\tvar r = inBytesRGBA.get(pos + 0);\r\n\t\t\t\tvar g = inBytesRGBA.get(pos + 1);\r\n\t\t\t\tvar b = inBytesRGBA.get(pos + 2);\r\n\t\t\t\t\r\n\t\t\t\toutBytesARGB.set(pos + 0, a);\r\n\t\t\t\toutBytesARGB.set(pos + 1, r);\r\n\t\t\t\toutBytesARGB.set(pos + 2, g);\r\n\t\t\t\toutBytesARGB.set(pos + 3, b);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n#if java\r\n\r\n\t/** Converts `inImage` into a new image of `imageType` format. */\r\n\tstatic public function convertBufferedImage(inImage:java.awt.image.BufferedImage, imageType:Int):java.awt.image.BufferedImage\r\n\t{\r\n\t\tvar outImage = new java.awt.image.BufferedImage(inImage.getWidth(), inImage.getHeight(), imageType);\r\n\t\tvar g2d = outImage.createGraphics();\r\n\t\tg2d.drawImage(inImage, 0, 0, null);\r\n\t\tg2d.dispose();\r\n\t\t\r\n\t\treturn outImage;\r\n\t}\r\n#end\r\n}","package hxDaedalus.graphics.luxe;\r\n\r\nimport hxDaedalus.graphics.ISimpleDrawingContext;\r\nimport hxDaedalus.graphics.TargetCanvas;\r\nimport luxe.Color;\r\nimport luxe.Vector;\r\n\r\n\r\nclass SimpleDrawingContext implements ISimpleDrawingContext\r\n{\r\n\tpublic var graphics(default, null):TargetCanvas;\r\n\r\n\tvar _prevX:Float = 0;\r\n\tvar _prevY:Float = 0;\r\n\t\r\n\tvar _lineColor:Color = new Color();\r\n\tvar _fillColor:Color = new Color();\r\n\t\r\n\tvar _inFillingMode:Bool = false;\r\n\t\r\n\tpublic function new(graphics:TargetCanvas) {\r\n\t\tthis.graphics = graphics;\r\n\t}\r\n\t\r\n\tpublic function clear():Void {\r\n\t\tvar geom;\r\n\t\twhile ((geom = graphics.pop()) != null) geom.drop();\r\n\t}\r\n\t\r\n\tpublic function lineStyle(thickness:Float, color:Int, ?alpha:Float = 1):Void\r\n\t{\r\n\t\t_lineColor = new Color().rgb(color);\r\n\t\t_lineColor.a = alpha;\r\n\t}\r\n\t\r\n\tpublic function beginFill(color:Int, ?alpha:Float = 1):Void {\r\n\t\t_fillColor = new Color().rgb(color);\r\n\t\t_fillColor.a = alpha;\r\n\t\t_inFillingMode = true;\r\n\t}\r\n\t\r\n\tpublic function endFill():Void {\r\n\t\t_inFillingMode = false;\r\n\t}\r\n\t\r\n\tpublic function moveTo(x:Float, y:Float):Void {\r\n\t\t_prevX = x;\r\n\t\t_prevY = y;\r\n\t}\r\n\t\r\n\tpublic function lineTo(x:Float, y:Float):Void {\r\n\t\tvar geom = Luxe.draw.line({\r\n\t\t\tp0: new Vector(_prevX, _prevY),\r\n\t\t\tp1: new Vector(x, y),\r\n\t\t\tcolor: _lineColor\r\n\t\t});\r\n\t\t_prevX = x;\r\n\t\t_prevY = y;\r\n\t\tgraphics.push(geom);\r\n\t}\r\n\t\r\n\tpublic function drawCircle(cx:Float, cy:Float, radius:Float):Void {\r\n\t\tif (_inFillingMode) {\r\n\t\t\tvar geom = Luxe.draw.circle({\r\n\t\t\t\tx: cx,\r\n\t\t\t\ty: cy,\r\n\t\t\t\tr: radius,\r\n\t\t\t\tcolor: _fillColor\r\n\t\t\t});\r\n\t\t\tgraphics.push(geom);\r\n\t\t}\r\n\t\t\r\n\t\tvar geom = Luxe.draw.ring({\r\n\t\t\tx: cx,\r\n\t\t\ty: cy,\r\n\t\t\tr: radius,\r\n\t\t\tcolor: _lineColor\r\n\t\t});\r\n\t\tgraphics.push(geom);\r\n\t}\r\n\t\r\n\tpublic function drawRect(x:Float, y:Float, width:Float, height:Float):Void {\r\n\t\tif (_inFillingMode) {\r\n\t\t\tvar geom = Luxe.draw.box({\r\n\t\t\t\tx: x,\r\n\t\t\t\ty: y,\r\n\t\t\t\tw: width,\r\n\t\t\t\th: height,\r\n\t\t\t\tcolor: _fillColor\r\n\t\t\t});\r\n\t\t\tgraphics.push(geom);\r\n\t\t}\r\n\t\t\r\n\t\tvar geom = Luxe.draw.rectangle({\r\n\t\t\tx: x,\r\n\t\t\ty: y,\r\n\t\t\tw: width,\r\n\t\t\th: height,\r\n\t\t\tcolor: _lineColor\r\n\t\t});\r\n\t\tgraphics.push(geom);\r\n\t}\r\n}","package hxDaedalus.iterators;\r\nimport hxDaedalus.data.Edge;\r\nimport hxDaedalus.data.Face;\r\nclass FromFaceToInnerEdges {\r\n    public var fromFace( never, set ): Face;\r\n    var _fromFace: Face;\r\n    var _nextEdge: Edge;\r\n    var _resultEdge: Edge;\r\n    \r\n    public function new(){}\r\n    \r\n    function set_fromFace( value: Face ): Face {\r\n        _fromFace = value;\r\n        _nextEdge = _fromFace.edge;\r\n        return value;\r\n    }\r\n    \r\n    public function next(): Edge {\r\n        if( _nextEdge != null ){\r\n            _resultEdge = _nextEdge;\r\n            _nextEdge = _nextEdge.nextLeftEdge;\r\n            if (_nextEdge == _fromFace.edge) _nextEdge = null;\r\n        } else {\r\n            _resultEdge = null;\r\n        }\r\n        return _resultEdge;\r\n    }\r\n}\r\n","package hxDaedalus.iterators;\r\nimport hxDaedalus.data.Face;\r\nimport hxDaedalus.data.Mesh;\r\nimport hxDaedalus.data.Vertex;\r\n\r\nclass FromMeshToVertices {\r\n    public var fromMesh(never, set) : Mesh;\r\n    var _fromMesh : Mesh;\r\n    var _currIndex : Int;\r\n    var _resultVertex : Vertex;\r\n    \r\n    public function new() {}\r\n    \r\n    function set_fromMesh(value : Mesh) : Mesh {\r\n        _fromMesh = value;\r\n        _currIndex = 0;\r\n        return value;\r\n    }\r\n    \r\n    public function next(): Vertex {\r\n        do{\r\n            if( _currIndex < _fromMesh._vertices.length ){\r\n                _resultVertex = _fromMesh._vertices[ _currIndex ];\r\n                _currIndex++;\r\n            } else {\r\n                _resultVertex = null;\r\n                break;\r\n            }\r\n        } while ( (!_resultVertex.isReal) );\r\n        return _resultVertex;\r\n    }\r\n}\r\n","package hxDaedalus.iterators;\r\nimport hxDaedalus.data.Edge;\r\nimport hxDaedalus.data.Face;\r\nimport hxDaedalus.data.Vertex;\r\nclass FromVertexToHoldingFaces {\r\n    public var fromVertex(never, set) : Vertex;\r\n    var _fromVertex : Vertex;\r\n    var _nextEdge : Edge;\r\n    var _resultFace : Face;\r\n    \r\n    public function new(){}\r\n    \r\n    function set_fromVertex( value: Vertex ): Vertex {\r\n        _fromVertex = value;\r\n        _nextEdge = _fromVertex.edge;\r\n        return value;\r\n    }\r\n    \r\n    public function next() : Face {\r\n        if( _nextEdge != null ){\r\n            do{\r\n                _resultFace = _nextEdge.leftFace;\r\n                _nextEdge = _nextEdge.rotLeftEdge;\r\n                if( _nextEdge == _fromVertex.edge ){\r\n                    _nextEdge = null;\r\n                    if( !_resultFace.isReal ) _resultFace = null;\r\n                    break;\r\n                }\r\n            } while ( !_resultFace.isReal );\r\n        } else {\r\n            _resultFace = null;\r\n        }\r\n        return _resultFace;\r\n    }\r\n}\r\n","package hxDaedalus.iterators;\r\nimport hxDaedalus.data.Edge;\r\nimport hxDaedalus.data.Vertex;\r\n\r\nclass FromVertexToIncomingEdges {\r\n    public var fromVertex( never, set ): Vertex;\r\n    var _fromVertex: Vertex;\r\n    var _nextEdge: Edge;\r\n    var _resultEdge : Edge;\r\n    \r\n    public function new() {}\r\n    \r\n    function set_fromVertex( value: Vertex ): Vertex {\r\n        _fromVertex = value;\r\n        _nextEdge = _fromVertex.edge;\r\n        while (!_nextEdge.isReal){\r\n            _nextEdge = _nextEdge.rotLeftEdge;\r\n        }\r\n        return value;\r\n    }\r\n    \r\n    \r\n    public function next() : Edge {\r\n        if( _nextEdge != null ) {\r\n            _resultEdge = _nextEdge.oppositeEdge;\r\n            do{\r\n                _nextEdge = _nextEdge.rotLeftEdge;\r\n                if( _nextEdge == _fromVertex.edge ){\r\n                    _nextEdge = null;\r\n                    break;\r\n                }\r\n            } while ( (!_nextEdge.isReal) );\r\n        } else {\r\n            _resultEdge = null;\r\n        }\r\n        return _resultEdge;\r\n    }\r\n}\r\n","package hxDaedalus.iterators;\r\n\r\n\r\nimport hxDaedalus.data.Edge;\r\nimport hxDaedalus.data.Vertex;\r\n\r\nclass FromVertexToOutgoingEdges\r\n{\r\n    public var fromVertex(never, set) : Vertex;\r\n\r\n    \r\n     var _fromVertex : Vertex;\r\n     var _nextEdge : Edge;\r\n    \r\n    public var realEdgesOnly : Bool = true;\r\n    \r\n    public function new()\r\n    {\r\n        \r\n        \r\n    }\r\n    \r\n     function set_fromVertex(value : Vertex) : Vertex\r\n    {\r\n        _fromVertex = value;\r\n        _nextEdge = _fromVertex.edge;\r\n        while (realEdgesOnly && !_nextEdge.isReal)\r\n        {\r\n            _nextEdge = _nextEdge.rotLeftEdge;\r\n        }\r\n        return value;\r\n    }\r\n    \r\n     var _resultEdge : Edge;\r\n    \r\n    public function next() : Edge\r\n    {\r\n        if (_nextEdge != null) \r\n        {\r\n            _resultEdge = _nextEdge;\r\n            do\r\n            {\r\n                _nextEdge = _nextEdge.rotLeftEdge;\r\n                if (_nextEdge == _fromVertex.edge) \r\n                {\r\n                    _nextEdge = null;\r\n                    break;\r\n                }\r\n            }            while ((realEdgesOnly && !_nextEdge.isReal));\r\n        }\r\n        else \r\n        {\r\n            _resultEdge = null;\r\n        }\r\n        \r\n        return _resultEdge;\r\n    }\r\n}\r\n","package hxDaedalus.view;\r\n\r\nimport hxDaedalus.ai.EntityAI;\r\nimport hxDaedalus.data.Edge;\r\nimport hxDaedalus.data.Face;\r\nimport hxDaedalus.data.math.Point2D;\r\nimport hxDaedalus.data.Mesh;\r\nimport hxDaedalus.data.Vertex;\r\nimport hxDaedalus.graphics.SimpleDrawingContext;\r\nimport hxDaedalus.iterators.FromMeshToVertices;\r\nimport hxDaedalus.iterators.FromVertexToHoldingFaces;\r\nimport hxDaedalus.iterators.FromVertexToIncomingEdges;\r\nimport hxDaedalus.graphics.TargetCanvas;\r\n\r\nclass SimpleView\r\n{\r\n\tpublic var edgesColor:Int = 0x999999;\r\n\tpublic var edgesWidth:Float = 1;\r\n\tpublic var edgesAlpha:Float = .25;\r\n\t\r\n\tpublic var constraintsColor:Int = 0xFF0000;\r\n\tpublic var constraintsWidth:Float = 2;\r\n\tpublic var constraintsAlpha:Float = 1.0;\r\n\t\r\n\tpublic var verticesColor:Int = 0x0000FF;\r\n\tpublic var verticesRadius:Float = .5;\r\n\tpublic var verticesAlpha:Float = .25;\r\n\t\r\n\tpublic var pathsColor:Int = 0xFFC010;\r\n\tpublic var pathsWidth:Float = 1.5;\r\n\tpublic var pathsAlpha:Float = .75;\r\n\t\r\n\tpublic var entitiesColor:Int = 0x00FF00;\r\n\tpublic var entitiesWidth:Float = 1;\r\n\tpublic var entitiesAlpha:Float = .75;\r\n\r\n    public var graphics(default, null): SimpleDrawingContext;\r\n    \r\n    #if java\r\n    public function refreshGraphics2D( g: java.awt.Graphics2D ){\r\n        graphics.graphics = g;\r\n    }\r\n    #end\r\n    \r\n    public function new( targetCanvas: TargetCanvas )\r\n    {\r\n        graphics = new SimpleDrawingContext( targetCanvas );\r\n    }\r\n    \r\n    public function drawVertex(vertex : Vertex) : Void\r\n\t{\r\n\t\tgraphics.lineStyle(verticesRadius, verticesColor, verticesAlpha);\r\n\t\tgraphics.beginFill(verticesColor, verticesAlpha);\r\n\t\tgraphics.drawCircle(vertex.pos.x, vertex.pos.y, verticesRadius);\r\n\t\tgraphics.endFill();\r\n\t\t\r\n\t\t#if showVerticesIndices \r\n\t\t\tvar tf : TextField = new TextField();\r\n\t\t\ttf.mouseEnabled = false;\r\n\t\t\ttf.text = Std.string(vertex.id);\r\n\t\t\ttf.x = vertex.pos.x + 5;\r\n\t\t\ttf.y = vertex.pos.y + 5;\r\n\t\t\ttf.width = tf.height = 20;\r\n\t\t\t_vertices.addChild(tf);\r\n\t\t#end\r\n\t}\r\n\t\r\n\tpublic function drawEdge(edge : Edge) : Void \r\n\t{\r\n\t\tif (edge.isConstrained) \r\n\t\t{\r\n\t\t\tgraphics.lineStyle(constraintsWidth, constraintsColor, constraintsAlpha);\r\n\t\t\tgraphics.moveTo(edge.originVertex.pos.x, edge.originVertex.pos.y);\r\n\t\t\tgraphics.lineTo(edge.destinationVertex.pos.x, edge.destinationVertex.pos.y);\r\n\t\t}\r\n\t\telse \r\n\t\t{\r\n\t\t\tgraphics.lineStyle(edgesWidth, edgesColor, edgesAlpha);\r\n\t\t\tgraphics.moveTo(edge.originVertex.pos.x, edge.originVertex.pos.y);\r\n\t\t\tgraphics.lineTo(edge.destinationVertex.pos.x, edge.destinationVertex.pos.y);\r\n\t\t}\r\n\t}\r\n\t\r\n    public function drawMesh(mesh:Mesh, cleanBefore : Bool = false):Void \r\n\t{\r\n        if (cleanBefore) graphics.clear();\r\n\t\t\r\n\t\tmesh.traverse(drawVertex, drawEdge);\r\n    }\r\n    \r\n    public function drawEntity(entity:EntityAI, cleanBefore:Bool = false):Void \r\n\t{\r\n        if (cleanBefore) graphics.clear();\r\n        \r\n        graphics.lineStyle(entitiesWidth, entitiesColor, entitiesAlpha);\r\n        graphics.beginFill(entitiesColor, entitiesAlpha);\r\n        graphics.drawCircle(entity.x, entity.y, entity.radius);\r\n        graphics.endFill();\r\n    }\r\n    \r\n    public function drawEntities(vEntities:Array<EntityAI>, cleanBefore:Bool = false):Void \r\n\t{\r\n        if (cleanBefore) graphics.clear();\r\n        \r\n        for (i in 0...vEntities.length) {\r\n            drawEntity(vEntities[i], false);\r\n        }\r\n    }\r\n    \r\n    public function drawPath(path:Array<Float>, cleanBefore:Bool = false): Void \r\n\t{\r\n        if (cleanBefore) graphics.clear();\r\n        \r\n        if (path.length == 0) return;\r\n        \r\n        graphics.lineStyle(pathsWidth, pathsColor, pathsAlpha);\r\n        \r\n        graphics.moveTo(path[0], path[1]);\r\n        var i = 2;\r\n        while (i < path.length) {\r\n            graphics.lineTo(path[i], path[i + 1]);\r\n            graphics.moveTo(path[i], path[i + 1]);\r\n            i += 2;\r\n        }\r\n    }\r\n}\r\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage js;\n\nprivate class HaxeError extends js.Error {\n\n\tvar val:Dynamic;\n\n\tpublic function new(val:Dynamic) untyped {\n\t\tsuper();\n\t\tthis.val = __define_feature__(\"js.Boot.HaxeError\", val);\n\t\tthis.message = String(val);\n\t\tif (js.Error.captureStackTrace) js.Error.captureStackTrace(this, HaxeError);\n\t}\n}\n\n@:dox(hide)\nclass Boot {\n\n\tprivate static function __unhtml(s : String) {\n\t\treturn s.split(\"&\").join(\"&amp;\").split(\"<\").join(\"&lt;\").split(\">\").join(\"&gt;\");\n\t}\n\n\tprivate static function __trace(v,i : haxe.PosInfos) {\n\t\tuntyped {\n\t\t\tvar msg = if( i != null ) i.fileName+\":\"+i.lineNumber+\": \" else \"\";\n\t\t\t#if jsfl\n\t\t\tmsg += __string_rec(v,\"\");\n\t\t\tfl.trace(msg);\n\t\t\t#else\n\t\t\tmsg += __string_rec(v, \"\");\n\t\t\tif( i != null && i.customParams != null )\n\t\t\t\tfor( v in i.customParams )\n\t\t\t\t\tmsg += \",\" + __string_rec(v, \"\");\n\t\t\tvar d;\n\t\t\tif( __js__(\"typeof\")(document) != \"undefined\" && (d = document.getElementById(\"haxe:trace\")) != null )\n\t\t\t\td.innerHTML += __unhtml(msg)+\"<br/>\";\n\t\t\telse if( __js__(\"typeof console\") != \"undefined\" && __js__(\"console\").log != null )\n\t\t\t\t__js__(\"console\").log(msg);\n\t\t\t#end\n\t\t}\n\t}\n\n\tprivate static function __clear_trace() {\n\t\tuntyped {\n\t\t\t#if jsfl\n\t\t\tfl.outputPanel.clear();\n\t\t\t#else\n\t\t\tvar d = document.getElementById(\"haxe:trace\");\n\t\t\tif( d != null )\n\t\t\t\td.innerHTML = \"\";\n\t\t\t#end\n\t\t}\n\t}\n\n\tstatic inline function isClass(o:Dynamic) : Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isClass\", o.__name__);\n\t}\n\n\tstatic inline function isEnum(e:Dynamic) : Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isEnum\", e.__ename__);\n\t}\n\n\tstatic function getClass(o:Dynamic) : Dynamic {\n\t\tif (Std.is(o, Array))\n\t\t\treturn Array;\n\t\telse {\n\t\t\tvar cl = untyped __define_feature__(\"js.Boot.getClass\", o.__class__);\n\t\t\tif (cl != null)\n\t\t\t\treturn cl;\n\t\t\tvar name = __nativeClassName(o);\n\t\t\tif (name != null)\n\t\t\t\treturn __resolveNativeClass(name);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@:ifFeature(\"has_enum\")\n\tprivate static function __string_rec(o,s:String) {\n\t\tuntyped {\n\t\t\tif( o == null )\n\t\t\t    return \"null\";\n\t\t\tif( s.length >= 5 )\n\t\t\t\treturn \"<...>\"; // too much deep recursion\n\t\t\tvar t = __js__(\"typeof(o)\");\n\t\t\tif( t == \"function\" && (isClass(o) || isEnum(o)) )\n\t\t\t\tt = \"object\";\n\t\t\tswitch( t ) {\n\t\t\tcase \"object\":\n\t\t\t\tif( __js__(\"o instanceof Array\") ) {\n\t\t\t\t\tif( o.__enum__ ) {\n\t\t\t\t\t\tif( o.length == 2 )\n\t\t\t\t\t\t\treturn o[0];\n\t\t\t\t\t\tvar str = o[0]+\"(\";\n\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\tfor( i in 2...o.length ) {\n\t\t\t\t\t\t\tif( i != 2 )\n\t\t\t\t\t\t\t\tstr += \",\" + __string_rec(o[i],s);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tstr += __string_rec(o[i],s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn str + \")\";\n\t\t\t\t\t}\n\t\t\t\t\tvar l = o.length;\n\t\t\t\t\tvar i;\n\t\t\t\t\tvar str = \"[\";\n\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\tfor( i in 0...l )\n\t\t\t\t\t\tstr += (if (i > 0) \",\" else \"\")+__string_rec(o[i],s);\n\t\t\t\t\tstr += \"]\";\n\t\t\t\t\treturn str;\n\t\t\t\t}\n\t\t\t\tvar tostr;\n\t\t\t\ttry {\n\t\t\t\t\ttostr = untyped o.toString;\n\t\t\t\t} catch( e : Dynamic ) {\n\t\t\t\t\t// strange error on IE\n\t\t\t\t\treturn \"???\";\n\t\t\t\t}\n\t\t\t\tif( tostr != null && tostr != __js__(\"Object.toString\") && __typeof__(tostr) == \"function\" ) {\n\t\t\t\t\tvar s2 = o.toString();\n\t\t\t\t\tif( s2 != \"[object Object]\")\n\t\t\t\t\t\treturn s2;\n\t\t\t\t}\n\t\t\t\tvar k : String = null;\n\t\t\t\tvar str = \"{\\n\";\n\t\t\t\ts += \"\\t\";\n\t\t\t\tvar hasp = (o.hasOwnProperty != null);\n\t\t\t\t__js__(\"for( var k in o ) {\");\n\t\t\t\t\tif( hasp && !o.hasOwnProperty(k) )\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif( k == \"prototype\" || k == \"__class__\" || k == \"__super__\" || k == \"__interfaces__\" || k == \"__properties__\" )\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif( str.length != 2 )\n\t\t\t\t\t\tstr += \", \\n\";\n\t\t\t\t\tstr += s + k + \" : \"+__string_rec(o[k],s);\n\t\t\t\t__js__(\"}\");\n\t\t\t\ts = s.substring(1);\n\t\t\t\tstr += \"\\n\" + s + \"}\";\n\t\t\t\treturn str;\n\t\t\tcase \"function\":\n\t\t\t\treturn \"<function>\";\n\t\t\tcase \"string\":\n\t\t\t\treturn o;\n\t\t\tdefault:\n\t\t\t\treturn String(o);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static function __interfLoop(cc : Dynamic,cl : Dynamic) {\n\t\tif( cc == null )\n\t\t\treturn false;\n\t\tif( cc == cl )\n\t\t\treturn true;\n\t\tvar intf : Dynamic = cc.__interfaces__;\n\t\tif( intf != null )\n\t\t\tfor( i in 0...intf.length ) {\n\t\t\t\tvar i : Dynamic = intf[i];\n\t\t\t\tif( i == cl || __interfLoop(i,cl) )\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\treturn __interfLoop(cc.__super__,cl);\n\t}\n\n\t@:ifFeature(\"typed_catch\") private static function __instanceof(o : Dynamic,cl : Dynamic) {\n\t\tif( cl == null )\n\t\t\treturn false;\n\t\tswitch( cl ) {\n\t\tcase Int:\n\t\t\treturn (untyped __js__(\"(o|0) === o\"));\n\t\tcase Float:\n\t\t\treturn (untyped __js__(\"typeof\"))(o) == \"number\";\n\t\tcase Bool:\n\t\t\treturn (untyped __js__(\"typeof\"))(o) == \"boolean\";\n\t\tcase String:\n\t\t\treturn (untyped __js__(\"typeof\"))(o) == \"string\";\n\t\tcase Array:\n\t\t\treturn (untyped __js__(\"(o instanceof Array)\")) && o.__enum__ == null;\n\t\tcase Dynamic:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\tif( o != null ) {\n\t\t\t\t// Check if o is an instance of a Haxe class or a native JS object\n\t\t\t\tif( (untyped __js__(\"typeof\"))(cl) == \"function\" ) {\n\t\t\t\t\tif( untyped __js__(\"o instanceof cl\") )\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tif( __interfLoop(getClass(o),cl) )\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse if ( (untyped __js__(\"typeof\"))(cl) == \"object\" && __isNativeObj(cl) ) {\n\t\t\t\t\tif( untyped __js__(\"o instanceof cl\") )\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// do not use isClass/isEnum here\n\t\t\tuntyped __feature__(\"Class.*\",if( cl == Class && o.__name__ != null ) return true);\n\t\t\tuntyped __feature__(\"Enum.*\",if( cl == Enum && o.__ename__ != null ) return true);\n\t\t\treturn o.__enum__ == cl;\n\t\t}\n\t}\n\n\t@:ifFeature(\"typed_cast\") private static function __cast(o : Dynamic, t : Dynamic) {\n\t\tif (__instanceof(o, t)) return o;\n\t\telse throw \"Cannot cast \" +Std.string(o) + \" to \" +Std.string(t);\n\t}\n\n\tstatic var __toStr = untyped __js__(\"{}.toString\");\n\t// get native JS [[Class]]\n\tstatic function __nativeClassName(o:Dynamic):String {\n\t\tvar name = untyped __toStr.call(o).slice(8, -1);\n\t\t// exclude general Object and Function\n\t\t// also exclude Math and JSON, because instanceof cannot be called on them\n\t\tif (name == \"Object\" || name == \"Function\" || name == \"Math\" || name == \"JSON\")\n\t\t\treturn null;\n\t\treturn name;\n\t}\n\n\t// check for usable native JS object\n\tstatic function __isNativeObj(o:Dynamic):Bool {\n\t\treturn __nativeClassName(o) != null;\n\t}\n\n\t// resolve native JS class (with window or global):\n\tstatic function __resolveNativeClass(name:String) untyped {\n\t\tif (__js__(\"typeof window\") != \"undefined\")\n\t\t\treturn window[name];\n\t\telse\n\t\t\treturn global[name];\n\t}\n\n}\n","/*\n * Copyright (C)2005-2015 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\n// This file is generated from mozilla/HTMLCanvasElement.webidl line 17:0. Do not edit!\n\npackage js.html;\n\n@:native(\"HTMLCanvasElement\")\nextern class CanvasElement extends Element\n{\n\tvar width : Int;\n\tvar height : Int;\n\t\n\t/** @throws DOMError */\n\tfunction getContext( contextId : String, ?contextOptions : Dynamic ) : Dynamic/*MISSING nsISupports*/;\n\t/** @throws DOMError */\n\tfunction toDataURL( ?type : String = \"\", ?encoderOptions : Dynamic ) : String;\n\t/** @throws DOMError */\n\tfunction toBlob( callback : Blob -> Void, ?type : String = \"\", ?encoderOptions : Dynamic ) : Void;\n\t\n\t/** Shorthand for getting a CanvasRenderingContext2D. */\n\tinline function getContext2d( ?attribs : {} ) : CanvasRenderingContext2D {\n\t\treturn cast getContext(\"2d\", attribs);\n\t}\n\t/** Shorthand for getting a js.html.webgl.RenderingContext. */\n\tinline function getContextWebGL( ?attribs : js.html.webgl.ContextAttributes ) : js.html.webgl.RenderingContext {\n\t\treturn CanvasUtil.getContextWebGL(this, attribs);\n\t}\n}\n\nprivate class CanvasUtil {\n\tpublic static function getContextWebGL( canvas :CanvasElement, attribs :{} ) {\n\t\tfor (name in [\"webgl\", \"experimental-webgl\"]) {\n\t\t\tvar ctx = canvas.getContext(name, attribs);\n\t\t\tif (ctx != null) return ctx;\n\t\t}\n\t\treturn null;\n\t}\n}\n","/*\n * Copyright (C)2005-2014 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage js.html.compat;\n\n@:keep\nclass ArrayBuffer {\n\n\tpublic var byteLength : Int;\n\tvar a : Array<Int>;\n\t\n\tpublic function new( ?a : Dynamic ) {\n\t\tif( Std.is(a,Array) ) {\n\t\t\tthis.a = a;\n\t\t\tbyteLength = a.length;\n\t\t} else {\n\t\t\tvar len : Int = a;\n\t\t\tthis.a = [];\n\t\t\tfor( i in 0...len )\n\t\t\t\tthis.a[i] = 0;\n\t\t\tbyteLength = len;\n\t\t}\n\t}\n\t\n\tpublic function slice(begin,?end) {\n\t\treturn new ArrayBuffer(a.slice(begin,end));\n\t}\n\t\n\tstatic function sliceImpl(begin,?end) {\n\t\tvar u = new js.html.Uint8Array(untyped __js__('this'), begin, end == null ? null : end - begin);\n        var result = new js.html.ArrayBuffer(u.byteLength);\n        var resultArray = new js.html.Uint8Array(result);\n\t\tresultArray.set(u);\n        return result;\n\t}\n\n\tstatic function __init__() untyped {\n\t\tvar ArrayBuffer = __js__('typeof(window) != \"undefined\" && window.ArrayBuffer') || __js__('typeof(global) != \"undefined\" && global.ArrayBuffer') || ArrayBuffer;\n\t\tif( ArrayBuffer.prototype.slice == null ) ArrayBuffer.prototype.slice = sliceImpl; // IE10\n\t}\n}","/*\n * Copyright (C)2005-2014 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage js.html.compat;\nimport haxe.io.Error;\n\n@:keep\n@:access(js.html.compat.ArrayBuffer)\nclass DataView {\n\n\tvar buf : ArrayBuffer;\n\tvar offset : Int;\n\tvar length : Int;\n\n\tpublic function new( buffer : ArrayBuffer, ?byteOffset : Int, ?byteLength : Int ) : Void {\n\t\tthis.buf = buffer;\n\t\tthis.offset = byteOffset == null ? 0 : byteOffset;\n\t\tthis.length = byteLength == null ? buffer.byteLength - this.offset : byteLength;\n\t\tif( offset < 0 || length < 0 || offset+length > buffer.byteLength )\n\t\t\tthrow OutsideBounds;\n\t}\n\n\tpublic function getInt8( byteOffset : Int ) : Int {\n\t\tvar v = buf.a[offset + byteOffset];\n\t\treturn v >= 0x80 ? v - 256 : v;\n\t}\n\n\tpublic function getUint8( byteOffset : Int ) : Int {\n\t\treturn buf.a[offset + byteOffset];\n\t}\n\n\tpublic function getInt16( byteOffset : Int, ?littleEndian : Bool ) : Int {\n\t\tvar v = getUint16(byteOffset, littleEndian);\n\t\treturn v >= 0x8000 ? v - 65536 : v;\n\t}\n\n\tpublic function getUint16( byteOffset : Int, ?littleEndian : Bool ) : Int {\n\t\treturn littleEndian ? buf.a[offset + byteOffset] | (buf.a[offset + byteOffset + 1] << 8) : (buf.a[offset + byteOffset]<<8) | buf.a[offset + byteOffset + 1];\n\t}\n\n\tpublic function getInt32( byteOffset : Int, ?littleEndian : Bool ) : Int {\n\t\tvar p = offset + byteOffset;\n\t\tvar a = buf.a[p++];\n\t\tvar b = buf.a[p++];\n\t\tvar c = buf.a[p++];\n\t\tvar d = buf.a[p++];\n\t\treturn littleEndian ? a | (b<<8) | (c<<16) | (d<<24) : d | (c << 8) | (b << 16) | (a << 24);\n\t}\n\n\tpublic function getUint32( byteOffset : Int, ?littleEndian : Bool ) : Int {\n\t\tvar v = getInt32(byteOffset, littleEndian);\n\t\treturn v < 0 ? cast (v + 4294967296.) : v;\n\t}\n\n\tpublic function getFloat32( byteOffset : Int, ?littleEndian : Bool ) : Float {\n\t\treturn haxe.io.FPHelper.i32ToFloat(getInt32(byteOffset,littleEndian));\n\t}\n\n\tpublic function getFloat64( byteOffset : Int, ?littleEndian : Bool ) : Float {\n\t\tvar a = getInt32(byteOffset, littleEndian);\n\t\tvar b = getInt32(byteOffset + 4, littleEndian);\n\t\treturn haxe.io.FPHelper.i64ToDouble(littleEndian?a:b,littleEndian?b:a);\n\t}\n\n\tpublic function setInt8( byteOffset : Int, value : Int ) : Void {\n\t\tbuf.a[byteOffset + offset] = (value < 0) ? (value + 128) & 0xFF : value & 0xFF;\n\t}\n\n\tpublic function setUint8( byteOffset : Int, value : Int ) : Void {\n\t\tbuf.a[byteOffset + offset] = value & 0xFF;\n\t}\n\n\tpublic function setInt16( byteOffset : Int, value : Int, ?littleEndian : Bool ) : Void {\n\t\tsetUint16(byteOffset, value < 0 ? value + 65536 : value, littleEndian);\n\t}\n\n\tpublic function setUint16( byteOffset : Int, value : Int, ?littleEndian : Bool ) : Void {\n\t\tvar p = byteOffset + offset;\n\t\tif( littleEndian ) {\n\t\t\tbuf.a[p] = value&0xFF;\n\t\t\tbuf.a[p++] = (value>>8) & 0xFF;\n\t\t} else {\n\t\t\tbuf.a[p++] = (value>>8) & 0xFF;\n\t\t\tbuf.a[p] = value&0xFF;\n\t\t}\n\t}\n\n\tpublic function setInt32( byteOffset : Int, value : Int, ?littleEndian : Bool ) : Void {\n\t\tsetUint32(byteOffset, value, littleEndian);\n\t}\n\n\tpublic function setUint32( byteOffset : Int, value : Int, ?littleEndian : Bool ) : Void {\n\t\tvar p = byteOffset + offset;\n\t\tif( littleEndian ) {\n\t\t\tbuf.a[p++] = value & 0xFF;\n\t\t\tbuf.a[p++] = (value>>8) & 0xFF;\n\t\t\tbuf.a[p++] = (value>>16) & 0xFF;\n\t\t\tbuf.a[p++] = value >>> 24;\n\t\t} else {\n\t\t\tbuf.a[p++] = value >>> 24;\n\t\t\tbuf.a[p++] = (value>>16) & 0xFF;\n\t\t\tbuf.a[p++] = (value>>8) & 0xFF;\n\t\t\tbuf.a[p++] = value & 0xFF;\n\t\t}\n\t}\n\n\tpublic function setFloat32( byteOffset : Int, value : Float, ?littleEndian : Bool ) : Void {\n\t\tsetUint32(byteOffset, haxe.io.FPHelper.floatToI32(value),littleEndian);\n\t}\n\n\tpublic function setFloat64( byteOffset : Int, value : Float, ?littleEndian : Bool ) : Void {\n\t\tvar i64 = haxe.io.FPHelper.doubleToI64(value);\n\t\tif( littleEndian ) {\n\t\t\tsetUint32(byteOffset, i64.low);\n\t\t\tsetUint32(byteOffset, i64.high);\n\t\t} else {\n\t\t\tsetUint32(byteOffset, i64.high);\n\t\t\tsetUint32(byteOffset, i64.low);\n\t\t}\n\t}\n\n\tstatic function __init__() untyped {\n\t\tvar DataView = __js__('typeof(window) != \"undefined\" && window.DataView') || (__js__('typeof(global) != \"undefined\" && global.DataView')) || DataView;\n\t}\n\n}","/*\n * Copyright (C)2005-2014 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage js.html.compat;\n\n@:keep\nclass Uint8Array {\n\n\tstatic var BYTES_PER_ELEMENT = 1;\n\n\tstatic function _new( ?arg1 : Dynamic, ?offset : Int, ?length : Int ) : Dynamic {\n\t\tvar arr;\n\t\tif( untyped __typeof__(arg1) == 'number' ) {\n\t\t\tarr = new Array();\n\t\t\tfor( i in 0...arg1 )\n\t\t\t\tarr[i] = 0;\n\t\t\tuntyped {\n\t\t\t\tarr.byteLength = arr.length;\n\t\t\t\tarr.byteOffset = 0;\n\t\t\t\tarr.buffer = new ArrayBuffer(arr);\n\t\t\t}\n\t\t} else if( Std.is(arg1,ArrayBuffer) ) {\n\t\t\tvar buffer : ArrayBuffer = arg1;\n\t\t\tif( offset == null ) offset = 0;\n\t\t\tif( length == null ) length = buffer.byteLength - offset;\n\t\t\tif( offset == 0 )\n\t\t\t\tarr = cast @:privateAccess buffer.a;\n\t\t\telse\n\t\t\t\t// here we are losing the fact that we should reference the same data,\n\t\t\t\t// but I don't see another way to have this behaviour while keeping [] access\n\t\t\t\tarr = cast @:privateAccess buffer.a.slice(offset, offset+length);\n\t\t\tuntyped {\n\t\t\t\tarr.byteLength = arr.length;\n\t\t\t\tarr.byteOffset = offset;\n\t\t\t\tarr.buffer = buffer;\n\t\t\t}\n\t\t} else if( Std.is(arg1, Array) ) {\n\t\t\tarr = (arg1 : Array<Int>).copy();\n\t\t\tuntyped {\n\t\t\t\tarr.byteLength = arr.length;\n\t\t\t\tarr.byteOffset = 0;\n\t\t\t\tarr.buffer = new ArrayBuffer(arr);\n\t\t\t}\n\t\t} else\n\t\t\tthrow \"TODO \"+arg1;\n\t\tuntyped {\n\t\t\tarr.subarray = _subarray;\n\t\t\tarr.set = _set;\n\t\t}\n\t\treturn arr;\n\t}\n\n\tstatic function _set( ?arg : Dynamic, ?offset : Int ) {\n\t\tvar t : Dynamic = untyped __js__(\"this\");\n\t\tif( Std.is(arg.buffer,ArrayBuffer) ) {\n\t\t\tvar a : Array<Int> = arg;\n\t\t\tif( arg.byteLength + offset > t.byteLength )\n\t\t\t\tthrow \"set() outside of range\";\n\t\t\tfor( i in 0...arg.byteLength )\n\t\t\t\tt[i + offset] = a[i];\n\t\t} else if( Std.is(arg,Array) ) {\n\t\t\tvar a : Array<Int> = arg;\n\t\t\tif( a.length + offset > t.byteLength )\n\t\t\t\tthrow \"set() outside of range\";\n\t\t\tfor( i in 0...a.length )\n\t\t\t\tt[i + offset] = a[i];\n\t\t} else\n\t\t\tthrow \"TODO\";\n\t}\n\n\tstatic function _subarray( start : Int, ?end : Int ) {\n\t\tvar t : Dynamic = untyped __js__(\"this\");\n\t\tvar a = _new(t.slice(start,end));\n\t\ta.byteOffset = start;\n\t\treturn a;\n\t}\n\n\tstatic function __init__() untyped {\n\t\tvar Uint8Array = __js__('typeof(window) != \"undefined\" && window.Uint8Array') || (__js__('typeof(global) != \"undefined\" && global.Uint8Array')) || _new;\n\t}\n\n}","package luxe;\r\n\r\nimport luxe.Core;\r\n\r\nimport luxe.Log._debug;\r\n\r\nclass Audio {\r\n\r\n    @:noCompletion public var core : Core;\r\n\r\n    @:noCompletion public function new( _core:Core ) {\r\n\r\n        core = _core;\r\n\r\n    } //new\r\n\r\n    @:noCompletion public function init() {\r\n        _debug('\\t audio initialized.');\r\n    } //init\r\n\r\n    @:noCompletion public function destroy() {\r\n        _debug('\\t audio shut down.');\r\n    } //destroy\r\n\r\n        /**\r\n            Create a named audio reference, with optional streaming flag   \r\n            **id** The asset file id from which the audio is loaded/streamed.   \r\n            **name** The name to assign the sound for the named api    \r\n            **streaming** Whether or not to stream the audio, default `false`   \r\n            **returns** The `Sound` instance, if needed. can be manipulated through named api as well.\r\n        */\r\n    public function create( _id:String, ?_name:String = '', ?_streaming:Bool = false ) : luxe.Sound {\r\n        return core.app.audio.create( _id, _name, _streaming );\r\n    } //create\r\n\r\n    // wip alpha-2.0\r\n    @:noCompletion\r\n    public function create_from_bytes( _id:String, ?_name:String = '', _bytes:snow.io.typedarray.Uint8Array ) : luxe.Sound {\r\n        return core.app.audio.create_from_bytes( _id, _name, _bytes );\r\n    } //create_from_bytes\r\n\r\n        /**\r\n            Destroy a named audio reference.\r\n            Use the reference directly with sound.destroy if you have an instance. */\r\n    public function uncreate( _name:String ) {\r\n        return core.app.audio.uncreate( _name );\r\n    } //uncreate\r\n\r\n        /** Listen for an event on a named sound. `load` and `end` are valid */\r\n    public function on(_name:String, _event:String, _handler:luxe.Sound->Void) {\r\n        return core.app.audio.on(_name, _event, _handler);\r\n    } //on\r\n\r\n        /** Stop listening for an event on a named sound. See `on` */\r\n    public function off(_name:String, _event:String, _handler:luxe.Sound->Void) {\r\n        return core.app.audio.off(_name, _event, _handler);\r\n    } //off\r\n\r\n        /**\r\n            Fetch a named audio reference   \r\n            **name** The name to acquire audio reference   \r\n            **returns** The `Sound` instance\r\n        */\r\n    public function get( _name:String ) : luxe.Sound {\r\n        return core.app.audio.get(_name);\r\n    } //get\r\n\r\n        /**\r\n            Determine whether a named audio reference exists   \r\n            **name** The audio reference name to check   \r\n            **returns** true/false\r\n        */\r\n    public function exists( _name:String ) : Bool {\r\n        return get(_name) != null;\r\n    } //exists\r\n\r\n        /**\r\n            Set the on complete handler for a named audio reference   \r\n            **name** The audio reference name to assign to   \r\n            **handler** The callback to call when playback is complete   \r\n            **returns** nothing\r\n        */\r\n    public function on_complete( _name:String, handler:Void->Void ) : Void {\r\n        // return get( _name ).on_complete( handler );\r\n    } //playing\r\n\r\n        /**\r\n            Loop a named audio reference indefinitely. Use `stop` if needed.   \r\n            **name** The audio reference name to loop   \r\n            **returns** nothing\r\n        */\r\n    public function loop( _name:String )  : Void{\r\n        return core.app.audio.loop(_name);\r\n    } //loop\r\n\r\n        /**\r\n            Stop a named audio reference from playing (or looping)   \r\n            **name** The audio reference name to stop   \r\n            **returns** nothing\r\n        */\r\n    public function stop( _name:String ) : Void {\r\n        return core.app.audio.stop(_name);\r\n    } //stop\r\n\r\n        /**\r\n            Play a named audio reference   \r\n            **name** The audio reference name to play   \r\n            **returns** nothing\r\n        */\r\n    public function play( _name:String ) {\r\n        return core.app.audio.play( _name );\r\n    } //play\r\n\r\n        /**\r\n            Pause a named audio reference   \r\n            **name** The audio reference name to pause   \r\n            **returns** nothing\r\n        */\r\n    public function pause( _name:String ) {\r\n        return core.app.audio.pause( _name );\r\n    } //pause\r\n\r\n\r\n        /** Toggle a sound instance by name, pausing the sound or resuming it */\r\n    public function toggle(_name:String) {\r\n        return core.app.audio.toggle(_name);\r\n    } //toggle\r\n\r\n        /**\r\n            get/set the volume of a named audio reference,   \r\n            leave the second argument empty for get   \r\n            **name** The audio reference name to adjust   \r\n            **volume** A new volume value\r\n        */\r\n    public function volume( _name:String, ?_volume:Float ) : Float {\r\n        return core.app.audio.volume(_name, _volume);\r\n    } //volume\r\n\r\n        /**\r\n            get/set the pan of a named audio reference,   \r\n            leave the second argument empty for get   \r\n            **name** The audio reference name to adjust   \r\n            **pan** A new pan value\r\n        */\r\n    public function pan( _name:String, ?_pan:Float ) : Float  {\r\n        return core.app.audio.pan(_name,_pan);\r\n    } //pan\r\n\r\n        /**\r\n            get/set the pitch of a named audio reference,   \r\n            leave the second argument empty for get   \r\n            **name** The audio reference name to adjust   \r\n            **pitch** A new pitch value\r\n        */\r\n    public function pitch( _name:String, ?_pitch:Float ) : Float {\r\n        return core.app.audio.pitch( _name, _pitch );\r\n    } //pitch\r\n        /**\r\n            get/set the position in `seconds` of a named audio reference,   \r\n            leave the second argument empty for get   \r\n            **name** The audio reference name to adjust   \r\n            **pan** A new pan value\r\n        */\r\n    public function position( _name:String, ?_position:Float ) : Float  {\r\n        return core.app.audio.position(_name, _position);\r\n    } //pan\r\n\r\n        /**\r\n            get the position in seconds of a named audio reference   \r\n            **name** The audio reference name to get   \r\n        */\r\n    public function duration( _name:String ) : Float {\r\n        return core.app.audio.duration( _name );\r\n    } //pitch\r\n\r\n    @:noCompletion public function process() {\r\n\r\n    } //process\r\n\r\n} //Audio\r\n","package luxe;\r\n\r\nimport haxe.io.Path;\r\nimport haxe.macro.Context;\r\nimport haxe.macro.Expr;\r\n\r\n/** A macro based logging class. See the logging guide for full details. */\r\nclass Log {\r\n\r\n        //default to log\r\n    @:noCompletion public static var _level : Int = 1;\r\n    @:noCompletion public static var _filter : Array<String>;\r\n    @:noCompletion public static var _exclude : Array<String>;\r\n\r\n    @:noCompletion public static var _log_width : Int = 16;\r\n\r\n    macro public static function level( __level:Int ) : haxe.macro.Expr {\r\n\r\n        #if !display\r\n            trace(\"/ luxe / set log level to \" + __level );\r\n        #end\r\n\r\n        _level = __level;\r\n\r\n        return macro null;\r\n\r\n    } //level\r\n\r\n    macro public static function filter( __filter:String ) : haxe.macro.Expr {\r\n\r\n        #if !display\r\n            trace(\"/ luxe / setting filter : \" + __filter );\r\n        #end\r\n\r\n        _filter = __filter.split(',');\r\n\r\n        var _index = 0;\r\n        for(_f in _filter) {\r\n            _filter[_index] = StringTools.trim(_f);\r\n            _index++;\r\n        }\r\n\r\n        return macro null;\r\n\r\n    } //filter\r\n\r\n    macro public static function exclude( __exclude:String ) : haxe.macro.Expr {\r\n\r\n        trace(\"/ luxe / setting exclude : \" + __exclude );\r\n\r\n        _exclude = __exclude.split(',');\r\n\r\n        var _index = 0;\r\n        for(_e in _exclude) {\r\n            _exclude[_index] = StringTools.trim(_e);\r\n            _index++;\r\n        }\r\n\r\n        return macro null;\r\n\r\n    } //exclude\r\n\r\n    macro public static function width( _width:Int ) : haxe.macro.Expr {\r\n\r\n        trace(\"/ luxe / set log width to \" + _width );\r\n\r\n        _log_width = _width;\r\n\r\n        return macro null;\r\n\r\n    } //width\r\n\r\n        //This macro uses the defined log level value to reject code that\r\n        //shouldn't even exist at runtime , like low level debug information\r\n        //and logging by injecting or not injecting code\r\n    macro public static function log( value:Dynamic ) : Expr {\r\n\r\n        var _file = Path.withoutDirectory(_get_log_file());\r\n        var _context = Path.withoutExtension(_file).toLowerCase();\r\n        var _spaces = _get_spacing(_file);\r\n\r\n        for(meta in Context.getLocalClass().get().meta.get()) {\r\n            if(meta.name == ':log_as') {\r\n                var _str = switch(meta.params[0].expr) {\r\n                    case EConst(CString(str)): _context = str;\r\n                    default: throw 'type should be string constant like \"name\" for log_as meta flag';\r\n                }\r\n            }\r\n        } //for each meta\r\n\r\n        var _log = (_level > 0);\r\n\r\n            if(_filter != null && (_filter.indexOf(_context) == -1)) {\r\n                _log = false;\r\n            }\r\n\r\n            if(_exclude != null && (_exclude.indexOf(_context) != -1)) {\r\n                _log = false;\r\n            }\r\n\r\n        if(_log) {\r\n            return macro @:pos(Context.currentPos()) trace('${_spaces}i / $_context / ' + $value);\r\n        }\r\n\r\n        return macro null;\r\n\r\n    } //log\r\n\r\n    macro public static function _debug( value:Dynamic ) : Expr {\r\n\r\n        var _file = Path.withoutDirectory(_get_log_file());\r\n        var _context = Path.withoutExtension(_file).toLowerCase();\r\n        var _spaces = _get_spacing(_file);\r\n\r\n        for(meta in Context.getLocalClass().get().meta.get()) {\r\n            if(meta.name == ':log_as') {\r\n                var _str = switch(meta.params[0].expr) {\r\n                    case EConst(CString(str)): _context = str;\r\n                    default: throw 'type should be string constant like \"name\" for log_as meta flag';\r\n                }\r\n            }\r\n        } //for each meta\r\n\r\n        var _log = (_level > 1);\r\n\r\n            if(_filter != null && (_filter.indexOf(_context) == -1)) {\r\n                _log = false;\r\n            }\r\n\r\n            if(_exclude != null && (_exclude.indexOf(_context) != -1)) {\r\n                _log = false;\r\n            }\r\n\r\n        if(_log) {\r\n            return macro @:pos(Context.currentPos()) trace('${_spaces}d / $_context / ' + $value);\r\n        }\r\n\r\n        return macro null;\r\n\r\n    } //_debug\r\n\r\n    macro public static function _verbose( value:Dynamic ) : Expr {\r\n\r\n        var _file = Path.withoutDirectory(_get_log_file());\r\n        var _context = Path.withoutExtension(_file).toLowerCase();\r\n        var _spaces = _get_spacing(_file);\r\n\r\n        for(meta in Context.getLocalClass().get().meta.get()) {\r\n            if(meta.name == ':log_as') {\r\n                var _str = switch(meta.params[0].expr) {\r\n                    case EConst(CString(str)): _context = str;\r\n                    default: throw 'type should be string constant like \"name\" for log_as meta flag';\r\n                }\r\n            }\r\n        } //for each meta\r\n\r\n        var _log = (_level > 2);\r\n\r\n            if(_filter != null && (_filter.indexOf(_context) == -1)) {\r\n                _log = false;\r\n            }\r\n\r\n            if(_exclude != null && (_exclude.indexOf(_context) != -1)) {\r\n                _log = false;\r\n            }\r\n\r\n        if(_log) {\r\n            return macro @:pos(Context.currentPos()) trace('${_spaces}v / $_context / ' + $value);\r\n        }\r\n\r\n        return macro null;\r\n\r\n    } //_verbose\r\n\r\n    macro public static function _verboser( value:Dynamic ) : Expr {\r\n\r\n        var _file = Path.withoutDirectory(_get_log_file());\r\n        var _context = Path.withoutExtension(_file).toLowerCase();\r\n        var _spaces = _get_spacing(_file);\r\n\r\n        for(meta in Context.getLocalClass().get().meta.get()) {\r\n            if(meta.name == ':log_as') {\r\n                var _str = switch(meta.params[0].expr) {\r\n                    case EConst(CString(str)): _context = str;\r\n                    default: throw 'type should be string constant like \"name\" for log_as meta flag';\r\n                }\r\n            }\r\n        } //for each meta\r\n\r\n        var _log = (_level > 3);\r\n\r\n            if(_filter != null && (_filter.indexOf(_context) == -1)) {\r\n                _log = false;\r\n            }\r\n\r\n            if(_exclude != null && (_exclude.indexOf(_context) != -1)) {\r\n                _log = false;\r\n            }\r\n\r\n        if(_log) {\r\n            return macro @:pos(Context.currentPos()) trace('${_spaces}V / $_context / ' + $value);\r\n        }\r\n\r\n        return macro null;\r\n\r\n    } //_verboser\r\n\r\n\r\n//Internal Helpers\r\n\r\n\r\n    static function _get_spacing(_file:String ) {\r\n\r\n        var _spaces = '';\r\n\r\n            //the magic number here is File.hx[:1234] for the trace listener log spacing\r\n        var _trace_length = _file.length + 4;\r\n        var _diff : Int = _log_width - _trace_length;\r\n        if(_diff > 0) {\r\n            for(i in 0 ... _diff) {\r\n                _spaces += ' ';\r\n            }\r\n        }\r\n\r\n        return _spaces;\r\n\r\n    } //_get_spacing\r\n\r\n    macro static function _get_log_file() {\r\n        return macro Context.getPosInfos(Context.currentPos()).file;\r\n    } //get_log_context\r\n\r\n} // Log","package luxe;\r\n\r\nclass ID {\r\n\r\n        /** the id */\r\n    public var id : String;\r\n        /** the name */\r\n    public var name : String = '';\r\n\r\n    @:noCompletion public function new(?_name:String='', _id:String='') {\r\n\r\n        name = _name;\r\n        id = _id == '' ? Luxe.utils.uniqueid() : _id;\r\n\r\n    } //new\r\n\r\n} //ID\r\n\r\n\r\n/** A simple base object, event emitter, and ID. */\r\nclass Objects extends Emitter<Int> {\r\n\r\n        /** the id */\r\n    public var id : String = '';\r\n        /** the name */\r\n    public var name : String = '';\r\n\r\n    @:noCompletion public function new(?_name:String='', _id:String='') {\r\n\r\n        super();\r\n        name = _name;\r\n        id = _id == '' ? Luxe.utils.uniqueid() : _id;\r\n\r\n    } //new\r\n\r\n} //Objects","package luxe;\r\n\r\nimport Luxe.Ev;\r\nimport luxe.Quaternion;\r\nimport luxe.Transform;\r\nimport luxe.Matrix;\r\n\r\nimport luxe.Input;\r\nimport luxe.Screen;\r\nimport luxe.Vector;\r\nimport luxe.Scene;\r\nimport luxe.components.Components;\r\nimport luxe.Component;\r\nimport luxe.Emitter;\r\nimport luxe.structural.OrderedMap;\r\n\r\nimport luxe.options.EntityOptions;\r\n\r\nimport luxe.Log.log;\r\nimport luxe.Log._debug;\r\nimport luxe.Log._verbose;\r\nimport luxe.Log._verboser;\r\n\r\n@:autoBuild(luxe.macros.EntityRules.apply())\r\nclass Entity extends Objects {\r\n\r\n        /** The map of attached components, by name. use .get to find components in children and from other components instead of accessing this unless you need to */\r\n    public var components (get,never) : OrderedMap<String, Component>;\r\n        /** A local event system for sending and receiving named events through the entity. Helps communicate between components, and more. */\r\n    public var events : luxe.Events;\r\n        /** The list of children this entity is parenting. Use `child.parent = null;` to remove, or `child.parent = entity;` to assign. */\r\n    public var children : Array<Entity>;\r\n\r\n        /** whether or not this entity has been destroyed */\r\n    public var destroyed : Bool = false;\r\n        /** whether or not this entity has been inited yet */\r\n    public var inited : Bool = false;\r\n        /** whether or not this entity has been started/reset by the scene */\r\n    public var started : Bool = false;\r\n\r\n        /** per entity fixed rate timer, if any. if 0 (default) no fixed update is called on this entity. */\r\n    @:isVar public var fixed_rate       (get,set) : Float = 0;\r\n        /** The parent entity if any, set to null for no parent */\r\n    @:isVar public var parent           (get,set) : Entity;\r\n        /** if the entity is in a scene, this is not null */\r\n    @:isVar public var scene            (get,set) : Scene;\r\n        /** if the entity is active in the scene or not. set to inactive to stop scene events propogating into this entity and it's components and children */\r\n    @:isVar public var active           (get,set) : Bool = true;\r\n\r\n        /** The spatial transform of the entity. */\r\n    @:isVar public var transform        (get,set) : Transform;\r\n        /** The local position of the spatial transform */\r\n    public var pos              (get,set) : Vector;\r\n        /** The local rotation of the spatial transform */\r\n    public var rotation         (get,set) : Quaternion;\r\n        /** The local scale of the spatial transform */\r\n    public var scale            (get,set) : Vector;\r\n        /** The local origin of the spatial transform */\r\n    public var origin           (get,set) : Vector;\r\n\r\n        /** the system for the entity */\r\n    var _components : Components;\r\n        /** the timer for the fixed update */\r\n    var fixed_rate_timer : snow.utils.Timer;\r\n        /** the options passed in for giving to the init function */\r\n    var options : Dynamic;\r\n\r\n\r\n        /** called when the scene is initiated. **use this instead of new** for state setup. it respects the order of creations, children, and component ordering. */\r\n    public function init() {}\r\n        /** called once per frame, passing the delta time */\r\n    public function update(dt:Float) {}\r\n        /** called once per fixed rate, only if fixed_rate != 0 */\r\n    public function onfixedupdate(rate:Float) {}\r\n\r\n        /** called when the scene starts or is reset. use this to reset state. */\r\n    @:noCompletion public function onreset() {}\r\n        /** called when the scene, parent or entity is destroyed. use this to clean up state. */\r\n    @:noCompletion public function ondestroy() {}\r\n\r\n        /** override this to get notified when a key is released. only called if overridden. */\r\n    @:noCompletion public function onkeyup( event:KeyEvent ) {}\r\n        /** override this to get notified when a key is pressed. only called if overridden. */\r\n    @:noCompletion public function onkeydown( event:KeyEvent ) {}\r\n        /** override this to get notified when a text input event happens. only called if overridden. */\r\n    @:noCompletion public function ontextinput( event:TextEvent ) {}\r\n\r\n        /** override this to get notified when a named input event happens. only called if overridden. */\r\n    @:noCompletion public function oninputdown( name:String, event:InputEvent ) {}\r\n        /** override this to get notified when a named input event happens. only called if overridden. */\r\n    @:noCompletion public function oninputup( name:String, event:InputEvent ) {}\r\n\r\n        /** override this to get notified when a mouse button is pressed. only called if overridden. */\r\n    @:noCompletion public function onmousedown( event:MouseEvent ) {}\r\n        /** override this to get notified when a mouse button is pressed. only called if overridden. */\r\n    @:noCompletion public function onmouseup( event:MouseEvent ) {}\r\n        /** override this to get notified when a mouse is moved. only called if overridden. */\r\n    @:noCompletion public function onmousemove( event:MouseEvent ) {}\r\n        /** override this to get notified when the mouse wheel/trackpad is scrolled. only called if overridden. */\r\n    @:noCompletion public function onmousewheel( event:MouseEvent ) {}\r\n\r\n        /** override this to get notified when a touch begins. only called if overridden. */\r\n    @:noCompletion public function ontouchdown( event:TouchEvent ) {}\r\n        /** override this to get notified when a touch ends. only called if overridden. */\r\n    @:noCompletion public function ontouchup( event:TouchEvent ) {}\r\n        /** override this to get notified when a touch moves. only called if overridden. */\r\n    @:noCompletion public function ontouchmove( event:TouchEvent ) {}\r\n\r\n        /** override this to get notified when a gamepad button is released. only called if overridden. */\r\n    @:noCompletion public function ongamepadup( event:GamepadEvent ) {}\r\n        /** override this to get notified when a gamepad button is pressed. only called if overridden. */\r\n    @:noCompletion public function ongamepaddown( event:GamepadEvent ) {}\r\n        /** override this to get notified when a gamepad axis changes. only called if overridden. */\r\n    @:noCompletion public function ongamepadaxis( event:GamepadEvent ) {}\r\n        /** override this to get notified when a gamepad device event happens. only called if overridden. */\r\n    @:noCompletion public function ongamepaddevice( event:GamepadEvent ) {}\r\n\r\n       /** override this to get notified when a window is moved, with the data containing the new x/y position */\r\n   @:noCompletion public function onwindowmoved( event:WindowEvent ) {}\r\n       /** override this to get notified when a window is resized by the user, with the data containing the new x/y size */\r\n   @:noCompletion public function onwindowresized( event:WindowEvent ) {}\r\n       /** override this to get notified when a window is resized by the system or code or the user, with the data containing the new x/y size */\r\n   @:noCompletion public function onwindowsized( event:WindowEvent ) {}\r\n       /** override this to get notified when a window is minimized. */\r\n   @:noCompletion public function onwindowminimized( event:WindowEvent ) {}\r\n       /** override this to get notified when a window is restored. */\r\n   @:noCompletion public function onwindowrestored( event:WindowEvent ) {}\r\n\r\n\r\n        /** Create a new entity with the given options */\r\n    public function new( ?_options:EntityOptions, ?_pos_info:haxe.PosInfos ) {\r\n\r\n        super('entity');\r\n\r\n            //default to name.id\r\n        name += '.$id';\r\n\r\n        options = _options;\r\n\r\n        _verbose('create new entity with options ' + options);\r\n\r\n        _components = new Components( this );\r\n        children = new Array<Entity>();\r\n        events = new luxe.Events();\r\n\r\n        if(options != null && options.transform != null) {\r\n            transform = options.transform;\r\n        } else {\r\n            transform = new Transform();\r\n        }\r\n\r\n            //listen for transform changes\r\n        transform.listen_pos(set_pos_from_transform);\r\n        transform.listen_scale(set_scale_from_transform);\r\n        transform.listen_origin(set_origin_from_transform);\r\n        transform.listen_parent(set_parent_from_transform);\r\n        transform.listen_rotation(set_rotation_from_transform);\r\n\r\n        if(options != null) {\r\n\r\n    //name\r\n                //default to non-unique name\r\n            if(options.name_unique == null) {\r\n                options.name_unique = false;\r\n            }\r\n\r\n            if(options.name != null) {\r\n                name = options.name;\r\n                if(options.name_unique) {\r\n                    name += '.$id';\r\n                }\r\n            }\r\n\r\n    //position\r\n            if(options.pos != null) {\r\n                var _op : Vector = options.pos;\r\n                pos = _op.clone();\r\n            }\r\n    //scale\r\n            if(options.scale != null) {\r\n                var _os : Vector = options.scale;\r\n                scale = _os.clone();\r\n            }\r\n\r\n    //scene\r\n            _verbose('\\tnon null options, checking for scene placement no_scene:' + options.no_scene + ' scene:' + options.scene);\r\n                //if they haven't explicitly said \"no scene management\"\r\n                //we add to the scene they requested, or the default scene otherwise\r\n            var _should_add:Bool = true;\r\n\r\n            if(options.no_scene != null) {\r\n                if(options.no_scene == true) {\r\n                    _should_add = false;\r\n                    _verbose(\" \\tno_scene flag requested\");\r\n                }\r\n            }\r\n\r\n            if(options.parent != null) {\r\n\r\n                _should_add = false;\r\n                parent = options.parent;\r\n                _verbose(\" \\tparent specified, not adding to scene only to parent :\" + options.parent.name);\r\n\r\n            }\r\n\r\n            if(_should_add) {\r\n\r\n                if(options.scene != null) {\r\n                    scene = options.scene;\r\n                    _verbose(\" \\tscene specified, storing in scene named : \" + options.scene.name );\r\n                } else {\r\n                    scene = Luxe.scene;\r\n                    _verbose(\" \\tno scene specified, adding to default scene\");\r\n                }\r\n\r\n            } //_should_add\r\n\r\n        } else {\r\n\r\n            scene = Luxe.scene;\r\n\r\n            _verbose(\" \\tadding to default scene because no options were specified.\");\r\n\r\n        } //options ! null\r\n\r\n\r\n            //finally, add to the requested scene\r\n        if(scene != null) {\r\n\r\n            _verbose(\" \\tadding to scene \" + scene.name);\r\n\r\n            scene.add( this, _pos_info );\r\n\r\n                //we also want to listen for scene events\r\n\r\n        } else {\r\n            _verbose(\" \\tnot adding to any scene.\");\r\n        }\r\n\r\n        _verbose(\" created \" + name);\r\n\r\n    } //new\r\n\r\n\r\n//components\r\n\r\n\r\n        /** attach a component to the entity */\r\n    var component_count : Int = 0;\r\n    public inline function add<T:Component>( _component:T ) : T {\r\n        component_count++;\r\n        return _components.add( _component );\r\n    } //add\r\n\r\n        /** remove a component from the entity */\r\n    public inline function remove( _name:String ) : Bool {\r\n        component_count--;\r\n        return _components.remove( _name );\r\n    } //remove\r\n\r\n        /** get a component from the entity, by name */\r\n    public inline function get<T>(_name:String, ?_in_children:Bool = false ) : T {\r\n        return _components.get( _name, _in_children );\r\n    } //get\r\n\r\n        /** get all component from the entity, by name */\r\n    public inline function get_any<T>(_name:String, ?_in_children:Bool = false, ?_first_only:Bool = true ) : Array<T> {\r\n        return _components.get_any( _name, _in_children, _first_only );\r\n    } //get\r\n\r\n        /** returns true if the entity has a component by the given name */\r\n    public inline function has( _name:String ) : Bool {\r\n        return _components.has( _name );\r\n    } //has\r\n\r\n\r\n\r\n//internal\r\n\r\n\r\n    @:noCompletion public inline function _init() {\r\n\r\n            //verbose debugging\r\n        _verbose('${this} inside _init with options as $options' );\r\n        _debug('calling init on ' + name);\r\n\r\n\r\n        init();\r\n            //for any potential listeners, after the init() direct call\r\n            //as there is likely connections made during init\r\n        emit(Ev.init);\r\n\r\n        if(component_count > 0) {\r\n            //init all the components attached\r\n            for(_component in components) {\r\n                _verbose(\"          \" + name + \" calling init on component \" + _component.name );\r\n                _component.init();\r\n            } //for each component\r\n        } //component_count\r\n\r\n            //now init our children, so they do the same\r\n        if(children.length > 0) {\r\n            for(_child in children) {\r\n                _verbose(\"         parent \" + name + \" calling init on child \" + _child.name );\r\n                _child._init();\r\n            } //for each child\r\n        }\r\n\r\n            //flag internally\r\n        inited = true;\r\n\r\n    } //_init\r\n\r\n    @:noCompletion public inline function _reset(_) {\r\n\r\n        _debug('calling reset on ' + name);\r\n\r\n            //parent\r\n        onreset();\r\n            //potential listeners\r\n        emit(Ev.reset);\r\n\r\n        if(component_count > 0) {\r\n            for(_component in components) {\r\n                _verbose(\"          \" + name + \" calling reset on component \" + _component.name );\r\n                _component.onreset();\r\n            } //for each component\r\n        }\r\n\r\n            //now reset our children, so they do the same\r\n        if(children.length > 0) {\r\n            for(_child in children) {\r\n                _child._reset(_);\r\n                _debug(\"         parent \" + name + \" calling reset on child \" + _child.name );\r\n            } //for each child\r\n        }\r\n\r\n            //start the fixed rate timer\r\n        _set_fixed_rate_timer( fixed_rate );\r\n\r\n            //flag internally\r\n        started = true;\r\n\r\n    } //_reset\r\n\r\n        /** destroy this entity. removes it from the scene if any, from the parent etc. */\r\n    public function destroy( ?_from_parent:Bool=false ) {\r\n\r\n        _debug('destroy ' + name + ' with ' + children.length + ' children and ' + Lambda.count(components) + \" components / \" + id);\r\n\r\n            //first destroy children\r\n        if(children.length > 0) {\r\n            for(_child in children) {\r\n                _verbose('     calling destroy on child ' + _child.name);\r\n                _child.destroy(true);\r\n            } //for each child\r\n        }\r\n\r\n            //clear the list\r\n        children = null;\r\n        children = [];\r\n\r\n        if(component_count > 0) {\r\n            for(_component in components) {\r\n                _verbose(\"          \" + name + \" calling destroy on component \" + _component.name );\r\n                _component.onremoved();\r\n                _component.ondestroy();\r\n            } //for each component\r\n        }\r\n\r\n            //tell listeners\r\n        emit(Ev.destroy);\r\n            //then parent\r\n        ondestroy();\r\n\r\n            //remove it from it's parent if any\r\n        if(parent != null && !_from_parent) {\r\n            _verbose(\"     removing \" + name + \"/\" + id + \" from parent \" + parent.name + \" / \" + parent.id );\r\n            parent._remove_child(this);\r\n        }\r\n\r\n            //kill any fixed rate timers\r\n        _stop_fixed_rate_timer();\r\n\r\n            //mark the flags\r\n        destroyed = true;\r\n        inited = false;\r\n        started = false;\r\n\r\n            //remove from the scene it's in if any\r\n        _verbose( \"     removing \" + name + \" / \" + id + \" from scene \" + scene );\r\n\r\n        if(scene != null) {\r\n            scene.remove(this);\r\n        }\r\n\r\n            //kill the events\r\n        if(events != null) {\r\n            events.destroy();\r\n            events = null;\r\n        }\r\n\r\n    } //destroy\r\n\r\n\r\n    @:noCompletion public inline function _update(dt:Float) {\r\n\r\n        if(destroyed) {\r\n            _debug(\" calling update AFTER DESTROYED on \" + name + \" / \" + id );\r\n            return;\r\n        }\r\n\r\n        if(!active || !inited || !started) {\r\n            return;\r\n        }\r\n\r\n        _verboser('calling update on ' + name);\r\n\r\n            //make sure transforms are resolved\r\n        transform.clean_check();\r\n\r\n            //update the parent first\r\n        update(dt);\r\n\r\n        if(events != null) {\r\n                //update the events\r\n            events.process();\r\n        }\r\n\r\n            //update all the components attached directly to us\r\n        if(component_count > 0) {\r\n            for(_component in components) {\r\n                _component.update(dt);\r\n            } //for each component\r\n        }\r\n\r\n            //now update our children, so they do the same\r\n        if(children.length > 0) {\r\n            for(_child in children) {\r\n                _child._update(dt);\r\n            } //for each child\r\n        }\r\n\r\n    } //_update\r\n\r\n//timing\r\n\r\n    @:noCompletion public function _fixed_update() {\r\n\r\n        if(destroyed) {\r\n            return;\r\n        }\r\n\r\n        if(!active || !inited || !started) {\r\n            return;\r\n        }\r\n\r\n        _verboser('calling fixedupdate on ' + name);\r\n\r\n        emit(Ev.fixedupdate);\r\n\r\n        onfixedupdate(fixed_rate);\r\n\r\n        if(component_count > 0) {\r\n            for(_component in components) {\r\n                _component.onfixedupdate(fixed_rate);\r\n            }\r\n        }\r\n\r\n        if(children.length > 0) {\r\n            for(_child in children) {\r\n                _child._fixed_update();\r\n            }\r\n        }\r\n\r\n    } //_fixed_update\r\n\r\n//events\r\n\r\n    inline function _find_emit_source() : Emitter<Luxe.Ev> {\r\n\r\n        var source = null;\r\n\r\n        if(scene != null) {\r\n\r\n            source = scene;\r\n\r\n        } else if(parent != null) {\r\n\r\n            var looking = true;\r\n\r\n            while(looking) {\r\n\r\n                    //not a root item\r\n                if(parent.scene == null) {\r\n                        //no parent? this is not connected at all\r\n                    if(parent.parent == null) {\r\n                        log('entity has no parent or scene, currently no core events will reach it.');\r\n                        looking = false;\r\n                        break;\r\n                    } else {\r\n                        //still has a parent,\r\n                        //keep looking\r\n                    }\r\n\r\n                } else {\r\n\r\n                    source = parent.scene;\r\n                    looking = false;\r\n                    break;\r\n\r\n                } //no scene\r\n\r\n            } //while looking\r\n\r\n        } else {\r\n            log('entity has no parent or scene, currently no core events will reach it.');\r\n        }\r\n\r\n        return source;\r\n\r\n    } //_find_emit_source\r\n\r\n        //:todo: switch to @:allow and remove public\r\n    @:noCompletion public function _listen( _event:Int, _handler:EmitHandler, ? _self:Bool=false ) {\r\n\r\n        //this function is called when a component, or a subclass tries to override the onmousedown handler,\r\n        //at which point it makes sure this entity is connected to the scene handlers, and then makes sure\r\n        //that the calling component or this instance is connected to its own events to the requested handler\r\n\r\n        //the duplication of events&handler combo is handled internally by Emitter, so we don't have to worry\r\n        //todo: potential consolidation to avoid the switch here\r\n\r\n\r\n        if( !_self ){\r\n            on(_event, _handler);\r\n        }\r\n\r\n        var source = _find_emit_source();\r\n\r\n        _debug('$name / listen to $_event sourced from $source');\r\n\r\n        if(source != null) {\r\n            switch(_event) {\r\n\r\n                case Ev.keyup           : source.on(_event, _keyup);\r\n                case Ev.keydown         : source.on(_event, _keydown);\r\n                case Ev.textinput       : source.on(_event, _textinput);\r\n\r\n                case Ev.mousedown       : source.on(_event, _mousedown);\r\n                case Ev.mouseup         : source.on(_event, _mouseup);\r\n                case Ev.mousemove       : source.on(_event, _mousemove);\r\n                case Ev.mousewheel      : source.on(_event, _mousewheel);\r\n\r\n                case Ev.touchdown       : source.on(_event, _touchdown);\r\n                case Ev.touchup         : source.on(_event, _touchup);\r\n                case Ev.touchmove       : source.on(_event, _touchmove);\r\n\r\n                case Ev.inputup         : source.on(_event, _inputup);\r\n                case Ev.inputdown       : source.on(_event, _inputdown);\r\n\r\n                case Ev.gamepaddown     : source.on(_event, _gamepaddown);\r\n                case Ev.gamepadup       : source.on(_event, _gamepadup);\r\n                case Ev.gamepadaxis     : source.on(_event, _gamepadaxis);\r\n                case Ev.gamepaddevice   : source.on(_event, _gamepaddevice);\r\n\r\n                case Ev.windowmoved     : source.on(_event, _windowmoved);\r\n                case Ev.windowresized   : source.on(_event, _windowresized);\r\n                case Ev.windowsized     : source.on(_event, _windowsized);\r\n                case Ev.windowminimized : source.on(_event, _windowminimized);\r\n                case Ev.windowrestored  : source.on(_event, _windowrestored);\r\n\r\n            } //switch event\r\n        } //source != null\r\n\r\n    } //_listen\r\n\r\n    @:noCompletion public function _unlisten( _event:Int, _handler:EmitHandler, ?_self:Bool=false ) {\r\n\r\n        var source = _find_emit_source();\r\n\r\n        _debug('$name / unlisten to $_event from $source');\r\n\r\n        if(!_self) {\r\n            off(_event, _handler);\r\n        }\r\n\r\n        if(source != null) {\r\n            switch(_event) {\r\n\r\n                case Ev.keyup           : source.off(_event, _keyup);\r\n                case Ev.keydown         : source.off(_event, _keydown);\r\n                case Ev.textinput       : source.off(_event, _textinput);\r\n\r\n                case Ev.mousedown       : source.off(_event, _mousedown);\r\n                case Ev.mouseup         : source.off(_event, _mouseup);\r\n                case Ev.mousemove       : source.off(_event, _mousemove);\r\n                case Ev.mousewheel      : source.off(_event, _mousewheel);\r\n\r\n                case Ev.touchdown       : source.off(_event, _touchdown);\r\n                case Ev.touchup         : source.off(_event, _touchup);\r\n                case Ev.touchmove       : source.off(_event, _touchmove);\r\n\r\n                case Ev.inputup         : source.off(_event, _inputup);\r\n                case Ev.inputdown       : source.off(_event, _inputdown);\r\n\r\n                case Ev.gamepaddown     : source.off(_event, _gamepaddown);\r\n                case Ev.gamepadup       : source.off(_event, _gamepadup);\r\n                case Ev.gamepadaxis     : source.off(_event, _gamepadaxis);\r\n                case Ev.gamepaddevice   : source.off(_event, _gamepaddevice);\r\n\r\n                case Ev.windowmoved     : source.off(_event, _windowmoved);\r\n                case Ev.windowresized   : source.off(_event, _windowresized);\r\n                case Ev.windowsized     : source.off(_event, _windowsized);\r\n                case Ev.windowminimized : source.off(_event, _windowminimized);\r\n                case Ev.windowrestored  : source.off(_event, _windowrestored);\r\n\r\n            } //switch event\r\n        } //source != null\r\n\r\n    } //_unlisten\r\n\r\n\r\n//scene\r\n\r\n    function _detach_scene() {\r\n\r\n        if(scene != null) {\r\n\r\n            scene.off(Ev.reset, _reset);\r\n            scene.off(Ev.destroy, destroy);\r\n\r\n                //precaution\r\n            scene.off(Ev.keyup, _keyup);\r\n            scene.off(Ev.keydown, _keydown);\r\n            scene.off(Ev.textinput, _textinput);\r\n            scene.off(Ev.mousedown, _mousedown);\r\n            scene.off(Ev.mouseup, _mouseup);\r\n            scene.off(Ev.mousemove, _mousemove);\r\n            scene.off(Ev.mousewheel, _mousewheel);\r\n            scene.off(Ev.touchdown, _touchdown);\r\n            scene.off(Ev.touchup, _touchup);\r\n            scene.off(Ev.touchmove, _touchmove);\r\n            scene.off(Ev.inputup, _inputup);\r\n            scene.off(Ev.inputdown, _inputdown);\r\n            scene.off(Ev.gamepaddown, _gamepaddown);\r\n            scene.off(Ev.gamepadup, _gamepadup);\r\n            scene.off(Ev.gamepadaxis, _gamepadaxis);\r\n            scene.off(Ev.gamepaddevice, _gamepaddevice);\r\n            scene.off(Ev.windowmoved, _windowmoved);\r\n            scene.off(Ev.windowresized, _windowresized);\r\n            scene.off(Ev.windowsized, _windowsized);\r\n            scene.off(Ev.windowminimized, _windowminimized);\r\n            scene.off(Ev.windowrestored, _windowrestored);\r\n\r\n        } //scene != null\r\n\r\n    } //detach_scene\r\n\r\n    function _attach_scene() {\r\n\r\n        if(scene != null) {\r\n            scene.on(Ev.reset, _reset);\r\n            scene.on(Ev.destroy, destroy);\r\n        }\r\n\r\n    } //attach_scene\r\n\r\n//Keys\r\n\r\n    @:noCompletion public function _keyup( _event:KeyEvent ) {\r\n\r\n        if(!active || !inited || !started) {\r\n            return;\r\n        }\r\n\r\n        _debug('calling _keyup on ' + name);\r\n\r\n        onkeyup(_event);\r\n        emit(Ev.keyup, _event);\r\n\r\n    } //_keyup\r\n\r\n    @:noCompletion public function _keydown( _event:KeyEvent ) {\r\n\r\n        if(!active || !inited || !started) {\r\n            return;\r\n        }\r\n\r\n        _debug('calling _keydown on ' + name);\r\n\r\n        onkeydown(_event);\r\n        emit(Ev.keydown, _event);\r\n\r\n    } //_keydown\r\n\r\n    @:noCompletion public function _textinput( _event:TextEvent ) {\r\n\r\n        if(!active || !inited || !started) {\r\n            return;\r\n        }\r\n\r\n        _debug('calling _textinput on ' + name);\r\n\r\n        ontextinput(_event);\r\n        emit(Ev.textinput, _event);\r\n\r\n    } //_textinput\r\n\r\n\r\n//Mouse\r\n\r\n    @:noCompletion public function _mousedown( _event:MouseEvent ) {\r\n\r\n        if(!active || !inited || !started) {\r\n            return;\r\n        }\r\n\r\n        _debug('calling _mousedown on ' + name );\r\n\r\n        onmousedown(_event);\r\n        emit(Ev.mousedown, _event);\r\n\r\n    } //_mousedown\r\n\r\n\r\n    @:noCompletion public function _mouseup( _event:MouseEvent ) {\r\n\r\n        if(!active || !inited || !started) {\r\n            return;\r\n        }\r\n\r\n        _debug('calling _mouseup on ' + name);\r\n\r\n        onmouseup(_event);\r\n        emit(Ev.mouseup, _event);\r\n\r\n    } //_mouseup\r\n\r\n    @:noCompletion public function _mousewheel( _event:MouseEvent ) {\r\n\r\n        if(!active || !inited || !started) {\r\n            return;\r\n        }\r\n\r\n        _debug('calling _mousewheel on ' + name);\r\n\r\n        onmousewheel(_event);\r\n        emit(Ev.mousewheel, _event);\r\n\r\n    } //_mousewheel\r\n\r\n    @:noCompletion public function _mousemove( _event:MouseEvent ) {\r\n\r\n        if(!active || !inited || !started) {\r\n            return;\r\n        }\r\n\r\n        _debug('calling _mousemove on ' + name);\r\n\r\n        onmousemove(_event);\r\n        emit(Ev.mousemove, _event);\r\n\r\n    } //_mousemove\r\n\r\n//Touch\r\n    @:noCompletion public function _touchdown( _event:TouchEvent ) {\r\n\r\n        if(!active || !inited || !started) {\r\n            return;\r\n        }\r\n\r\n        _debug('calling _touchdown on ' + name);\r\n\r\n        ontouchdown(_event);\r\n        emit(Ev.touchdown, _event);\r\n\r\n    } //_touchdown\r\n\r\n    @:noCompletion public function _touchup( _event:TouchEvent ) {\r\n\r\n        if(!active || !inited || !started) {\r\n            return;\r\n        }\r\n\r\n        _debug('calling _touchup on ' + name);\r\n\r\n        ontouchup(_event);\r\n        emit(Ev.touchup, _event);\r\n\r\n    } //_touchup\r\n\r\n    @:noCompletion public function _touchmove( _event:TouchEvent ) {\r\n\r\n        if(!active || !inited || !started) {\r\n            return;\r\n        }\r\n\r\n        _debug('calling _touchmove on ' + name);\r\n\r\n        ontouchmove(_event);\r\n        emit(Ev.touchmove, _event);\r\n\r\n    } //_touchmove\r\n\r\n//Gamepad\r\n    @:noCompletion public function _gamepadaxis( _event:GamepadEvent ) {\r\n\r\n        if(!active || !inited || !started) {\r\n            return;\r\n        }\r\n\r\n        _debug('calling _gamepadaxis on ' + name);\r\n\r\n        ongamepadaxis(_event);\r\n        emit(Ev.gamepadaxis, _event);\r\n\r\n    } //_gamepadaxis\r\n\r\n    @:noCompletion public function _gamepaddown( _event:GamepadEvent ) {\r\n\r\n        if(!active || !inited || !started) {\r\n            return;\r\n        }\r\n\r\n        _debug('calling _gamepaddown on ' + name);\r\n\r\n        ongamepaddown(_event);\r\n        emit(Ev.gamepaddown, _event);\r\n\r\n    } //_gamepaddown\r\n\r\n    @:noCompletion public function _gamepadup( _event:GamepadEvent ) {\r\n\r\n        if(!active || !inited || !started) {\r\n            return;\r\n        }\r\n\r\n        _debug('calling _gamepadup on ' + name);\r\n\r\n        ongamepadup(_event);\r\n        emit(Ev.gamepadup, _event);\r\n\r\n    } //_gamepadup\r\n\r\n    @:noCompletion public function _gamepaddevice( _event:GamepadEvent ) {\r\n\r\n        if(!active || !inited || !started) {\r\n            return;\r\n        }\r\n\r\n        _debug('calling _gamepaddevice on ' + name);\r\n\r\n        ongamepaddevice(_event);\r\n        emit(Ev.gamepaddevice, _event);\r\n\r\n    } //_gamepaddevice\r\n\r\n//Windowing\r\n\r\n    @:noCompletion public function _windowmoved( _event:WindowEvent ) {\r\n\r\n        if(!active || !inited || !started) {\r\n            return;\r\n        }\r\n\r\n        _debug('calling _windowmoved on ' + name);\r\n\r\n        onwindowmoved(_event);\r\n        emit(Ev.windowmoved, _event);\r\n\r\n    } //_windowmoved\r\n\r\n    @:noCompletion public function _windowresized( _event:WindowEvent ) {\r\n\r\n        if(!active || !inited || !started) {\r\n            return;\r\n        }\r\n\r\n        _debug('calling _windowresized on ' + name);\r\n\r\n        onwindowresized(_event);\r\n        emit(Ev.windowresized, _event);\r\n\r\n    } //_windowresized\r\n\r\n    @:noCompletion public function _windowsized( _event:WindowEvent ) {\r\n\r\n        if(!active || !inited || !started) {\r\n            return;\r\n        }\r\n\r\n        _debug('calling _windowsized on ' + name);\r\n\r\n        onwindowsized(_event);\r\n        emit(Ev.windowsized, _event);\r\n\r\n    } //_windowsized\r\n\r\n    @:noCompletion public function _windowminimized( _event:WindowEvent ) {\r\n\r\n        if(!active || !inited || !started) {\r\n            return;\r\n        }\r\n\r\n        _debug('calling _windowminimized on ' + name);\r\n\r\n        onwindowminimized(_event);\r\n        emit(Ev.windowminimized, _event);\r\n\r\n    } //_windowminimized\r\n\r\n    @:noCompletion public function _windowrestored( _event:WindowEvent ) {\r\n\r\n        if(!active || !inited || !started) {\r\n            return;\r\n        }\r\n\r\n        _debug('calling _windowrestored on ' + name);\r\n\r\n        onwindowrestored(_event);\r\n        emit(Ev.windowrestored, _event);\r\n\r\n    } //_windowrestored\r\n\r\n//Input\r\n\r\n    @:noCompletion public function _inputdown( _event : { name:String, event:InputEvent } ) {\r\n\r\n        if(!active || !inited || !started) {\r\n            return;\r\n        }\r\n\r\n        _debug('calling _inputdown on ' + name);\r\n\r\n        oninputdown(_event.name, _event.event);\r\n        emit(Ev.inputdown, _event);\r\n\r\n    } //_inputdown\r\n\r\n    @:noCompletion public function _inputup( _event : { name:String, event:InputEvent } ) {\r\n\r\n        if(!active || !inited || !started) {\r\n            return;\r\n        }\r\n\r\n        _debug('calling _inputup on ' + name);\r\n\r\n        oninputup(_event.name, _event.event);\r\n        emit(Ev.inputup, _event );\r\n\r\n    } //_inputup\r\n\r\n\r\n//timing\r\n\r\n    inline function get_fixed_rate() : Float {\r\n\r\n        return fixed_rate;\r\n\r\n    } //get_fixed_rate\r\n\r\n    inline function set_fixed_rate( _rate:Float ) : Float {\r\n\r\n        fixed_rate = _rate;\r\n\r\n        if(started) {\r\n            _set_fixed_rate_timer( _rate );\r\n        }\r\n\r\n        return fixed_rate;\r\n\r\n    } //set_fixed_rate\r\n\r\n    inline function _stop_fixed_rate_timer() {\r\n\r\n        if(fixed_rate_timer != null) {\r\n            fixed_rate_timer.stop();\r\n            fixed_rate_timer = null;\r\n        }\r\n\r\n    } //_stop_fixed_rate_timer\r\n\r\n    inline function _set_fixed_rate_timer( _rate:Float, ?_pos:haxe.PosInfos ) {\r\n\r\n        _stop_fixed_rate_timer();\r\n\r\n            //only top tier entities call this,\r\n            //all their children are fixed under the parent rate\r\n            //for now, that is.\r\n        if(_rate != 0 && parent == null && !destroyed) {\r\n            fixed_rate_timer = new snow.utils.Timer( _rate );\r\n            fixed_rate_timer.run = _fixed_update;\r\n        } //_rate\r\n\r\n    } //_set_fixed_rate_timer\r\n\r\n//components\r\n\r\n    inline function get_components() {\r\n        return _components.components;\r\n    } //get_components\r\n\r\n//children\r\n\r\n    @:noCompletion public function _add_child( child:Entity ) {\r\n\r\n        children.push(child);\r\n\r\n        _debug( '' + name + \" : add child : \" + child.name );\r\n\r\n            //children inherit the updates and such from the parent, so they shouldn't be in the root of the scene\r\n        if(child.scene != null) {\r\n            _debug( '' + name + \" add child \" + child.name + \" being parented, removing from scene root of \" + child.scene.name);\r\n            var removed = child.scene.remove( child );\r\n        } else {\r\n            _debug('' + name + \" add child \" + child.name + \" being parented, but not from a scene\");\r\n        }\r\n\r\n    } //_add_child\r\n\r\n        //internal function do not use directly\r\n    @:noCompletion public function _remove_child(child:Entity) {\r\n\r\n        children.remove(child);\r\n\r\n    } //removeChild\r\n\r\n//listeners\r\n\r\n    function set_pos_from_transform( _pos:Vector ) {\r\n\r\n            //and we have to propogate the values to the components\r\n        if(component_count > 0) {\r\n            for(_component in components) {\r\n                _component.entity_pos_change( _pos );\r\n            } //for each _component\r\n        }\r\n\r\n    } //set_pos_from_transform\r\n\r\n    function set_rotation_from_transform( _rotation:Quaternion ) {\r\n\r\n            //and we have to propogate the values to the components\r\n        if(component_count > 0) {\r\n            for(_component in components) {\r\n                _component.entity_rotation_change( _rotation );\r\n            } //for each _component\r\n        }\r\n\r\n    } //set_rotation_from_transform\r\n\r\n    function set_scale_from_transform( _scale:Vector ) {\r\n\r\n            //and we have to propogate the values to the components\r\n        if(component_count > 0) {\r\n            for(_component in components) {\r\n                _component.entity_scale_change( _scale );\r\n            } //for each _component\r\n        }\r\n\r\n    } //set_scale_from_transform\r\n\r\n    function set_origin_from_transform( _origin:Vector ) {\r\n\r\n            //and we have to propogate the values to the components\r\n        if(component_count > 0) {\r\n            for(_component in components) {\r\n                _component.entity_origin_change( _origin );\r\n            } //for each _component\r\n        }\r\n\r\n    } //set_origin_from_transform\r\n\r\n    function set_parent_from_transform( _parent:Transform ) {\r\n\r\n            //and we have to propogate the values to the components\r\n        if(component_count > 0) {\r\n            for(_component in components) {\r\n                _component.entity_parent_change( _parent );\r\n            } //for each _component\r\n        }\r\n\r\n    } //set_parent_from_transform\r\n\r\n//pos\r\n\r\n    function set_pos(_p:Vector) {\r\n\r\n        return transform.pos = _p;\r\n\r\n    } //set_pos\r\n\r\n    function get_pos() {\r\n\r\n        return transform.pos;\r\n\r\n    } //get_pos\r\n\r\n//rotation\r\n\r\n    function set_rotation( _r:Quaternion ) {\r\n\r\n        return transform.rotation = _r;\r\n\r\n    } //set_rotation\r\n\r\n    function get_rotation() {\r\n\r\n        return transform.rotation;\r\n\r\n    } //get_rotation\r\n\r\n//scale\r\n\r\n    function set_scale( _s:Vector ) {\r\n\r\n        return transform.scale = _s;\r\n\r\n    } //set_scale\r\n\r\n    function get_scale() {\r\n\r\n        return transform.scale;\r\n\r\n    } //get_scale\r\n\r\n//origin\r\n\r\n    function set_origin( _origin:Vector ) {\r\n\r\n        return transform.origin = _origin;\r\n\r\n    } //set_origin\r\n\r\n\r\n    function get_origin() {\r\n\r\n        return transform.origin;\r\n\r\n    } //get_origin\r\n\r\n//transform\r\n\r\n    function set_transform( _transform:Transform ) {\r\n\r\n        return transform = _transform;\r\n\r\n    } //set_transform\r\n\r\n\r\n    function get_transform() {\r\n\r\n        return transform;\r\n\r\n    } //get_transform\r\n\r\n//parent\r\n\r\n    function set_parent( other:Entity ) {\r\n\r\n        _debug('>>  ' + name + ' calling set parent to ' + (other == null ? 'null' : other.name) );\r\n\r\n            //if we are parented already,\r\n            //remove ourselves from that parent\r\n        if(parent != null) {\r\n            parent._remove_child( this );\r\n        } //remove\r\n\r\n            //store the new parent, even if it's null, that is ok\r\n        parent = other;\r\n\r\n            //and if we are not detaching parent using null\r\n            //we add it to the parent directly and update its transform\r\n        if(parent != null) {\r\n            parent._add_child(this);\r\n            transform.parent = parent.transform;\r\n        } else {\r\n            transform.parent = null;\r\n        }\r\n\r\n        return parent;\r\n\r\n    } //set_parent\r\n\r\n    function get_parent() {\r\n\r\n        return parent;\r\n\r\n    } //get_parent\r\n\r\n//scene\r\n\r\n    function set_scene(_scene:Scene) {\r\n\r\n        _detach_scene();\r\n\r\n            scene = _scene;\r\n\r\n        _attach_scene();\r\n\r\n        return scene;\r\n\r\n    } //set_scene\r\n\r\n    function get_scene() {\r\n\r\n        return scene;\r\n\r\n    } //get_scene\r\n\r\n//active\r\n\r\n    function set_active(_active:Bool) : Bool {\r\n\r\n        return active = _active;\r\n\r\n    } //set_active\r\n\r\n    function get_active() {\r\n\r\n        return active;\r\n\r\n    } //get_active\r\n\r\n} //Entity\r\n","package luxe.structural;\r\n\r\n/**\r\n    WIP\r\n*/\r\n\r\nimport Map;\r\n\r\nclass OrderedMapIterator<K,V> {\r\n\r\n    var map : OrderedMap<K,V>;\r\n    var index : Int = 0;\r\n\r\n    public inline function new(omap:OrderedMap<K,V>)\r\n        map = omap;\r\n    public inline function hasNext() : Bool\r\n        return index < map._keys.length;\r\n    public inline function next() : V\r\n        return map.get( map._keys[index++] );\r\n\r\n} //OrderedMapIterator\r\n\r\nclass OrderedMap<K, V> implements IMap<K, V> {\r\n\r\n    var map:Map<K, V>;\r\n    var idx = 0;\r\n\r\n    @:allow(luxe.structural.OrderedMapIterator)\r\n    var _keys:Array<K>;\r\n\r\n    public inline function new(_map) {\r\n       _keys = [];\r\n       map = _map;\r\n    }\r\n\r\n    public inline function set(key:K, value:V) {\r\n        if (!map.exists(key)) _keys.push(key);\r\n        map[key] = value;\r\n    }\r\n\r\n    public inline function toString() {\r\n        var _ret = ''; var _cnt = 0; var _len = _keys.length;\r\n        for(k in _keys) _ret += '$k => ${map.get(k)}${(_cnt++<_len-1?\", \":\"\")}';\r\n        return '{$_ret}';\r\n    }\r\n\r\n    public inline function iterator()          return new OrderedMapIterator<K,V>(this);\r\n    public inline function remove(key)         return map.remove(key) && _keys.remove(key);\r\n    public inline function exists(key)         return map.exists(key);\r\n    public inline function get(key)            return map.get(key);\r\n    public inline function keys()              return _keys.iterator();\r\n\r\n} //OrderedMap\r\n","package luxe;\r\n\r\nimport luxe.Rectangle;\r\nimport luxe.utils.Maths;\r\nimport luxe.Vector;\r\nimport luxe.Entity;\r\nimport luxe.tween.Actuate;\r\nimport luxe.tween.easing.Quad;\r\nimport phoenix.Camera.ProjectionType;\r\nimport phoenix.Quaternion;\r\n\r\nimport luxe.options.CameraOptions;\r\n\r\ntypedef ProjectionType = phoenix.Camera.ProjectionType;\r\n\r\n    /** A value to use when controlling the camera size property only. */\r\nenum SizeMode {\r\n\r\n        /** fit the size into the camera viewport (possible letter/pillar box) */\r\n    fit;\r\n        /** cover the viewport with the size (possible cropping) */\r\n    cover;\r\n        /** contain the size (stretch to fit the viewport)*/\r\n    contain;\r\n\r\n} //SizeMode\r\n\r\n    /** An entity based camera class */\r\nclass Camera extends Entity {\r\n\r\n        /** The viewport size for this camera, proxy to the view */\r\n    public var viewport (get,set) : Rectangle;\r\n        /** The center point of this camera, proxy to the view */\r\n    public var center (get,set) : Vector;\r\n        /** The current zoom value this camera can be set to, proxy to the view */\r\n    public var zoom (get,set) : Float;\r\n        /** The minimum zoom value this camera can be set to, proxy to the view */\r\n    public var minimum_zoom (get,set) : Float;\r\n\r\n        /** The virtual size of this camera. allows simple upscaling world coordinates, using `size_mode`. Note that this changes the view `scale` values and the `center` property. */\r\n    @:isVar public var size (get,set) : Vector;\r\n        /** When the size of the world is set using the `size` property, this controls how the scaling will apply. */\r\n    @:isVar public var size_mode (get,set) : SizeMode;\r\n\r\n        /** the view camera this entity wraps */\r\n    public var view : phoenix.Camera;\r\n        /** if set, the camera will not move outside of this region (world space) */\r\n    public var bounds : Rectangle;\r\n\r\n        /** the current shake vector amounts in x,y,z */\r\n    @:noCompletion public var shake_vector : Vector;\r\n        /** the last shake amount */\r\n    @:noCompletion public var shake_amount : Float;\r\n        /** if true, shake is busy happening */\r\n    @:noCompletion public var shaking : Bool = false;\r\n        /** the threshold cutoff for shaking */\r\n    @:noCompletion public var minimum_shake : Float = 0.1;\r\n\r\n    var update_view_pos : Vector;\r\n\r\n    var _size_factor : Vector;\r\n    var _final_pos : Vector;\r\n    var _rotation_radian : Vector;\r\n    var _rotation_cache : Quaternion;\r\n\r\n        /** create a new camera with the given options */\r\n    public function new( ?options:LuxeCameraOptions ) {\r\n\r\n            //cache for later\r\n        _size_factor = new Vector();\r\n        _rotation_radian = new Vector();\r\n        _rotation_cache = new Quaternion();\r\n        size_mode = SizeMode.fit;\r\n\r\n        var _name = 'untitled camera';\r\n\r\n        if(options != null) {\r\n            if(options.name != null) {\r\n                _name = options.name;\r\n            }\r\n        } else {\r\n            options = {\r\n                no_scene : false\r\n            }\r\n        }\r\n\r\n            //create or assign the underlying camera view\r\n        view = options.view == null ? new phoenix.Camera( options ) : options.view;\r\n\r\n            //Init the entity part\r\n        super({\r\n            name : _name,\r\n            no_scene : options.no_scene\r\n        });\r\n\r\n            //Start with the transform\r\n        _final_pos = view.pos;\r\n\r\n    } //new\r\n\r\n    function get_viewport() : Rectangle {\r\n        return view.viewport;\r\n    } //get_viewport\r\n\r\n    function set_viewport( _v:Rectangle ) : Rectangle {\r\n        return view.viewport = _v;\r\n    } //set_viewport\r\n\r\n    function get_center() : Vector {\r\n        return view.center;\r\n    } //get_center\r\n\r\n    function set_center( _c:Vector ) : Vector {\r\n\r\n        pos = new Vector(_c.x - (viewport.w/2), _c.y - (viewport.h/2));\r\n        return view.center = _c;\r\n\r\n    } //set_center\r\n\r\n    function get_minimum_zoom() : Float {\r\n        return view.minimum_zoom;\r\n    } //get_minimum_zoom\r\n\r\n    function set_minimum_zoom( _m:Float ) : Float {\r\n        return view.minimum_zoom = _m;\r\n    } //set_minimum_zoom\r\n\r\n    function get_zoom() : Float {\r\n        return view.zoom;\r\n    } //get_zoom\r\n\r\n    function set_zoom( _z:Float ) : Float {\r\n\r\n            //assign the base zoom\r\n        view.zoom = _z;\r\n\r\n            //handle size mode scale factor\r\n        if(size != null) {\r\n            view.scale.x *= (1/_size_factor.x);\r\n            view.scale.y *= (1/_size_factor.y);\r\n        }\r\n\r\n        return view.zoom;\r\n\r\n    } //set_zoom\r\n\r\n    function get_size() : Vector {\r\n        return size;\r\n    } //get_size\r\n\r\n    function get_size_mode() : SizeMode {\r\n        return size_mode;\r\n    } //get_size\r\n\r\n    function set_size_mode( _m:SizeMode ) : SizeMode {\r\n\r\n        if(size_mode != null) {\r\n            size_mode = _m;\r\n            if(size != null) {\r\n                set_size( size );\r\n            }\r\n        }\r\n\r\n        return size_mode = _m;\r\n\r\n    } //get_size\r\n\r\n    var _connected = false;\r\n    function _onwindowsized( _event:luxe.Screen.WindowEvent ) {\r\n        if(size != null) {\r\n                //:todo: set_xy handlers on viewport etc\r\n                //:todo: disconnect on destroy when destroy exists for camera\r\n            viewport = new Rectangle(viewport.x, viewport.y, _event.event.x, _event.event.y );\r\n            set_size(size);\r\n        }\r\n    }\r\n\r\n    function set_size( _size:Vector ) : Vector {\r\n\r\n            //disable size\r\n        if( _size == null ) {\r\n            center = new Vector(viewport.w/2, viewport.h/2);\r\n            size = _size;\r\n            _size_factor.x = _size_factor.y = 1;\r\n            set_zoom(zoom);\r\n            _connected = false;\r\n            Luxe.off(Luxe.Ev.windowsized, _onwindowsized);\r\n            return size;\r\n        }\r\n\r\n        if(!_connected) {\r\n            Luxe.on(Luxe.Ev.windowsized, _onwindowsized);\r\n            _connected = true;\r\n        }\r\n\r\n            //setting the size is an explicit action,\r\n            //making the center point fixed to the middle of the size,\r\n            //and making the scale of the view a ratio between the viewport\r\n            //size and the actual \"world\" size given\r\n        var _ratio_x = viewport.w / _size.x;\r\n        var _ratio_y = viewport.h / _size.y;\r\n        var _shortest = Math.max( _ratio_x, _ratio_y );\r\n        var _longest = Math.min( _ratio_x, _ratio_y );\r\n\r\n        switch(size_mode) {\r\n\r\n            case fit:{\r\n                _ratio_x = _ratio_y = _longest;\r\n            }\r\n\r\n            case cover: {\r\n                _ratio_x = _ratio_y = _shortest;\r\n            }\r\n\r\n            case contain: {\r\n                //use actual size\r\n            }\r\n\r\n        } //size_mode\r\n\r\n            //assign the scale values\r\n        _size_factor.x = _ratio_x;\r\n        _size_factor.y = _ratio_y;\r\n\r\n        view.scale.x = 1/(_size_factor.x * zoom);\r\n        view.scale.y = 1/(_size_factor.y * zoom);\r\n\r\n            //set the center\r\n        center = new Vector( _size.x/2, _size.y/2 );\r\n\r\n            //return\r\n        return size = _size.clone();\r\n\r\n    } //set_size\r\n\r\n        /**Focus the camera on a specific point, for Ortho only.\r\n        Use `.target` for a focus in perspective */\r\n    public function focus( _p:Vector, _t:Float = 0.6, ?oncomplete:Void->Void=null ) {\r\n\r\n        Actuate.tween(view.center, _t, { x:_p.x, y:_p.y }, true )\r\n            .onComplete( oncomplete ).ease( Quad.easeInOut )\r\n            .onUpdate( function() {\r\n                transform.pos.set_xy(view.pos.x, view.pos.y);\r\n            });\r\n\r\n    } //focus\r\n\r\n        /** convert a screen point to world space for this camera. handles zoom, rotation, scale, etc */\r\n    public function screen_point_to_world( _vector:Vector ) : Vector {\r\n\r\n        return view.screen_point_to_world( _vector );\r\n\r\n    } //screen_point_to_world\r\n\r\n        /** convert a world point to screen space for this camera. handles zoom, rotation, scale, etc */\r\n    public function world_point_to_screen( _vector:Vector, ?_viewport:Rectangle=null ) : Vector {\r\n\r\n        return view.world_point_to_screen( _vector, _viewport );\r\n\r\n    } //world_point_to_screen\r\n\r\n    // var cnt = 0;\r\n    override function set_pos_from_transform(_pos:Vector) {\r\n\r\n        var vw = view.viewport.w;\r\n        var vh = view.viewport.h;\r\n        var hvw = vw/2;\r\n        var hvh = vh/2;\r\n\r\n        var _px = _pos.x; var _py = _pos.y;\r\n\r\n        if(bounds != null) {\r\n            if(_px < bounds.x)        _px = bounds.x;\r\n            if(_py < bounds.y)        _py = bounds.y;\r\n            if(_px+hvw > bounds.w-vw) _px = bounds.w-vw-hvw;\r\n            if(_py+hvh > bounds.h-vh) _py = bounds.h-vh-hvh;\r\n        }\r\n\r\n        var prev = _pos.ignore_listeners;\r\n            _pos.ignore_listeners = true;\r\n        _pos.set_xy(_px, _py);\r\n            _pos.ignore_listeners = prev;\r\n\r\n        super.set_pos_from_transform(_pos);\r\n\r\n            //flag for update\r\n        update_view_pos = _pos;\r\n\r\n\r\n    } //set_pos_from_transform\r\n\r\n    override function set_rotation_from_transform(_rotation:Quaternion) {\r\n\r\n        super.set_rotation_from_transform(_rotation);\r\n\r\n        if(view != null) {\r\n            view.rotation = _rotation;\r\n        }\r\n\r\n    } //set_scale_from_transform\r\n\r\n    override function set_scale_from_transform(_scale:Vector) {\r\n\r\n        super.set_scale_from_transform(_scale);\r\n\r\n        if(view != null) {\r\n            view.scale = _scale;\r\n        }\r\n\r\n    } //set_scale_from_transform\r\n\r\n        /** Shake the camera a given amount */\r\n    public function shake(amount:Float) {\r\n\r\n        shake_amount = amount;\r\n        shaking = true;\r\n\r\n    } //shake\r\n\r\n        //Called by the scene the camera belongs to, or manually if you want\r\n    @:noCompletion override public function update(dt:Float) {\r\n\r\n            //add camera shake\r\n        if(shaking) {\r\n\r\n                //start at our base position\r\n            _final_pos.set_xyz( transform.pos.x, transform.pos.y, transform.pos.z );\r\n\r\n                //get a random direction\r\n            shake_vector = Luxe.utils.geometry.random_point_in_unit_circle();\r\n\r\n                //apply the shake amount scale\r\n            shake_vector.x *= shake_amount;\r\n            shake_vector.y *= shake_amount;\r\n            shake_vector.z *= shake_amount;\r\n\r\n                //fade the shake down\r\n            shake_amount *= 0.9;\r\n\r\n                //stop when it's too low\r\n            if(shake_amount <= minimum_shake) {\r\n                shake_amount = 0;\r\n                shaking = false;\r\n            }\r\n\r\n                //add the shake to the final position and apply it to the view\r\n            _final_pos.set_xyz(_final_pos.x+shake_vector.x, _final_pos.y+shake_vector.y, _final_pos.z+shake_vector.z);\r\n\r\n                //tell it to update the view\r\n            update_view_pos = _final_pos;\r\n\r\n        } //shaking\r\n\r\n        if(update_view_pos != null && view != null) {\r\n            view.pos = update_view_pos.clone();\r\n            update_view_pos = null;\r\n        }\r\n\r\n    } //update\r\n\r\n} //Camera\r\n","package luxe.macros;\r\n\r\nimport haxe.macro.Context;\r\nimport haxe.macro.Expr;\r\nimport haxe.macro.ExprTools;\r\n\r\n@:noCompletion class EntityRules {\r\n\r\n#if macro\r\n\r\n    static var init_field : Field;\r\n    static var ondestroy_field : Field;\r\n\r\n    macro public static function apply() : Array<Field> {\r\n\r\n        init_field = null;\r\n        ondestroy_field = null;\r\n\r\n        var _fields = Context.getBuildFields();\r\n\r\n            //do this first to ensure the values are set\r\n        for(_field in _fields) {\r\n            switch(_field.name) {\r\n                case 'init': init_field = _field;\r\n                case 'ondestroy': ondestroy_field = _field;\r\n            }\r\n        }\r\n\r\n            //if no init field, insert one\r\n        if(init_field == null) {\r\n            init_field = {\r\n                name: 'init',\r\n                doc: null, meta: [],\r\n                access: [AOverride],\r\n                kind: FFun({ params:[], args:[], ret:null, expr:macro { } }),\r\n                pos: Context.currentPos()\r\n            };\r\n            _fields.push(init_field);\r\n        }\r\n\r\n            //if no ondestroy field, insert one\r\n        if(ondestroy_field == null) {\r\n            ondestroy_field = {\r\n                name: 'ondestroy',\r\n                doc: null, meta: [],\r\n                access: [AOverride],\r\n                kind: FFun({ params:[], args:[], ret:null, expr:macro { super.ondestroy(); } }),\r\n                pos: Context.currentPos()\r\n            };\r\n            _fields.push(ondestroy_field);\r\n        }\r\n\r\n        for(_field in _fields) {\r\n\r\n            switch(_field.name) {\r\n\r\n                case\r\n                    'ontouchmove',\r\n                    'ontouchdown',\r\n                    'ontouchup',\r\n                    'onmousemove',\r\n                    'onmousedown',\r\n                    'onmouseup',\r\n                    'onmousewheel',\r\n                    'ongamepadaxis',\r\n                    'ongamepadup',\r\n                    'ongamepaddown',\r\n                    'ongamepaddevice',\r\n                    'onkeydown',\r\n                    'onkeyup',\r\n                    'ontextinput',\r\n                    'oninputdown',\r\n                    'oninputup',\r\n                    'onwindowmoved',\r\n                    'onwindowresized',\r\n                    'onwindowsized',\r\n                    'onwindowminimized',\r\n                    'onwindowrestored' :\r\n                {\r\n                    connect_event(_field);\r\n                }\r\n\r\n            } //switch _field.name\r\n\r\n        } //for field in fields\r\n\r\n        return _fields;\r\n\r\n    } //apply\r\n\r\n\r\n\r\n    static function connect_event( _field:haxe.macro.Field ) {\r\n\r\n        if(_field.access.indexOf(AOverride) != -1) {\r\n\r\n            var _event_name : String = _field.name.substr(2);\r\n\r\n                //inject the init connection\r\n            switch(init_field.kind) {\r\n                default:\r\n                case FFun(f):\r\n                    switch(f.expr.expr) {\r\n                        default:\r\n                        case EBlock(exprs):\r\n                            exprs.push( Context.parse('_listen( Luxe.Ev.${_event_name}, ${_field.name}, true )', _field.pos) );\r\n                    } //switch exp\r\n            } //switch kind\r\n\r\n                //and inject the ondestroy connection\r\n            switch(ondestroy_field.kind) {\r\n                default:\r\n                case FFun(f):\r\n                    switch(f.expr.expr) {\r\n                        default:\r\n                        case EBlock(exprs):\r\n                            exprs.push( Context.parse('_unlisten( Luxe.Ev.${_event_name}, ${_field.name}, true )', _field.pos) );\r\n                    } //switch exp\r\n            } //switch kind\r\n\r\n        } //if override\r\n\r\n    } //connect_event\r\n\r\n#end //macro\r\n\r\n} //EntityRules\r\n","package luxe;\r\n\r\nimport luxe.Quaternion;\r\nimport luxe.Vector;\r\nimport luxe.Transform;\r\nimport luxe.Input;\r\nimport luxe.Screen;\r\nimport luxe.Objects.ID;\r\nimport luxe.options.ComponentOptions;\r\n\r\nimport luxe.Log.log;\r\nimport luxe.Log._debug;\r\nimport luxe.Log._verbose;\r\n\r\n@:autoBuild(luxe.macros.ComponentRules.apply())\r\nclass Component extends ID {\r\n\r\n        /** the entity this component is attached to */\r\n    @:isVar public var entity (get,set) : Entity;\r\n\r\n        /** The spatial transform of the attached entity. direct proxy to the entity transform */\r\n    public var transform : Transform;\r\n        /** The local position of the spatial transform. direct proxy to the entity transform */\r\n    public var pos              (get,set) : Vector;\r\n        /** The local rotation of the spatial transform. direct proxy to the entity transform */\r\n    public var rotation         (get,set) : Quaternion;\r\n        /** The local scale of the spatial transform. direct proxy to the entity transform */\r\n    public var scale            (get,set) : Vector;\r\n        /** The local origin of the spatial transform. direct proxy to the entity transform */\r\n    public var origin           (get,set) : Vector;\r\n\r\n        /** called when the scene is initiated. **use this instead of new** for state setup. it respects the order of creations, children, and component ordering. */\r\n    public function init() {}\r\n        /** called once per frame, passing the delta time */\r\n    public function update(dt:Float) {}\r\n\r\n        /** called when the component is attached to an entity */\r\n    public function onadded() {}\r\n        /** called when the component is removed from an entity */\r\n    public function onremoved() {}\r\n\r\n        /** called when the fixed update is triggered, if the entity has a fixed_rate set. hands the fixed_rate for interchangeable update/fixedupdate convenience */\r\n    @:noCompletion public function onfixedupdate(rate:Float) {}\r\n       /** called when the scene starts or is reset. use this to reset state. */\r\n    @:noCompletion public function onreset() {}\r\n        /** called when the scene, parent or entity is destroyed. use this to clean up state. */\r\n    @:noCompletion public function ondestroy() {}\r\n\r\n        /** override this to get notified when a key is released. only called if overridden. */\r\n    @:noCompletion public function onkeyup( event:KeyEvent ) {}\r\n        /** override this to get notified when a key is pressed. only called if overridden. */\r\n    @:noCompletion public function onkeydown( event:KeyEvent ) {}\r\n        /** override this to get notified when a text input event happens. only called if overridden. */\r\n    @:noCompletion public function ontextinput( event:TextEvent ) {}\r\n\r\n        /** override this to get notified when a named input event happens. only called if overridden. */\r\n    @:noCompletion public function oninputdown( event:{ name:String, event:InputEvent } ) {}\r\n        /** override this to get notified when a named input event happens. only called if overridden. */\r\n    @:noCompletion public function oninputup( event:{ name:String, event:InputEvent } ) {}\r\n\r\n        /** override this to get notified when a mouse button is pressed. only called if overridden. */\r\n    @:noCompletion public function onmousedown( event:MouseEvent ) {}\r\n        /** override this to get notified when a mouse button is pressed. only called if overridden. */\r\n    @:noCompletion public function onmouseup( event:MouseEvent ) {}\r\n        /** override this to get notified when a mouse is moved. only called if overridden. */\r\n    @:noCompletion public function onmousemove( event:MouseEvent ) {}\r\n        /** override this to get notified when the mouse wheel/trackpad is scrolled. only called if overridden. */\r\n    @:noCompletion public function onmousewheel( event:MouseEvent ) {}\r\n\r\n        /** override this to get notified when a touch begins. only called if overridden. */\r\n    @:noCompletion public function ontouchdown( event:TouchEvent ) {}\r\n        /** override this to get notified when a touch ends. only called if overridden. */\r\n    @:noCompletion public function ontouchup( event:TouchEvent ) {}\r\n        /** override this to get notified when a touch moves. only called if overridden. */\r\n    @:noCompletion public function ontouchmove( event:TouchEvent ) {}\r\n\r\n        /** override this to get notified when a gamepad button is released. only called if overridden. */\r\n    @:noCompletion public function ongamepadup( event:GamepadEvent ) {}\r\n        /** override this to get notified when a gamepad button is pressed. only called if overridden. */\r\n    @:noCompletion public function ongamepaddown( event:GamepadEvent ) {}\r\n        /** override this to get notified when a gamepad axis changes. only called if overridden. */\r\n    @:noCompletion public function ongamepadaxis( event:GamepadEvent ) {}\r\n        /** override this to get notified when a gamepad device event happens. only called if overridden. */\r\n    @:noCompletion public function ongamepaddevice( event:GamepadEvent ) {}\r\n\r\n       /** override this to get notified when a window is moved, with the data containing the new x/y position */\r\n   @:noCompletion public function onwindowmoved( event:WindowEvent ) {}\r\n       /** override this to get notified when a window is resized by the user, with the data containing the new x/y size */\r\n   @:noCompletion public function onwindowresized( event:WindowEvent ) {}\r\n       /** override this to get notified when a window is resized by the system or code or the user, with the data containing the new x/y size */\r\n   @:noCompletion public function onwindowsized( event:WindowEvent ) {}\r\n       /** override this to get notified when a window is minimized. */\r\n   @:noCompletion public function onwindowminimized( event:WindowEvent ) {}\r\n       /** override this to get notified when a window is restored. */\r\n   @:noCompletion public function onwindowrestored( event:WindowEvent ) {}\r\n\r\n        /** Use this to pass instance specific data and values to the component. */\r\n    public function new( ?_options:ComponentOptions ) {\r\n\r\n        var _name = '';\r\n\r\n        if(_options != null) {\r\n            if(_options.name != null) {\r\n                _name = _options.name;\r\n            }\r\n        }\r\n\r\n        super(_name == '' ? Luxe.utils.uniqueid() : _name);\r\n\r\n    } //new\r\n\r\n//components\r\n\r\n        /** attach a component to the entity */\r\n    public function add<T:Component>( component:T ) : T {\r\n        return entity.add( component );\r\n    } //add\r\n\r\n        /** remove a component from the entity */\r\n    public function remove( _name:String ) : Bool {\r\n        return entity.remove( _name );\r\n    } //add\r\n\r\n        /** get a component from the entity, by name */\r\n    public function get<T>( _name:String, ?in_children:Bool = false ) : T {\r\n        return entity.get( _name, in_children );\r\n    } //get\r\n\r\n        /** get all component from the entity, by name */\r\n    public function get_any<T>( _name:String, ?in_children:Bool = false, ?first_only:Bool = true ) : Array<T> {\r\n        return entity.get_any( _name, in_children, first_only );\r\n    } //get_any\r\n\r\n        /** returns true if the entity has a component by the given name */\r\n    public function has( _name:String ) : Bool {\r\n        return entity.has( _name );\r\n    } //has\r\n\r\n//Internal\r\n\r\n//entity\r\n\r\n    function _detach_entity() {\r\n\r\n        if(entity != null) {\r\n            //entity.off(Ev.reset, _reset);\r\n        }\r\n\r\n    } //detach_entity\r\n\r\n    function _attach_entity() {\r\n\r\n        if(entity != null) {\r\n            //entity.on(Ev.reset, _reset);\r\n        }\r\n\r\n    } //attach_entity\r\n\r\n    function set_entity(_entity:Entity) {\r\n\r\n        _detach_entity();\r\n\r\n            entity = _entity;\r\n\r\n        _attach_entity();\r\n\r\n        return entity;\r\n\r\n    } //set_entity\r\n\r\n    function get_entity() {\r\n\r\n        return entity;\r\n\r\n    } //get_entity\r\n\r\n//transforms\r\n\r\n    function set_pos( _p:Vector ) {\r\n        return entity.transform.pos = _p;\r\n    } //set_pos\r\n\r\n    function get_pos() {\r\n        return entity.transform.pos;\r\n    } //get_pos\r\n\r\n    function set_rotation( _r:Quaternion ) {\r\n        return entity.transform.rotation = _r;\r\n    } //set_rotation\r\n\r\n    function get_rotation() {\r\n        return entity.transform.rotation;\r\n    } //get_rotation\r\n\r\n    function set_scale(_s:Vector) {\r\n        return entity.transform.scale = _s;\r\n    } //set_scale\r\n\r\n    function get_scale() {\r\n        return entity.transform.scale;\r\n    } //get_scale\r\n\r\n    function set_origin(_o:Vector) {\r\n        return entity.transform.origin = _o;\r\n    } //set_origin\r\n\r\n    function get_origin() {\r\n        return entity.transform.origin;\r\n    } //get_origin\r\n\r\n    function set_transform(_o:Transform) {\r\n        return entity.transform = _o;\r\n    } //set_transform\r\n\r\n    function get_transform() {\r\n        return entity.transform;\r\n    } //get_transform\r\n\r\n    @:noCompletion public function entity_pos_change( _pos:Vector ) {}\r\n    @:noCompletion public function entity_scale_change( _scale:Vector ) {}\r\n    @:noCompletion public function entity_rotation_change( _rotation:Quaternion ) {}\r\n    @:noCompletion public function entity_origin_change( _origin:Vector ) {}\r\n    @:noCompletion public function entity_parent_change( _parent:Transform ) {}\r\n\r\n//internal api\r\n\r\n} //Component\r\n","package snow;\r\n\r\nimport snow.input.Input;\r\nimport snow.types.Types;\r\n\r\n    //Note all times in snow are in seconds.\r\n\r\n/** The default type of snow application, with variable delta, update limit, render limit, timescale and more. \r\n    See the {App Guide} for complete details. */\r\nclass App {\r\n\r\n//Access to the snow API\r\n\r\n        /** use this to access the api features. *i.e* `app.assets.text(_id)` */\r\n    public var app : Snow;\r\n\r\n//Configurable values\r\n\r\n        /** the scale of time */\r\n    public var timescale : Float = 1;\r\n        /** if this is non zero this will be passed in */\r\n    public var fixed_delta : Float = 0;\r\n        /** if this is non zero, rendering will be forced to this rate */\r\n    public var render_rate : Float = 1/60;\r\n        /** if this is non zero, updates will be forced to this rate */\r\n    public var update_rate : Float = 0;\r\n        /** the maximum frame time */\r\n    public var max_frame_time : Float = 0.25;\r\n\r\n//Timing information\r\n\r\n        /** the time the last frame took to run */\r\n    public var delta_time : Float = 1/60;\r\n        /** the simulated time the last frame took to run, relative to scale etc */\r\n    public var delta_sim : Float = 1/60;\r\n        /** the start time of the last frame */\r\n    public var last_frame_start : Float = 0.0;\r\n        /** the current simulation time */\r\n    public var current_time : Float = 0;\r\n        /** the start time of this frame */\r\n    public var cur_frame_start : Float = 0.0;\r\n        /** the alpha time for a render between frame updates */\r\n    public var alpha : Float = 1.0;\r\n\r\n//Internal values\r\n\r\n        /** for update_rate, the time when the next tick should occur around */\r\n    var next_tick : Float = 0;\r\n        /** for update_rate, the time when the next tick should occur around */\r\n    var next_render : Float = 0;\r\n\r\n//override these in your game class\r\n\r\n        /** The default constructor of an App is empty, so you can override it if you want, but take note that this happens way before snow is ready for use. Use [ready](#ready) for entry point. */\r\n    public function new() {}\r\n        /** Called by snow to request config changes, override this to change the defaults.\r\n            This happens before ready, so the values are available when ready is called. */\r\n    public function config( config:AppConfig ) : AppConfig  { return config; }\r\n        /** Your entry point. Called for you when you can initialize your application */\r\n    public function ready() {}\r\n        /** Your update loop. Called every frame for you. The dt value depends on the timing configuration (see the {App Guide}) */\r\n    public function update(dt:Float) {}\r\n        /** Your exit point. Called for you when you should shut down your application */\r\n    public function ondestroy() {}\r\n        /** Low level event handler from snow core. Often handled by the subsystems so check there first. */\r\n    public function onevent( event:SystemEvent ) {}\r\n\r\n        /** Called for you when a key is pressed down */\r\n    public function onkeydown( keycode:Int, scancode:Int, repeat:Bool, mod:ModState, timestamp:Float, window_id:Int ) {}\r\n        /** Called for you when a key is released */\r\n    public function onkeyup( keycode:Int, scancode:Int, repeat:Bool, mod:ModState, timestamp:Float, window_id:Int ) {}\r\n        /** Called for you when text input is happening. Use this for textfields, as it handles the complexity of unicode etc. */\r\n    public function ontextinput( text:String, start:Int, length:Int, type:TextEventType, timestamp:Float, window_id:Int ) {}\r\n\r\n        /** Called for you when a mouse button is pressed */\r\n    public function onmousedown( x:Int, y:Int, button:Int, timestamp:Float, window_id:Int ) {}\r\n        /** Called for you when a mouse button is released */\r\n    public function onmouseup( x:Int, y:Int, button:Int, timestamp:Float, window_id:Int ) {}\r\n        /** Called for you when the mouse wheel moves */\r\n    public function onmousewheel( x:Int, y:Int, timestamp:Float, window_id:Int ) {}\r\n        /** Called for you when the mouse moves */\r\n    public function onmousemove( x:Int, y:Int, xrel:Int, yrel:Int, timestamp:Float, window_id:Int ) {}\r\n\r\n        /** Called for you when a touch is released, use the `touch_id` to track which */\r\n    public function ontouchdown( x:Float, y:Float, touch_id:Int, timestamp:Float ) {}\r\n        /** Called for you when a touch is first pressed, use the `touch_id` to track which */\r\n    public function ontouchup( x:Float, y:Float, touch_id:Int, timestamp:Float ) {}\r\n        /** Called for you when a touch is moved, use the `touch_id` to track which */\r\n    public function ontouchmove( x:Float, y:Float, dx:Float, dy:Float, touch_id:Int, timestamp:Float ) {}\r\n\r\n        /** Called for you when a connected gamepad axis moves, use `which` to determine gamepad id */\r\n    public function ongamepadaxis( gamepad:Int, axis:Int, value:Float, timestamp:Float ) {}\r\n        /** Called for you when a connected gamepad button is pressed, use `which` to determine gamepad id */\r\n    public function ongamepaddown( gamepad:Int, button:Int, value:Float, timestamp:Float ) {}\r\n        /** Called for you when a connected gamepad button is released, use `which` to determine gamepad id */\r\n    public function ongamepadup( gamepad:Int, button:Int, value:Float, timestamp:Float ) {}\r\n        /** Called for you when a gamepad is connected or disconnected, use `which` to determine gamepad id */\r\n    public function ongamepaddevice( gamepad:Int, type:GamepadDeviceEventType, timestamp:Float ) {}\r\n\r\n\r\n\r\n//No need to interact with these, unless you want pre-ready init, just call super.on_internal_init() etc\r\n//to maintain expected App behavior. You can override behavior in the base class, like AppFixedTimestep\r\n\r\n        //internal facing api\r\n    @:allow(snow.Snow)\r\n    function on_internal_init() {\r\n\r\n        cur_frame_start = app.time;\r\n        last_frame_start = cur_frame_start;\r\n        current_time = 0;\r\n        delta_time = 0.016;\r\n\r\n    } //on_internal_init\r\n\r\n    @:allow(snow.Snow)\r\n    function on_internal_update() {\r\n\r\n        if(update_rate != 0) {\r\n            if(next_tick < app.time) {\r\n                    //we have reached the next frame, update the tick\r\n                next_tick = app.time + update_rate;\r\n            } else {\r\n                    //we haven't reached the next frame yet?\r\n                return;\r\n            }\r\n        } //update_rate\r\n\r\n            //the start of this frame is now\r\n        cur_frame_start = app.time;\r\n            //delta is time since the last frame start\r\n        delta_time = (cur_frame_start - last_frame_start);\r\n            //last frame start is updated to now\r\n        last_frame_start = cur_frame_start;\r\n\r\n            //clamp delta to max frame time, preventing large deltas\r\n        if(delta_time > max_frame_time) {\r\n            delta_time = max_frame_time;\r\n        }\r\n\r\n            //which delta we are going to use, fixed or variable\r\n        var used_delta = (fixed_delta == 0) ? delta_time : fixed_delta;\r\n            //timescale the delta to the given scale\r\n        used_delta *= timescale;\r\n            //update the simulated delta value\r\n        delta_sim = used_delta;\r\n\r\n            //update the internal \"time\" counter\r\n        current_time += used_delta;\r\n            //do the internal systems update\r\n        app.do_internal_update( used_delta );\r\n\r\n    } //on_internal_update\r\n\r\n    @:allow(snow.Snow)\r\n    function on_internal_render() {\r\n\r\n            //and finally call render, if it's time\r\n        if(render_rate != 0) {\r\n            if(next_render < app.time) {\r\n                app.render();\r\n                next_render += render_rate;\r\n            }\r\n        }\r\n\r\n    } //on_internal_render\r\n\r\n\r\n} //App\r\n\r\n\r\n\r\n/** Read the {App Guide} for full info, and for even more information see : http://gafferongames.com/game-physics/fix-your-timestep/\r\n    this stores and calculates a fixed game update loop, and rendering interpolation is required\r\n    for smooth updates between frames. */\r\nclass AppFixedTimestep extends App {\r\n\r\n        /** fixed simulation update speed */\r\n    public var frame_time : Float = 0.0167;\r\n        /** the overflow of the updates. This is used internally, for you, to calculate the alpha time for rendering interpolation as follows `alpha = overflow / frame_time;` */\r\n    public var overflow : Float = 0.0;\r\n\r\n    @:allow(snow.Snow)\r\n    override function on_internal_init() {\r\n\r\n        super.on_internal_init();\r\n\r\n        frame_time = 1.0/60.0;\r\n        last_frame_start = app.time;\r\n\r\n    } //on_internal_init\r\n\r\n        //no super.on_internal_update because this entirely controls\r\n        //the update loop for the application itself\r\n    @:allow(snow.Snow)\r\n    override function on_internal_update() {\r\n\r\n        cur_frame_start = app.time;\r\n        delta_time = (cur_frame_start - last_frame_start);\r\n        delta_sim = delta_time * timescale;\r\n\r\n        if(delta_sim > max_frame_time) {\r\n            delta_sim = max_frame_time;\r\n        }\r\n\r\n        last_frame_start = cur_frame_start;\r\n\r\n        overflow += delta_sim;\r\n\r\n        while(overflow >= frame_time) {\r\n\r\n            app.do_internal_update(frame_time * timescale);\r\n\r\n            current_time += frame_time * timescale;\r\n\r\n            overflow -= frame_time * timescale;\r\n\r\n        } //overflow >= frame_time\r\n\r\n            //work this out before a render\r\n        alpha = overflow / frame_time;\r\n\r\n    } //on_internal_update\r\n\r\n} //AppFixedTimestep\r\n","package luxe;\r\n\r\nimport snow.Snow;\r\nimport snow.types.Types;\r\nimport snow.window.Window;\r\n\r\nimport Luxe;\r\nimport luxe.IO;\r\nimport luxe.Audio;\r\nimport luxe.Events;\r\nimport luxe.Emitter;\r\nimport luxe.Input;\r\nimport luxe.Scene;\r\nimport luxe.Debug;\r\nimport luxe.Timer;\r\nimport luxe.Physics;\r\nimport luxe.AppConfig;\r\nimport luxe.resource.Resources;\r\n\r\nimport luxe.debug.ProfilerDebugView;\r\n\r\nimport phoenix.Renderer;\r\nimport phoenix.Texture;\r\nimport phoenix.Shader;\r\n\r\nimport luxe.Game;\r\nimport luxe.Log._verbose;\r\nimport luxe.Log._debug;\r\nimport luxe.Log.log;\r\n\r\n\r\n@:keep\r\n@:noCompletion\r\n@:log_as('luxe')\r\n\r\nclass Core\r\nextends\r\n    #if luxe_appfixedtimestep\r\n        snow.App.AppFixedTimestep\r\n    #else\r\n        snow.App\r\n    #end\r\n{\r\n\r\n        //the game object running the core\r\n    public var game : Game;\r\n    public var appconfig : AppConfig;\r\n\r\n        //if the console is displayed atm\r\n    public var console_visible : Bool = false;\r\n        /** Set to true if the app is running without a window */\r\n    public var headless : Bool = false;\r\n\r\n\r\n//Sub Systems, mostly in order of importance\r\n    public var emitter   : Emitter<Ev>;\r\n    public var debug     : Debug;\r\n    public var io        : IO;\r\n    public var draw      : Draw;\r\n    public var timer     : Timer;\r\n    public var events    : Events;\r\n    public var input     : Input;\r\n    public var audio     : Audio;\r\n    public var scene     : Scene;\r\n    public var resources : Resources;\r\n    public var renderer  : Renderer;\r\n    public var screen    : luxe.Screen;\r\n    public var physics   : Physics;\r\n\r\n//flags\r\n\r\n       //if we have started a shutdown\r\n    public var shutting_down : Bool = false;\r\n    public var has_shutdown : Bool = false;\r\n    public var inited : Bool = false;\r\n\r\n    @:noCompletion public function new( _game:Game, _config:AppConfig ) {\r\n\r\n        super();\r\n\r\n        appconfig = _config;\r\n        game = _game;\r\n\r\n            //Store the core for reference in the game\r\n        game.app = this;\r\n\r\n            //Create internal stuff\r\n        emitter = new Emitter<Ev>();\r\n\r\n            //Set external references\r\n        Luxe.core = this;\r\n        Luxe.utils = new luxe.utils.Utils(this);\r\n\r\n    } //new\r\n\r\n\r\n        //This gets called once snow has booted us - this is\r\n    override function ready() {\r\n\r\n        Luxe.version = haxe.Resource.getString('version');\r\n            //Don't change this, it matches semantic versioning http://semver.org/\r\n        Luxe.build = Luxe.version + haxe.Resource.getString('build');\r\n\r\n        log('version ${Luxe.build}');\r\n\r\n            //Create the subsystems\r\n        init();\r\n\r\n            //\r\n        _debug('ready.');\r\n\r\n            //Call the main ready function\r\n            //and send the ready event to the game\r\n        game.ready();\r\n\r\n            //shutdown can come from the ready function\r\n        if(!shutting_down) {\r\n\r\n                //emit the init event\r\n                //so that scene and others can start up\r\n            emitter.emit(Ev.init);\r\n            inited = true;\r\n\r\n                //Reset the physics (starts the timer etc)\r\n            physics.reset();\r\n\r\n                //Now, if no main loop is requested we should immediately shutdown\r\n            if(!app.snow_config.has_loop) {\r\n                shutdown();\r\n            }\r\n\r\n        } //!shutting down\r\n\r\n    } //ready\r\n\r\n    override function ondestroy() {\r\n\r\n            //Make sure all systems know we are going down\r\n        shutting_down = true;\r\n\r\n        log('shutting down...');\r\n\r\n            //shutdown the game class\r\n        game.ondestroy();\r\n\r\n            //shutdown the default scene\r\n        emitter.emit(Ev.destroy);\r\n\r\n            //Order is imporant here too\r\n        if(renderer != null) {\r\n            renderer.destroy();\r\n        }\r\n\r\n        physics.destroy();\r\n        input.destroy();\r\n        audio.destroy();\r\n        timer.destroy();\r\n        events.destroy();\r\n        debug.destroy();\r\n\r\n            //Clear up for GC\r\n        emitter = null;\r\n        input = null;\r\n        audio = null;\r\n        events = null;\r\n        timer = null;\r\n        debug = null;\r\n        Luxe.utils = null;\r\n\r\n            //Flag it\r\n        has_shutdown = true;\r\n\r\n        log('goodbye.');\r\n\r\n    }\r\n\r\n    public function init() {\r\n\r\n            //Create the subsystems\r\n        _debug('creating subsystems...');\r\n\r\n            //Order is important here\r\n\r\n        Luxe.debug = debug = new Debug( this );\r\n        Luxe.io = io = new IO( this );\r\n\r\n        draw = new Draw( this );\r\n        timer = new Timer( this );\r\n        events = new Events();\r\n        audio = new Audio( this );\r\n        input = new Input( this );\r\n        physics = new Physics( this );\r\n\r\n            //should be up earlier\r\n        resources = new Resources();\r\n        Luxe.resources = resources;\r\n\r\n            //flag for later\r\n        headless = (app.window == null);\r\n\r\n        if(!headless) {\r\n                //listen for window events\r\n            app.window.onevent = window_event;\r\n                //create the renderer\r\n            renderer = new Renderer( this );\r\n                //assign the globals\r\n            Luxe.renderer = renderer;\r\n        }\r\n\r\n            //if there is a window,\r\n            //store the size\r\n        var _window_w = 0;\r\n        var _window_h = 0;\r\n\r\n        if(app.window != null) {\r\n            _window_w = app.window.width;\r\n            _window_h = app.window.height;\r\n        }\r\n\r\n            //store the size for access from API\r\n        screen = new luxe.Screen( this, _window_w, _window_h );\r\n\r\n            //Now make sure\r\n            //they start up\r\n\r\n        debug.init();\r\n        io.init();\r\n        timer.init();\r\n        audio.init();\r\n        input.init();\r\n\r\n        if(!headless) {\r\n            renderer.init();\r\n        }\r\n\r\n        physics.init();\r\n\r\n        Luxe.audio = audio;\r\n        Luxe.draw = draw;\r\n        Luxe.events = events;\r\n        Luxe.timer = timer;\r\n        Luxe.input = input;\r\n\r\n        if(!headless) {\r\n            Luxe.camera = new luxe.Camera({ name:'default camera', view:renderer.camera });\r\n        }\r\n\r\n        Luxe.physics = physics;\r\n\r\n        scene = new Scene('default scene');\r\n        Luxe.scene = scene;\r\n\r\n        if(!headless) {\r\n            scene.add(Luxe.camera);\r\n            debug.create_debug_console();\r\n        }\r\n\r\n            //and even more finally, tell snow we want to\r\n            //know when it's rendering the window so we can draw\r\n        if(app.window != null && !headless) {\r\n\r\n            app.window.onrender = render;\r\n\r\n                //start here because end is called first below\r\n            debug.start(Tag.update, 50);\r\n            debug.start(Tag.renderdt, 50);\r\n\r\n        } //app.window != null && !headless\r\n\r\n    } //init\r\n\r\n    public function shutdown() {\r\n\r\n            //Make sure all systems know we are going down\r\n        shutting_down = true;\r\n\r\n            //shutdown snow, which calls ondestroy for us\r\n        snow.Snow.next(app.shutdown);\r\n\r\n    } //shutdown\r\n\r\n    public function on<T>(event:Ev, handler:T->Void ) {\r\n        emitter.on(event, handler);\r\n    }\r\n\r\n    public function off<T>(event:Ev, handler:T->Void ) {\r\n        return emitter.off(event, handler);\r\n    }\r\n\r\n    public function emit<T>(event:Ev, ?data:T) {\r\n        return emitter.emit(event, data);\r\n    }\r\n\r\n        //called by snow\r\n    override function onevent( event:snow.types.Types.SystemEvent ) {\r\n\r\n            //forward to game class\r\n        game.onevent( event );\r\n\r\n    } //onevent\r\n\r\n        //called by snow\r\n    override function update( dt:Float ) {\r\n\r\n        #if luxe_fullprofile\r\n            _verbose('on_update ' + Luxe.time);\r\n        #end //luxe_fullprofile\r\n\r\n        if(has_shutdown) return;\r\n\r\n        debug.end(Tag.update);\r\n        debug.start(Tag.update);\r\n\r\n            //Update all the subsystems, again, order important\r\n//Timers first\r\n            #if luxe_fullprofile debug.start(Tag.timer); #end\r\n        timer.process();\r\n            #if luxe_fullprofile debug.end(Tag.timer); #end\r\n//Input second\r\n            #if luxe_fullprofile debug.start(Tag.input); #end\r\n        input.process();\r\n            #if luxe_fullprofile debug.end(Tag.input); #end\r\n//Audio\r\n            #if luxe_fullprofile debug.start(Tag.audio); #end\r\n        audio.process();\r\n            #if luxe_fullprofile debug.end(Tag.audio); #end\r\n//Events\r\n            #if luxe_fullprofile debug.start(Tag.events); #end\r\n        events.process();\r\n            #if luxe_fullprofile debug.end(Tag.events); #end\r\n//Physics\r\n            //note that this does not update the physics, simply processes the active engines\r\n        physics.process();\r\n\r\n//Run update callbacks\r\n            debug.start(Tag.updates);\r\n        emitter.emit(Ev.update, dt);\r\n            debug.end(Tag.updates);\r\n\r\n//Update the game class for the game\r\n            debug.start( Tag.game_update );\r\n        game.update(dt);\r\n            debug.end( Tag.game_update );\r\n\r\n//And finally the debug stuff\r\n            #if luxe_fullprofile debug.start(Tag.debug); #end\r\n        debug.process();\r\n            #if luxe_fullprofile debug.end(Tag.debug); #end\r\n\r\n    } //update\r\n\r\n    function window_event( _event:snow.types.Types.WindowEvent ) {\r\n\r\n        if(shutting_down) {\r\n            return;\r\n        }\r\n\r\n        emitter.emit(Ev.window, _event );\r\n\r\n        switch(_event.type) {\r\n\r\n            case WindowEventType.moved : {\r\n                emitter.emit(Ev.windowmoved, _event );\r\n                game.onwindowmoved( _event );\r\n            } //moved\r\n\r\n            case WindowEventType.resized : {\r\n                screen.internal_resized(_event.event.x, _event.event.y);\r\n                renderer.internal_resized(_event.event.x, _event.event.y);\r\n                emitter.emit(Ev.windowresized, _event );\r\n                game.onwindowresized( _event );\r\n            } //resized\r\n\r\n            case WindowEventType.size_changed : {\r\n                screen.internal_resized(_event.event.x, _event.event.y);\r\n                renderer.internal_resized(_event.event.x, _event.event.y);\r\n                emitter.emit(Ev.windowsized, _event );\r\n                game.onwindowsized( _event );\r\n            } //size_changed\r\n\r\n            case WindowEventType.minimized : {\r\n                emitter.emit(Ev.windowminimized, _event );\r\n                game.onwindowminimized( _event );\r\n            } //minimized\r\n\r\n            case WindowEventType.restored : {\r\n                emitter.emit(Ev.windowrestored, _event );\r\n                game.onwindowrestored( _event );\r\n            } //restored\r\n\r\n            default: {}\r\n\r\n        } //switch\r\n\r\n    } //window_event\r\n\r\n    function render( window:Window ) {\r\n\r\n        if(shutting_down) {\r\n            return;\r\n        }\r\n\r\n        debug.end(Tag.renderdt);\r\n        debug.start(Tag.renderdt);\r\n\r\n        if(!headless) {\r\n\r\n            debug.start(Tag.render);\r\n\r\n            emitter.emit(Ev.prerender);\r\n            game.onprerender();\r\n\r\n                emitter.emit(Ev.render);\r\n                game.onrender();\r\n                renderer.process();\r\n\r\n            emitter.emit(Ev.postrender);\r\n            game.onpostrender();\r\n\r\n            debug.end(Tag.render);\r\n\r\n        } //!headless\r\n\r\n    } //render\r\n\r\n    public function show_console(_show:Bool = true) {\r\n\r\n        console_visible = _show;\r\n        debug.show_console(console_visible);\r\n\r\n    } //show_console\r\n\r\n//input events\r\n//keys\r\n    override function onkeydown( keycode:Int, scancode:Int, repeat:Bool, mod:ModState, timestamp:Float, window_id:Int ) {\r\n\r\n        var event : KeyEvent = {\r\n            scancode : scancode,\r\n            keycode : keycode,\r\n            state : InteractState.down,\r\n            mod : mod,\r\n            repeat : repeat,\r\n            timestamp : timestamp,\r\n            window_id : window_id\r\n        }\r\n\r\n        if(!shutting_down) {\r\n\r\n                //check for named input\r\n            input.check_named_keys(event, true);\r\n            emitter.emit(Ev.keydown, event);\r\n\r\n            game.onkeydown(event);\r\n\r\n            if(scancode == Scan.grave) {\r\n                show_console( !console_visible );\r\n            }\r\n\r\n        } //!shutting down\r\n\r\n    } //onkeydown\r\n\r\n    override function onkeyup( keycode:Int, scancode:Int, repeat:Bool, mod:ModState, timestamp:Float, window_id:Int ) {\r\n\r\n        var event : KeyEvent = {\r\n            scancode : scancode,\r\n            keycode : keycode,\r\n            state : InteractState.up,\r\n            mod : mod,\r\n            repeat : repeat,\r\n            timestamp : timestamp,\r\n            window_id : window_id\r\n        }\r\n\r\n        if(!shutting_down) {\r\n\r\n                //check for named input\r\n            input.check_named_keys(event);\r\n            emitter.emit(Ev.keyup, event);\r\n\r\n            game.onkeyup(event);\r\n\r\n        } //!shutting down\r\n\r\n    } //onkeyup\r\n\r\n    override function ontextinput( text:String, start:Int, length:Int, type:snow.types.TextEventType, timestamp:Float, window_id:Int ) {\r\n\r\n        var _type : TextEventType = TextEventType.unknown;\r\n\r\n        switch(type) {\r\n            case edit: _type = TextEventType.edit;\r\n            case input: _type = TextEventType.input;\r\n            default: {\r\n                return;\r\n            }\r\n        }\r\n\r\n        var event : TextEvent = {\r\n            text : text,\r\n            start : start,\r\n            length : length,\r\n            type : _type,\r\n            timestamp : timestamp,\r\n            window_id : window_id\r\n        }\r\n\r\n        if(!shutting_down) {\r\n\r\n            emitter.emit(Ev.textinput, event);\r\n\r\n            game.ontextinput(event);\r\n\r\n        } //!shutting_down\r\n\r\n    } //ontextinput\r\n\r\n//input\r\n\r\n    public function oninputdown( name:String, event:InputEvent ) {\r\n\r\n        if(!shutting_down) {\r\n\r\n            emitter.emit(Ev.inputdown, { name:name, event:event });\r\n\r\n            game.oninputdown( name, event );\r\n\r\n        } //!shutting_down\r\n\r\n    } //oninputdown\r\n\r\n    public function oninputup( name:String, event:InputEvent ) {\r\n\r\n        if(!shutting_down) {\r\n\r\n            emitter.emit(Ev.inputup, { name:name, event:event });\r\n\r\n            game.oninputup( name, event );\r\n\r\n        } //!shutting_down\r\n\r\n    } //oninputup\r\n\r\n//mouse\r\n\r\n    override function onmousedown( x:Int, y:Int, button:Int, timestamp:Float, window_id:Int ) {\r\n\r\n            //this has to be a new value because if it's cached it sends in references that get kept by user code\r\n        screen.cursor.set_internal(new luxe.Vector( x, y ));\r\n\r\n        var event : MouseEvent = {\r\n            timestamp : timestamp,\r\n            window_id : window_id,\r\n            state : InteractState.down,\r\n            button : button,\r\n            x : x,\r\n            y : y,\r\n            xrel : x,\r\n            yrel : y,\r\n            pos : screen.cursor.pos,\r\n        }\r\n\r\n        if(!shutting_down) {\r\n\r\n            input.check_named_mouse(event, true);\r\n            emitter.emit(Ev.mousedown, event);\r\n            game.onmousedown(event);\r\n\r\n        } //!shutting_down\r\n\r\n    } //onmousedown\r\n\r\n    override function onmouseup( x:Int, y:Int, button:Int, timestamp:Float, window_id:Int ) {\r\n\r\n            //see notes on new in mousedown\r\n        screen.cursor.set_internal(new luxe.Vector( x, y ));\r\n\r\n        var event : MouseEvent = {\r\n            timestamp : timestamp,\r\n            window_id : window_id,\r\n            state : InteractState.up,\r\n            button : button,\r\n            x : x,\r\n            y : y,\r\n            xrel : x,\r\n            yrel : y,\r\n            pos : screen.cursor.pos\r\n        }\r\n\r\n        if(!shutting_down) {\r\n\r\n            input.check_named_mouse(event);\r\n            emitter.emit(Ev.mouseup, event);\r\n            game.onmouseup(event);\r\n\r\n        } //!shutting_down\r\n\r\n    } //onmouseup\r\n\r\n    override function onmousemove( x:Int, y:Int, xrel:Int, yrel:Int, timestamp:Float, window_id:Int ) {\r\n\r\n            //see notes on new in mousedown\r\n        screen.cursor.set_internal(new luxe.Vector( x, y ));\r\n\r\n        var event : MouseEvent = {\r\n            timestamp : timestamp,\r\n            window_id : window_id,\r\n            state : InteractState.move,\r\n            button : MouseButton.none,\r\n            x : x,\r\n            y : y,\r\n            xrel : xrel,\r\n            yrel : yrel,\r\n            pos : screen.cursor.pos\r\n        }\r\n\r\n        if(!shutting_down) {\r\n\r\n            emitter.emit(Ev.mousemove, event);\r\n            game.onmousemove(event);\r\n\r\n        } //!shutting_down\r\n\r\n    } //onmousemove\r\n\r\n    override function onmousewheel( x:Int, y:Int, timestamp:Float, window_id:Int ) {\r\n\r\n        var event : MouseEvent = {\r\n            timestamp : timestamp,\r\n            window_id : window_id,\r\n            state : InteractState.wheel,\r\n            button : MouseButton.none,\r\n            x : x,\r\n            y : y,\r\n            xrel : x,\r\n            yrel : y,\r\n            pos : screen.cursor.pos\r\n        }\r\n\r\n        if(!shutting_down) {\r\n\r\n            input.check_named_mouse(event, false);\r\n            emitter.emit(Ev.mousewheel, event);\r\n            game.onmousewheel(event);\r\n\r\n        } //!shutting_down\r\n\r\n    } //onmousewheel\r\n\r\n//touch\r\n        //cached touch pos\r\n    var _touch_pos : Vector;\r\n\r\n    override function ontouchdown( x:Float, y:Float, touch_id:Int, timestamp:Float ) {\r\n\r\n         _touch_pos = new luxe.Vector( x, y );\r\n\r\n        var event : TouchEvent = {\r\n            state : InteractState.down,\r\n            timestamp : timestamp,\r\n            touch_id : touch_id,\r\n            x : x,\r\n            y : y,\r\n            dx : x,\r\n            dy : y,\r\n            pos : _touch_pos\r\n        }\r\n\r\n        if(!shutting_down) {\r\n\r\n            emitter.emit(Ev.touchdown, event);\r\n\r\n            game.ontouchdown(event);\r\n\r\n            #if !no_debug_console\r\n\r\n                    //3 finger tap when console opens will switch tabs\r\n                if(app.input.touch_count == 3) {\r\n                    if(console_visible) {\r\n                        debug.switch_view();\r\n                    }\r\n                }\r\n\r\n                    //4 finger tap toggles console\r\n                if(app.input.touch_count == 4) {\r\n                    show_console( !console_visible );\r\n                }\r\n\r\n            #end //no_debug_console\r\n\r\n        } //!shutting_down\r\n\r\n    } //ontouchdown\r\n\r\n    override function ontouchup( x:Float, y:Float, touch_id:Int, timestamp:Float ) {\r\n\r\n         _touch_pos = new luxe.Vector( x, y );\r\n\r\n        var event : TouchEvent = {\r\n            state : InteractState.up,\r\n            timestamp : timestamp,\r\n            touch_id : touch_id,\r\n            x : x,\r\n            y : y,\r\n            dx : x,\r\n            dy : y,\r\n            pos : _touch_pos\r\n        }\r\n\r\n        if(!shutting_down) {\r\n\r\n            emitter.emit(Ev.touchup, event);\r\n            game.ontouchup(event);\r\n\r\n        } //!shutting_down\r\n\r\n    } //ontouchup\r\n\r\n    override function ontouchmove( x:Float, y:Float, dx:Float, dy:Float, touch_id:Int, timestamp:Float ) {\r\n\r\n        _touch_pos = new luxe.Vector( x, y );\r\n\r\n        var event : TouchEvent = {\r\n            state : InteractState.move,\r\n            timestamp : timestamp,\r\n            touch_id : touch_id,\r\n            x : x,\r\n            y : y,\r\n            dx : dx,\r\n            dy : dy,\r\n            pos : _touch_pos\r\n        }\r\n\r\n        if(!shutting_down) {\r\n\r\n            emitter.emit(Ev.touchmove, event);\r\n            game.ontouchmove(event);\r\n\r\n        } //!shutting_down\r\n\r\n    } //ontouchmove\r\n\r\n//gamepad\r\n\r\n    override function ongamepadaxis( gamepad:Int, axis:Int, value:Float, timestamp:Float ) {\r\n\r\n        var event : GamepadEvent = {\r\n            timestamp : timestamp,\r\n            type : GamepadEventType.axis,\r\n            state : InteractState.axis,\r\n            gamepad : gamepad,\r\n            button : -1,\r\n            axis : axis,\r\n            value : value\r\n        }\r\n\r\n        if(!shutting_down) {\r\n\r\n            emitter.emit(Ev.gamepadaxis,event);\r\n            game.ongamepadaxis(event);\r\n\r\n        } //!shutting_down\r\n\r\n    } //ongamepadaxis\r\n\r\n    override function ongamepaddown( gamepad:Int, button:Int, value:Float, timestamp:Float ) {\r\n\r\n        var event : GamepadEvent = {\r\n            timestamp : timestamp,\r\n            type : GamepadEventType.button,\r\n            state : InteractState.down,\r\n            gamepad : gamepad,\r\n            button : button,\r\n            axis : -1,\r\n            value : value\r\n        }\r\n\r\n        if(!shutting_down) {\r\n\r\n            input.check_named_gamepad_buttons(event, true);\r\n            emitter.emit(Ev.gamepaddown,event);\r\n            game.ongamepaddown(event);\r\n\r\n        } //!shutting_down\r\n\r\n    } //ongamepadbuttondown\r\n\r\n    override function ongamepadup( gamepad:Int, button:Int, value:Float, timestamp:Float ) {\r\n\r\n        var event : GamepadEvent = {\r\n            timestamp : timestamp,\r\n            type : GamepadEventType.button,\r\n            state : InteractState.up,\r\n            gamepad : gamepad,\r\n            button : button,\r\n            axis : -1,\r\n            value : value\r\n        }\r\n\r\n        if(!shutting_down) {\r\n\r\n            input.check_named_gamepad_buttons(event, false);\r\n            emitter.emit(Ev.gamepadup, event);\r\n            game.ongamepadup(event);\r\n\r\n        } //!shutting_down\r\n\r\n    } //ongamepadup\r\n\r\n    override function ongamepaddevice( gamepad:Int, type:GamepadDeviceEventType, timestamp:Float ) {\r\n\r\n        var _event_type : GamepadEventType = GamepadEventType.unknown;\r\n\r\n        switch(type) {\r\n            case GamepadDeviceEventType.device_added:\r\n                _event_type = GamepadEventType.device_added;\r\n            case GamepadDeviceEventType.device_removed:\r\n                _event_type = GamepadEventType.device_removed;\r\n            case GamepadDeviceEventType.device_remapped:\r\n                _event_type = GamepadEventType.device_remapped;\r\n            default:\r\n        }\r\n\r\n        var event : GamepadEvent = {\r\n            timestamp : timestamp,\r\n            type : _event_type,\r\n            state : InteractState.none,\r\n            gamepad : gamepad,\r\n            button : -1,\r\n            axis : -1,\r\n            value : 0\r\n        }\r\n\r\n        if(!shutting_down) {\r\n\r\n            game.ongamepaddevice(event);\r\n\r\n        } //!shutting_down\r\n\r\n    } //ongamepaddevice\r\n\r\n        /** return what the game decides for runtime config */\r\n    override function config( config:AppConfig ) : AppConfig {\r\n\r\n            config.window.width = appconfig.window.width;\r\n            config.window.height = appconfig.window.height;\r\n            config.window.fullscreen = appconfig.window.fullscreen;\r\n            config.window.borderless = appconfig.window.borderless;\r\n            config.window.resizable = appconfig.window.resizable;\r\n            config.window.title = appconfig.window.title;\r\n\r\n       return game.config( config );\r\n\r\n    } //config\r\n\r\n} //Core\r\n\r\n\r\n/**\r\nA tag class for the string based values in the core.\r\nNote that these values are not inline intentionally, they avoid\r\nallocating strings each frame.\r\n*/\r\n@:noCompletion\r\n@:allow(luxe.Core)\r\nclass Tag {\r\n    static var update       = 'real dt';\r\n    static var renderdt     = 'render dt';\r\n    static var game_update  = 'game.update';\r\n    static var render       = 'core.render';\r\n    static var debug        = 'core.debug';\r\n    static var updates      = 'core.updates';\r\n    static var events       = 'core.events';\r\n    static var audio        = 'core.audio';\r\n    static var input        = 'core.input';\r\n    static var timer        = 'core.timer';\r\n    static var scene        = 'core.scene';\r\n}\r\n","package luxe;\r\n\r\nimport luxe.Core;\r\nimport Luxe.Ev;\r\n\r\nimport luxe.debug.Inspector;\r\nimport luxe.Input.KeyEvent;\r\nimport luxe.Input;\r\nimport phoenix.Batcher;\r\nimport phoenix.BitmapFont;\r\nimport phoenix.Camera;\r\nimport phoenix.geometry.CompositeGeometry;\r\nimport phoenix.geometry.Geometry;\r\nimport phoenix.geometry.QuadGeometry;\r\nimport luxe.utils.Maths;\r\n\r\nimport luxe.debug.DebugView;\r\nimport luxe.debug.TraceDebugView;\r\nimport luxe.debug.ProfilerDebugView;\r\nimport luxe.debug.StatsDebugView;\r\nimport luxe.debug.BatcherDebugView;\r\n\r\nimport luxe.Log._debug;\r\n\r\nclass Debug {\r\n\r\n    public var core : Core;\r\n    public var visible : Bool = false;\r\n    public static var shut_down : Bool = false;\r\n\r\n    public var debug_inspector : Inspector;\r\n    public var overlay : QuadGeometry;\r\n\r\n    public var batcher : Batcher;\r\n    public var view : Camera;\r\n    public var debug_font : BitmapFont;\r\n\r\n        //track a 10 frame average\r\n    public var dt_average : Float = 0;\r\n    public var dt_average_accum : Float = 0;\r\n    public var dt_average_span : Int = 60;\r\n    public var dt_average_count : Int = 0;\r\n\r\n    public var current_view_index = 0;\r\n    public var last_view_index = 0;\r\n    public var current_view : DebugView;\r\n    public static var views : Array<DebugView>;\r\n\r\n    public var padding : Vector;\r\n\r\n    public var started = false;\r\n\r\n//Profile path\r\n    public var profile_path : String = \"profile.txt\";\r\n    public var profiling : Bool = false;\r\n\r\n    static var trace_callbacks : Map<String, Dynamic->?haxe.PosInfos->Void>;\r\n\r\n    @:noCompletion public function new( _core:Core ) {\r\n        core = _core;\r\n    } //new\r\n\r\n    @:noCompletion public function init() {\r\n\r\n        trace_callbacks = new Map();\r\n\r\n        #if !no_debug_console\r\n            views = [\r\n                new TraceDebugView(),\r\n                new StatsDebugView(),\r\n                // new BatcherDebugView(),\r\n                new ProfilerDebugView()\r\n            ];\r\n        #else\r\n            views = [];\r\n        #end\r\n\r\n        current_view = views[0];\r\n\r\n        haxe.Log.trace = internal_trace;\r\n\r\n        _debug('\\t debug initialized.');\r\n\r\n    } //init\r\n\r\n        /** start a profiling section for the profiler debug view */\r\n    public function start(_name:String, ?_max:Float=0.0) {\r\n        #if !no_debug_console\r\n        if(!core.headless) {\r\n            ProfilerDebugView.start(_name, _max);\r\n        }\r\n        #end\r\n    }\r\n\r\n        /** end a profiling section for the profiler debug view */\r\n    public function end(_name:String) {\r\n        #if !no_debug_console\r\n        if(!core.headless) {\r\n            ProfilerDebugView.end(_name);\r\n        }\r\n        #end\r\n    }\r\n        /** remove a trace listener added via add_trace_listener */\r\n    public function remove_trace_listener( _name:String ) {\r\n        trace_callbacks.remove(_name);\r\n    }\r\n\r\n        /** since luxe captures the haxe `trace` log, you can add listeners to catch trace values for yourself. */\r\n    public function add_trace_listener( _name:String, _callback: Dynamic->?haxe.PosInfos->Void ) {\r\n        trace_callbacks.set(_name, _callback);\r\n    }\r\n\r\n\r\n    //Taken from haxe std lib\r\n#if cpp\r\n    static function default_cpp_trace( v : Dynamic, ?infos : haxe.PosInfos ) {\r\n        if (infos!=null && infos.customParams!=null) {\r\n            var extra:String = \"\";\r\n            for( v in infos.customParams ) { extra += \",\" + v; }\r\n            untyped __trace(v + extra,infos);\r\n        } else {\r\n            untyped __trace(v,infos);\r\n        }\r\n    } //default_native_trace\r\n#end //cpp\r\n#if neko\r\n    static function default_neko_trace(v:Dynamic, ?infos:haxe.PosInfos) {\r\n        untyped {\r\n            $print(infos.fileName + \":\" + infos.lineNumber + \": \", v);\r\n            if( infos.customParams != null ) for( v in infos.customParams ) $print(\",\", v);\r\n            $print(\"\\n\");\r\n        }\r\n    }\r\n#end //neko\r\n\r\n    @:noCompletion public static function internal_trace( v : Dynamic, ?inf : haxe.PosInfos ) {\r\n\r\n        var _line = StringTools.rpad(Std.string(inf.lineNumber), ' ', 4);\r\n\r\n        #if neko default_neko_trace(v, inf);\r\n        #elseif cpp default_cpp_trace(v, inf);\r\n        #end\r\n\r\n        #if luxe_web untyped console.log('${inf.fileName}::$_line $v');\r\n        #end\r\n\r\n        if(shut_down) {\r\n            return;\r\n        }\r\n\r\n            //call listeners\r\n        for(_callback in trace_callbacks) {\r\n            _callback(v, inf);\r\n        }\r\n\r\n    } //internal_trace\r\n\r\n    @:noCompletion public function create_debug_console() {\r\n\r\n        #if !no_debug_console\r\n\r\n            core.on(Ev.keyup, keyup);\r\n            core.on(Ev.keydown, keydown);\r\n            core.on(Ev.mouseup, mouseup);\r\n            core.on(Ev.mousedown, mousedown);\r\n            core.on(Ev.mousemove, mousemove);\r\n            core.on(Ev.mousewheel, mousewheel);\r\n\r\n                //create the debug renderer and view\r\n            batcher = new Batcher( Luxe.renderer, 'debug_batcher' );\r\n                //create a camera\r\n            view = new Camera();\r\n                //set the camera of the batcher\r\n            batcher.view = view;\r\n                //Also, set the layer so it renders last\r\n            batcher.layer = 999;\r\n\r\n            Luxe.renderer.add_batch( batcher );\r\n\r\n            overlay = new QuadGeometry({\r\n                x:0, y:0,\r\n                w: Luxe.screen.w,  h: Luxe.screen.h,\r\n                color : new Color(0,0,0,0.8),\r\n                depth : 999,    //debug depth\r\n                group : 999,    //debug group\r\n                visible : false, //default invisible\r\n                batcher : batcher\r\n            });\r\n\r\n                //create the scene inspector\r\n            padding = new Vector(Luxe.screen.w*0.05,Luxe.screen.h*0.05);\r\n            debug_inspector = new Inspector({\r\n                title:'luxe debug',\r\n                pos : new Vector(padding.x, padding.y),\r\n                size : new Vector(Luxe.screen.w-(padding.x*2), Luxe.screen.h-(padding.y*2)),\r\n                batcher : batcher\r\n            });\r\n\r\n            debug_inspector.onrefresh = refresh;\r\n\r\n                //:todo:wip: alpha-2.0 implementation\r\n            core.on(Ev.windowsized, function( _event:luxe.Screen.WindowEvent ){\r\n\r\n                var _w = _event.event.x;\r\n                var _h = _event.event.y;\r\n                var _v = new Vector(_w, _h);\r\n\r\n                padding.set_xy(_w*0.05,_h*0.05);\r\n\r\n                overlay.resize(_v);\r\n                view.viewport = new Rectangle(0, 0, _w, _h);\r\n                debug_inspector.size = new Vector(_w-(padding.x*2), _h-(padding.y*2));\r\n                debug_inspector.pos = new Vector(padding.x, padding.y);\r\n\r\n                for(view in views) {\r\n                    view.onwindowsized(_event);\r\n                }\r\n            });\r\n\r\n                //no need to process this while we are here.\r\n            batcher.enabled = false;\r\n\r\n            for(view in views) {\r\n                view.create();\r\n            }\r\n\r\n        #end //no_debug_console\r\n\r\n    } //create_debug_console\r\n\r\n    function mouseup(e:MouseEvent) {\r\n        if(visible) {\r\n            for(view in views) {\r\n                view.onmouseup(e);\r\n            }\r\n        }\r\n    } //mouseup\r\n\r\n    function mousedown(e:MouseEvent) {\r\n        if(visible) {\r\n            for(view in views) {\r\n                view.onmousedown(e);\r\n            }\r\n        }\r\n    } //mousedown\r\n\r\n    function mousewheel(e:MouseEvent) {\r\n        if(visible) {\r\n            for(view in views) {\r\n                view.onmousewheel(e);\r\n            }\r\n        }\r\n    } //mousewheel\r\n\r\n    function mousemove(e:MouseEvent) {\r\n        if(visible) {\r\n            for(view in views) {\r\n                view.onmousemove(e);\r\n            }\r\n        }\r\n    } //mousemove\r\n\r\n    function keyup(e:KeyEvent) {\r\n\r\n        if(visible) {\r\n            for(view in views) {\r\n                view.onkeyup(e);\r\n            }\r\n        } //visible\r\n\r\n        #if profiler\r\n            #if luxe_native\r\n                if(e.keycode == Key.key_p && profiling) {\r\n                    cpp.vm.Profiler.stop();\r\n                    profiling = false;\r\n                    trace(\"profiling complete. Look for the results in \" + profile_path );\r\n                }\r\n            #end //luxe_native\r\n        #end //profiler\r\n\r\n    } //keyup\r\n\r\n    function keydown(e:KeyEvent) {\r\n\r\n        if(visible) {\r\n\r\n            if(e.keycode == Key.key_1 && core.console_visible) {\r\n                switch_view();\r\n            }\r\n\r\n            for(view in views) {\r\n                view.onkeydown(e);\r\n            }\r\n\r\n        }\r\n\r\n        #if profiler\r\n            #if luxe_native\r\n                if(e.keycode == Key.key_p && e.mod.ctrl && !e.repeat) {\r\n                    trace(\"starting profiler ... let go of key to stop profiling.\");\r\n                    cpp.vm.Profiler.start( profile_path );\r\n                    profiling = true;\r\n                }\r\n            #end //luxe_native\r\n        #end //profiler\r\n\r\n    } //keydown\r\n\r\n    function refresh() {\r\n        current_view.refresh();\r\n    } //refresh\r\n\r\n        /** programmatically switch the debug console view. currently cycles the view. */\r\n    @:noCompletion public function switch_view() {\r\n\r\n            //keep knowledge of this\r\n        last_view_index = current_view_index;\r\n            //then go up one, :todo : make easier to jump to specific view?\r\n        current_view_index++;\r\n\r\n            //handle looping\r\n        if(current_view_index > views.length-1) {\r\n            current_view_index = 0;\r\n        }\r\n\r\n            //now hide the last view\r\n        views[last_view_index].hide();\r\n            //store the new one\r\n        current_view = views[current_view_index];\r\n\r\n            //show the new one\r\n        current_view.show();\r\n\r\n    } //switch_view\r\n\r\n    var last_cursor_shown : Bool = true;\r\n    var last_cursor_grab : Bool = false;\r\n\r\n    @:noCompletion public function show_console(_show:Bool = true) {\r\n\r\n        #if no_debug_console\r\n            return;\r\n        #end\r\n\r\n        if(_show) {\r\n\r\n            last_cursor_shown = Luxe.screen.cursor.visible;\r\n            last_cursor_grab = Luxe.screen.cursor.grab;\r\n\r\n            Luxe.screen.cursor.visible = true;\r\n            Luxe.screen.cursor.grab = false;\r\n\r\n        } else {\r\n\r\n            if(last_cursor_shown!=true) {\r\n                Luxe.screen.cursor.visible = last_cursor_shown;\r\n            }\r\n\r\n            if(last_cursor_grab!=false) {\r\n                Luxe.screen.cursor.grab = last_cursor_grab;\r\n            }\r\n        }\r\n\r\n        visible = _show;\r\n        batcher.enabled = _show;\r\n\r\n        if(_show) {\r\n            current_view.show();\r\n            overlay.visible = true;\r\n            debug_inspector.show();\r\n        } else {\r\n            current_view.hide();\r\n            debug_inspector.hide();\r\n            overlay.visible = false;\r\n        }\r\n\r\n    } //show_console\r\n\r\n    @:noCompletion public function destroy() {\r\n\r\n        core.off(Ev.keyup, keyup);\r\n        core.off(Ev.keydown, keydown);\r\n        core.off(Ev.mouseup, mouseup);\r\n        core.off(Ev.mousedown, mousedown);\r\n        core.off(Ev.mousemove, mousemove);\r\n        core.off(Ev.mousewheel, mousewheel);\r\n\r\n        _debug('\\t debug shut down.');\r\n        shut_down = true;\r\n\r\n    } //destroy\r\n\r\n    @:noCompletion public function process() {\r\n\r\n        dt_average_accum += Luxe.dt;\r\n        dt_average_count++;\r\n\r\n        if(dt_average_count == dt_average_span - 1) {\r\n            dt_average = dt_average_accum/dt_average_span;\r\n            dt_average_accum = dt_average;\r\n            dt_average_count = 0;\r\n        }\r\n\r\n        if(!visible) {\r\n            return;\r\n        }\r\n\r\n            //update the title\r\n        debug_inspector._title_text.text = \"[ \" + current_view.name + \" ] \" + Maths.fixed(Luxe.dt,5) + ' / ' + Maths.fixed(dt_average,5);\r\n\r\n        // #if !luxe_native\r\n            for(view in views) {\r\n                view.process();\r\n            }\r\n        // #end\r\n\r\n    } //process\r\n\r\n} //Debug\r\n\r\n","package luxe;\r\n\r\nimport luxe.Color;\r\nimport phoenix.geometry.Geometry;\r\nimport phoenix.geometry.LineGeometry;\r\nimport phoenix.geometry.QuadGeometry;\r\nimport phoenix.geometry.RectangleGeometry;\r\nimport phoenix.geometry.CircleGeometry;\r\nimport phoenix.Batcher;\r\nimport phoenix.geometry.RingGeometry;\r\nimport phoenix.geometry.ArcGeometry;\r\nimport phoenix.geometry.PlaneGeometry;\r\nimport phoenix.geometry.Vertex;\r\nimport phoenix.geometry.TextGeometry;\r\n\r\nimport luxe.options.GeometryOptions;\r\nimport luxe.options.DrawOptions;\r\n\r\n/**\r\n    The `Luxe.draw` API class implementation.\r\n    This class handles quick access to drawing common geometry options,\r\n    and is a facilitator for higher level drawing. These can be used given to a `Visual` to convert\r\n    them into a higher level entity for use with the default scene.\r\n */\r\nclass Draw {\r\n\r\n//Public API\r\n\r\n        /** Draw a line geometry between points `p0` and `p1` with options */\r\n    public function line( options:DrawLineOptions ) {\r\n\r\n        if(options.p0 == null) { throw \"draw.line requires p0:Vector, and p1:Vector\"; }\r\n        if(options.p1 == null) { throw \"draw.line requires p0:Vector, and p1:Vector\"; }\r\n        if(options.id == null) { options.id = 'line.geometry'; }\r\n        if(options.batcher == null) { options.batcher = Luxe.renderer.batcher; }\r\n\r\n            return new LineGeometry(options);\r\n\r\n    } // line\r\n\r\n        /** Draw a rectangle outline at the specified `x`,`y`,`w`,`h` with options */\r\n    public function rectangle( options:DrawRectangleOptions ) {\r\n\r\n        if(options.id == null) { options.id = 'rectangle.geometry'; };\r\n        if(options.batcher == null) { options.batcher = Luxe.renderer.batcher; }\r\n\r\n        return new RectangleGeometry(options);\r\n\r\n    } //rectangle\r\n\r\n        /** Draw a solid rectangle box at the specified `x`,`y`,`w`,`h` with options */\r\n    public function box( options:DrawBoxOptions ) {\r\n\r\n        if(options.id == null) { options.id = 'quad.geometry'; }\r\n        if(options.batcher == null) { options.batcher = Luxe.renderer.batcher; }\r\n\r\n        return new QuadGeometry(options);\r\n\r\n    } //box\r\n\r\n        /** Draw a circle outline at the specified `x`,`y` with radius `r` (or `rx`,`ry` optionally for an ellipse), with options */\r\n    public function ring( options:DrawRingOptions ) {\r\n\r\n        if(options.id == null) { options.id = 'ring.geometry'; };\r\n        if(options.batcher == null) { options.batcher = Luxe.renderer.batcher; }\r\n\r\n        return new RingGeometry(options);\r\n\r\n    } //ring\r\n\r\n        /** Draw a solid circle at the specified `x`,`y` with radius `r` (or `rx`,`ry` optionally for an ellipse), with options */\r\n    public function circle( options:DrawCircleOptions ) {\r\n\r\n        if(options.id == null) { options.id = 'circle.geometry'; };\r\n        if(options.batcher == null) { options.batcher = Luxe.renderer.batcher; }\r\n\r\n        return new CircleGeometry(options);\r\n\r\n    } //circle\r\n\r\n        /** Draw an arc (open circle) at the specified `x`,`y`, between `start_angle` and `end_angle` with radius `r` (or `rx`,`ry` optionally for an ellipsical arc), with options */\r\n    public function arc( options:DrawArcOptions ) {\r\n\r\n        if(options.id == null) { options.id = 'arc.geometry'; };\r\n        if(options.batcher == null) { options.batcher = Luxe.renderer.batcher; }\r\n\r\n        return new ArcGeometry(options);\r\n\r\n    } //arc\r\n\r\n        /** Draw an n-sided polygon (3 sides for triangle, 6 for hexagon etc) at `x`,`y` with a radius `r` and `sides` with options  */\r\n    public function ngon( options:DrawNgonOptions ) : Geometry {\r\n\r\n        if(options.id == null) { options.id = 'ngon.geometry'; };\r\n        if(options.batcher == null) { options.batcher = Luxe.renderer.batcher; }\r\n\r\n        var _sides : Int = 3;\r\n        var _radius : Float = 64;\r\n        var _solid : Bool = false;\r\n        var _x : Float = 0;\r\n        var _y : Float = 0;\r\n        var _angle : Float = 0;\r\n\r\n        if(options.sides != null) {\r\n            _sides = options.sides;\r\n        }\r\n\r\n        if(options.r != null) { _radius = options.r; }\r\n        if(options.x != null) { _x = options.x; }\r\n        if(options.y != null) { _y = options.y; }\r\n        if(options.angle != null) { _angle = options.angle; }\r\n        if(options.solid != null) { _solid = options.solid; }\r\n\r\n        var _geometry = new Geometry(options);\r\n\r\n        if(!_solid) {\r\n            _geometry.primitive_type = PrimitiveType.lines;\r\n        } else {\r\n            _geometry.primitive_type = PrimitiveType.triangle_fan;\r\n        }\r\n\r\n        var _two_pi : Float = 2 * Math.PI;\r\n        var _sides_over_pi : Float = Math.PI / _sides;\r\n        var _sides_over_twopi : Float = _two_pi / _sides;\r\n        var _angle_rad : Float = luxe.utils.Maths.radians(_angle);\r\n\r\n        if(_solid) {\r\n                //add the center vertex\r\n            _geometry.add( new Vertex( new Vector( _x, _y ), options.color ) );\r\n        }\r\n\r\n        var _count : Int = (_solid == false) ? _sides : _sides+1;\r\n        var _points:Array<Vector> = [];\r\n\r\n        for(i in 0 ... _count ) {\r\n\r\n            var __x   = (_radius * Math.sin(_angle_rad + (_sides_over_pi) + (i * (_sides_over_twopi))));\r\n            var __y   = (_radius * Math.cos(_angle_rad + (_sides_over_pi) + (i * (_sides_over_twopi))));\r\n            var __pos = new Vector( _x + __x, _y + __y, 0 );\r\n\r\n            _geometry.add( new Vertex( __pos, options.color ) );\r\n\r\n            if(!_solid) {\r\n                if(i > 0) {\r\n                    var _last = _points[i - 1];\r\n                    _geometry.add( new Vertex( __pos, options.color ) );\r\n                }\r\n            }\r\n\r\n            _points.push(__pos);\r\n\r\n        } //for all sides\r\n\r\n        if(!_solid) {\r\n            _geometry.add( new Vertex( _points[0], options.color ) );\r\n        }\r\n\r\n        return _geometry;\r\n\r\n    } //ngon\r\n\r\n        /** Draw a textured `box` with image `texture` at `x`,`y`,`w`,`h` OR with `pos` and `size`, and `uv` with options */\r\n    public function texture( options:DrawTextureOptions ) {\r\n\r\n        if(options.id == null) { options.id = 'texture.geometry'; };\r\n        if(options.batcher == null) { options.batcher = Luxe.renderer.batcher; }\r\n\r\n        var _x : Float = 0;\r\n        var _y : Float = 0;\r\n        var _w : Float = 0;\r\n        var _h : Float = 0;\r\n\r\n            //this is an arbitrary default\r\n        var _tw : Int = 64;\r\n        var _th : Int = 64;\r\n\r\n            if(options.texture != null) {\r\n                _tw = options.texture.width;\r\n                _th = options.texture.height;\r\n\r\n                if(options.size == null) {\r\n                    _w = _tw;\r\n                    _h = _th;\r\n                }\r\n            }\r\n\r\n            if(options.pos != null) {\r\n                _x = options.pos.x;\r\n                _y = options.pos.y;\r\n            }\r\n            if(options.size != null) {\r\n                _w = options.size.x;\r\n                _h = options.size.y;\r\n            }\r\n\r\n            if(options.x == null) {\r\n                options.x = _x;\r\n            }\r\n\r\n            if(options.y == null) {\r\n                options.y = _y;\r\n            }\r\n\r\n            if(options.w == null) {\r\n                options.w = _w;\r\n            }\r\n\r\n            if(options.h == null) {\r\n                options.h = _h;\r\n            }\r\n\r\n            var _quad = new QuadGeometry(options);\r\n\r\n            var _ux : Float = 0;\r\n            var _uy : Float = 0;\r\n            var _uw : Float = _tw;\r\n            var _uh : Float = _th;\r\n\r\n            if(options.uv != null) {\r\n                _ux = options.uv.x;\r\n                _uy = options.uv.y;\r\n                _uw = options.uv.w;\r\n                _uh = options.uv.h;\r\n            }\r\n\r\n            _quad.uv( new Rectangle(_ux, _uy, _uw, _uh) );\r\n\r\n        return _quad;\r\n\r\n    } //texture\r\n\r\n        /** Draw `text` with options (default font used if none specified) */\r\n    public function text( options:TextGeometryOptions ) {\r\n\r\n        if(options.batcher == null) { options.batcher = Luxe.renderer.batcher; }\r\n\r\n        return new TextGeometry(options);\r\n\r\n    } //text\r\n\r\n        //hidden as 3D specifics aren't in the API yet.\r\n        /** Draw a plane (three dimensional quad) with options */\r\n    @:noCompletion public function plane( ?options:DrawPlaneOptions ) {\r\n\r\n        if(options.id == null) { options.id = 'plane.geometry'; };\r\n        if(options.batcher == null) { options.batcher = Luxe.renderer.batcher; }\r\n\r\n        return new PlaneGeometry( options );\r\n\r\n    } //_plane\r\n\r\n\r\n//Internal API\r\n\r\n    @:noCompletion public var core : Core;\r\n    @:noCompletion public function new( _core:Core ) {\r\n\r\n        core = _core;\r\n\r\n    } //new\r\n\r\n\r\n} //Draw\r\n","package luxe;\r\n\r\nimport luxe.Core;\r\n\r\nclass Events {\r\n\r\n\r\n    @:noCompletion public var event_queue : Map< String, EventObject>;\r\n    @:noCompletion public var event_connections : Map< String, EventConnection>; //event id, connect\r\n    @:noCompletion public var event_slots : Map< String, Array<EventConnection> >; //event name, array of connections\r\n    @:noCompletion public var event_filters : Map< String, Array<EventConnection> >; //event name, array of connections\r\n    @:noCompletion public var event_schedules : Map< String, snow.utils.Timer >; //event id, timer\r\n\r\n        /** create a new instance for sending/receiving events */\r\n    public function new( ) {\r\n\r\n            //create the queue, lists and map\r\n        event_connections = new Map();\r\n        event_slots = new Map();\r\n        event_filters = new Map();\r\n        event_queue = new Map();\r\n        event_schedules = new Map();\r\n\r\n    } //new\r\n\r\n        /** destroy this `Events` instance */\r\n    public function destroy() {\r\n\r\n        clear();\r\n\r\n    } //destroy\r\n\r\n        /** clear any scheduled or bound events. called on destroy. */\r\n    public function clear() {\r\n\r\n        for(schedule in event_schedules) {\r\n            schedule.stop();\r\n            schedule = null;\r\n        }\r\n\r\n        for(connection in event_connections.keys()) {\r\n            event_connections.remove(connection);\r\n        }\r\n\r\n        for(filter in event_filters.keys()) {\r\n            event_filters.remove(filter);\r\n        }\r\n\r\n        for(slot in event_slots.keys()) {\r\n            event_slots.remove(slot);\r\n        }\r\n\r\n        for(event in event_queue.keys()) {\r\n            event_queue.remove(event);\r\n        }\r\n\r\n    }\r\n\r\n        /** helper. Exposed for learning/testing api. */\r\n    public function does_filter_event( _filter:String, _event:String ) {\r\n\r\n        var _replace_stars : EReg = ~/\\*/gi;\r\n        var _final_filter : String = _replace_stars.replace( _filter, '.*?' );\r\n        var _final_search : EReg = new EReg(_final_filter, 'gi');\r\n\r\n        return _final_search.match( _event );\r\n\r\n    } //does_filter_event\r\n\r\n\r\n        /**Bind a signal (listener) to a slot (event_name)   \r\n            event_name : The event id   \r\n            listener : A function handler that should get called on event firing*/\r\n    public function listen<T>( _event_name : String, _listener : T -> Void ):String {\r\n\r\n            //we need an ID and a connection to store\r\n        var id : String = Luxe.utils.uniqueid();\r\n        var connection : EventConnection = new EventConnection( id, _event_name, _listener );\r\n\r\n            //now we store it in the map\r\n        event_connections.set( id, connection );\r\n\r\n            //first check if the event name in question has a * wildcard,\r\n            //if it does we have to store it as a filtered event so it's more optimal\r\n            //to search through when events are fired\r\n        var _has_stars : EReg = ~/\\*/gi;\r\n        if(_has_stars.match(_event_name)) {\r\n\r\n                //also store the listener inside the slots\r\n            if(!event_filters.exists(_event_name)) {\r\n                    //no slot exists yet? make one!\r\n                event_filters.set(_event_name, new Array<EventConnection>() );\r\n            }\r\n\r\n                //it should exist by now, lets store the connection by event name\r\n            event_filters.get(_event_name).push( connection );\r\n\r\n        } else {\r\n\r\n                //also store the listener inside the slots\r\n            if(!event_slots.exists(_event_name)) {\r\n                    //no slot exists yet? make one!\r\n                event_slots.set(_event_name, new Array<EventConnection>() );\r\n            }\r\n\r\n                //it should exist by now, lets store the connection by event name\r\n            event_slots.get(_event_name).push( connection );\r\n\r\n        }\r\n\r\n            //return the id for disconnecting\r\n        return id;\r\n\r\n    } //listen\r\n\r\n        /**Disconnect a vound signal   \r\n            event connection id, returned from connect()   \r\n            returns true if the event existed and was removed */\r\n    public function disconnect( event_id : String ) : Bool {\r\n\r\n        if(event_connections.exists(event_id)) {\r\n\r\n            var connection = event_connections.get(event_id);\r\n            var event_slot = event_slots.get(connection.event_name);\r\n\r\n            if(event_slot != null) {\r\n                event_slot.remove(connection);\r\n                return true;\r\n            } else {\r\n                var event_filter = event_filters.get(connection.event_name);\r\n                if(event_filter != null) {\r\n                    event_filter.remove(connection);\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                } //event_filter != null\r\n            } //event_slot != null\r\n\r\n            return true;\r\n\r\n        } else {\r\n            return false;\r\n        }\r\n\r\n    } //disconnect\r\n\r\n        /*Queue an event in the next update loop   \r\n            event_name : The event (register listeners with connect())   \r\n            properties : A dynamic pass-through value to hand off data   \r\n            returns : a String, the unique ID of the event */\r\n    public function queue<T>( event_name : String, ?properties : T ) : String {\r\n\r\n        var id : String = Luxe.utils.uniqueid();\r\n\r\n                //store it in case we want to manipulate it\r\n            var event:EventObject = new EventObject(id, event_name, properties);\r\n\r\n                //stash it away\r\n            event_queue.set(id, event);\r\n\r\n            //return the user the id\r\n        return id;\r\n    } //queue\r\n\r\n        /** Remove an event from the queue by id returned from queue. */\r\n    public function dequeue( event_id: String ) {\r\n\r\n        if(event_queue.exists(event_id)) {\r\n\r\n            var event = event_queue.get(event_id);\r\n            event = null;\r\n            event_queue.remove( event_id );\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n\r\n    } //dequeue\r\n\r\n        /** Process/update the events, firing any events in the queue. if you create a custom instance, call this when you want to process. */\r\n    public function process() {\r\n\r\n            //fire each event in the queue\r\n        for(event in event_queue) {\r\n            fire( event.name, event.properties );\r\n        }\r\n\r\n            //if we actually have any events, clear the queue\r\n        if(event_queue.keys().hasNext()) {\r\n                //clear out the queue\r\n            event_queue = null;\r\n            event_queue = new Map();\r\n        }\r\n\r\n    } //update\r\n\r\n        //Fire an event immediately, bypassing the queue.\r\n            //event_name : The event (register listeners with connect())\r\n            //properties : A dynamic pass-through value to hand off data\r\n            //  -- Returns a Bool, true if event existed, false otherwise\r\n    public function fire<T>( _event_name : String, ?_properties : T ) : Bool {\r\n\r\n        //we have to check against our filters if this event matches anything\r\n        for(_filter in event_filters) {\r\n\r\n            if(_filter.length > 0) {\r\n\r\n                var _filter_name = _filter[0].event_name;\r\n                if(does_filter_event(_filter_name, _event_name)) {\r\n                        //ok, it hits so call each of it's listeners\r\n                    _properties = tag_properties(_properties, _event_name, _filter.length);\r\n\r\n                    for(_connection in _filter) {\r\n                        _connection.listener( _properties );\r\n                    } //each connection to this filter\r\n\r\n                } //if it actually fits this event filter\r\n            } //if there are any connections\r\n\r\n        } //for each of our filters\r\n\r\n        if(event_slots.exists( _event_name )) {\r\n\r\n                //we have an event by this name\r\n            var connections:Array<EventConnection> = event_slots.get(_event_name);\r\n\r\n                //store additional info about the events\r\n                //:todo : is this needed anymore?\r\n            // _properties = tag_properties(_properties, _event_name, connections.length);\r\n\r\n                //call each listener\r\n            for(connection in connections) {\r\n                connection.listener( cast _properties );\r\n            }\r\n\r\n        } else {\r\n                //event not found\r\n            return false;\r\n        }\r\n\r\n        return false;\r\n\r\n    } //fire\r\n\r\n        //Schedule and event in the future\r\n            //event_name : The event (register listeners with connect())\r\n            //properties : A dynamic pass-through value to hand off data\r\n            //  -- Returns a String, the ID of the schedule (see unschedule)\r\n    public function schedule<T>( time:Float, event_name : String, ?properties : T ) : String {\r\n\r\n        var id : String = Luxe.utils.uniqueid();\r\n\r\n            var _timer = Luxe.timer.schedule(time, function(){\r\n                fire( event_name, properties );\r\n            });\r\n\r\n            event_schedules.set( id, _timer );\r\n\r\n        return id;\r\n\r\n    } //schedule\r\n\r\n        //Unschedule a previously scheduled event\r\n            //schedule_id : The id of the schedule (returned from schedule)\r\n            // -- Returns false if fails, or event doesn't exist\r\n    public function unschedule( schedule_id : String ) : Bool {\r\n\r\n        if(event_schedules.exists(schedule_id)) {\r\n                //find the timer\r\n            var timer = event_schedules.get(schedule_id);\r\n                //kill it\r\n            timer.stop();\r\n                //remove it from the list\r\n            event_schedules.remove(schedule_id);\r\n                //done\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n\r\n    } //unschedule\r\n\r\n    function tag_properties(_properties:Dynamic, _name:String,_count:Int) {\r\n\r\n        if(_properties == null) {\r\n            _properties = {};\r\n        }\r\n\r\n            //tag these information slots, with _ so they don't clobber other stuff\r\n        Reflect.setField(_properties,'_event_name_', _name);\r\n            //tag a listener count\r\n        Reflect.setField(_properties,'_event_connection_count_', _count);\r\n\r\n        return _properties;\r\n    }\r\n\r\n} // Events\r\n\r\nprivate class EventConnection {\r\n\r\n\r\n    public var listener : Dynamic -> Void;\r\n    public var id : String;\r\n    public var event_name : String;\r\n\r\n\r\n    public function new( _id:String, _event_name:String, _listener : Dynamic -> Void ) {\r\n\r\n        id = _id;\r\n        listener = _listener;\r\n        event_name = _event_name;\r\n\r\n    } //new\r\n\r\n\r\n} //EventConnection\r\n\r\nprivate class EventObject {\r\n\r\n\r\n    public var id : String;\r\n    public var name:String;\r\n    public var properties : Dynamic;\r\n\r\n\r\n    public function new(_id:String, _event_name:String, _event_properties:Dynamic ) {\r\n\r\n        id = _id;\r\n        name = _event_name;\r\n        properties = _event_properties;\r\n\r\n    } //new\r\n\r\n\r\n} //EventObject\r\n","package luxe;\r\n\r\nimport luxe.Core;\r\n\r\nclass IO {\r\n\r\n    public var core : Core;\r\n\r\n    @:allow(luxe.Core)\r\n    function new( _core:Core ) {\r\n        core = _core;\r\n    } //new\r\n\r\n//Path specifics\r\n\r\n    public var app_path (get,never) : String;\r\n    public var app_path_prefs (get,never) : String;\r\n\r\n//Utility features\r\n\r\n        /** Open the system default browser with the given URL.\r\n            supported: mac/window/linux/iOS/web\r\n            pending: android https://github.com/underscorediscovery/snow/issues/25 */\r\n    public function url_open( _url:String ) {\r\n\r\n        core.app.io.url_open( _url );\r\n\r\n    } //url_open\r\n\r\n//Internal\r\n\r\n    function get_app_path() {\r\n\r\n        return core.app.io.app_path();\r\n\r\n    } //get_app_path\r\n\r\n    function get_app_path_prefs() {\r\n\r\n        return core.app.io.app_path_prefs();\r\n\r\n    } //get_app_path\r\n\r\n    @:allow(luxe.Core)\r\n    function init() {\r\n\r\n    } //init\r\n\r\n} //IO\r\n","package luxe;\r\n\r\nimport luxe.Core;\r\nimport luxe.Log._debug;\r\nimport snow.types.Types;\r\n\r\n    /** A modifier state for key events */\r\ntypedef ModState        =   snow.types.Types.ModState;\r\n    /** A named list of keycodes. Use to compare against key event `keycode` values */\r\ntypedef Key             =   snow.input.Keycodes.Keycodes;\r\n    /** A named list of scancodes. Use to compare against key event `scancode` values */\r\ntypedef Scan            =   snow.input.Keycodes.Scancodes;\r\n\r\n/** A typed mouse button id */\r\n@:enum abstract MouseButton(Int) from Int to Int {\r\n\r\n/** no mouse buttons */\r\n    var none = 0;\r\n/** left mouse button */\r\n    var left = 1;\r\n/** middle mouse button */\r\n    var middle = 2;\r\n/** right mouse button */\r\n    var right = 3;\r\n/** extra button pressed (4) */\r\n    var extra1 = 4;\r\n/** extra button pressed (5) */\r\n    var extra2 = 5;\r\n\r\n} //MouseButton\r\n\r\n/** A typed state for mouse, touch, or pressed/similar */\r\nenum InteractState {\r\n\r\n/** An unknown state */\r\n    unknown;\r\n/** An none state */\r\n    none;\r\n/** In a pressed state */\r\n    down;\r\n/** In a released state */\r\n    up;\r\n/** In a moving state */\r\n    move;\r\n/** A mouse wheel state */\r\n    wheel;\r\n/** A gamepad axis state */\r\n    axis;\r\n\r\n} //MouseState\r\n\r\n/** A typed text event type */\r\nenum TextEventType {\r\n\r\n/** An unknown event */\r\n    unknown;\r\n/** An edit text typing event */\r\n    edit;\r\n/** An input text typing event */\r\n    input;\r\n\r\n} //TextEventType\r\n\r\n/** Information about a keyboard event */\r\ntypedef KeyEvent = {\r\n\r\n        /** The `Scan` code value for this event */\r\n    var scancode : Int;\r\n        /** The `Key` code value for this event */\r\n    var keycode : Int;\r\n        /** The state of the key in this event */\r\n    var state : InteractState;\r\n        /** The modifier state of this event */\r\n    var mod : ModState;\r\n        /** If this value is bigger than 0 this is a key repeat event of a key held down */\r\n    var repeat : Bool;\r\n        /** The time in seconds when this touch event occurred, use for deltas */\r\n    var timestamp : Float;\r\n        /** The window id this event originated from */\r\n    var window_id : Int;\r\n\r\n} //KeyEvent\r\n\r\n/** Information about a touch event */\r\ntypedef TouchEvent = {\r\n\r\n        /** The state this touch event is in */\r\n    var state : InteractState;\r\n        /** The time in seconds when this touch event occurred, use for deltas */\r\n    var timestamp : Float;\r\n        /** The id of the touch that this event comes from, a finger id */\r\n    var touch_id : Int;\r\n        /** The x position in the window of the touch event */\r\n    var x : Float;\r\n        /** The x position in the window of the touch event */\r\n    var y : Float;\r\n        /** The delta x value of the touch event, if the state is `moving` */\r\n    var dx : Float;\r\n        /** The delta y value of the touch event, if the state is `moving` */\r\n    var dy : Float;\r\n        /** A convenience vector access of the x and y position */\r\n    var pos : luxe.Vector;\r\n\r\n} //TouchEvent\r\n\r\n/** Information about a text input event */\r\ntypedef TextEvent = {\r\n\r\n        /** The text that this event has generated */\r\n    var text : String;\r\n        /** The type of text event */\r\n    var type : TextEventType;\r\n        /** The time in seconds when this touch event occurred, use for deltas */\r\n    var timestamp : Float;\r\n        /** The window id this event originated from */\r\n    var window_id : Int;\r\n        /** The start position, if the `type` is `edit` */\r\n    var start : Int;\r\n        /** The length position, if the `type` is `edit` */\r\n    var length : Int;\r\n\r\n} //TextEvent\r\n\r\n/** A typed gamepad event type */\r\nenum GamepadEventType {\r\n\r\n/** An unknown event */\r\n    unknown;\r\n/** An axis change event */\r\n    axis;\r\n/** A button event */\r\n    button;\r\n/** A device added event */\r\n    device_added;\r\n/** A device removed event */\r\n    device_removed;\r\n/** A device was remapped */\r\n    device_remapped;\r\n\r\n} //GamepadEventType\r\n\r\n/** Information about a gamepad event */\r\ntypedef GamepadEvent = {\r\n\r\n        /** The time in seconds when this gamepad event occurred, use for deltas */\r\n    var timestamp : Float;\r\n        /** The type of gamepad event that this corresponds with */\r\n    var type : GamepadEventType;\r\n        /** The state this event is in */\r\n    var state : InteractState;\r\n        /** The id of the gamepad this event comes from */\r\n    var gamepad : Int;\r\n        /** The button id, if the event `type` is `button` */\r\n    var button : Int;\r\n        /** The axis id, if the event `type` is `axis` */\r\n    var axis : Int;\r\n        /** The axis value, if the event `type` is `axis` */\r\n    var value : Float;\r\n\r\n} //GamepadEvent\r\n\r\n/** Information about a mouse event */\r\ntypedef MouseEvent = {\r\n\r\n        /** The time in seconds when this touch event occurred, use for deltas */\r\n    var timestamp : Float;\r\n        /** The window id this event originated from */\r\n    var window_id : Int;\r\n        /** The state this event is in */\r\n    var state : InteractState;\r\n        /** The button id, if the event `state` is `down` or `up` */\r\n    var button : MouseButton;\r\n        /** The x position in the window of the mouse event */\r\n    var x : Int;\r\n        /** The y position in the window of the mouse event */\r\n    var y : Int;\r\n        /** The relative x position if `state` is `move` or a window has grabbed state */\r\n    var xrel : Int;\r\n        /** The relative y position if `state` is `move` or a window has grabbed state */\r\n    var yrel : Int;\r\n        /** A convenience vector access of the x and y position */\r\n    var pos : luxe.Vector;\r\n\r\n} //MouseEvent\r\n\r\n/** A type for a named input event */\r\nenum InputType {\r\n\r\n        /** A mouse input event */\r\n    mouse;\r\n        /** A touch input event */\r\n    touch;\r\n        /** A key input event */\r\n    keys;\r\n        /** A gampad input event */\r\n    gamepad;\r\n\r\n} //InputType\r\n\r\n/** Information about a named input event */\r\ntypedef InputEvent = {\r\n\r\n        /** the name of the input event */\r\n    var name : String;\r\n        /** the type of input this event was generated for */\r\n    var type  : InputType;\r\n        /** The state of the event */\r\n    var state : InteractState;\r\n        /** null, unless type is `touch` */\r\n    @:optional var touch_event : TouchEvent;\r\n        /** null, unless type is `mouse` */\r\n    @:optional var mouse_event : MouseEvent;\r\n        /** null, unless type is `keys` */\r\n    @:optional var key_event : KeyEvent;\r\n        /** null, unless type is `gamepad` */\r\n    @:optional var gamepad_event : GamepadEvent;\r\n\r\n}\r\n\r\nclass Input {\r\n\r\n    @:noCompletion public var core : Core;\r\n    @:noCompletion public function new( _core:Core ) { core = _core; }\r\n\r\n    var key_bindings : Map<String, Map<Int,Bool> >;\r\n    var mouse_bindings : Map<String, Map<Int,Bool> >;\r\n    var gamepad_bindings: Map<String, Map<Int, Null<Int>> >;\r\n\r\n    var _named_input_released : Map<String, Bool>;\r\n    var _named_input_pressed : Map<String, Bool>;\r\n    var _named_input_down : Map<String, Bool>;\r\n\r\n    @:noCompletion public function init() {\r\n\r\n        key_bindings = new Map();\r\n        mouse_bindings = new Map();\r\n        gamepad_bindings = new Map();\r\n\r\n        _named_input_down = new Map();\r\n        _named_input_pressed = new Map();\r\n        _named_input_released = new Map();\r\n\r\n        _debug('\\t input initialized.');\r\n\r\n    } //init\r\n\r\n    @:noCompletion public function destroy() {\r\n        _debug('\\t input shut down.');\r\n    } //destroy\r\n\r\n    @:noCompletion public function process() {\r\n\r\n           //remove any stale named pressed value\r\n            //unless it wasn't alive for a full frame yet,\r\n            //then flag it so that it may be\r\n        for(_event in _named_input_pressed.keys()){\r\n\r\n            if(_named_input_pressed.get(_event)){\r\n                _named_input_pressed.remove(_event);\r\n            } else {\r\n                _named_input_pressed.set(_event, true);\r\n            }\r\n\r\n        } //each _named_input_pressed\r\n\r\n            //remove any stale key released value\r\n            //unless it wasn't alive for a full frame yet,\r\n            //then flag it so that it may be\r\n        for(_event in _named_input_released.keys()){\r\n\r\n            if(_named_input_released.get(_event)){\r\n                _named_input_released.remove(_event);\r\n            } else {\r\n                _named_input_released.set(_event, true);\r\n            }\r\n\r\n        } //each _named_input_released\r\n\r\n    } //process\r\n\r\n//Input query\r\n\r\n        /** immediate query of the pressed state of a named input. only true if pressed within one frame */\r\n    public function inputpressed( _event:String ) : Bool {\r\n        return _named_input_pressed.exists( _event );\r\n    } //inputpressed\r\n\r\n        /** immediate query of the released state of a named input. only true if released within one frame */\r\n    public function inputreleased( _event:String ) : Bool{\r\n        return _named_input_released.exists( _event );\r\n    } //inputreleased\r\n\r\n        /** immediate query of the down state of a named input. only true while the key is down */\r\n    public function inputdown( _event:String ) : Bool{\r\n        return _named_input_down.exists( _event );\r\n    } //inputdown\r\n\r\n//Keys\r\n\r\n        /** immediate query of the pressed state of a `keycode`, use `Key` for named keycodes. only true if pressed within one frame */\r\n    public function keypressed( _code:Int ) : Bool {\r\n        return core.app.input.keypressed( _code );\r\n    } //keypressed\r\n\r\n        /** immediate query of the released state of a `keycode`, use `Key` for named keycodes. only true if released within one frame */\r\n    public function keyreleased( _code:Int ) : Bool{\r\n        return core.app.input.keyreleased( _code );\r\n    } //keyreleased\r\n\r\n        /** immediate query of the down state of a `keycode`, use `Key` for named keycodes. only true while the key is down */\r\n    public function keydown( _code:Int ) : Bool{\r\n        return core.app.input.keydown( _code );\r\n    } //keydown\r\n\r\n\r\n        /** immediate query of the pressed state of a `scancode`, use `Scan` for named scancodes. only true if pressed within one frame */\r\n    public function scanpressed( _code:Int ) : Bool {\r\n        return core.app.input.scanpressed( _code );\r\n    } //scanpressed\r\n\r\n        /** immediate query of the released state of a `scancode`, use `Scan` for named scancodes. only true if released within one frame */\r\n    public function scanreleased( _code:Int ) : Bool{\r\n        return core.app.input.scanreleased( _code );\r\n    } //scanreleased\r\n\r\n        /** immediate query of the down state of a `scancode`, use `Scan` for named scancodes. only true while the key is down */\r\n    public function scandown( _code:Int ) : Bool{\r\n        return core.app.input.scandown( _code );\r\n    } //scandown\r\n\r\n//Mouse\r\n\r\n        /** immediate query of the pressed state of a mouse button. only true if pressed within one frame */\r\n    public function mousepressed( _button:MouseButton ) : Bool {\r\n        return core.app.input.mousepressed( _button );\r\n    } //mousepressed\r\n\r\n        /** immediate query of the released state of a mouse button. only true if released within one frame */\r\n    public function mousereleased( _button:MouseButton ) : Bool{\r\n        return core.app.input.mousereleased( _button );\r\n    } //mousereleased\r\n\r\n        /** immediate query of the down state of a mouse button. only true while the button is down. :todo: use `MouseButton` like it should be. */\r\n    public function mousedown( _button:MouseButton ) : Bool{\r\n        return core.app.input.mousedown( _button );\r\n    } //mousedown\r\n\r\n//Gamepad\r\n\r\n        /** immediate query of the pressed state of a gamepad button. only true if pressed within one frame */\r\n    public function gamepadpressed( _gamepad:Int, _button:Int ) : Bool {\r\n        return core.app.input.gamepadpressed( _gamepad, _button );\r\n    } //gamepadpressed\r\n\r\n        /** immediate query of the released state of a gamepad button. only true if released within one frame */\r\n    public function gamepadreleased( _gamepad:Int, _button:Int ) : Bool{\r\n        return core.app.input.gamepadreleased( _gamepad, _button );\r\n    } //gamepadreleased\r\n\r\n        /** immediate query of the down state of a gamepad button. only true while the button is down */\r\n    public function gamepaddown( _gamepad:Int, _button:Int ) : Bool{\r\n        return core.app.input.gamepaddown( _gamepad, _button );\r\n    } //gamepaddown\r\n\r\n        /** immediate query of the axis value of a gamepad axis. */\r\n    public function gamepadaxis( _gamepad:Int, _axis:Int ) : Float {\r\n        return core.app.input.gamepadaxis( _gamepad, _axis );\r\n    } //gamepadaxis\r\n\r\n\r\n//Named event handlers\r\n\r\n        /** Bind a named input binding to a `Key` */\r\n    public function bind_key( _name:String, _key:Int ) {\r\n\r\n        if( !key_bindings.exists(_name) ) {\r\n            key_bindings.set(_name, new Map<Int,Bool>() );\r\n        } //if the map doesn't exist yet\r\n\r\n        var kb = key_bindings.get(_name);\r\n            kb.set( _key, true );\r\n\r\n    } //bind_key\r\n\r\n        /** Bind a named input binding to a `MouseButton` */\r\n    public function bind_mouse( _name:String, _button:MouseButton ) {\r\n\r\n        if( !mouse_bindings.exists(_name) ) {\r\n            mouse_bindings.set(_name, new Map<Int,Bool>());\r\n        } //if the map doesn't exist yet\r\n\r\n        var mb = mouse_bindings.get(_name);\r\n            mb.set( _button, true );\r\n\r\n    } //bind_mouse\r\n\r\n    /** Bind a named input binding to a `Gamepad Button`. If no `Gamepad Id` is specified, any gamepad fires the named binding.*/\r\n    public function bind_gamepad( _name:String, _gamepad_button:Int, ?_gamepad_id:Null<Int> = null) {\r\n        if ( !gamepad_bindings.exists(_name) ) {\r\n            gamepad_bindings.set(_name, new Map<Int, Null<Int>>());\r\n        }\r\n\r\n        var gp = gamepad_bindings.get(_name);\r\n        gp.set ( _gamepad_button, _gamepad_id);\r\n    } //bind_gamepad\r\n\r\n    @:noCompletion public function check_named_keys( e:KeyEvent, _down:Bool=false ) {\r\n\r\n        var _fired : Array<String> = [];\r\n        for(_name in key_bindings.keys()) {\r\n\r\n            var _b = key_bindings.get(_name);\r\n            var _is_down_repeat = _down && e.repeat;\r\n            if(_b.exists(e.keycode) && !_is_down_repeat) {\r\n                if( !Lambda.has(_fired, _name)) {\r\n                    _fired.push(_name);\r\n                }\r\n            } //if the key fired is stored in a named binding\r\n\r\n        } //for each binding\r\n\r\n        for(_f in _fired) {\r\n            if(_down) {\r\n\r\n                    //down but not yet processed\r\n                _named_input_pressed.set( _f, false);\r\n                    //down is true immediate, cos up removes it\r\n                _named_input_down.set( _f, true);\r\n\r\n                core.oninputdown( _f, {\r\n                    name : _f,\r\n                    type : InputType.keys,\r\n                    state : InteractState.down,\r\n                    key_event : e\r\n                });\r\n\r\n            } else {\r\n\r\n                    //up but not yet processed\r\n                _named_input_released.set( _f, false);\r\n                    //remove down state\r\n                _named_input_down.remove( _f );\r\n\r\n                core.oninputup( _f, {\r\n                    name : _f,\r\n                    type : InputType.keys,\r\n                    state : InteractState.up,\r\n                    key_event : e\r\n                });\r\n\r\n            } //if _down\r\n        } //_f in _fired\r\n\r\n    } //check_named_keys\r\n\r\n    @:noCompletion public function check_named_mouse( e:MouseEvent, _down:Bool=false ) {\r\n\r\n        var _fired : Array<String> = [];\r\n        for(_name in mouse_bindings.keys()) {\r\n\r\n            var _b = mouse_bindings.get(_name);\r\n            if(_b.exists(e.button)) {\r\n                if( !Lambda.has(_fired, _name)) {\r\n                    _fired.push(_name);\r\n                }\r\n            } //if the key fired is stored in a named binding\r\n\r\n        } //for each binding\r\n\r\n        for(_f in _fired) {\r\n            if(_down) {\r\n\r\n                    //down but not yet processed\r\n                _named_input_pressed.set( _f, false);\r\n                    //down is true immediate, cos up removes it\r\n                _named_input_down.set( _f, true);\r\n\r\n                core.oninputdown( _f, {\r\n                    name : _f,\r\n                    type : InputType.mouse,\r\n                    state : InteractState.down,\r\n                    mouse_event : e\r\n                });\r\n\r\n            } else {\r\n\r\n                    //up but not yet processed\r\n                _named_input_released.set( _f, false);\r\n                    //remove down state\r\n                _named_input_down.remove( _f );\r\n\r\n                core.oninputup( _f, {\r\n                    name : _f,\r\n                    type : InputType.mouse,\r\n                    state : InteractState.up,\r\n                    mouse_event : e\r\n                });\r\n            }\r\n        } //_f in _fired\r\n\r\n    } //check_named_keys\r\n\r\n    @:noCompletion public function check_named_gamepad_buttons( e:GamepadEvent, _down:Bool=false ) {\r\n\r\n        var _fired : Array<String> = [];\r\n        for (_name in gamepad_bindings.keys()) {\r\n\r\n            var _b = gamepad_bindings.get(_name);\r\n            if (_b.exists(e.button)) {\r\n                var _kb = _b.get(e.button);\r\n                var _accepted_gamepad = _kb == null || _kb == e.gamepad;\r\n                if ( !Lambda.has(_fired, _name) && _accepted_gamepad) {\r\n                    _fired.push(_name);\r\n                }\r\n            } // if the button fired is stored in a named binding\r\n        }\r\n\r\n        for(_f in _fired) {\r\n            if (_down) {\r\n\r\n                //down but now yet processed\r\n                _named_input_pressed.set( _f, false);\r\n                // down is true immediate, because up removes it\r\n                _named_input_down.set( _f, true);\r\n\r\n                core.oninputdown( _f, {\r\n                    name: _f,\r\n                    type: InputType.gamepad,\r\n                    state: InteractState.down,\r\n                    gamepad_event: e\r\n                });\r\n\r\n            } else {\r\n\r\n                // up but not yet processed\r\n                _named_input_released.set( _f, false);\r\n                // remove down state\r\n                _named_input_down.remove( _f );\r\n\r\n                core.oninputup( _f, {\r\n                    name: _f,\r\n                    type: InputType.gamepad,\r\n                    state: InteractState.up,\r\n                    gamepad_event: e\r\n                });\r\n\r\n            }\r\n        } //_f in _fired\r\n    } //check_named_gamepad_buttons\r\n\r\n} //Input\r\n","package luxe;\r\n\r\nimport luxe.Color;\r\nimport luxe.Entity;\r\nimport luxe.Vector;\r\nimport luxe.Rectangle;\r\nimport luxe.utils.Maths;\r\nimport luxe.resource.Resource;\r\n\r\nimport phoenix.geometry.Geometry;\r\nimport phoenix.geometry.QuadGeometry;\r\n\r\nimport phoenix.Shader;\r\nimport phoenix.Batcher;\r\nimport phoenix.Quaternion;\r\nimport phoenix.Texture;\r\n\r\nimport luxe.options.VisualOptions;\r\n\r\nimport luxe.Log.log;\r\nimport luxe.Log._verbose;\r\nimport luxe.Log._debug;\r\n\r\nclass Visual extends Entity {\r\n\r\n\r\n        /** the size of this geometry (only makes sense for QuadGeometry) */\r\n    @:isVar public var size         (default,set) : Vector;\r\n        /** the geometry this visual contains */\r\n    @:isVar public var geometry     (default,set) : Geometry;\r\n        /** the geometry static flag. This is a hint on how to render the geometry for performance */\r\n    @:isVar public var locked       (default,set) : Bool = false;\r\n        /** the texture for the geometry */\r\n    @:isVar public var texture      (default,set) : Texture;\r\n        /** the shader for the geometry */\r\n    @:isVar public var shader       (default,set) : Shader;\r\n        /** the base color */\r\n    @:isVar public var color        (default,set) : Color;\r\n        /** the visibility */\r\n    @:isVar public var visible      (default,set) : Bool = true;\r\n        /** the geometry depth value (see guides)*/\r\n    @:isVar public var depth        (default,set) : Float = 0.0;\r\n        /** the geometry group id (see guides)*/\r\n    @:isVar public var group        (default,set) : Int = 0;\r\n        /** If note null, the geometry will be clipped to this rectangle region (in world space). */\r\n    @:isVar public var clip_rect    (default,set) : Rectangle;\r\n        /** convenience: controls the rotation around the z axis, in radians. */\r\n    @:isVar public var radians      (get,set) : Float = 0.0;\r\n        /** convenience: controls the rotation around the z axis, in degrees. */\r\n    public var rotation_z           (get,set) : Float;\r\n\r\n        //private\r\n    var _rotation_euler : Vector;\r\n    var _rotation_quat : Quaternion;\r\n    var _has_custom_origin : Bool = false;\r\n\r\n        /** Create a new visual based on the given options */\r\n    public function new( _options:VisualOptions, ?_pos_info:haxe.PosInfos ) {\r\n\r\n        //safe\r\n        if(_options == null) {\r\n            throw \"Visual needs not-null options at the moment\";\r\n        }\r\n\r\n            //cached values\r\n            //these need to be before super\r\n        _rotation_euler = new Vector();\r\n        _rotation_quat = new Quaternion();\r\n\r\n            //call the entity constructor\r\n        super( _options, _pos_info );\r\n\r\n            //create the position value so we can exploit it a bit\r\n        color = new Color();\r\n        size = new Vector();\r\n\r\n            //texture\r\n        if(options.texture != null) {\r\n            texture = options.texture;\r\n        }\r\n            //shader\r\n        if(options.shader != null) {\r\n            shader = options.shader;\r\n        }\r\n            //color\r\n        if(options.color != null) {\r\n            color = options.color;\r\n        }\r\n            //depth\r\n        if(options.depth != null) {\r\n            depth = options.depth;\r\n        }\r\n            //group\r\n        if(options.group != null) {\r\n            group = options.group;\r\n        }\r\n            //visible\r\n        if(options.visible != null) {\r\n            visible = options.visible;\r\n        }\r\n\r\n            //size is interesting, as it's possibly based on texture\r\n\r\n            //user specified a size\r\n        if(options.size != null) {\r\n\r\n            size = options.size;\r\n                //the size is explicit, so make the geometry\r\n            _create_geometry();\r\n\r\n        } else {\r\n\r\n                //if the texture isn't invalid entirely\r\n            if(texture != null) {\r\n                if(texture.loaded) {\r\n\r\n                    size = new Vector(texture.width, texture.height);\r\n                    _create_geometry();\r\n\r\n                } else {\r\n\r\n                    texture.onload = function(_texture) {\r\n                        size = new Vector(_texture.width, _texture.height);\r\n                        _create_geometry();\r\n                    }\r\n                } //texture is not loaded\r\n\r\n            } else {\r\n                    //default to a value big enough to see\r\n                size = new Vector(64,64);\r\n                // trace('\\t\\tWarning : no texture, or size, handed to visual constructor so going with a default size.');\r\n                _create_geometry();\r\n\r\n            } //texture !=null\r\n\r\n        } //\r\n\r\n    } //new\r\n\r\n    var _creating_geometry : Bool = false;\r\n    @:noCompletion public function _create_geometry() {\r\n\r\n            //if they give a geometry, don't create one\r\n        if(options.geometry == null) {\r\n\r\n            if(options.no_geometry == null || options.no_geometry == false) {\r\n\r\n                _creating_geometry = true;\r\n\r\n                var _batcher : Batcher = null;\r\n                if(options.no_batcher_add == null || options.no_batcher_add == false) {\r\n                    if(options.batcher != null) {\r\n                        _batcher = options.batcher;\r\n                    } else {\r\n                        _batcher = Luxe.renderer.batcher;\r\n                    }\r\n                }\r\n\r\n                    geometry = new QuadGeometry({\r\n                        id:name + '.visual',\r\n                        x:0,\r\n                        y:0,\r\n                        w:size.x,\r\n                        h:size.y,\r\n                        scale: new Vector(1,1,1),\r\n                        texture : texture,\r\n                        color : color,\r\n                        shader : shader,\r\n                        batcher : _batcher,\r\n                        depth : (options.depth == null) ? 0 : options.depth,\r\n                        group : (options.group == null) ? 0 : options.group,\r\n                        visible : (options.visible == null) ? visible : options.visible\r\n                    });\r\n\r\n                _creating_geometry = false;\r\n\r\n                    //call the geometry create listener\r\n                on_geometry_created();\r\n\r\n            } //no_geometry is not present\r\n\r\n        } else {\r\n\r\n            geometry = options.geometry;\r\n\r\n        }\r\n\r\n            //default to the visual name\r\n        if(geometry != null) {\r\n            geometry.id = name + \".visual\";\r\n            geometry.transform.id = name + \".visual.transform\";\r\n        }\r\n\r\n            //custom provided origin will override any until now\r\n        if(options.origin != null) {\r\n            _has_custom_origin = true;\r\n            origin = options.origin;\r\n        }\r\n\r\n            //apply the rotation if any\r\n        if(options.rotation_z != null) {\r\n            rotation_z = options.rotation_z;\r\n        }\r\n\r\n    } //create_geometry\r\n\r\n    override function ondestroy() {\r\n\r\n            //drop the geometry\r\n        if(geometry != null && geometry.added ) {\r\n            geometry.drop( true );\r\n        }\r\n\r\n            //clear our references to these\r\n        geometry = null;\r\n        texture = null;\r\n\r\n    } //ondestroy\r\n\r\n    function on_geometry_created() {\r\n\r\n        // geometry.transform.parent = transform;\r\n\r\n    } //on_geometry_created\r\n\r\n//Visibility properties\r\n\r\n    function set_visible(_v:Bool) {\r\n\r\n        visible = _v;\r\n\r\n            //careful\r\n        if(geometry != null) {\r\n            geometry.visible = visible;\r\n        }\r\n\r\n        return visible;\r\n\r\n    } //set_visible\r\n\r\n    function set_depth(_v:Float) {\r\n\r\n        if(geometry != null) {\r\n            geometry.depth = _v;\r\n        } //geometry\r\n\r\n        return depth = _v;\r\n\r\n    } //set_depth\r\n\r\n    function set_group(_v:Int) {\r\n\r\n        if(geometry != null) {\r\n            geometry.group = _v;\r\n        } //geometry\r\n\r\n        return group = _v;\r\n\r\n    } //set_group\r\n\r\n//Color properties\r\n\r\n    function set_color(_c:Color) {\r\n\r\n        if(color != null && geometry != null) {\r\n            geometry.color = _c;\r\n        }\r\n\r\n        return color = _c;\r\n\r\n    } //set_color\r\n\r\n    function set_texture(_t:Texture) {\r\n\r\n        if(geometry != null && geometry.texture != _t) {\r\n            geometry.texture = _t;\r\n        } //geometry!=null\r\n\r\n        return texture = _t;\r\n    }\r\n\r\n    function set_shader(_s:Shader) {\r\n\r\n        if(geometry != null && geometry.shader != _s) {\r\n            geometry.shader = _s;\r\n        } //geometry!=null\r\n\r\n        return shader = _s;\r\n    }\r\n\r\n//Geometry\r\n\r\n    var ignore_texture_on_geometry_change : Bool = false;\r\n\r\n    function set_geometry(_g:Geometry) : Geometry {\r\n\r\n            //same geometry?\r\n        if(geometry == _g) {\r\n            return geometry;\r\n        }\r\n\r\n            //kill the existing geometry first\r\n        if(geometry != null) {\r\n            geometry.drop();\r\n        }\r\n\r\n            //store the new one\r\n        geometry = _g;\r\n\r\n            //rebind it's colors and whatever else\r\n        if(geometry != null) {\r\n\r\n                //make sure it's attached\r\n            geometry.transform.parent = transform;\r\n\r\n            _verbose('    assign geometry transform as child : $geometry.id to $name');\r\n\r\n                //:todo: This block is dumb\r\n                //and was solving some obscure issue\r\n                //and needs to be redone as it\r\n                //causes more issues than it solves.\r\n                {\r\n                    if(_creating_geometry == false) {\r\n\r\n                        geometry.color = color;\r\n                        geometry.group = group;\r\n                        geometry.depth = depth;\r\n                        geometry.visible = visible;\r\n                        // geometry.shader = shader;\r\n\r\n                        if(!ignore_texture_on_geometry_change) {\r\n                            // geometry.texture = texture;\r\n                        }\r\n\r\n                    } //_creating_geometry == false\r\n                }\r\n\r\n        } //geometry != null\r\n\r\n        return geometry;\r\n\r\n    } //set_geometry\r\n\r\n\r\n//Transforms\r\n\r\n    override function set_parent_from_transform( _parent:Transform ) {\r\n\r\n        super.set_parent_from_transform( _parent );\r\n\r\n        if(geometry != null) {\r\n                //make sure it's attached\r\n            geometry.transform.parent = transform;\r\n        }\r\n\r\n    } //set_parent_from_transform\r\n\r\n    override function set_rotation_from_transform( _rotation:Quaternion ) {\r\n\r\n        super.set_rotation_from_transform(_rotation);\r\n\r\n            //update caches\r\n        _rotation_euler.setEulerFromQuaternion(_rotation);\r\n        _rotation_quat.copy(_rotation);\r\n\r\n    } //set_rotation_from_transform\r\n\r\n//Size\r\n\r\n    function set_size( _v:Vector ) : Vector {\r\n\r\n        size = _v;\r\n\r\n        if(size != null)\r\n            Vector.Listen( size, _size_change );\r\n\r\n        return size;\r\n\r\n    } //set_size\r\n\r\n//Rotation\r\n\r\n    function get_rotation_z() : Float {\r\n\r\n        return Maths.degrees(radians);\r\n\r\n    } //get_rotation\r\n\r\n    function set_rotation_z( _degrees:Float ) : Float {\r\n\r\n        radians = Maths.radians(_degrees);\r\n\r\n        return _degrees;\r\n\r\n    } //set_rotation_z\r\n\r\n    function set_radians(_r:Float) : Float {\r\n\r\n        _rotation_euler.z = _r;\r\n        _rotation_quat.setFromEuler( _rotation_euler );\r\n\r\n        rotation = _rotation_quat.clone();\r\n\r\n        return radians = _r;\r\n\r\n    } //set_radians\r\n\r\n    function get_radians() : Float {\r\n        return radians;\r\n    } //get_radians\r\n\r\n//Locked\r\n\r\n    function set_locked(_l:Bool) : Bool {\r\n\r\n        if(geometry != null) {\r\n            geometry.locked = _l;\r\n        }\r\n\r\n        return locked = _l;\r\n\r\n    } //set_locked\r\n\r\n\r\n//Geometry properties\r\n//Clip rect\r\n    function set_clip_rect(_val : Rectangle) : Rectangle {\r\n\r\n        if(geometry != null) {\r\n            geometry.clip_rect = _val;\r\n        }\r\n\r\n        return clip_rect = _val;\r\n    }\r\n\r\n//Size\r\n\r\n        //An internal callback for when x y or z on a size changes\r\n    function _size_change( _v:Float ) { this.set_size( size ); }\r\n\r\n} //Visual\r\n","package luxe;\r\n\r\nimport luxe.Color;\r\nimport luxe.Rectangle;\r\nimport luxe.Sprite;\r\nimport luxe.Vector;\r\nimport phoenix.Batcher;\r\nimport phoenix.geometry.QuadPackGeometry;\r\nimport phoenix.geometry.CompositeGeometry;\r\nimport phoenix.geometry.QuadGeometry;\r\nimport phoenix.geometry.TextureCoord;\r\n\r\nimport luxe.options.NineSliceOptions;\r\n\r\nprivate typedef Slice = {\r\n    pos : Vector,\r\n    width : Float,\r\n    height : Float,\r\n    source_x : Float,\r\n    source_y : Float,\r\n    source_width : Float,\r\n    source_height : Float,\r\n    geometry_id : Int\r\n};\r\n\r\n/** A nineslice based sprite, for scaling */\r\nclass NineSlice extends luxe.Visual {\r\n\r\n    public var top : Float = 32;\r\n    public var left : Float = 32;\r\n    public var right : Float = 32;\r\n    public var width : Float = 0.0;\r\n    public var bottom : Float = 32;\r\n    public var height : Float = 0.0;\r\n    public var source_x : Float = 0.0;\r\n    public var source_y : Float = 0.0;\r\n    public var source_w : Float = 0.0;\r\n    public var source_h : Float = 0.0;\r\n    public var is_set : Bool = false;\r\n\r\n    @:noCompletion public var midwidth : Float = 0.0;\r\n    @:noCompletion public var midheight : Float = 0.0;\r\n    @:noCompletion public var slices : Array<Slice>;\r\n    @:noCompletion public var added : Bool = false;\r\n    @:noCompletion public var nineslice_options : NineSliceOptions;\r\n    @:noCompletion public var _geometry : QuadPackGeometry;\r\n\r\n    var _batcher : Batcher;\r\n\r\n        /** create a new nineslice with given options */\r\n    public function new( _options:NineSliceOptions ) {\r\n\r\n            //default to internal batcher\r\n        slices = new Array<Slice>();\r\n\r\n            //we need to tell the sprite not to create geometry ,\r\n            //and not to add us to any scenes or anything\r\n        if(_options == null) {\r\n            _options = {\r\n                no_geometry : true,\r\n                no_scene : true\r\n            }\r\n        } else {\r\n            _options.no_geometry = true;\r\n            _options.no_scene = true;\r\n        }\r\n\r\n        nineslice_options = _options;\r\n\r\n        if(_options.batcher != null) {\r\n            _batcher = _options.batcher;\r\n        } else {\r\n            _batcher = Luxe.renderer.batcher;\r\n        }\r\n\r\n            //visual options to parent\r\n        super(_options);\r\n\r\n            //now local options\r\n        if(_options.top != null) top = _options.top;\r\n        if(_options.left != null) left = _options.left;\r\n        if(_options.right != null) right = _options.right;\r\n        if(_options.bottom != null) bottom = _options.bottom;\r\n\r\n        if(_options.source_x != null) { source_x = _options.source_x; }\r\n        if(_options.source_y != null) { source_y = _options.source_y; }\r\n        if(_options.source_w != null) {\r\n            source_w = _options.source_w;\r\n        } else {\r\n            source_w = texture.width;\r\n        }\r\n\r\n        if(_options.source_h != null) {\r\n            source_h = _options.source_h;\r\n        } else {\r\n            source_h = texture.height;\r\n        }\r\n\r\n        geometry = null;\r\n\r\n    } //new\r\n\r\n    public function lock() {\r\n        if(is_set && _geometry != null) {\r\n            _geometry.locked = true;\r\n        }\r\n    } //lock\r\n\r\n    public function dirty() {\r\n        if(is_set && _geometry != null) {\r\n            _geometry.dirty = true;\r\n        }\r\n    } //dirty\r\n\r\n    @:noCompletion public function update_size(_width:Float, _height:Float) {\r\n\r\n        width = _width;\r\n        height = _height;\r\n\r\n        midwidth = Math.abs(width - left - right);\r\n        midheight = Math.abs(height - top - bottom);\r\n\r\n        //top left\r\n        slices[0].source_width  = left;\r\n        slices[0].source_height = top;\r\n        slices[0].source_x = source_x;\r\n        slices[0].source_y = source_y;\r\n        slices[0].pos.set_xy(0,0);\r\n        slices[0].width = left;\r\n        slices[0].height = top;\r\n\r\n        //top middle\r\n        slices[1].source_width  = source_w - left - right;\r\n        slices[1].source_height = top;\r\n        slices[1].source_x = source_x+left;\r\n        slices[1].source_y = source_y;\r\n        slices[1].pos.set_xy(left,0);\r\n        slices[1].width = width - left - right;\r\n        slices[1].height = top;\r\n\r\n        //top right\r\n        slices[2].source_width  = right;\r\n        slices[2].source_height = top;\r\n        slices[2].source_x = source_x+ (source_w - right);\r\n        slices[2].source_y = source_y;\r\n        slices[2].pos.set_xy(left + midwidth,0);\r\n        slices[2].width = right;\r\n        slices[2].height = top;\r\n\r\n\r\n        //middle left\r\n        slices[3].source_width  = left;\r\n        slices[3].source_height = source_h - top - bottom;\r\n        slices[3].source_x = source_x;\r\n        slices[3].source_y = source_y+top;\r\n        slices[3].pos.set_xy(0,top);\r\n        slices[3].width = left;\r\n        slices[3].height = height - top - bottom;\r\n\r\n        //middle middle\r\n        slices[4].source_width  = source_w - left - right;\r\n        slices[4].source_height = source_h - top - bottom;\r\n        slices[4].source_x = source_x+left;\r\n        slices[4].source_y = source_y+top;\r\n        slices[4].pos.set_xy(left,top);\r\n        slices[4].width = width - left - right;\r\n        slices[4].height = height - top - bottom;\r\n\r\n        //middle right\r\n        slices[5].source_width  = right;\r\n        slices[5].source_height = source_h - top - bottom;\r\n        slices[5].source_x = source_x+(source_w - right);\r\n        slices[5].source_y = source_y+top;\r\n        slices[5].pos.set_xy(left + midwidth,top);\r\n        slices[5].width = right;\r\n        slices[5].height = height - top - bottom;\r\n\r\n\r\n        //bottom left\r\n        slices[6].source_width  = left;\r\n        slices[6].source_height = bottom;\r\n        slices[6].source_x = source_x;\r\n        slices[6].source_y = source_y+ (source_h - bottom);\r\n        slices[6].pos.set_xy(0,top + midheight);\r\n        slices[6].width = left;\r\n        slices[6].height = bottom;\r\n\r\n        //bottom middle\r\n        slices[7].source_width  = source_w - left - right;\r\n        slices[7].source_height = bottom;\r\n        slices[7].source_x = source_x+left;\r\n        slices[7].source_y = source_y+(source_h - bottom);\r\n        slices[7].pos.set_xy(left,top + midheight);\r\n        slices[7].width = width - left - right;\r\n        slices[7].height = bottom;\r\n\r\n        //bottom right\r\n        slices[8].source_width  = right;\r\n        slices[8].source_height = bottom;\r\n        slices[8].source_x = source_x+(source_w - right);\r\n        slices[8].source_y = source_y+(source_h - bottom);\r\n        slices[8].pos.set_xy(left + midwidth, top + midheight);\r\n        slices[8].width = right;\r\n        slices[8].height = bottom;\r\n\r\n    } //update_size\r\n\r\n    @:noCompletion public function set(_width:Float, _height:Float) {\r\n\r\n        if(added) {\r\n            _geometry.drop();\r\n            added = false;\r\n        }\r\n\r\n            //clear the slices\r\n        slices.splice(0,slices.length);\r\n        width = _width;\r\n        height = _height;\r\n\r\n        midwidth = Math.abs(width - left - right);\r\n        midheight = Math.abs(height - top - bottom);\r\n\r\n            //top left\r\n        slices.push({\r\n            source_width  : left,\r\n            source_height : top,\r\n            source_x : source_x,\r\n            source_y : source_y,\r\n            pos : new Vector(0,0),\r\n            width : left,\r\n            height : top,\r\n            geometry_id : 0\r\n        });\r\n            //top middle\r\n        slices.push({\r\n            source_width  : source_w - left - right,\r\n            source_height : top,\r\n            source_x : source_x+left,\r\n            source_y : source_y,\r\n            pos : new Vector(left,0),\r\n            width : width - left - right,\r\n            height : top,\r\n            geometry_id : 0\r\n        });\r\n            //top right\r\n        slices.push({\r\n            source_width  : right,\r\n            source_height : top,\r\n            source_x : source_x+ (source_w - right),\r\n            source_y : source_y,\r\n            pos : new Vector(left + midwidth,0),\r\n            width : right,\r\n            height : top,\r\n            geometry_id : 0\r\n        });\r\n\r\n\r\n            //middle left\r\n        slices.push({\r\n            source_width  : left,\r\n            source_height : source_h - top - bottom,\r\n            source_x : source_x,\r\n            source_y : source_y+top,\r\n            pos : new Vector(0,top),\r\n            width : left,\r\n            height : height - top - bottom,\r\n            geometry_id : 0\r\n        });\r\n            //middle middle\r\n        slices.push({\r\n            source_width  : source_w - left - right,\r\n            source_height : source_h - top - bottom,\r\n            source_x : source_x+left,\r\n            source_y : source_y+top,\r\n            pos : new Vector(left,top),\r\n            width : width - left - right,\r\n            height : height - top - bottom,\r\n            geometry_id : 0\r\n        });\r\n            //middle right\r\n        slices.push({\r\n            source_width  : right,\r\n            source_height : source_h - top - bottom,\r\n            source_x : source_x+(source_w - right),\r\n            source_y : source_y+top,\r\n            pos : new Vector(left + midwidth,top),\r\n            width : right,\r\n            height : height - top - bottom,\r\n            geometry_id : 0\r\n        });\r\n\r\n\r\n            //bottom left\r\n        slices.push({\r\n            source_width  : left,\r\n            source_height : bottom,\r\n            source_x : source_x,\r\n            source_y : source_y+ (source_h - bottom),\r\n            pos : new Vector(0,top + midheight),\r\n            width : left,\r\n            height : bottom,\r\n            geometry_id : 0\r\n        });\r\n            //bottom middle\r\n        slices.push({\r\n            source_width  : source_w - left - right,\r\n            source_height : bottom,\r\n            source_x : source_x+left,\r\n            source_y : source_y+(source_h - bottom),\r\n            pos : new Vector(left,top + midheight),\r\n            width : width - left - right,\r\n            height : bottom,\r\n            geometry_id : 0\r\n        });\r\n            //bottom right\r\n        slices.push({\r\n            source_width  : right,\r\n            source_height : bottom,\r\n            source_x : source_x+(source_w - right),\r\n            source_y : source_y+(source_h - bottom),\r\n            pos : new Vector(left + midwidth, top + midheight),\r\n            width : right,\r\n            height : bottom,\r\n            geometry_id : 0\r\n        });\r\n\r\n        is_set = true;\r\n\r\n    } //set\r\n\r\n    override function set_size( _v : Vector ) {\r\n\r\n        if(!is_set) return _v;\r\n            //update the values\r\n        update_size(_v.x, _v.y);\r\n            //update the vertices\r\n        for(slice in slices) {\r\n            if(_geometry != null) {\r\n                _geometry.quad_resize(slice.geometry_id , new Rectangle( slice.pos.x, slice.pos.y, slice.width, slice.height ));\r\n            } //_geometry\r\n        }\r\n\r\n        return _v;\r\n\r\n    } //set_size\r\n\r\n    function _create(_pos:Vector, _w:Float, _h:Float, ?_reset:Bool = false) {\r\n\r\n        if(!is_set || _reset) {\r\n            set(_w, _h);\r\n        }\r\n\r\n        var _color = new Color();\r\n\r\n        _geometry = new QuadPackGeometry({\r\n            texture : texture,\r\n            color : _color,\r\n            depth : nineslice_options.depth,\r\n            group : nineslice_options.group,\r\n            visible : nineslice_options.visible,\r\n            batcher : _batcher\r\n        });\r\n\r\n        for(slice in slices) {\r\n\r\n            slice.geometry_id = _geometry.quad_add({\r\n                x: slice.pos.x,\r\n                y: slice.pos.y,\r\n                w: slice.width,\r\n                h: slice.height,\r\n                color: nineslice_options.color,\r\n                uv: new Rectangle(slice.source_x, slice.source_y, slice.source_width, slice.source_height)\r\n            });\r\n\r\n            // _geometry.quad_pos( slice.geometry_id, new Vector(slice.pos.x, slice.pos.y) );\r\n\r\n        } //each slice\r\n\r\n        _geometry.id = 'NineSlice' + _geometry.id;\r\n        geometry = _geometry;\r\n        pos = _pos;\r\n\r\n        added = true;\r\n        is_set = true;\r\n\r\n    } // _create\r\n\r\n    public function create( _pos:Vector, _w:Float, _h:Float, ?_reset:Bool = false ) {\r\n\r\n        if(!texture.loaded) {\r\n            texture.onload = function(texture){\r\n                _create(_pos,_w,_h,_reset);\r\n            }\r\n        } else {\r\n            _create(_pos,_w,_h,_reset);\r\n        }\r\n\r\n    } //create\r\n\r\n\r\n} //NineSlice\r\n","package luxe.resource;\r\n\r\nimport phoenix.BitmapFont;\r\nimport phoenix.Shader;\r\nimport phoenix.Texture;\r\nimport phoenix.RenderTexture;\r\n\r\nimport luxe.resource.Resource;\r\n\r\n\r\nclass Resources {\r\n\r\n\r\n    public var resourcelist : Array<Resource>;\r\n        //cache lists for creating\r\n    public var render_textures : Map<String,RenderTexture>;\r\n    public var textures : Map<String,Texture>;\r\n    public var shaders : Map<String,Shader>;\r\n    public var fonts : Map<String,BitmapFont>;\r\n    public var data : Map<String,DataResource>;\r\n    public var text : Map<String,TextResource>;\r\n    public var json : Map<String,JSONResource>;\r\n    public var sounds : Map<String,SoundResource>;\r\n\r\n    public var stats : ResourceStats;\r\n\r\n\r\n    public function new( ) {\r\n\r\n        resourcelist = new Array<Resource>();\r\n        textures = new Map();\r\n        render_textures = new Map();\r\n        fonts = new Map();\r\n        shaders = new Map();\r\n        sounds = new Map();\r\n        data = new Map();\r\n        text = new Map();\r\n        json = new Map();\r\n        stats = new ResourceStats();\r\n\r\n    } //new\r\n\r\n    public function add( res:Resource ) {\r\n\r\n        resourcelist.push(res);\r\n\r\n        switch (res.type) {\r\n\r\n            case ResourceType.texture:          stats.textures++;\r\n            case ResourceType.render_texture:   stats.render_textures++;\r\n            case ResourceType.font:             stats.fonts++;\r\n            case ResourceType.shader:           stats.shaders++;\r\n            case ResourceType.sound:            stats.sounds++;\r\n            case ResourceType.text:             stats.texts++;\r\n            case ResourceType.json:             stats.jsons++;\r\n            case ResourceType.data:             stats.datas++;\r\n            case ResourceType.unknown:          stats.unknown++;\r\n\r\n        } //switch\r\n\r\n        stats.resources++;\r\n\r\n    } //add\r\n\r\n    public function remove( res:Resource ) {\r\n\r\n        resourcelist.remove(res);\r\n        uncache(res);\r\n\r\n        switch (res.type) {\r\n\r\n            case ResourceType.texture:          stats.textures--;\r\n            case ResourceType.render_texture:   stats.render_textures--;\r\n            case ResourceType.font:             stats.fonts--;\r\n            case ResourceType.shader:           stats.shaders--;\r\n            case ResourceType.sound:            stats.sounds--;\r\n            case ResourceType.text:             stats.texts--;\r\n            case ResourceType.json:             stats.jsons--;\r\n            case ResourceType.data:             stats.datas--;\r\n            case ResourceType.unknown:          stats.unknown--;\r\n        }\r\n\r\n        stats.resources--;\r\n\r\n    } //remove\r\n\r\n    public function uncache(res:Resource) {\r\n\r\n        switch (res.type) {\r\n\r\n            case ResourceType.texture:          textures.remove(res.id);\r\n            case ResourceType.render_texture:   render_textures.remove(res.id);\r\n            case ResourceType.font:             fonts.remove(res.id);\r\n            case ResourceType.shader:           shaders.remove(res.id);\r\n            case ResourceType.sound:            sounds.remove(res.id);\r\n            case ResourceType.data:             data.remove(res.id);\r\n            case ResourceType.text:             text.remove(res.id);\r\n            case ResourceType.json:             json.remove(res.id);\r\n            case ResourceType.unknown:\r\n\r\n        } //switch\r\n\r\n    } //uncache\r\n\r\n    public function cache( res:Resource ) {\r\n\r\n        switch (res.type) {\r\n\r\n            case ResourceType.texture:          textures.set(res.id, cast res);\r\n            case ResourceType.render_texture:   render_textures.set(res.id, cast res);\r\n            case ResourceType.font:             fonts.set(res.id, cast res);\r\n            case ResourceType.shader:           shaders.set(res.id, cast res);\r\n            case ResourceType.sound:            sounds.set(res.id, cast res);\r\n            case ResourceType.text:             text.set(res.id, cast res);\r\n            case ResourceType.json:             json.set(res.id, cast res);\r\n            case ResourceType.data:             data.set(res.id, cast res);\r\n            case ResourceType.unknown:\r\n\r\n        } //switch\r\n\r\n    } //cache\r\n\r\n    public function find_render_texture( _name:String ) return render_textures.get(_name);\r\n    public function find_texture( _name:String ) return textures.get(_name);\r\n    public function find_shader( _name:String ) return shaders.get(_name);\r\n    public function find_font( _name:String ) return fonts.get(_name);\r\n    public function find_sound( _name:String ) return sounds.get(_name);\r\n    public function find_text( _name:String ) return text.get(_name);\r\n    public function find_json( _name:String ) return json.get(_name);\r\n    public function find_data( _name:String ) return data.get(_name);\r\n\r\n\r\n    public function clear( ?and_persistent : Bool = false ) {\r\n\r\n        var keep = [];\r\n        for(res in resourcelist) {\r\n            if(!res.persistent || and_persistent) {\r\n                res.drop();\r\n            } else {\r\n                keep.push(res);\r\n            }\r\n        }\r\n\r\n            //kill everything, and readd them\r\n            //will reset the counters for internal data\r\n        resourcelist.splice(0,resourcelist.length);\r\n        resourcelist = new Array<Resource>();\r\n        stats.reset();\r\n\r\n            //readd\r\n        for(res in keep) {\r\n            add(res);\r\n        }\r\n\r\n        keep = null;\r\n\r\n    } //clear\r\n\r\n    public function find( id : String ) : Resource {\r\n\r\n        for(resource in resourcelist) {\r\n            if(resource.id == id) {\r\n                return resource;\r\n            }\r\n        }\r\n\r\n        return null;\r\n\r\n    } //find\r\n\r\n\r\n} //Resources\r\n\r\n\r\n\r\nclass ResourceStats {\r\n\r\n\r\n    public var resources : Int = 0;\r\n    public var fonts : Int = 0;\r\n    public var textures : Int = 0;\r\n    public var render_textures : Int = 0;\r\n    public var shaders : Int = 0;\r\n    public var texts : Int = 0;\r\n    public var jsons : Int = 0;\r\n    public var datas : Int = 0;\r\n    public var sounds : Int = 0;\r\n    public var unknown : Int = 0;\r\n\r\n\r\n    public function new() {\r\n\r\n    } //new\r\n\r\n    function toString() {\r\n\r\n        return\r\n            'Resource Statistics\\n' +\r\n            '\\ttotal resources : ' + resources + '\\n' +\r\n            '\\ttextures : ' + textures + ' \\n' + '' +\r\n            '\\trender textures : ' + render_textures + ' \\n' +\r\n            '\\tfonts : ' + fonts + '\\n' +\r\n            '\\tshaders : ' + shaders + '\\n' +\r\n            '\\tsounds : ' + sounds + '\\n' +\r\n            '\\ttext : ' + texts + '\\n' +\r\n            '\\tjson : ' + jsons + '\\n' +\r\n            '\\tdata : ' + datas + '\\n' +\r\n            '\\tunknown : ' + unknown;\r\n\r\n    } //toString\r\n\r\n    public function reset() {\r\n\r\n        resources = 0;\r\n        fonts = 0;\r\n        textures = 0;\r\n        render_textures = 0;\r\n        shaders = 0;\r\n        texts = 0;\r\n        jsons = 0;\r\n        datas = 0;\r\n        sounds = 0;\r\n        unknown = 0;\r\n\r\n    } //reset\r\n\r\n\r\n} //ResourceStats\r\n","package luxe;\r\n\r\nimport luxe.resource.Resource;\r\nimport luxe.options.ParcelOptions;\r\n\r\nimport luxe.Log._verbose;\r\nimport luxe.Log._debug;\r\nimport luxe.Log.log;\r\n\r\n\r\nprivate typedef ShaderInfo = {\r\n    ps_id : String,\r\n    vs_id : String\r\n}\r\n\r\nprivate typedef FontInfo = {\r\n    id : String,\r\n    texture_path : String\r\n}\r\n\r\nprivate typedef DataInfo = {\r\n    id : String\r\n}\r\n\r\nprivate typedef TextInfo = DataInfo;\r\nprivate typedef JSONInfo = DataInfo;\r\n\r\nprivate typedef SoundInfo = {\r\n    id : String,\r\n    name : String,\r\n    is_stream : Bool\r\n}\r\n\r\nclass Parcel extends luxe.resource.Resources {\r\n\r\n    public var time_to_load : Float = 0;\r\n    var time_start_load : Float = 0;\r\n\r\n    var texture_list : Array<String>;\r\n    var shader_list : Array<ShaderInfo>;\r\n    var font_list : Array<FontInfo>;\r\n    var sound_list : Array<SoundInfo>;\r\n    var text_list : Array<TextInfo>;\r\n    var json_list : Array<JSONInfo>;\r\n    var data_list : Array<DataInfo>;\r\n\r\n    public var total_items : Int = 0;\r\n    public var current_count : Int = 0;\r\n    public var options : ParcelOptions;\r\n\r\n    public function new( ?_options:ParcelOptions ) {\r\n\r\n        super();\r\n\r\n        options = _options != null ? _options : {};\r\n\r\n        if( options.load_spacing == null ) { options.load_spacing = 0.1; }\r\n        if( options.start_spacing == null ) { options.start_spacing = 0.4; }\r\n        if( options.sequential == null ) { options.sequential = false; }\r\n        if( options.silent == null ) { options.silent = false; }\r\n\r\n        texture_list    = [];\r\n        font_list       = [];\r\n        shader_list     = [];\r\n        sound_list      = [];\r\n        text_list       = [];\r\n        json_list       = [];\r\n        data_list       = [];\r\n\r\n    } //new\r\n\r\n//Load the parcel up\r\n\r\n    var index_textures  : Int = 0;\r\n    var index_fonts     : Int = 0;\r\n    var index_shaders   : Int = 0;\r\n    var index_sounds    : Int = 0;\r\n    var index_datas     : Int = 0;\r\n    var index_texts     : Int = 0;\r\n    var index_jsons     : Int = 0;\r\n\r\n    function refresh_total_items() {\r\n\r\n        total_items =\r\n            texture_list.length +\r\n            shader_list.length  +\r\n            font_list.length    +\r\n            sound_list.length   +\r\n            text_list.length    +\r\n            json_list.length    +\r\n            data_list.length;\r\n    }\r\n\r\n    public function load() {\r\n\r\n        time_start_load = Luxe.time;\r\n        current_count = 0;\r\n\r\n        refresh_total_items();\r\n\r\n        if( total_items == 0 ) {\r\n            do_complete();\r\n            return;\r\n        }\r\n\r\n        _debug('loading parcel ${options.start_spacing}s from now');\r\n\r\n        Luxe.timer.schedule(options.start_spacing, function(){\r\n\r\n            if(!options.silent) log(\"starting load\");\r\n\r\n            if( !options.sequential ) {\r\n\r\n                start_textures_load();\r\n                start_fonts_load();\r\n                start_shaders_load();\r\n                start_sounds_load();\r\n                start_texts_load();\r\n                start_jsons_load();\r\n                start_datas_load();\r\n\r\n            } else {\r\n\r\n                start_textures_load();\r\n\r\n            }\r\n\r\n        }); //timer schedule\r\n\r\n    } //load\r\n\r\n    public function from_json( _json_object:Dynamic ) {\r\n\r\n        if(_json_object != null) {\r\n\r\n            if(_json_object.textures != null) {\r\n                var _textures : Array<Dynamic> = cast _json_object.textures;\r\n                for(item in _textures) {\r\n                    if(item != null) {\r\n                        var id : String = item.id == null ? '' : cast item.id;\r\n                        if(id != '') {\r\n                            add_texture( id );\r\n                        } else {\r\n                            log(\"texture not added due to incomplete info: \" + item);\r\n                        }\r\n                    } //item != null\r\n                } //item in textures\r\n            } //json object textures\r\n\r\n            if(_json_object.shaders != null) {\r\n                var _shaders : Array<Dynamic> = cast _json_object.shaders;\r\n                for(item in _shaders) {\r\n                    if(item != null) {\r\n                        var ps_id : String = item.ps_id == null ? 'default' : cast item.ps_id;\r\n                        var vs_id : String = item.vs_id == null ? 'default' : cast item.vs_id;\r\n\r\n                        add_shader(ps_id, vs_id);\r\n\r\n                    } //item != null\r\n                } //item in shaders\r\n            } //json object shaders\r\n\r\n            if(_json_object.fonts != null) {\r\n                var _fonts : Array<Dynamic> = cast _json_object.fonts;\r\n                for(item in _fonts) {\r\n                    if(item != null) {\r\n                        var id : String = item.id == null ? '' : cast item.id;\r\n                        if(id != '') {\r\n                            add_font(id, cast item.texture_path);\r\n                        } else {\r\n                            log(\"font not added due to incomplete info: \" + item);\r\n                        }\r\n                    } //item != null\r\n                } //item in fonts\r\n            } //json object fonts\r\n\r\n            if(_json_object.sounds != null) {\r\n                var _sounds : Array<Dynamic> = cast _json_object.sounds;\r\n                for(item in _sounds) {\r\n                    if(item != null) {\r\n                        var id : String = item.id == null ? '' : cast item.id;\r\n                        var name : String = item.name == null ? '' : cast item.name;\r\n                        var is_stream : Bool = item.is_stream == null ? false : cast item.is_stream;\r\n                        if(id != '' && name != '') {\r\n                            add_sound( id, name, is_stream);\r\n                        } else {\r\n                            log(\"sounds not added due to incomplete info: \" + item);\r\n                        }\r\n                    } //item != null\r\n                } //each sounds\r\n            } //json object sounds\r\n\r\n            if(_json_object.text != null) {\r\n                var _texts : Array<Dynamic> = cast _json_object.text;\r\n                for(item in _texts) {\r\n                    if(item != null) {\r\n                        var id : String = item.id == null ? '' : cast item.id;\r\n                        if(id != '') {\r\n                            add_text( id );\r\n                        }  else {\r\n                            log(\"text not added due to incomplete info: \" + item);\r\n                        }//id != ''\r\n                    } //item != null\r\n                } //each text\r\n            } //json object text\r\n\r\n            if(_json_object.json != null) {\r\n                var _jsons : Array<Dynamic> = cast _json_object.json;\r\n                for(item in _jsons) {\r\n                    if(item != null) {\r\n                        var id : String = item.id == null ? '' : cast item.id;\r\n                        if(id != '') {\r\n                            add_json( id );\r\n                        }  else {\r\n                            log(\"json not added due to incomplete info: \" + item);\r\n                        }//id != ''\r\n                    } //item != null\r\n                } //each json\r\n            } //json object json\r\n\r\n            if(_json_object.data != null) {\r\n                var _datas : Array<Dynamic> = cast _json_object.data;\r\n                for(item in _datas) {\r\n                    if(item != null) {\r\n                        var id : String = item.id == null ? '' : cast item.id;\r\n                        if(id != '') {\r\n                            add_data( id );\r\n                        } else {\r\n                            log(\"data not added due to incomplete info: \" + item);\r\n                        }\r\n                    }\r\n                }\r\n            } //json object data\r\n\r\n        } //json_object\r\n\r\n        refresh_total_items();\r\n\r\n    } //from_json\r\n\r\n//Texture\r\n\r\n    function start_textures_load() {\r\n\r\n        if(texture_list.length > 0) {\r\n\r\n            index_textures = 0;\r\n\r\n            if(options.sequential) {\r\n\r\n                    //load recursive so that it is sequential\r\n                recursive_load_textures( null );\r\n\r\n            } else {\r\n\r\n                    //load all fonts immediately\r\n                    //whether that's sequential or not\r\n                load_textures();\r\n\r\n\r\n            } //sequential\r\n\r\n        } else { //texture_list\r\n\r\n            if( options.sequential ) {\r\n                start_fonts_load();\r\n            }\r\n\r\n        }\r\n\r\n    } //start_texture_load\r\n\r\n//Font\r\n\r\n    function start_fonts_load() {\r\n\r\n        if(font_list.length > 0) {\r\n\r\n            index_fonts = 0;\r\n\r\n            if(options.sequential) {\r\n\r\n                    //load recursive so that it is sequential\r\n                recursive_load_fonts( null );\r\n\r\n            } else {\r\n\r\n                    //load all fonts immediately\r\n                    //whether that's sequential or not\r\n                load_fonts();\r\n\r\n            } //sequential\r\n\r\n        } else { //font_list > 0\r\n\r\n            if( options.sequential ) {\r\n                start_shaders_load();\r\n            }\r\n\r\n        }\r\n\r\n    } //start_fonts_load\r\n\r\n//Shader\r\n\r\n    function start_shaders_load() {\r\n\r\n        if(shader_list.length > 0) {\r\n\r\n            index_shaders = 0;\r\n\r\n            if(options.sequential) {\r\n\r\n                    //load recursive so that it is sequential\r\n                recursive_load_shaders( null );\r\n\r\n            } else {\r\n\r\n                    //load all fonts immediately\r\n                    //whether that's sequential or not\r\n                load_shaders();\r\n\r\n            } //sequential\r\n\r\n        } else { //shader_list > 0\r\n\r\n            if( options.sequential ) {\r\n                start_sounds_load();\r\n            }\r\n\r\n        }\r\n\r\n    } //start_shaders_load\r\n\r\n//Sound\r\n\r\n    function start_sounds_load() {\r\n\r\n        if(sound_list.length > 0) {\r\n\r\n            index_sounds = 0;\r\n\r\n            if(options.sequential) {\r\n\r\n                    //load recursive so that it is sequential\r\n                recursive_load_sounds( null );\r\n\r\n            } else {\r\n\r\n                    //load all fonts immediately\r\n                    //whether that's sequential or not\r\n                load_sounds();\r\n\r\n            } //sequential\r\n\r\n        } else { //sound_list > 0\r\n\r\n            if( options.sequential ) {\r\n                start_texts_load();\r\n            }\r\n\r\n        }\r\n\r\n    } //start_sounds_load\r\n\r\n//Texts\r\n\r\n    function start_texts_load() {\r\n\r\n        if(text_list.length > 0) {\r\n\r\n            index_texts = 0;\r\n\r\n            if(options.sequential) {\r\n\r\n                    //load recursive so that it is sequential\r\n                recursive_load_texts( null );\r\n\r\n            } else {\r\n\r\n                    //load all texts immediately\r\n                    //whether that's sequential or not\r\n                load_texts();\r\n\r\n            } //sequential\r\n\r\n        } else { //text_list > 0\r\n\r\n            if( options.sequential ) {\r\n                start_jsons_load();\r\n            }\r\n\r\n        }\r\n\r\n    } //start_texts_load\r\n\r\n\r\n//JSONs\r\n\r\n    function start_jsons_load() {\r\n\r\n        if(json_list.length > 0) {\r\n\r\n            index_jsons = 0;\r\n\r\n            if(options.sequential) {\r\n\r\n                    //load recursive so that it is sequential\r\n                recursive_load_jsons( null );\r\n\r\n            } else {\r\n\r\n                    //load all jsons immediately\r\n                    //whether that's sequential or not\r\n                load_jsons();\r\n\r\n            } //sequential\r\n\r\n        } else { //json_list > 0\r\n\r\n            if( options.sequential ) {\r\n                start_datas_load();\r\n            }\r\n\r\n        }\r\n\r\n    } //start_jsons_load\r\n\r\n//Data\r\n\r\n    function start_datas_load() {\r\n\r\n        if(data_list.length > 0) {\r\n\r\n            index_datas = 0;\r\n\r\n            if(options.sequential) {\r\n\r\n                    //load recursive so that it is sequential\r\n                recursive_load_datas( null );\r\n\r\n            } else {\r\n\r\n                    //load all datas immediately\r\n                    //whether that's sequential or not\r\n                load_datas();\r\n\r\n            } //sequential\r\n\r\n        } else { //data_list > 0\r\n            //last in the list\r\n        }\r\n\r\n    } //start_datas_load\r\n\r\n\r\n//Texture\r\n\r\n    function load_textures() {\r\n        for(tex in texture_list) {\r\n            load_texture( tex, single_item_complete );\r\n        }\r\n    }\r\n\r\n//Font\r\n\r\n    function load_fonts() {\r\n        for(fnt in font_list) {\r\n            load_font( fnt, single_item_complete );\r\n        }\r\n    }\r\n\r\n//Shader\r\n\r\n    function load_shaders() {\r\n        for(shader in shader_list) {\r\n            load_shader( shader, single_item_complete );\r\n        }\r\n    }\r\n\r\n//Sound\r\n\r\n    function load_sounds() {\r\n        for(sound in sound_list) {\r\n            load_sound( sound, single_item_complete );\r\n        }\r\n    }\r\n\r\n//Data\r\n\r\n    function load_datas() {\r\n        for(data in data_list) {\r\n            load_data( data, single_item_complete );\r\n        }\r\n    }\r\n\r\n//Text\r\n\r\n    function load_texts() {\r\n        for(text in text_list) {\r\n            load_text( text, single_item_complete );\r\n        }\r\n    }\r\n\r\n//JSON\r\n\r\n    function load_jsons() {\r\n        for(json in json_list) {\r\n            load_json( json, single_item_complete );\r\n        }\r\n    }\r\n\r\n\r\n//Texture\r\n\r\n    function recursive_load_textures( item:Resource ) {\r\n\r\n        if(item != null) {\r\n\r\n            single_item_complete( item );\r\n\r\n            if(index_textures == texture_list.length && options.sequential) {\r\n                start_fonts_load();\r\n            }\r\n\r\n        }\r\n\r\n            //if you are debugging progress, change this line and it's closing brace\r\n        // Luxe.timer.schedule(1, function(){\r\n\r\n            if( index_textures < texture_list.length ) {\r\n                    //hold current so we can skip\r\n                var current = index_textures;\r\n                    //increase count for complete around\r\n                index_textures++;\r\n                    //send off\r\n                load_texture( texture_list[current], recursive_load_textures );\r\n\r\n            } //not past max length\r\n\r\n        // });  //schedule closing brace\r\n\r\n    } //recursive_load_textures\r\n\r\n//Shader\r\n\r\n    function recursive_load_shaders( item:Resource ) {\r\n\r\n        if(item != null) {\r\n\r\n            single_item_complete( item );\r\n\r\n            if(index_shaders == shader_list.length && options.sequential) {\r\n                start_sounds_load();\r\n            }\r\n\r\n        }\r\n\r\n            //if you are debugging progress, change this line and it's closing brace\r\n        // Luxe.timer.schedule(1, function(){\r\n\r\n            if( index_shaders < shader_list.length ) {\r\n                    //hold current so we can skip\r\n                var current = index_shaders;\r\n                    //increase count for complete around\r\n                index_shaders++;\r\n                    //send off\r\n                load_shader( shader_list[current], recursive_load_shaders );\r\n\r\n            } //not past max length\r\n\r\n        // });  //schedule closing brace\r\n\r\n    } //recursive_load_shaders\r\n\r\n//Font\r\n\r\n    function recursive_load_fonts( item:Resource ) {\r\n\r\n        if(item != null) {\r\n\r\n            single_item_complete( item );\r\n\r\n            if(index_fonts == font_list.length && options.sequential) {\r\n                start_shaders_load();\r\n            }\r\n\r\n        }\r\n\r\n            //if you are debugging progress, change this line and it's closing brace\r\n        // Luxe.timer.schedule(1, function(){\r\n\r\n            if( index_fonts < font_list.length ) {\r\n                    //hold current so we can skip\r\n                var current = index_fonts;\r\n                    //increase count for complete around\r\n                index_fonts++;\r\n                    //send off\r\n                load_font( font_list[current], recursive_load_fonts );\r\n\r\n            } //not past max length\r\n\r\n        // });  //schedule closing brace\r\n\r\n    } //recursive_load_fonts\r\n\r\n//Sound\r\n\r\n    function recursive_load_sounds( item:Resource ) {\r\n\r\n        if(item != null) {\r\n\r\n            single_item_complete( item );\r\n\r\n            if(index_sounds == sound_list.length && options.sequential) {\r\n                start_texts_load();\r\n            }\r\n\r\n        }\r\n\r\n            //if you are debugging progress, change this line and it's closing brace\r\n        // Luxe.timer.schedule(1, function(){\r\n\r\n            if( index_sounds < sound_list.length ) {\r\n                    //hold current so we can skip\r\n                var current = index_sounds;\r\n                    //increase count for complete around\r\n                index_sounds++;\r\n                    //send off\r\n                load_sound( sound_list[current], recursive_load_sounds );\r\n\r\n            } //not past max length\r\n\r\n        // });  //schedule closing brace\r\n\r\n    } //recursive_load_sounds\r\n\r\n//Data\r\n\r\n    function recursive_load_datas( item:Resource ) {\r\n\r\n        if(item != null) {\r\n            single_item_complete( item );\r\n        }\r\n\r\n            //if you are debugging progress, change this line and it's closing brace\r\n        // Luxe.timer.schedule(1, function(){\r\n\r\n            if( index_datas < data_list.length ) {\r\n                    //hold current so we can skip\r\n                var current = index_datas;\r\n                    //increase count for complete around\r\n                index_datas++;\r\n                    //send off\r\n                load_data( data_list[current], recursive_load_datas );\r\n\r\n            } //not past max length\r\n\r\n        // });  //schedule closing brace\r\n\r\n    } //recursive_load_datas\r\n\r\n//Text\r\n\r\n    function recursive_load_texts( item:Resource ) {\r\n\r\n        if(item != null) {\r\n\r\n            single_item_complete( item );\r\n\r\n            if(index_texts == text_list.length && options.sequential) {\r\n                start_jsons_load();\r\n            }\r\n\r\n        }\r\n\r\n            //if you are debugging progress, change this line and it's closing brace\r\n        // Luxe.timer.schedule(1, function(){\r\n\r\n            if( index_texts < text_list.length ) {\r\n                    //hold current so we can skip\r\n                var current = index_texts;\r\n                    //increase count for complete around\r\n                index_texts++;\r\n                    //send off\r\n                load_text( text_list[current], recursive_load_texts );\r\n\r\n            } //not past max length\r\n\r\n        // });  //schedule closing brace\r\n\r\n    } //recursive_load_texts\r\n\r\n//JSON\r\n\r\n    function recursive_load_jsons( item:Resource ) {\r\n\r\n        if(item != null) {\r\n\r\n            single_item_complete( item );\r\n\r\n            if(index_jsons == json_list.length && options.sequential) {\r\n                start_datas_load();\r\n            }\r\n\r\n        }\r\n\r\n            //if you are debugging progress, change this line and it's closing brace\r\n        // Luxe.timer.schedule(1, function(){\r\n\r\n            if( index_jsons < json_list.length ) {\r\n                    //hold current so we can skip\r\n                var current = index_jsons;\r\n                    //increase count for complete around\r\n                index_jsons++;\r\n                    //send off\r\n                load_json( json_list[current], recursive_load_jsons );\r\n\r\n            } //not past max length\r\n\r\n        // });  //schedule closing brace\r\n\r\n    } //recursive_load_jsons\r\n\r\n//Public api for preparing a parcel\r\n\r\n//Texture\r\n\r\n    public function add_texture( _id:String ) {\r\n        texture_list.push(_id);\r\n    } //add_texture\r\n\r\n    public function add_textures( list:Array<String> ) {\r\n        for(texture in list) {\r\n            texture_list.push(texture);\r\n        }\r\n    } //add_textures\r\n\r\n//Shader\r\n\r\n    public function add_shader( ps_id:String='default', vs_id:String='default' ) {\r\n        shader_list.push({ ps_id:ps_id, vs_id:vs_id });\r\n    } //add_shader\r\n\r\n    public function add_shaders( list:Array<ShaderInfo> ) {\r\n        for(shader_info in list) {\r\n            shader_list.push( shader_info );\r\n        }\r\n    } //add_shaders\r\n\r\n//Font\r\n\r\n    public function add_font( _id:String, ?_texture_path:String ) {\r\n        font_list.push( { id:_id, texture_path:_texture_path });\r\n    } //add_font\r\n\r\n    public function add_fonts( list:Array<FontInfo> ) {\r\n        for(font_info in list) {\r\n            font_list.push( font_info );\r\n        }\r\n    } //add_fonts\r\n\r\n//Sound\r\n\r\n    public function add_sound( _id:String, _name:String, _is_stream:Bool = false ) {\r\n        sound_list.push( { id:_id, name:_name, is_stream:_is_stream });\r\n    } //add_sound\r\n\r\n    public function add_sounds( list:Array<SoundInfo> ) {\r\n        for(sound_info in list) {\r\n            sound_list.push( sound_info );\r\n        }\r\n    } //add_sounds\r\n\r\n//Text\r\n\r\n    public function add_text( _id:String ) {\r\n        text_list.push({ id:_id });\r\n    } //add_text\r\n\r\n    public function add_texts( list:Array<TextInfo> ) {\r\n        for(text_info in list) {\r\n            text_list.push( text_info );\r\n        }\r\n    } //add_texts\r\n\r\n//JSON\r\n\r\n    public function add_json( _id:String ) {\r\n        json_list.push({ id:_id });\r\n    } //add_json\r\n\r\n    public function add_jsons( list:Array<JSONInfo> ) {\r\n        for(json_info in list) {\r\n            json_list.push( json_info );\r\n        }\r\n    } //add_jsons\r\n\r\n//Data\r\n\r\n    public function add_data( _id:String ) {\r\n        data_list.push({ id:_id });\r\n    } //add_data\r\n\r\n    public function add_datas( list:Array<DataInfo> ) {\r\n        for(data in list) {\r\n            data_list.push( data );\r\n        }\r\n    } //add_datas\r\n\r\n\r\n//Per item handlers\r\n\r\n    function load_texture( _tex:String, _complete ) {\r\n        #if luxe_parcel_logging log(\"    loading texture \" + _tex ); #end\r\n\r\n        Luxe.timer.schedule( options.load_spacing, function(){\r\n            Luxe.loadTexture( _tex, _complete, options.silent );\r\n        });\r\n\r\n    } //load_texture\r\n\r\n    function load_shader( _shader:ShaderInfo, _complete ) {\r\n        #if luxe_parcel_logging log(\"    loading shader \" + _shader.ps_id + _shader.vs_id ); #end\r\n\r\n        Luxe.timer.schedule( options.load_spacing, function(){\r\n            Luxe.loadShader( _shader.ps_id, _shader.vs_id, _complete, options.silent );\r\n        });\r\n\r\n    } //load_shader\r\n\r\n    function load_font( _font:FontInfo, _complete ) {\r\n        #if luxe_parcel_logging log(\"    loading font \" + _font.id + \" with optional texture path = \" + _font.texture_path ); #end\r\n\r\n        Luxe.timer.schedule( options.load_spacing, function(){\r\n            Luxe.loadFont( _font.id, _font.texture_path, _complete, options.silent );\r\n        });\r\n\r\n    } //load_font\r\n\r\n    function load_data( _data_info:DataInfo, _complete ) {\r\n        #if luxe_parcel_logging log(\"    loading data \" + _data_info ); #end\r\n\r\n        Luxe.timer.schedule( options.load_spacing, function(){\r\n            Luxe.loadData( _data_info.id, _complete );\r\n        });\r\n\r\n    } //load_data_path\r\n\r\n    function load_text( _text_info:TextInfo, _complete ) {\r\n        #if luxe_parcel_logging log('    loading text $_text_info' ); #end\r\n\r\n        Luxe.timer.schedule( options.load_spacing, function(){\r\n            Luxe.loadText( _text_info.id, _complete );\r\n        });\r\n\r\n    } //load_text\r\n\r\n    function load_json( _json_info:JSONInfo, _complete ) {\r\n        #if luxe_parcel_logging log('    loading json $_json_info' ); #end\r\n\r\n        Luxe.timer.schedule( options.load_spacing, function(){\r\n            Luxe.loadJSON( _json_info.id, _complete );\r\n        });\r\n\r\n    } //load_json\r\n\r\n    function load_sound( _sound:SoundInfo, _complete ) {\r\n        #if luxe_parcel_logging log(\"    loading sound \" + _sound.id + \" (\" + _sound.name + \")\" ); #end\r\n\r\n        Luxe.timer.schedule( options.load_spacing, function(){\r\n            Luxe.loadSound( _sound.name, _sound.id, _sound.is_stream, _complete );\r\n        });\r\n\r\n    } //load_sound\r\n\r\n//Complete internal handler\r\n\r\n    function do_complete() {\r\n\r\n            //figure out how long\r\n        time_to_load = Luxe.time - time_start_load;\r\n\r\n            //tell the creator\r\n        if( options.oncomplete != null ) {\r\n            options.oncomplete( this );\r\n        }\r\n\r\n    } //do_complete\r\n\r\n//Per item complete handler\r\n\r\n    function single_item_complete( item:Resource ) {\r\n\r\n        item.time_to_load = Luxe.time - item.time_created;\r\n\r\n        current_count++;\r\n\r\n        #if luxe_parcel_logging\r\n            log( \"    parcel: item finished \" + item.id + \"( \" + current_count + \"/\" + total_items + \" )\");\r\n        #end //luxe_parcel_logging\r\n\r\n        if(options.onprogress != null) {\r\n            options.onprogress( item );\r\n        }\r\n\r\n            //There will always be a 0.1 second delay before\r\n            //oncomplete to allow for progress bar renders to complete\r\n        if(current_count >= total_items) {\r\n            Luxe.timer.schedule(0.1, function(){\r\n                do_complete();\r\n            });\r\n        }\r\n\r\n    } //single_item_complete\r\n\r\n}\r\n","package luxe;\r\n\r\nimport luxe.resource.Resource;\r\n\r\nimport luxe.Parcel;\r\nimport luxe.Sprite;\r\nimport luxe.Color;\r\nimport luxe.options.ParcelProgressOptions;\r\n\r\nclass ParcelProgress {\r\n\r\n    var parcel : Parcel;\r\n\r\n        //Parcle progress will create a fullscreen overlay\r\n        //color background, logo image, and a progress bar\r\n    var progress_bar        : Sprite;\r\n    var progress_border     : Visual;\r\n    var background          : Sprite;\r\n\r\n    var image_logo          : Sprite;\r\n    var options             : ParcelProgressOptions;\r\n\r\n        //for now,\r\n    var width : Float = 0;\r\n    var height : Float = 0;\r\n\r\n    public function new( _options:ParcelProgressOptions ) {\r\n\r\n        var _view_width = Luxe.screen.w;\r\n        var _view_height = Luxe.screen.h;\r\n\r\n        if(Luxe.camera.size != null) {\r\n            _view_width = Luxe.camera.size.x;\r\n            _view_height = Luxe.camera.size.y;\r\n        }\r\n\r\n        var _view_mid_x = Math.floor(_view_width/2);\r\n        var _view_mid_y = Math.floor(_view_height/2);\r\n\r\n        options = _options;\r\n\r\n        if(options.bar == null) {\r\n            options.bar = new Color().rgb(0x343434);\r\n        }\r\n\r\n        if(options.bar_border == null) {\r\n            options.bar_border = new Color().rgb(0x161616);\r\n        }\r\n\r\n        if(options.background == null) {\r\n            options.background = new Color().rgb(0x090909);\r\n        }\r\n\r\n        if(options.fade_in == null) {\r\n            options.fade_in = true;\r\n        }\r\n\r\n        if(options.fade_out == null) {\r\n            options.fade_out = true;\r\n        }\r\n\r\n        if(options.fade_time == null) {\r\n            options.fade_time = 0.3;\r\n        }\r\n\r\n        // if(options.texture != null) {\r\n        //     image_logo = new Sprite({\r\n        //         texture : options.texture,\r\n        //         pos : Luxe.screen.mid\r\n        //     });\r\n        // }\r\n\r\n        var fade_alpha : Float = options.background.a;\r\n\r\n        if(options.fade_in) {\r\n\r\n            options.background.a = 0;\r\n            options.bar.a = 0;\r\n            options.bar_border.a = 0;\r\n\r\n        } //fade in\r\n\r\n        width = Math.max(Math.floor(_view_width * 0.75), 2);\r\n        height = Math.max(Math.floor(_view_height * 0.002), 2);\r\n        var ypos = Math.floor(_view_height * 0.60);\r\n        var half_width = Math.floor(width/2);\r\n        var half_height = Math.floor(height/2);\r\n\r\n        background = new Sprite({\r\n            no_scene : true,\r\n            size : new Vector( _view_width, _view_height ),\r\n            centered : false,\r\n            color : options.background,\r\n            depth : 998,\r\n            visible: true,\r\n        });\r\n\r\n        progress_bar = new Sprite({\r\n            pos : new Vector(_view_mid_x - half_width, ypos - half_height),\r\n            size : new Vector( 2, height ),\r\n            no_scene : true,\r\n            centered : false,\r\n            color : options.bar,\r\n            depth : 998\r\n        });\r\n\r\n        progress_border = new Visual({\r\n            color : options.bar,\r\n            no_scene : true,\r\n            pos : new Vector(_view_mid_x - half_width, ypos - half_height),\r\n            geometry : Luxe.draw.rectangle({\r\n                w : width,\r\n                h : height,\r\n                depth : 998.1\r\n            }),\r\n            depth : 998.1\r\n        });\r\n\r\n            //we intercept the onprogress and oncomplete of the parcel\r\n        options.parcel.options.oncomplete = oncomplete;\r\n        options.parcel.options.onprogress = onprogress;\r\n\r\n        if(options.fade_in) {\r\n\r\n                //fade in the progress bar\r\n            background.color.tween(options.fade_time,{a:fade_alpha},true);\r\n            progress_bar.color.tween(options.fade_time,{a:1},true);\r\n            progress_border.color.tween(options.fade_time,{a:1},true);\r\n\r\n        } //fade_in\r\n\r\n    } //new\r\n\r\n    public function set_progress( amount : Float ) {\r\n\r\n        if(amount < 0) amount = 0;\r\n        if(amount > 1) amount = 1;\r\n\r\n        progress_bar.size.x = Math.ceil(width * amount);\r\n\r\n    } //set_progress\r\n\r\n    public function onprogress( r:Resource ) {\r\n\r\n            //work out where we are out\r\n        var amount = options.parcel.current_count / options.parcel.total_items;\r\n\r\n            //update the progress bar\r\n        set_progress( amount );\r\n\r\n    } //onprogress\r\n\r\n    public function oncomplete( p:Parcel ) {\r\n\r\n        if(options.fade_out) {\r\n\r\n            background.color.tween( options.fade_time, {a:0}, true);\r\n            progress_bar.color.tween( options.fade_time, {a:0}, true);\r\n            progress_border.color.tween( options.fade_time, {a:0}, true)\r\n                .onComplete( do_complete );\r\n\r\n        } else {\r\n\r\n            do_complete();\r\n\r\n        } //fade out\r\n\r\n    } //oncomplete\r\n\r\n    function do_complete() {\r\n        if(options.oncomplete != null) {\r\n            options.oncomplete( options.parcel );\r\n        }\r\n    } //do_complete\r\n\r\n} //Parcel Progress\r\n","package luxe;\r\n\r\nimport Luxe.Ev;\r\nimport luxe.Core;\r\nimport luxe.Vector;\r\nimport snow.utils.Timer;\r\n\r\n#if deflect\r\n    import luxe.physics.deflect.PhysicsDeflect;\r\n#end //deflect\r\n\r\n#if nape\r\n    import luxe.physics.nape.PhysicsNape;\r\n#end //nape\r\n\r\n\r\nclass Physics {\r\n\r\n\r\n    #if deflect\r\n        public var deflect : PhysicsDeflect;\r\n    #end //deflect\r\n\r\n    #if nape\r\n        public var nape : PhysicsNape;\r\n    #end //nape\r\n\r\n    public var core : Core;\r\n    public var engines : Array<PhysicsEngine>;\r\n\r\n        //how often to update\r\n    public var step_rate (default,set) : Float = 1/60;\r\n        //how much is a single step. This is set from step_rate initially, but can be changed manually\r\n    public var step_delta : Float = 1/60;\r\n\r\n//Physics fixed updates\r\n    @:noCompletion public var timer : Timer;\r\n\r\n    public function new( _core:Core ) {\r\n\r\n        core = _core;\r\n\r\n    } //new\r\n\r\n    public function init() {\r\n\r\n        engines = [];\r\n\r\n        #if deflect\r\n            deflect = add_engine(PhysicsDeflect);\r\n        #end //deflect\r\n\r\n        #if nape\r\n            nape = add_engine(PhysicsNape);\r\n        #end //nape\r\n\r\n    } //init\r\n\r\n    public function reset() {\r\n\r\n            //stop any existing loop\r\n        if(timer != null) {\r\n            timer.stop();\r\n            timer = null;\r\n        }\r\n\r\n        if(step_rate != 0) {\r\n\r\n                //Start the physics update loop\r\n            timer = Luxe.timer.schedule( step_rate, fixed_update, true );\r\n\r\n        } //only if there is a step rate\r\n\r\n    } //reset\r\n\r\n    static var tag_physics : String = 'physics';\r\n\r\n        //called by the timer at a fixed rate\r\n    function fixed_update() {\r\n\r\n            Luxe.debug.start(tag_physics);\r\n\r\n        update();\r\n\r\n            Luxe.debug.end(tag_physics);\r\n\r\n    } //fixed_update\r\n\r\n    @:noCompletion public function add_engine<T1,T2>( type:Class<T1>, ?_data:T2 ) : T1 {\r\n\r\n        var _engine_instance = Type.createInstance( type, [ _data ] );\r\n        var _physics_engine : PhysicsEngine = cast _engine_instance;\r\n\r\n            //start with init\r\n        _physics_engine.init();\r\n\r\n            //push the engine into the list to be updated\r\n        engines.push( _physics_engine );\r\n\r\n            //return typed instance\r\n        return _engine_instance;\r\n\r\n    } //add_engine\r\n\r\n        /** Only call this manually if step_rate is 0! */\r\n    public function update() {\r\n        for(engine in engines) {\r\n            engine.update();\r\n        }\r\n    }\r\n\r\n    public function process() {\r\n        for(engine in engines) {\r\n            engine.process();\r\n        }\r\n    } //process\r\n\r\n    public function render() {\r\n        for(engine in engines) {\r\n            engine.render();\r\n        }\r\n    } //render\r\n\r\n    public function destroy() {\r\n\r\n        if(timer != null) {\r\n            timer.stop();\r\n        }\r\n\r\n        timer = null;\r\n\r\n        for(engine in engines) {\r\n            engine.destroy();\r\n        }\r\n\r\n    } //destroy\r\n\r\n        //on changing the fixed rate, update the physics timer\r\n    function set_step_rate( _rate:Float ) {\r\n\r\n            //update the step size\r\n        step_rate = _rate;\r\n        step_delta = step_rate;\r\n\r\n            //reset the timer so it runs at the new rate\r\n        reset();\r\n\r\n        return step_rate;\r\n\r\n    } //set_step_rate\r\n\r\n\r\n} //Physics\r\n\r\n\r\n\r\n    //base class for simple physics world\r\n    //updates and access\r\nclass PhysicsEngine {\r\n\r\n    public var name : String = 'engine';\r\n\r\n    @:isVar public var paused (get,set) : Bool = false;\r\n    @:isVar public var gravity (get,set) : Vector;\r\n    @:isVar public var draw (get,set) : Bool = true;\r\n\r\n    public function new() {\r\n\r\n        gravity = new Vector(0, -9.8, 0);\r\n        Luxe.on(Ev.render, _render);\r\n\r\n    } //new\r\n\r\n    public function init() {\r\n\r\n    } //init\r\n\r\n    function _render(_) {\r\n        render();\r\n    }\r\n\r\n    public function process() {\r\n\r\n    } //process\r\n\r\n    public function update() {\r\n\r\n    } //update\r\n\r\n    public function render() {\r\n\r\n    } //render\r\n\r\n    public function get_paused() : Bool {\r\n\r\n        return paused;\r\n\r\n    } //get_paused\r\n\r\n    public function set_paused( ?_pause:Bool ) {\r\n\r\n        return paused = _pause;\r\n\r\n    } //set_paused\r\n\r\n    public function get_draw() : Bool {\r\n\r\n        return draw;\r\n\r\n    } //get_draw\r\n\r\n    public function set_draw( _draw:Bool ) : Bool {\r\n\r\n        return draw = _draw;\r\n\r\n    } //set_draw\r\n\r\n    public function get_gravity() : Vector {\r\n\r\n        return gravity;\r\n\r\n    } //get_gravity\r\n\r\n    public function set_gravity( _gravity:Vector ) {\r\n\r\n        return gravity = _gravity;\r\n\r\n    } //set_gravity\r\n\r\n    public function destroy() {\r\n\r\n    }\r\n\r\n} //PhysicsEngine\r\n","package luxe;\r\n\r\nimport Luxe.Ev;\r\nimport luxe.Input;\r\nimport luxe.Screen;\r\nimport luxe.options.EntityOptions;\r\n\r\nimport luxe.Log._verboser;\r\nimport luxe.Log._verbose;\r\nimport luxe.Log._debug;\r\nimport luxe.Log.log;\r\n\r\nclass Scene extends Objects {\r\n\r\n    public var entities : Map<String,Entity>;\r\n    public var inited : Bool = false;\r\n    public var started : Bool = false;\r\n\r\n    var _delayed_init_entities : Array<Entity>;\r\n    var _delayed_reset_entities : Array<Entity>;\r\n\r\n    public var length(get, null) : Int = 0;\r\n\r\n    public function new( ?_name:String='untitled scene' ) {\r\n\r\n        super(_name);\r\n\r\n        entities = new Map<String,Entity>();\r\n\r\n        _delayed_init_entities = [];\r\n        _delayed_reset_entities = [];\r\n\r\n        Luxe.core.on(Ev.init, init);\r\n        Luxe.core.on(Ev.destroy, _destroy);\r\n        Luxe.core.on(Ev.update, update);\r\n\r\n        Luxe.core.on(Ev.prerender, prerender);\r\n        Luxe.core.on(Ev.postrender, postrender);\r\n        Luxe.core.on(Ev.render, render);\r\n\r\n        Luxe.core.on(Ev.keydown, keydown);\r\n        Luxe.core.on(Ev.keyup, keyup);\r\n        Luxe.core.on(Ev.textinput, textinput);\r\n\r\n        Luxe.core.on(Ev.inputup, inputup);\r\n        Luxe.core.on(Ev.inputdown, inputdown);\r\n\r\n        Luxe.core.on(Ev.mouseup, mouseup);\r\n        Luxe.core.on(Ev.mousedown, mousedown);\r\n        Luxe.core.on(Ev.mousemove, mousemove);\r\n        Luxe.core.on(Ev.mousewheel, mousewheel);\r\n\r\n        Luxe.core.on(Ev.touchup, touchup);\r\n        Luxe.core.on(Ev.touchdown, touchdown);\r\n        Luxe.core.on(Ev.touchmove, touchmove);\r\n\r\n        Luxe.core.on(Ev.gamepadup, gamepadup);\r\n        Luxe.core.on(Ev.gamepaddown, gamepaddown);\r\n        Luxe.core.on(Ev.gamepadaxis, gamepadaxis);\r\n        Luxe.core.on(Ev.gamepaddevice, gamepaddevice);\r\n\r\n        Luxe.core.on(Ev.windowmoved, windowmoved);\r\n        Luxe.core.on(Ev.windowresized, windowresized);\r\n        Luxe.core.on(Ev.windowsized, windowsized);\r\n        Luxe.core.on(Ev.windowminimized, windowminimized);\r\n        Luxe.core.on(Ev.windowrestored, windowrestored);\r\n\r\n            //if we have already missed the internal init\r\n        if(Luxe.core.inited) {\r\n            init(null);\r\n        }\r\n\r\n    } //new\r\n\r\n        /** add given entity to this scene */\r\n    var entity_count : Int = 0;\r\n    public function add( entity:Entity, ?pos:haxe.PosInfos ) {\r\n\r\n        if(entity == null) {\r\n            throw \"can't put entity in a scene if the entity is null.\";\r\n        }\r\n\r\n            _debug('${name} / adding ${entity.name} with id : ${entity.id}');\r\n\r\n        if(entities.exists(entity.name)) {\r\n            log('${name} / adding a second entity named ${entity.name}! ${Luxe.utils.pos_info(pos)}\r\n                This will replace the existing one, possibly leaving the previous one in limbo.\r\n                Use EntityOptions name_unique flag to automatically handle this for similar named entities.');\r\n        }\r\n\r\n        entity.scene = this;\r\n        entities.set( entity.name, entity );\r\n        entity_count++;\r\n\r\n\r\n            if(inited) {\r\n                _debug('adding a delayed entity to init list ' + entity.name);\r\n                _delayed_init_entities.push(entity);\r\n            } //inited\r\n\r\n            if(started) {\r\n                _debug('adding a delayed entity to reset list ' + entity.name);\r\n                _delayed_reset_entities.push(entity);\r\n            } //started\r\n\r\n    } //add\r\n\r\n        /** removes given entity from this scene */\r\n    public function remove( entity:Entity ) : Bool {\r\n\r\n        if(entity == null) {\r\n            throw \"can't remove entity from a scene if the entity is null.\";\r\n        }\r\n\r\n        if(entity.scene == this) {\r\n\r\n            entity.scene = null;\r\n            entity_count--;\r\n            return entities.remove( entity.name );\r\n\r\n        } else {\r\n\r\n            log(\"can't remove the entity from this scene, it is not mine (entity.scene != this)\");\r\n            return false;\r\n\r\n        }\r\n\r\n        return false;\r\n\r\n    } //remove\r\n\r\n        /** destroy all entities in this scene, emptying it. */\r\n    public function empty() {\r\n\r\n        if(entity_count > 0) {\r\n            for(entity in entities) {\r\n                if(entity != null) {\r\n\r\n                    remove( entity );\r\n                    entity.destroy();\r\n                    entity = null;\r\n\r\n                }\r\n            } //each entity\r\n        }\r\n\r\n    } //empty\r\n\r\n        /**\r\n            Return a list of similarly named entities in the scene.\r\n            For example, enemy.1 enemy.2 enemy.3 with 'enemy' will return all of these.\r\n            Useful for the EntityOptions name_unique flag.\r\n            Iterates all entities in the scene, use carefully.\r\n            Note that this is a function that will likely become a part of a set of functions so it may change slightly.\r\n            Current behavior works based on (name.)* from the beginning of the name only.\r\n            `enemy.1` will match, `enemy` will not (no .), `this.enemy.name` will not.\r\n            `^((?:enemy)[.]{1})`\r\n        */\r\n    public function get_named_like(_name:String, into:Array<Entity> ) {\r\n\r\n        if(entity_count > 0) {\r\n            var _filter : EReg = new EReg('^((?:' + _name + ')[.]{1})', 'g');\r\n            for(_entity in entities) {\r\n                if( _filter.match(_entity.name) ) {\r\n                    into.push(_entity);\r\n                }\r\n            }\r\n        }\r\n\r\n        return into;\r\n\r\n    } //get_named_like\r\n\r\n//render\r\n\r\n    function render(_) {\r\n\r\n        emit(Ev.render);\r\n\r\n    } //render\r\n\r\n    function prerender(_) {\r\n\r\n        emit(Ev.prerender);\r\n\r\n    } //prerender\r\n\r\n    function postrender(_) {\r\n\r\n        emit(Ev.postrender);\r\n\r\n    } //postrender\r\n\r\n//Keys\r\n\r\n    function keydown(e:KeyEvent) {\r\n\r\n        _verboser('$name / key down / $e');\r\n\r\n        emit(Ev.keydown, e);\r\n\r\n    } //keydown\r\n\r\n    function keyup(e:KeyEvent) {\r\n\r\n        _verboser('$name / key up / $e');\r\n\r\n        emit(Ev.keyup, e);\r\n\r\n    } //keyup\r\n\r\n    function textinput(e:TextEvent) {\r\n\r\n        _verboser('$name / text event / $e');\r\n\r\n        emit(Ev.textinput, e);\r\n\r\n    } //textinput\r\n\r\n//Mouse\r\n\r\n    function mousedown(e:MouseEvent) {\r\n\r\n        _verboser('$name / mousedown / $e');\r\n\r\n        emit(Ev.mousedown, e);\r\n\r\n    } //onmousedown\r\n\r\n    function mousewheel(e:MouseEvent) {\r\n\r\n        _verboser('$name / mousewheel / $e');\r\n\r\n        emit(Ev.mousewheel, e);\r\n\r\n    } //onmousewheel\r\n\r\n    function mouseup(e:MouseEvent) {\r\n\r\n        _verboser('$name / mouseup / $e');\r\n\r\n        emit(Ev.mouseup, e);\r\n\r\n    } //onmouseup\r\n\r\n    function mousemove(e:MouseEvent) {\r\n\r\n        _verboser('$name / mousemove / $e');\r\n\r\n        emit(Ev.mousemove, e);\r\n\r\n    } //onmousemove\r\n\r\n//Touch\r\n\r\n    function touchdown( event : TouchEvent ) {\r\n\r\n        emit(Ev.touchdown, event);\r\n\r\n    } //ontouchdown\r\n\r\n    function touchup( event : TouchEvent ) {\r\n\r\n        emit(Ev.touchup, event);\r\n\r\n    } //ontouchup\r\n\r\n    function touchmove( event : TouchEvent ) {\r\n\r\n        emit(Ev.touchmove, event);\r\n\r\n    } //ontouchmove\r\n\r\n//Gamepad\r\n\r\n    function gamepadaxis( event:GamepadEvent ) {\r\n\r\n        emit(Ev.gamepadaxis, event);\r\n\r\n    } //gamepadaxis\r\n\r\n    function gamepadup( event:GamepadEvent ) {\r\n\r\n        emit(Ev.gamepadup, event);\r\n\r\n    } //gamepadup\r\n\r\n    function gamepaddown( event:GamepadEvent ) {\r\n\r\n        emit(Ev.gamepaddown, event);\r\n\r\n    } //gamepaddown\r\n\r\n    function gamepaddevice( event:GamepadEvent ) {\r\n\r\n        emit(Ev.gamepaddevice, event);\r\n\r\n    } //gamepaddown\r\n\r\n\r\n//windowing\r\n\r\n    function windowmoved( event:WindowEvent ) {\r\n\r\n        emit(Ev.windowmoved, event);\r\n\r\n    } //windowmoved\r\n\r\n    function windowresized( event:WindowEvent ) {\r\n\r\n        emit(Ev.windowresized, event);\r\n\r\n    } //windowresized\r\n\r\n    function windowsized( event:WindowEvent ) {\r\n\r\n        emit(Ev.windowsized, event);\r\n\r\n    } //windowsized\r\n\r\n    function windowminimized( event:WindowEvent ) {\r\n\r\n        emit(Ev.windowminimized, event);\r\n\r\n    } //windowminimized\r\n\r\n    function windowrestored( event:WindowEvent ) {\r\n\r\n        emit(Ev.windowrestored, event);\r\n\r\n    } //windowrestored\r\n\r\n//Input\r\n\r\n    function inputdown( event:{ _name:String, event:InputEvent } ) {\r\n\r\n        emit(Ev.inputdown, event);\r\n\r\n    } //oninputdown\r\n\r\n    function inputup( event:{ _name:String, event:InputEvent }) {\r\n\r\n        emit(Ev.inputup, event);\r\n\r\n    } //oninputup\r\n\r\n//Cleanup\r\n\r\n    function _destroy(_) {\r\n\r\n        destroy();\r\n\r\n    } //destroy\r\n\r\n    public function destroy() {\r\n\r\n        Luxe.core.off(Ev.init, init);\r\n        Luxe.core.off(Ev.destroy, _destroy);\r\n        Luxe.core.off(Ev.update, update);\r\n\r\n        Luxe.core.off(Ev.prerender, prerender);\r\n        Luxe.core.off(Ev.postrender, postrender);\r\n        Luxe.core.off(Ev.render, render);\r\n\r\n        Luxe.core.off(Ev.keydown, keydown);\r\n        Luxe.core.off(Ev.keyup, keyup);\r\n        Luxe.core.off(Ev.textinput, textinput);\r\n\r\n        Luxe.core.off(Ev.inputup, inputup);\r\n        Luxe.core.off(Ev.inputdown, inputdown);\r\n\r\n        Luxe.core.off(Ev.mouseup, mouseup);\r\n        Luxe.core.off(Ev.mousedown, mousedown);\r\n        Luxe.core.off(Ev.mousemove, mousemove);\r\n        Luxe.core.off(Ev.mousewheel, mousewheel);\r\n\r\n        Luxe.core.off(Ev.touchup, touchup);\r\n        Luxe.core.off(Ev.touchdown, touchdown);\r\n        Luxe.core.off(Ev.touchmove, touchmove);\r\n\r\n        Luxe.core.off(Ev.gamepadup, gamepadup);\r\n        Luxe.core.off(Ev.gamepaddown, gamepaddown);\r\n        Luxe.core.off(Ev.gamepadaxis, gamepadaxis);\r\n        Luxe.core.off(Ev.gamepaddevice, gamepaddevice);\r\n\r\n        Luxe.core.off(Ev.windowmoved, windowmoved);\r\n        Luxe.core.off(Ev.windowresized, windowresized);\r\n        Luxe.core.off(Ev.windowsized, windowsized);\r\n        Luxe.core.off(Ev.windowminimized, windowminimized);\r\n        Luxe.core.off(Ev.windowrestored, windowrestored);\r\n\r\n        emit(Ev.destroy);\r\n\r\n    } //destroy\r\n\r\n    function _do_init() : Bool {\r\n\r\n        var _before_count = length;\r\n\r\n        if(entity_count > 0) {\r\n            for(entity in entities) {\r\n                if(entity != null) {\r\n                    if(!entity.inited) {\r\n                        _verbose('calling init on an entity : ' + entity.name);\r\n                        entity._init();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        var _after_count = length;\r\n\r\n        return _before_count != _after_count;\r\n\r\n    } // _do_init\r\n\r\n        //Entities themselves can create entities\r\n        //inside of their init so we have to keep checking\r\n    public function init(_) {\r\n\r\n        var keep_going : Bool = true;\r\n        while(keep_going) {\r\n            keep_going = _do_init();\r\n        }\r\n\r\n        inited = true;\r\n\r\n        emit(Ev.init);\r\n\r\n        reset();\r\n\r\n    } //init\r\n\r\n        /** reset this scene, allowing all entities, children and attached components to be notified of the reset */\r\n    public function reset() {\r\n\r\n        started = false;\r\n\r\n            emit(Ev.reset);\r\n\r\n        started = true;\r\n\r\n    } //reset\r\n\r\n    function update(dt:Float) {\r\n\r\n        Luxe.core.debug.start('scene.' + name);\r\n\r\n            //late scene additions get init'ed and start'ed\r\n        handle_delayed_additions();\r\n            //just in case, as the entities are called directly\r\n        emit(Ev.update, dt);\r\n\r\n            //finally update them\r\n        if(entity_count > 0) {\r\n            for(entity in entities) {\r\n                if(entity != null) {\r\n                    entity._update(dt);\r\n                }\r\n            } //for each entity\r\n        }\r\n\r\n        Luxe.core.debug.end('scene.' + name);\r\n\r\n    } //update\r\n\r\n    function handle_delayed_additions() {\r\n\r\n        if(_delayed_init_entities.length != 0 || _delayed_reset_entities.length != 0) {\r\n            _debug(\"delayed entities in scene will init/reset now! \" + _delayed_init_entities.length + ' / ' + _delayed_reset_entities.length);\r\n        }\r\n\r\n        if(_delayed_init_entities.length > 0) {\r\n            for(entity in _delayed_init_entities) {\r\n                _debug('\\t handling late entity init ' + entity.name);\r\n                entity._init();\r\n            }\r\n            _delayed_init_entities.splice(0, _delayed_init_entities.length);\r\n        }\r\n\r\n        if(_delayed_reset_entities.length > 0) {\r\n            for(entity in _delayed_reset_entities) {\r\n                _debug('\\t handling late entity reset ' + entity.name);\r\n                entity._reset(null);\r\n            }\r\n            _delayed_reset_entities.splice(0, _delayed_reset_entities.length);\r\n        }\r\n\r\n    } //handle_delayed_additions\r\n\r\n    function get_length() : Int {\r\n\r\n        return Lambda.count(entities);\r\n\r\n    } //get_length\r\n\r\n    function toString() {\r\n\r\n        return 'luxe Scene: $name / $length entities / id: $id';\r\n\r\n    } //toString\r\n\r\n\r\n} //Scene\r\n","package luxe;\r\n\r\nimport luxe.Vector;\r\n\r\n\r\ntypedef WindowEventType = snow.types.Types.WindowEventType;\r\n\r\n/** The data related to the specific window event. */\r\ntypedef WindowEventData = {\r\n        /** The x data for the event, if applicable */\r\n    @:optional var x:Int;\r\n        /** The y data for the event, if applicable */\r\n    @:optional var y:Int;\r\n\r\n} //WindowEventData\r\n\r\n\r\n/** A window event */\r\ntypedef WindowEvent = {\r\n\r\n        /** The type of window event this was. Use WindowEventType */\r\n    @:optional var type : WindowEventType;\r\n        /** The time in seconds that this event occured, useful for deltas */\r\n    @:optional var timestamp : Float;\r\n        /** The window id from which this event originated */\r\n    @:optional var window_id : Int;\r\n        /** The event data, where applicable. For example, with move, resized or sized events the data contains the new information as a result of the event. */\r\n    @:optional var event : WindowEventData;\r\n\r\n} //WindowEvent\r\n\r\n\r\n\r\n@:allow(luxe.Core)\r\nclass Screen {\r\n\r\n    @:isVar public var w (default,null) : Float;\r\n    @:isVar public var h (default,null) : Float;\r\n    @:isVar public var mid (get,null) : Vector;\r\n    @:isVar public var size (get,null) : Vector;\r\n\r\n        /** Access to the mouse cursor, position, visibility, locking etc. */\r\n    public var cursor : Cursor;\r\n\r\n    @:noCompletion public var core : Core;\r\n\r\n    @:allow(luxe.Core)\r\n    function new( ?_core:Core, _w:Int, _h:Int ) {\r\n\r\n        core = _core;\r\n        cursor = new Cursor(this);\r\n\r\n        w = _w;\r\n        h = _h;\r\n\r\n        mid = new Vector( Math.round(w/2), Math.round(h/2) );\r\n        size = new Vector(w, h);\r\n\r\n    } //new\r\n\r\n    function toString() {\r\n        return 'luxe.Screen({ w:$w, h:$h })';\r\n    }\r\n\r\n//Public API\r\n\r\n        /** Returns true if the given point falls within the bounds of the w/h of the screen. */\r\n    public function point_inside( _p:Vector ) {\r\n\r\n        if( _p.x < 0 )    return false;\r\n        if( _p.y < 0 )    return false;\r\n        if( _p.x > w )  return false;\r\n        if( _p.y > h )  return false;\r\n\r\n        return true;\r\n\r\n    } //point_inside\r\n\r\n        /** Returns true if the given point as floats fall within the bounds of the w/h of the screen. */\r\n    public function point_inside_xy( _x:Float, _y:Float ) {\r\n\r\n        if( _x < 0 )    return false;\r\n        if( _y < 0 )    return false;\r\n        if( _x > w )  return false;\r\n        if( _y > h )  return false;\r\n\r\n        return true;\r\n\r\n    } //point_inside_xy\r\n\r\n//Internal\r\n\r\n    var internal = false;\r\n    @:noCompletion function internal_resized(_w:Float, _h:Float) {\r\n\r\n        w = _w;\r\n        h = _h;\r\n\r\n        internal = true;\r\n\r\n            size.x = _w;\r\n            size.y = _h;\r\n            mid.x = _w/2;\r\n            mid.y = _h/2;\r\n\r\n        internal = false;\r\n\r\n    } //set_size\r\n\r\n\r\n//getters/setters\r\n\r\n    function get_mid() : Vector {\r\n\r\n        if(internal) return mid;\r\n        return mid.clone();\r\n\r\n    } //get_mid\r\n\r\n    function get_size() : Vector {\r\n\r\n        if(internal) return size;\r\n        return size.clone();\r\n\r\n    } //get_size\r\n\r\n\r\n} //Screen\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass Cursor {\r\n\r\n        /** The visibility of the cursor. (get/set) */\r\n    @:isVar public var visible (get,set): Bool = true;\r\n        /** Grabbing the cursor locks it to the window bounds. On web this is analogous to `lock`. (get/set) */\r\n    @:isVar public var grab (get,set): Bool = false;\r\n        /** Locking the cursor hides it, and enables the `xrel`/`yrel`   \r\n            values on the mouse move events. This changes the mouse to   \r\n            allow movement without it stopping at the bounds.   \r\n            On `web`, this must come from a user initiated action, and asks their permission. (get/set) */\r\n    @:isVar public var lock (get,set): Bool = false;\r\n        /** The current mouse position. Setting this has no effect on `web` (and cannot). */\r\n    @:isVar public var pos (get,set): Vector;\r\n\r\n        /** The screen this cursor relates to. */\r\n    var screen : Screen;\r\n    var ignore : Bool = false;\r\n\r\n    @:allow(luxe.Screen)\r\n    function new( _screen:Screen ) {\r\n\r\n        screen = _screen;\r\n        pos = new Vector();\r\n\r\n    } //new\r\n\r\n    @:allow(luxe.Core)\r\n    function set_internal( _pos:Vector ) {\r\n\r\n        ignore = true;\r\n            pos = _pos;\r\n        ignore = false;\r\n\r\n    } //set_internal\r\n\r\n//getters/setters\r\n\r\n    function get_visible() : Bool {\r\n\r\n        return visible;\r\n\r\n    } //get_visible\r\n\r\n    function set_visible( _visible:Bool ) : Bool {\r\n\r\n        screen.core.app.windowing.enable_cursor( _visible );\r\n\r\n        return visible = _visible;\r\n\r\n    } //set_visible\r\n\r\n    function get_grab() : Bool {\r\n\r\n        return grab;\r\n\r\n    } //get_grab\r\n\r\n    function get_lock() : Bool {\r\n\r\n        return lock;\r\n\r\n    } //get_lock\r\n\r\n    function set_grab( _grab:Bool ) : Bool {\r\n\r\n        screen.core.app.window.grab = _grab;\r\n\r\n        return grab = _grab;\r\n\r\n    } //set_grab\r\n\r\n    function set_lock( _lock:Bool ) : Bool {\r\n\r\n        screen.core.app.windowing.enable_cursor_lock(_lock);\r\n\r\n        return lock = _lock;\r\n\r\n    } //set_lock\r\n\r\n    function get_pos() : Vector {\r\n\r\n        return pos;\r\n\r\n    } //get_pos\r\n\r\n    function set_pos( _p:Vector ) : Vector {\r\n\r\n        if(pos != null && _p != null && !ignore) {\r\n            screen.core.app.window.set_cursor_position( Std.int(_p.x), Std.int(_p.y) );\r\n        }\r\n\r\n        return pos = _p;\r\n\r\n    } //set_pos\r\n\r\n\r\n} //Cursor\r\n","package luxe;\r\n\r\nimport luxe.Visual;\r\nimport luxe.Vector;\r\nimport luxe.Rectangle;\r\n\r\nimport luxe.resource.Resource;\r\nimport phoenix.geometry.Geometry;\r\nimport phoenix.geometry.QuadGeometry;\r\n\r\nimport luxe.options.SpriteOptions;\r\n\r\nclass Sprite extends Visual {\r\n\r\n\r\n    @:isVar public var centered     (default, set) : Bool = true;\r\n    @:isVar public var flipx        (default, set) : Bool = false;\r\n    @:isVar public var flipy        (default, set) : Bool = false;\r\n    @:isVar public var uv           (default, set) : Rectangle;\r\n\r\n    public var geometry_quad : QuadGeometry;\r\n\r\n\r\n    public function new( options:SpriteOptions ) {\r\n\r\n        uv = new Rectangle();\r\n\r\n        if(options == null) {\r\n            throw \"Sprite needs not-null options at the moment\";\r\n        }\r\n\r\n            //centered\r\n        if(options.centered != null) {\r\n            centered = options.centered;\r\n        }\r\n\r\n            //flipx\r\n        if(options.flipx != null) {\r\n            flipx = options.flipx;\r\n        }\r\n\r\n            //flipy\r\n        if(options.flipy != null) {\r\n            flipy = options.flipy;\r\n        }\r\n\r\n            //create visual\r\n        super( options );\r\n\r\n    }\r\n\r\n    override function on_geometry_created() {\r\n\r\n        super.on_geometry_created();\r\n\r\n        if(texture != null) {\r\n\r\n            texture.onload = function(t) {\r\n\r\n                    //because the default is 0,0,1,1 uv for the quad, we don't want that when\r\n                    //textures are padded (like on web)\r\n                if(options.uv == null) {\r\n\r\n                    // if(texture.width_actual != texture.width || texture.height_actual != texture.height) {\r\n                        uv = new Rectangle(0,0,texture.width,texture.height);\r\n                    // }\r\n\r\n                } else {\r\n\r\n                    uv = options.uv;\r\n\r\n                }\r\n\r\n                    //if texture is render target, flipy\r\n                if(texture.type == ResourceType.render_texture) {\r\n                    flipy = true;\r\n                }\r\n\r\n            } //onload\r\n\r\n        } //texture !null\r\n\r\n            //set the origin and centered once created\r\n        centered = !!centered;\r\n            //and re assign the flip values\r\n        flipx = !!flipx;\r\n        flipy = !!flipy;\r\n\r\n    } //on_geometry_created\r\n\r\n    override function set_geometry( _g:Geometry ) {\r\n\r\n        geometry_quad = cast _g;\r\n        return super.set_geometry(_g);\r\n\r\n    } //set_geometry\r\n\r\n//Helper functions\r\n\r\n        //:todo: this function is utilitarian and should be flagged for dirty state if used extensively\r\n    public function point_inside( _p:Vector ) : Bool {\r\n\r\n        if(geometry == null) {\r\n            return false;\r\n        }\r\n\r\n        return Luxe.utils.geometry.point_in_geometry(_p, geometry);\r\n\r\n    } //point_inside\r\n\r\n        /** Returns true if a point is inside the AABB unrotated */\r\n    public function point_inside_AABB(_p:Vector) : Bool {\r\n\r\n        if(pos == null) return false;\r\n        if(size == null) return false;\r\n\r\n            //scaled size\r\n        var _s_x = size.x * scale.x;\r\n        var _s_y = size.y * scale.y;\r\n\r\n        if(centered) {\r\n            var _hx = _s_x / 2;\r\n            var _hy = _s_y / 2;\r\n            if(_p.x < pos.x - _hx) return false;\r\n            if(_p.y < pos.y - _hy) return false;\r\n            if(_p.x > pos.x+_s_x - _hx) return false;\r\n            if(_p.y > pos.y+_s_y - _hy) return false;\r\n        } else {\r\n            if(_p.x < pos.x) return false;\r\n            if(_p.y < pos.y) return false;\r\n            if(_p.x > pos.x+_s_x) return false;\r\n            if(_p.y > pos.y+_s_y) return false;\r\n        }\r\n\r\n        return true;\r\n\r\n    } //point_inside_AABB\r\n\r\n//Properties\r\n\r\n\r\n//UV / source rect\r\n\r\n    function set_uv(_uv:Rectangle) : Rectangle {\r\n\r\n        if(geometry_quad != null) {\r\n            geometry_quad.uv(_uv);\r\n        }\r\n\r\n        uv = _uv;\r\n\r\n        Rectangle.listen( uv, _uv_change );\r\n\r\n        return uv;\r\n    }\r\n\r\n//Flipping\r\n\r\n    function set_flipy(_v:Bool) {\r\n\r\n        if(_v == flipy) {\r\n            return flipy;\r\n        }\r\n\r\n        if(geometry_quad != null) {\r\n            geometry_quad.flipy = _v;\r\n        }\r\n\r\n        return flipy = _v;\r\n\r\n    } //set_flipy\r\n\r\n    function set_flipx(_v:Bool) {\r\n\r\n        if(_v == flipx) {\r\n            return flipx;\r\n        }\r\n\r\n        if(geometry_quad != null) {\r\n            geometry_quad.flipx = _v;\r\n        }\r\n\r\n        return flipx = _v;\r\n\r\n    } //set_flipv\r\n\r\n//Size\r\n\r\n    override function set_size( _v:Vector ) : Vector {\r\n\r\n            //resize the mesh vertices themselves, as scale is relative to this size\r\n            //if explicitly set\r\n        if(geometry_quad != null) {\r\n\r\n            geometry_quad.resize( new Vector( _v.x, _v.y ) );\r\n\r\n                //If the user doesn't specify a custom origin, we try and work with the center\r\n            if(!_has_custom_origin) {\r\n                if(centered) {\r\n                        //half of the new size\r\n                    origin = _v.clone().divideScalar(2);\r\n                }\r\n            }\r\n\r\n        } //if geometry != null\r\n\r\n            //done\r\n        return super.set_size(_v);\r\n\r\n    } //set_size\r\n\r\n//Centered\r\n\r\n    function set_centered(_c:Bool) : Bool {\r\n\r\n            //centered geometry affects the origin directly\r\n        if(size != null) {\r\n            if(_c) {\r\n                origin = new Vector(size.x/2, size.y/2);\r\n            } else {\r\n                origin = new Vector();\r\n            }\r\n        } //size != null\r\n\r\n        return centered = _c;\r\n\r\n    } //set_centered\r\n\r\n\r\n        //An internal callback for when x y or w or h on a transform changes\r\n    function _uv_change(_v:Float) { this.set_uv(uv); }\r\n\r\n} //Sprite\r\n","package luxe;\r\n\r\nimport luxe.Rectangle;\r\nimport luxe.Vector;\r\nimport luxe.Visual;\r\nimport luxe.options.VisualOptions;\r\nimport luxe.options.TextOptions;\r\n\r\nimport phoenix.Batcher;\r\nimport phoenix.BitmapFont;\r\nimport phoenix.geometry.TextGeometry;\r\n\r\ntypedef TextAlign = phoenix.BitmapFont.TextAlign;\r\n\r\nclass Text extends Visual {\r\n\r\n        public var geom : TextGeometry;\r\n\r\n    //regular font stuff\r\n\r\n        public var text (get,set) : String;\r\n            function get_text() return geom.text;\r\n            function set_text(_s) return geom.text = _s;\r\n        public var font (get,set) : BitmapFont;\r\n            function get_font() return geom.font;\r\n            function set_font(_f) return geom.font = _f;\r\n        public var point_size (get,set) : Float;\r\n            function get_point_size() return geom.point_size;\r\n            function set_point_size(_s) return geom.point_size = _s;\r\n        public var letter_spacing (get,set) : Float;\r\n            function get_letter_spacing() return geom.letter_spacing;\r\n            function set_letter_spacing(_s) return geom.letter_spacing = _s;\r\n        public var line_spacing (get,set) : Float;\r\n            function get_line_spacing() return geom.line_spacing;\r\n            function set_line_spacing(_s) return geom.line_spacing = _s;\r\n\r\n        public var bounds (get,set) : Rectangle;\r\n            function get_bounds() return geom.bounds;\r\n            function set_bounds(_b) return geom.bounds = _b;\r\n        public var bounds_wrap (get,set) : Bool;\r\n            function get_bounds_wrap() return geom.bounds_wrap;\r\n            function set_bounds_wrap(_b) return geom.bounds_wrap = _b;\r\n\r\n        public var align (get,set) : TextAlign;\r\n            function get_align() return geom.align;\r\n            function set_align(_a) return geom.align = _a;\r\n        public var align_vertical (get,set) : TextAlign;\r\n            function get_align_vertical() return geom.align_vertical;\r\n            function set_align_vertical(_a) return geom.align_vertical = _a;\r\n\r\n    //distance field specific\r\n\r\n        public var sdf (get,set) : Bool;\r\n            function get_sdf() return geom.sdf;\r\n            function set_sdf(_s) return geom.sdf = _s;\r\n\r\n        public var smoothness (get,set) : Float;\r\n            function get_smoothness() return geom.smoothness;\r\n            function set_smoothness(_s) return geom.smoothness = _s;\r\n        public var thickness (get,set) : Float;\r\n            function get_thickness() return geom.thickness;\r\n            function set_thickness(_t) return geom.thickness = _t;\r\n\r\n        public var outline (get,set) : Float;\r\n            function get_outline() return geom.outline;\r\n            function set_outline(_o) return geom.outline = _o;\r\n        public var outline_color (get,set) : Color;\r\n            function get_outline_color() return geom.outline_color;\r\n            function set_outline_color(_c) return geom.outline_color = _c;\r\n\r\n        public var glow_threshold (get,set) : Float;\r\n            function get_glow_threshold() return geom.glow_threshold;\r\n            function set_glow_threshold(_s) return geom.glow_threshold = _s;\r\n        public var glow_amount (get,set) : Float;\r\n            function get_glow_amount() return geom.glow_amount;\r\n            function set_glow_amount(_e) return geom.glow_amount = _e;\r\n        public var glow_color (get,set) : Color;\r\n            function get_glow_color() return geom.glow_color;\r\n            function set_glow_color(_c) return geom.glow_color = _c;\r\n\r\n    public var text_options : TextOptions;\r\n\r\n    public function new( _options : TextOptions, ?_pos_info:haxe.PosInfos ) {\r\n\r\n            //store for later\r\n        text_options = _options;\r\n        text_bounds = new Rectangle();\r\n\r\n    \tvar _batcher : Batcher = null;\r\n    \tif(_options.no_batcher_add == null || _options.no_batcher_add == false) {\r\n    \t\tif(_options.batcher != null) {\r\n    \t\t\t_batcher = _options.batcher;\r\n    \t\t} else {\r\n    \t\t\t_batcher = Luxe.renderer.batcher;\r\n    \t\t}\r\n    \t}\r\n\r\n            //create the text geometry\r\n        geom = new TextGeometry({\r\n\r\n                //render properties\r\n            batcher: _batcher,\r\n            depth : _options.depth,\r\n            group : _options.group,\r\n            visible : _options.visible,\r\n            immediate : _options.immediate,\r\n                //transform properties\r\n            // pos : _options.pos,\r\n            // rotation : _options.rotation,\r\n            // scale : _options.scale,\r\n            // origin : _options.origin,\r\n                //geometry specific\r\n            color : _options.color,\r\n            shader : _options.shader,\r\n            texture : _options.texture,\r\n                //text geometry specific\r\n            text: _options.text,\r\n            font: _options.font,\r\n            point_size: _options.point_size,\r\n            line_spacing: _options.line_spacing,\r\n            letter_spacing: _options.letter_spacing,\r\n\r\n            bounds : _options.bounds,\r\n            bounds_wrap : _options.bounds_wrap,\r\n            align : _options.align,\r\n            align_vertical : _options.align_vertical,\r\n\r\n            sdf: _options.sdf,\r\n            smoothness: _options.smoothness,\r\n            thickness: _options.thickness,\r\n\r\n            outline: _options.outline,\r\n            outline_color: _options.outline_color,\r\n\r\n            glow_threshold: _options.glow_threshold,\r\n            glow_amount: _options.glow_amount,\r\n            glow_color: _options.glow_color\r\n\r\n        });\r\n\r\n        geom.emitter.on(EvTextGeometry.update_text, on_geom_text_update);\r\n\r\n        _options.geometry = geom;\r\n        _options.shader = geom.shader;\r\n\r\n            //create the visual\r\n        super(_options, _pos_info);\r\n            //flush\r\n        _update_bounds();\r\n\r\n    } //new\r\n\r\n//Public API\r\n\r\n    public function point_inside( p:Vector ) {\r\n\r\n        _update_bounds();\r\n        return text_bounds.point_inside(p);\r\n\r\n    } //point_inside\r\n\r\n//Internal\r\n\r\n    override function set_pos_from_transform( _p:Vector ) {\r\n\r\n        super.set_pos_from_transform(_p);\r\n        _update_bounds();\r\n        text_options.pos = pos;\r\n\r\n    } //set_pos_from_transform\r\n\r\n//\r\n\r\n        //:todo: This is being considered overall, for the best fit.\r\n        //for now, for basic behavior that was there before, it'll do.\r\n    @:noCompletion\r\n    public var text_bounds : Rectangle;\r\n\r\n    function on_geom_text_update(_) {\r\n        _update_bounds();\r\n    }\r\n\r\n    @:noCompletion\r\n    inline function _update_bounds() {\r\n\r\n        var _x = pos.x;\r\n        var _y = pos.y;\r\n        var _tw = geom.text_width;\r\n        var _th = geom.text_height;\r\n        var _bw = geom.text_width;\r\n        var _bh = geom.text_height;\r\n\r\n        if(bounds != null) {\r\n            _bh = bounds.h;\r\n            _bw = bounds.w;\r\n            _x = bounds.x;\r\n            _y = bounds.y;\r\n\r\n            _x += switch(align) {\r\n                case center: _tw/2;\r\n                case right: _tw;\r\n                case _: 0.0;\r\n            }\r\n\r\n            _y += switch(align_vertical) {\r\n                case center: (_bh/2)-(_th/2);\r\n                case bottom: _bh - _th;\r\n                case _: 0.0;\r\n            }\r\n\r\n        } else {\r\n\r\n            _x -= switch(align) {\r\n                case center: _tw/2;\r\n                case right: _tw;\r\n                case _: 0.0;\r\n            }\r\n\r\n            _y -= switch(align_vertical) {\r\n                case center: _th/2;\r\n                case bottom: _th;\r\n                case _: 0.0;\r\n            }\r\n\r\n        } //bounds based\r\n\r\n        text_bounds.set( _x, _y, _tw, _th );\r\n\r\n    } //_update_bounds\r\n\r\n\r\n\r\n} //Text\r\n","package luxe;\r\n\r\nimport luxe.Core;\r\nimport haxe.Timer;\r\nimport luxe.Log._debug;\r\n\r\nclass Timer {\r\n\r\n\r\n    @:noCompletion public var core : Core;\r\n    @:noCompletion public var timers : Array<snow.utils.Timer>;\r\n\r\n\r\n    @:noCompletion public function new( _core:Core ) {\r\n        core = _core;\r\n        timers = [];\r\n    } //new\r\n\r\n    @:noCompletion public function init() {\r\n\r\n        _debug('\\t timer initialized.');\r\n\r\n    } //init\r\n\r\n    @:noCompletion public function destroy() {\r\n\r\n        reset();\r\n        _debug('\\t timer shut down.');\r\n\r\n    } //destroy\r\n\r\n    @:noCompletion public function process() {\r\n\r\n    } //process\r\n\r\n        /** Kill all existing scheduled timers created through `schedule` */\r\n    public function reset() {\r\n\r\n        for( t in timers ) {\r\n            t.stop();\r\n            t = null;\r\n        }\r\n\r\n        timers = null;\r\n        timers = [];\r\n\r\n    } //reset\r\n\r\n    public function schedule( _time_in_seconds:Float, _on_time:Void->Void, ?repeat:Bool = false ) : snow.utils.Timer {\r\n\r\n        var t = new snow.utils.Timer( _time_in_seconds );\r\n\r\n        t.run = function () {\r\n            if(!repeat) {\r\n                t.stop ();\r\n                timers.remove(t);\r\n            }\r\n            _on_time();\r\n        };\r\n\r\n        timers.push(t);\r\n\r\n        return t;\r\n\r\n    } //schedule\r\n\r\n\r\n} //Timer\r\n","package luxe.components;\r\n\r\nimport luxe.Quaternion;\r\nimport luxe.structural.OrderedMap;\r\n\r\nimport luxe.Log._debug;\r\nimport luxe.Log._verbose;\r\n\r\n\r\n@:noCompletion class Components {\r\n\r\n        //the list of attached components\r\n    public var components : OrderedMap<String, Component>;\r\n        //the root entity\r\n    public var entity : Entity;\r\n\r\n    public function new( _entity:Entity ) {\r\n\r\n        var _map = new Map<String,Component>();\r\n        components = new OrderedMap(_map);\r\n        entity = _entity;\r\n\r\n    } //new\r\n\r\n    public function add<T:Component>( _component:T ) : T {\r\n\r\n        if(_component == null) {\r\n            trace('attempt to add null component to ${entity.name}' );\r\n            return _component;\r\n        }\r\n\r\n        _component.entity = entity;\r\n\r\n        components.set( _component.name, _component );\r\n\r\n            _debug('    entity ${entity.name} added component ${_component.name}, now at ${Lambda.count(components)} components');\r\n            _debug('    entity ${entity.name} added component, calling added() on ${_component.name}');\r\n\r\n        _component.onadded();\r\n\r\n            //now check against the entity already being init'ed and reset'ed\r\n            //and if so, call them manually\r\n        if(entity.inited) {\r\n            _debug('\\t entity ${entity.name} adding component after init, so doing init on ${_component.name}' );\r\n            _component.init();\r\n        }\r\n\r\n        if(entity.started) {\r\n            _debug('\\t entity ${entity.name} adding component after reset, so doing reset on ${_component.name}' );\r\n            _component.onreset();\r\n        }\r\n\r\n        return _component;\r\n\r\n    } //add component\r\n\r\n    public function remove( _name:String ) : Bool {\r\n\r\n            //doesn't exist?\r\n        if(!components.exists(_name)) {\r\n            trace('attempt to remove $_name from ${entity.name} failed because that component was not attached to this entity');\r\n            return false;\r\n        }\r\n\r\n        _debug('\\t entity ${entity.name} removing component $_name');\r\n\r\n        var _component = components.get( _name );\r\n            _component.onremoved();\r\n\r\n            //we also set the entity to null\r\n            _component.entity = null;\r\n\r\n        return components.remove(_name);\r\n\r\n    } //remove\r\n\r\n    public function get<T>(_name:String, ?in_children:Bool = false ) : T {\r\n\r\n        _debug('looking for all of ' + _name + ' in children : ' + in_children );\r\n\r\n        if(!in_children) {\r\n\r\n            return cast components.get(_name);\r\n\r\n        } else {\r\n\r\n                //if found in the root entity\r\n            var in_this_entity = components.get( _name );\r\n            if( in_this_entity != null ) {\r\n                return cast in_this_entity;\r\n            }\r\n\r\n            _debug('check each of our children for the component');\r\n\r\n                //check each child of our entity\r\n            for(_child in entity.children) {\r\n\r\n                _debug('looking at ' + _child.name + ' for ' + _name );\r\n\r\n                var found : T = _child.get( _name, true );\r\n\r\n                if(found != null) {\r\n                    return cast found;\r\n                } //found\r\n\r\n            } //for each child\r\n\r\n            return null;\r\n\r\n        } //if in children\r\n\r\n        return null;\r\n\r\n    } //get\r\n\r\n    public function get_any<T>(_name:String, ?in_children:Bool = false, ?first_only:Bool = true ) : Array<T> {\r\n\r\n        _debug('looking for all of ' + _name + ' in children : ' + in_children + ' first only ; ' + first_only);\r\n\r\n        var results : Array<T> = [];\r\n\r\n        if(!in_children) {\r\n\r\n            return [cast components.get(_name)];\r\n\r\n        } else {\r\n\r\n            var in_this_entity = components.get( _name );\r\n            if( in_this_entity != null ) {\r\n                if(first_only) {\r\n                    return [cast in_this_entity];\r\n                } else {\r\n                    results.push( cast in_this_entity );\r\n                }\r\n            } //if found in the root entity\r\n\r\n            _debug('check each of our children for the component');\r\n\r\n                //check each child of our entity\r\n            for(_child in entity.children) {\r\n\r\n                _debug('looking at ' + _child.name + ' for ' + _name );\r\n\r\n                var found : Array<T> = _child.get_any( _name, true, first_only );\r\n\r\n                if(found != null) {\r\n\r\n                        //only want the first result, i.e not a list\r\n                    if(first_only && found.length > 0) {\r\n                        return [cast found[0]];\r\n                    } else {\r\n                        results.concat(found);\r\n                    } //append to the list\r\n\r\n                } //found\r\n\r\n            } //for each child\r\n\r\n        } //if in children\r\n\r\n        return results;\r\n\r\n    } //get_any\r\n\r\n    public function has(_name:String) : Bool {\r\n        return components.exists(_name);\r\n    } //has\r\n\r\n} //Components\r\n","package luxe.debug;\r\n\r\nimport luxe.Input.KeyEvent;\r\nimport luxe.Input.MouseEvent;\r\nimport luxe.Screen.WindowEvent;\r\n\r\n\r\nclass DebugView extends luxe.Objects {\r\n    public function new() {\r\n        super();\r\n    }\r\n\r\n    public var visible : Bool = false;\r\n\r\n    public function refresh() {}\r\n    public function process() {}\r\n    public function onmousedown(e:MouseEvent) {}\r\n    public function onmousewheel(e:MouseEvent) {}\r\n    public function onmouseup(e:MouseEvent) {}\r\n    public function onmousemove(e:MouseEvent) {}\r\n    public function onkeydown(e:KeyEvent) {}\r\n    public function onkeyup(e:KeyEvent) {}\r\n    public function onwindowsized(e:WindowEvent) {}\r\n    public function create() {}\r\n    public function show() {\r\n        visible = true;\r\n    }\r\n    public function hide() {\r\n        visible = false;\r\n    }\r\n}\r\n","package luxe.debug;\r\n\r\nimport luxe.Input.MouseEvent;\r\nimport luxe.Vector;\r\nimport phoenix.Batcher;\r\nimport phoenix.geometry.CompositeGeometry;\r\nimport luxe.structural.BalancedBST.BalancedBSTNode;\r\nimport phoenix.geometry.Geometry;\r\n\r\n\r\nclass BatcherDebugView extends luxe.debug.DebugView {\r\n\r\n    public function new(  ) {\r\n        super();\r\n        name = 'Batcher Debug';\r\n    }\r\n\r\n    var batcher : Batcher;\r\n\r\n    public override function create() {\r\n\r\n        batcher = Luxe.renderer.create_batcher({\r\n            name:'debug_batcher_view',\r\n            camera : new phoenix.Camera({ camera_name : 'batcher_debug_view' }),\r\n            layer : 1000\r\n        });\r\n\r\n    } //create\r\n\r\n    public override function refresh() {\r\n        clear_batcher_tree();\r\n        draw_batcher_tree();\r\n    }\r\n\r\n    var dragging = false;\r\n    var dragstart : Vector;\r\n    var dragmstart : Vector;\r\n\r\n    public override function onmousedown(e:MouseEvent) {\r\n        dragmstart = e.pos.clone();\r\n        dragstart = batcher.view.pos.clone();\r\n        dragging = true;\r\n    }\r\n    public override function onmouseup(e:MouseEvent) {\r\n        dragging = false;\r\n    }\r\n    public override function onmousemove(e:MouseEvent) {\r\n        if(dragging) {\r\n            var diff = Vector.Subtract(e.pos, dragmstart);\r\n            batcher.view.pos = Vector.Subtract(dragstart, diff);\r\n        }\r\n    }\r\n\r\n    public override function onmousewheel(e:MouseEvent) {\r\n        if(e.y < 0) {\r\n            batcher.view.zoom -= 0.1;\r\n        } else {\r\n            batcher.view.zoom += 0.1;\r\n        }\r\n    }\r\n\r\n    var _tree_geom : CompositeGeometry;\r\n    var as_immediate : Bool = false;\r\n\r\n    public function clear_batcher_tree() {\r\n        if(_tree_geom != null) {\r\n            _tree_geom.drop();\r\n            _tree_geom = null;\r\n        }\r\n    }\r\n\r\n    function keystr( key:GeometryKey, key2:GeometryKey) {\r\n         return\r\n            'ts: '+ key.timestamp + '\\n' +\r\n            'seq: '+ key.sequence + '\\n' +\r\n            'primitive_type: '+ key.primitive_type + \" \" + (key.primitive_type) + '\\n' +\r\n            'texture: '+ (key.texture == null ? 'null' : Std.string(key.texture.texture)) + '\\n' +\r\n            'texture id: '+ (key.texture == null ? 'null' : key.texture.id) + '\\n' +\r\n            'shader: '+ (key.shader == null ? 'null' : key.shader.id) + '\\n' +\r\n            'group: '+ key.group + '\\n' +\r\n            'depth: '+ key.depth + '\\n' +\r\n            'clip: '+ key.clip;\r\n    }\r\n\r\n    public function draw_geom_node(l:Bool, _leaf : BalancedBSTNode<GeometryKey,Geometry>, _p:Vector, _bbw:Float=20 ) {\r\n\r\n        var _bw:Float = 128;\r\n        var _bwhalf:Float = _bw /2;\r\n        var _bh:Float = 128;\r\n\r\n        var _g : Geometry = _leaf.value;\r\n\r\n        var c = new Color(1,1,1,0.4).rgb(0xffffff);\r\n\r\n        if(_g.dropped) {\r\n            c = new Color(1,1,1,1).rgb(0xcc0000);\r\n        }\r\n\r\n        _tree_geom.add_geometry(\r\n            Luxe.draw.rectangle({\r\n                immediate:as_immediate,\r\n                x:_p.x-_bwhalf, y:_p.y,\r\n                w:_bw, h:_bh,\r\n                color: c,\r\n                batcher : batcher,\r\n                depth : 999.4\r\n            })\r\n        ); //node square\r\n\r\n        _tree_geom.add_geometry(\r\n            Luxe.draw.text({\r\n                immediate:as_immediate,\r\n                bounds : new Rectangle(_p.x-_bwhalf, _p.y, _bw, _bh),\r\n                point_size : 13,\r\n                color : c,\r\n                batcher : batcher,\r\n                depth : 999.4,\r\n                text : keystr(_leaf.key, _g.key),\r\n                align : luxe.Text.TextAlign.center,\r\n                align_vertical : luxe.Text.TextAlign.center\r\n            })\r\n        ); //node text\r\n\r\n        var t = _p.clone().set_xy( _p.x, _p.y-16 );\r\n        var t2 = _p.clone().set_xy( _p.x, _p.y+_bw+2 );\r\n        var talign = luxe.Text.TextAlign.center;\r\n        // if(l) {\r\n            // t.x = _p.x - (_bwhalf*1.5);\r\n            // talign = luxe.Text.TextAlign.right;\r\n        // }\r\n\r\n        _tree_geom.add_geometry(\r\n            Luxe.draw.text({\r\n                immediate:as_immediate,\r\n                pos : t,\r\n                point_size : 13,\r\n                color : c,\r\n                batcher : batcher,\r\n                depth : 999.4,\r\n                text : _g.id,\r\n                align : talign\r\n            })\r\n        ); //node text\r\n\r\n        var c2 = new Color(1,1,1,0.4).rgb(0xff9944);\r\n        var notes_l = \"none\";\r\n        var notes_r = \"none\";\r\n\r\n        if(_leaf.left != null) {\r\n            notes_l = 'node';\r\n            var compare = Luxe.renderer.batcher.compare_rule(_leaf.key, _leaf.left.key);\r\n            notes_l = Luxe.renderer.batcher.compare_rule_to_string(compare);\r\n        }\r\n\r\n        if(_leaf.right != null) {\r\n            notes_r = 'node';\r\n            var compare = Luxe.renderer.batcher.compare_rule(_leaf.key, _leaf.right.key);\r\n            notes_r = Luxe.renderer.batcher.compare_rule_to_string(compare);\r\n        }\r\n\r\n        _tree_geom.add_geometry(\r\n            Luxe.draw.text({\r\n                immediate:as_immediate,\r\n                pos : t2,\r\n                point_size : 13,\r\n                color : c2,\r\n                batcher : batcher,\r\n                depth : 999.4,\r\n                text : notes_l + \" / \" + notes_r,\r\n                align : talign\r\n            })\r\n        ); //node text\r\n    }\r\n\r\n    public function draw_geom_leaf( L:Bool, _leaf : BalancedBSTNode<GeometryKey,Geometry>, _p:Vector ) {\r\n\r\n        if(_leaf == null) {\r\n            return;\r\n        }\r\n\r\n        var _bw:Float = _leaf.nodecount / 20;\r\n        var _bwb:Float = _leaf.nodecount * 25;\r\n        var _bh:Float = 128;\r\n        var _bh2:Float = 148;\r\n        var _bwhalf:Float = _bw/2;\r\n\r\n        var c = new Color(1,1,1,0.4).rgb(0xffffff);\r\n\r\n        if(_leaf != null) {\r\n\r\n            draw_geom_node(L, _leaf, _p, _bw);\r\n\r\n            if(_leaf.left != null) {\r\n\r\n                if( Luxe.renderer.batcher.geometry_compare( _leaf.left.key, _leaf.key ) < 0 ) {\r\n                    c = new Color(1,1,1,1).rgb(0x00cc00);\r\n                } else {\r\n                    c = new Color(1,1,1,1).rgb(0xcc0000);\r\n                }\r\n\r\n                _tree_geom.add_geometry(\r\n                    Luxe.draw.line({\r\n                        immediate:as_immediate,\r\n                        p0 : new Vector(_p.x-_bwhalf,_p.y+_bh),\r\n                        p1 : new Vector(_p.x-_bwb, _p.y+_bh2 ),\r\n                        color: c,\r\n                        batcher : batcher,\r\n                        depth : 999.4\r\n                    })\r\n                );\r\n\r\n                draw_geom_leaf(true, _leaf.left, new Vector(_p.x-_bwb, _p.y+_bh2 ));\r\n            }\r\n            if(_leaf.right != null) {\r\n\r\n                if( Luxe.renderer.batcher.geometry_compare( _leaf.right.key, _leaf.key ) > 0 ) {\r\n                    c = new Color(1,1,1,1).rgb(0x00cc00);\r\n                } else {\r\n                    c = new Color(1,1,1,1).rgb(0xcc0000);\r\n                }\r\n\r\n                _tree_geom.add_geometry(\r\n                    Luxe.draw.line({\r\n                        immediate:as_immediate,\r\n                        p0 : new Vector(_p.x+_bwhalf,_p.y+_bh),\r\n                        p1 : new Vector(_p.x+_bwb, _p.y+_bh2),\r\n                        color: c,\r\n                        batcher : batcher,\r\n                        depth : 999.4\r\n                    })\r\n                );\r\n\r\n                draw_geom_leaf(false, _leaf.right, new Vector(_p.x+_bwb, _p.y+_bh2));\r\n            }\r\n        } //leaf != null\r\n    }\r\n\r\n    public function draw_batcher_tree() {\r\n\r\n        _tree_geom = null;\r\n        _tree_geom = new CompositeGeometry({\r\n            batcher : batcher,\r\n            immediate:as_immediate,\r\n            depth : 999.4\r\n        });\r\n\r\n        //draw the root\r\n        var _p : Vector = new Vector(Luxe.screen.w/2, (Luxe.debug.padding.y*2)+10);\r\n\r\n        var _node = Luxe.renderer.batcher.geometry.root;\r\n\r\n            draw_geom_leaf(true, _node, _p);\r\n\r\n    }\r\n\r\n    public override function process() {\r\n        if(visible) {\r\n            if(Luxe.renderer.batcher.tree_changed) {\r\n                refresh();\r\n            }\r\n        }\r\n    }\r\n\r\n    public override function show() {\r\n        super.show();\r\n        refresh();\r\n    }\r\n\r\n    public override function hide() {\r\n        super.hide();\r\n        clear_batcher_tree();\r\n    }\r\n\r\n} //BatcherDebugView\r\n","package luxe.debug;\r\n\r\nimport luxe.Text;\r\nimport phoenix.Texture;\r\nimport luxe.NineSlice;\r\nimport phoenix.Batcher;\r\nimport phoenix.BitmapFont;\r\n\r\ntypedef DebugInspectorOptions = {\r\n    ? title : String,\r\n    ? font : BitmapFont,\r\n    ? pos  : Vector,\r\n    ? size : Vector,\r\n    ? batcher : Batcher\r\n}\r\n\r\n@:noCompletion class Inspector {\r\n\r\n    public var title:String;\r\n    public var font : BitmapFont;\r\n    @:isVar public var pos (default,set): Vector;\r\n    @:isVar public var size (default,set): Vector;\r\n\r\n        //pieces\r\n    public var _title_text : Text;\r\n    public var _version_text : Text;\r\n\r\n    public var uitexture : Texture;\r\n    public var uibutton : Texture;\r\n\r\n    public var _window : NineSlice;\r\n    public var onrefresh : Void->Void;\r\n\r\n    var _batcher : Batcher;\r\n\r\n    public function new( _options:DebugInspectorOptions ) {\r\n\r\n        title = 'Inspector';\r\n        font = Luxe.renderer.font;\r\n        size = new Vector( Std.int(Luxe.screen.w*0.2), Std.int(Luxe.screen.h*0.6) );\r\n        pos = new Vector((Luxe.screen.w/2) - (size.x/2), (Luxe.screen.h/2) - (size.y/2));\r\n\r\n            //load the images\r\n        uitexture = Texture.load_from_resource('tiny.ui.png');\r\n        uibutton =  Texture.load_from_resource('tiny.button.png');\r\n\r\n            //default to the internal batcher\r\n        _batcher = Luxe.renderer.batcher;\r\n\r\n        if(_options != null) {\r\n\r\n            if(_options.title != null) title = _options.title;\r\n            if(_options.font != null) font = _options.font;\r\n            if(_options.pos != null) pos = _options.pos;\r\n            if(_options.size != null) size = _options.size;\r\n            if(_options.batcher != null) _batcher = _options.batcher;\r\n\r\n        } //_options != null\r\n\r\n    } //new\r\n\r\n    public function refresh() {\r\n        if(_window == null) {\r\n            _create_window();\r\n        }\r\n\r\n        if(onrefresh != null) {\r\n            onrefresh();\r\n        }\r\n    }\r\n\r\n    public function show() {\r\n        refresh();\r\n        _window.visible = true;\r\n        _title_text.visible = true;\r\n        _version_text.visible = true;\r\n    }\r\n    public function hide() {\r\n        _window.visible = false;\r\n        _title_text.visible = false;\r\n        _version_text.visible = false;\r\n    }\r\n\r\n    function set_size(_size:Vector) {\r\n\r\n        if(size != null && _window != null) {\r\n            _window.size = _size;\r\n        }\r\n\r\n        if(_version_text != null) {\r\n            _version_text.pos = new Vector( pos.x+(_size.x-14), pos.y+6 );\r\n        }\r\n\r\n        return size = _size;\r\n    }\r\n\r\n    function set_pos(_pos:Vector) {\r\n\r\n        if(pos != null && _window != null) {\r\n            _window.pos = _pos;\r\n        }\r\n\r\n        if(_title_text != null) {\r\n            _title_text.pos = new Vector( _pos.x+14, _pos.y+6 );\r\n        }\r\n\r\n        if(_version_text != null) {\r\n            _version_text.pos = new Vector( _pos.x+(size.x-14), _pos.y+6 );\r\n        }\r\n\r\n        return pos = _pos;\r\n    }\r\n\r\n    function _create_window() {\r\n\r\n            //if already exists, clean up\r\n        if(_window != null) {\r\n            _window.destroy();\r\n        }\r\n\r\n        _window = new NineSlice({\r\n            depth : 999.1,\r\n            texture : uitexture,\r\n            batcher : _batcher\r\n        });\r\n\r\n        _window.create( pos, size.x, size.y );\r\n        _window._geometry.id = 'debug.Inspector';\r\n\r\n            //static batch\r\n        _window.lock();\r\n\r\n        _title_text = new Text({\r\n            name : 'debug.title',\r\n            batcher : _batcher,\r\n            no_scene : true,\r\n            depth : 999.2,\r\n            color : new Color().rgb(0xf6007b),\r\n            pos : new Vector( pos.x+14, pos.y+6 ),\r\n            align : TextAlign.left,\r\n            font : font,\r\n            text : title,\r\n            point_size : 15,\r\n            visible : false\r\n        });\r\n\r\n        _version_text = new Text({\r\n            name : 'debug.version',\r\n            batcher : _batcher,\r\n            no_scene : true,\r\n            depth : 999.2,\r\n            color : new Color().rgb(0x333333),\r\n            pos : new Vector( pos.x+(size.x-14), pos.y+6 ),\r\n            align : TextAlign.right,\r\n            font : font,\r\n            text : '${Luxe.build}',\r\n            point_size : 16,\r\n            visible : false\r\n        });\r\n\r\n        if(_title_text.geometry != null) {\r\n            _title_text.geometry.id = 'debug.title.text';\r\n        }\r\n\r\n        if(_version_text.geometry != null) {\r\n            _version_text.geometry.id = 'debug.version.text';\r\n        }\r\n\r\n    }\r\n}\r\n","package luxe.debug;\r\n\r\nimport luxe.Input.MouseEvent;\r\nimport luxe.Rectangle;\r\nimport luxe.Text;\r\nimport luxe.Vector;\r\nimport phoenix.Batcher.PrimitiveType;\r\nimport phoenix.geometry.Geometry;\r\nimport phoenix.geometry.QuadGeometry;\r\nimport phoenix.geometry.Vertex;\r\n\r\nclass ProfilerDebugView extends luxe.debug.DebugView {\r\n\r\n    public static var lists:Map<String,ProfilerValue>;\r\n\r\n    public function new() {\r\n\r\n        super();\r\n\r\n        name = 'Profiler';\r\n        lists = new Map();\r\n    }\r\n\r\n    var _setup : Bool = false;\r\n\r\n    public static function add_offset(_id:String, _offset:String) {\r\n        var _item = lists.get(_id);\r\n        var _offsetitem = lists.get(_offset);\r\n        if(_item != null && _offsetitem != null) {\r\n            _item.offsets.push(_offsetitem);\r\n        } else {\r\n            trace(\"not found for \" + _id + \" or \" + _offset);\r\n            trace(_item + \" / \" + _offsetitem);\r\n        }\r\n    }\r\n\r\n    public static function hide_item(_id:String) {\r\n        var _item = lists.get(_id);\r\n        if(_item != null) {\r\n            _item.hidden = true;\r\n            _item.bar.hide();\r\n        }\r\n    }\r\n    public static function show_item(_id:String) {\r\n        var _item = lists.get(_id);\r\n        if(_item != null) {\r\n            _item.hidden = false;\r\n            _item.bar.show();\r\n        }\r\n    }\r\n\r\n    public static function start(_id:String, ?_max:Float=0.0) {\r\n        var _item = lists.get(_id);\r\n        if(_item == null) {\r\n            //create it\r\n            _item = new ProfilerValue(_id, new ProfilerBar(_id, _max, new Color().rgb(0xf6007b) ));\r\n            _item.bar.pos = new Vector(Luxe.debug.padding.x*2,(Luxe.debug.padding.y*3) + (Lambda.count(lists) * 20) );\r\n            lists.set(_id, _item);\r\n        }\r\n\r\n        _item.start = Luxe.time;\r\n    }\r\n\r\n    public static function end(_id:String) {\r\n        var _item = lists.get(_id);\r\n        if(_item!=null) {\r\n            _item.set();\r\n        } else {\r\n            throw \"Profile end called for \" + _id + \" but no start called\";\r\n        }\r\n    }\r\n\r\n    public override function show() {\r\n        for(_item in lists) {\r\n            if(!_item.hidden) {\r\n                _item.bar.show();\r\n            }\r\n        }\r\n\r\n        if(!_setup) {\r\n            ProfilerDebugView.add_offset('core.render' , 'batch.debug_batcher');\r\n            // ProfilerDebugView.add_offset('core.render' , 'batch.debug_batcher_view');\r\n            // ProfilerDebugView.hide_item('batch.debug_batcher');\r\n            // ProfilerDebugView.hide_item('batch.debug_batcher_view');\r\n            _setup = true;\r\n        }\r\n    }\r\n    public override function hide() {\r\n        for(_item in lists) {\r\n            _item.bar.hide();\r\n        }\r\n    }\r\n\r\n}\r\n\r\nprivate class ProfilerValue {\r\n\r\n    public var offsets : Array<ProfilerValue>;\r\n    public var bar : ProfilerBar;\r\n    public var name : String;\r\n    public var start : Float = 0.0;\r\n    public var history : Array<Float>;\r\n    public var avg : Int = 10;\r\n    public var hidden : Bool = false;\r\n    var count : Int = 0;\r\n    var accum : Float = 0;\r\n\r\n    public function new(_name:String, _bar:ProfilerBar) {\r\n        name = _name; bar = _bar;\r\n        history = [];\r\n        offsets = [];\r\n    }\r\n\r\n    public function set() {\r\n\r\n        var _t = Luxe.time - start;\r\n\r\n            //adjust by any offsets\r\n        for(_offset in offsets) {\r\n            _t -= _offset.history[_offset.history.length-1];\r\n        }\r\n\r\n            //push the value into history\r\n        history.push(_t);\r\n            //drop old values\r\n        if(history.length > avg) {\r\n            history.shift();\r\n        }\r\n\r\n        count++;\r\n            //reset if maxed average\r\n        if(count == avg) {\r\n            var __t = accum / avg;\r\n            bar.value = __t;\r\n            bar.ping = __t;\r\n            accum = 0;\r\n            count = 0;\r\n        }\r\n\r\n        accum += _t;\r\n\r\n        if(bar.visible) {\r\n            bar.text = Std.string(luxe.utils.Maths.fixed(_t*1000,4));\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\nprivate class ProfilerBar {\r\n\r\n    public var bar_geometry : QuadGeometry;\r\n    public var bg_geometry : QuadGeometry;\r\n    public var graphbg_geometry : QuadGeometry;\r\n    public var graph_geometry : Geometry;\r\n\r\n    public var text_item : Text;\r\n    public var name : String;\r\n\r\n    public var width : Float = 128;\r\n    public var height : Float = 8;\r\n    public var height2 : Float = 8;\r\n    public var max : Float = 16.6;\r\n    public var history:Int = 33;\r\n    public var visible:Bool = false;\r\n    var segment : Float;\r\n\r\n    var color_red : Color;\r\n    var color_green : Color;\r\n    var color_normal : Color;\r\n\r\n    @:isVar public var text (default,set) : String;\r\n    @:isVar public var pos (default,set) : Vector;\r\n    @:isVar public var value (default,set) : Float;\r\n    @:isVar public var ping (default,set) : Float;\r\n\r\n    public function new(_name:String, ?_max:Float=0.0, _color:Color){\r\n\r\n        color_red = new Color().rgb(0xcc0000);\r\n        color_green = new Color().rgb(0x228844);\r\n        color_normal = new Color().rgb(0xf0f0f0);\r\n\r\n        max = _max == 0.0 ? (1/60) * 1000 : _max;\r\n        max = luxe.utils.Maths.fixed(max,1);\r\n        name = _name;\r\n        segment = (width/history);\r\n        height2 = height*2;\r\n\r\n        text_item = new Text({\r\n            no_scene : true,\r\n            name : 'profiler.text.' + _name,\r\n            pos : new Vector(0,0),\r\n            color : _color,\r\n            point_size : height*1.8,\r\n            depth : 999.3,\r\n            text : '',\r\n            batcher : Luxe.debug.batcher\r\n        });\r\n\r\n        bg_geometry = Luxe.draw.box({\r\n            color : new Color().rgb(0x090909),\r\n            depth : 999.3,\r\n            batcher : Luxe.debug.batcher,\r\n            x:0, y:0, w:width, h:height\r\n        });\r\n\r\n        graphbg_geometry = Luxe.draw.box({\r\n            color : new Color().rgb(0x222222),\r\n            depth : 999.3,\r\n            batcher : Luxe.debug.batcher,\r\n            x:0, y:0, w:width-segment, h:height*2\r\n        });\r\n\r\n        bar_geometry = Luxe.draw.box({\r\n            color : _color,\r\n            depth : 999.33,\r\n            batcher : Luxe.debug.batcher,\r\n            x:1, y:1, w:width-2, h:height-2\r\n        });\r\n\r\n        graph_geometry = new Geometry({\r\n            color : _color,\r\n            depth : 999.33,\r\n            batcher : Luxe.debug.batcher\r\n        });\r\n\r\n        for(i in 0 ... history) {\r\n            var _b = new Vertex(new Vector(segment*i, 0), _color);\r\n            graph_geometry.add( _b );\r\n        }\r\n\r\n        graph_geometry.primitive_type = PrimitiveType.line_strip;\r\n\r\n        hide();\r\n\r\n    }\r\n\r\n    public function hide() {\r\n        visible = false;\r\n        bar_geometry.visible = false;\r\n        bg_geometry.visible = false;\r\n        graph_geometry.visible = false;\r\n        graphbg_geometry.visible = false;\r\n        text_item.visible = false;\r\n    }\r\n    public function show() {\r\n        visible = true;\r\n        bar_geometry.visible = true;\r\n        bg_geometry.visible = true;\r\n        graph_geometry.visible = true;\r\n        graphbg_geometry.visible = true;\r\n        text_item.visible = true;\r\n    }\r\n\r\n    function set_ping(_v:Float) {\r\n\r\n        var _vv = luxe.utils.Maths.fixed(_v*1000,4);\r\n        var _p = _vv/max;\r\n\r\n            //shift every vertex left\r\n        for(i in 0 ... history) {\r\n            //copy x from the next one\r\n            var v = graph_geometry.vertices[i];\r\n            if(i < (history-1)) {\r\n                var v1 = graph_geometry.vertices[i+1];\r\n                if(v1 != null) {\r\n                    v.pos.y = Math.floor(v1.pos.y);\r\n                    v.color = v1.color;\r\n                }\r\n            }\r\n        }\r\n\r\n        if(_p > 1) {\r\n            _p = 1;\r\n            graph_geometry.vertices[history-1].color = color_red;\r\n        } else if(_p < 0.2) {\r\n            graph_geometry.vertices[history-1].color = color_green;\r\n        } else {\r\n            graph_geometry.vertices[history-1].color = color_normal;\r\n        }\r\n\r\n        if(_p < 0.001) {\r\n            _p = 0.001;\r\n        }\r\n\r\n        graph_geometry.vertices[history-1].pos.y = Math.floor(((height2)*(1.0-_p)));\r\n\r\n        return ping = _v;\r\n    }\r\n\r\n    function set_value(_v:Float) {\r\n        var _vv = luxe.utils.Maths.fixed(_v*1000,4);\r\n        var _p = _vv/max;\r\n        if(_p > 1) {\r\n            _p = 1;\r\n            bar_geometry.color = color_red;\r\n        } else if(_p < 0.15) {\r\n            bar_geometry.color = color_green;\r\n        } else {\r\n            bar_geometry.color = color_normal;\r\n        }\r\n\r\n        if(_p < 0.005) {\r\n            _p = 0.005;\r\n        }\r\n\r\n        var nx = (width-2)*_p;\r\n        // bar_geometry.transform.pos = new Vector();\r\n        bar_geometry.resize(new Vector(nx, height-2));\r\n        // bar_geometry.transform.pos = new Vector(bg_geometry.transform.pos.x+1, bg_geometry.transform.pos.y+1);\r\n\r\n        return value = _v;\r\n    }\r\n\r\n    function set_pos(_p:Vector) {\r\n        bg_geometry.transform.pos = _p;\r\n        bar_geometry.transform.pos = new Vector(_p.x+1, _p.y+1);\r\n        text_item.pos = new Vector(_p.x+(width*2)+10, _p.y-6);\r\n        graphbg_geometry.transform.pos = new Vector(_p.x+width+2, _p.y-4);\r\n        graph_geometry.transform.pos = graphbg_geometry.transform.pos;\r\n        return pos = _p;\r\n    }\r\n\r\n    function set_text(_t:String) {\r\n        text_item.text = '$name (${max}ms) | ${_t}ms';\r\n        return text = _t;\r\n    }\r\n\r\n}\r\n","package luxe.debug;\r\n\r\nimport luxe.Input;\r\nimport luxe.Screen.WindowEvent;\r\nimport luxe.resource.Resource;\r\n\r\ntypedef RenderStats = {\r\n    batchers : Int,\r\n    geometry_count : Int,\r\n    dynamic_batched_count : Int,\r\n    static_batched_count : Int,\r\n    visible_count : Int,\r\n    draw_calls : Int,\r\n    vert_count : Int,\r\n    group_count : Int\r\n}\r\n\r\nclass StatsDebugView extends luxe.debug.DebugView  {\r\n\r\n    public var _last_render_stats : RenderStats;\r\n    public var _render_stats : RenderStats;\r\n\r\n    public var debug_draw_call_count : Int = 3;\r\n    public var debug_geometry_count : Int = 13;\r\n    public var font_size : Int = 15;\r\n\r\n        //stats console\r\n    public var render_stats_text : luxe.Text;\r\n    public var resource_stats_text : luxe.Text;\r\n    public var resource_list_text : luxe.Text;\r\n\r\n    public function new() {\r\n\r\n        super();\r\n\r\n        name = 'Statistics';\r\n\r\n        _last_render_stats = {\r\n            batchers : 0,\r\n            geometry_count : 0,\r\n            dynamic_batched_count : 0,\r\n            static_batched_count : 0,\r\n            visible_count : 0,\r\n            draw_calls : 0,\r\n            vert_count : 0,\r\n            group_count : 0\r\n        };\r\n\r\n        _render_stats = {\r\n            batchers : 0,\r\n            geometry_count : 0,\r\n            dynamic_batched_count : 0,\r\n            static_batched_count : 0,\r\n            visible_count : 0,\r\n            draw_calls : 0,\r\n            vert_count : 0,\r\n            group_count : 0\r\n        };\r\n\r\n    }\r\n\r\n    public function get_resource_stats_string() {\r\n        return Std.string( Luxe.resources.stats );\r\n    }\r\n\r\n    public function get_render_stats_string() {\r\n        return\r\n            'Renderer Statistics\\n' +\r\n            '\\tbatcher count : ' + _render_stats.batchers + '\\n' +\r\n            '\\ttotal geometry : ' + _render_stats.geometry_count + '\\n' +\r\n            '\\tvisible geometry : ' + _render_stats.visible_count + '\\n' +\r\n            '\\tdynamic batch count : ' + _render_stats.dynamic_batched_count + '\\n' +\r\n            '\\tstatic batch count : ' + _render_stats.static_batched_count + '\\n' +\r\n            '\\ttotal draw calls : ' + _render_stats.draw_calls + '\\n' +\r\n            '\\ttotal vert count : ' + _render_stats.vert_count;\r\n    }\r\n\r\n    public override function create() {\r\n\r\n        var debug = Luxe.debug;\r\n\r\n        render_stats_text = new luxe.Text({\r\n            depth : 999.3,\r\n            no_scene : true,\r\n            color : new Color(0,0,0,1).rgb(0xf6007b),\r\n            pos : new Vector(debug.padding.x*2,debug.padding.y*3),\r\n            font : Luxe.renderer.font,\r\n            text : get_render_stats_string(),\r\n            point_size : font_size,\r\n            batcher : debug.batcher,\r\n            visible : false\r\n        });\r\n\r\n        resource_stats_text = new luxe.Text({\r\n            depth : 999.3,\r\n            no_scene : true,\r\n            color : new Color(0,0,0,1).rgb(0xf6007b),\r\n            pos : new Vector(debug.padding.x*2,debug.padding.y*7.5),\r\n            font : Luxe.renderer.font,\r\n            text : get_resource_stats_string(),\r\n            point_size : font_size,\r\n            batcher : debug.batcher,\r\n            visible : false\r\n        });\r\n\r\n        resource_list_text = new luxe.Text({\r\n            depth : 999.3,\r\n            no_scene : true,\r\n            color : new Color(0,0,0,1).rgb(0xf6007b),\r\n            pos : new Vector(debug.padding.x*7,debug.padding.y*3),\r\n            font : Luxe.renderer.font,\r\n            text : '',\r\n            point_size : font_size*0.8,\r\n            batcher : debug.batcher,\r\n            visible : false\r\n        });\r\n\r\n\r\n        resource_list_text.locked = true;\r\n        resource_stats_text.locked = true;\r\n\r\n    }\r\n\r\n    override function onwindowsized(e:WindowEvent) {\r\n\r\n        var debug = Luxe.debug;\r\n\r\n        if(resource_list_text != null) {\r\n            resource_list_text.pos = new Vector(debug.padding.x*7,debug.padding.y*3);\r\n            resource_list_text.geometry.dirty = true;\r\n        }\r\n        if(resource_stats_text != null) {\r\n            resource_stats_text.pos = new Vector(debug.padding.x*2,debug.padding.y*7.5);\r\n            resource_stats_text.geometry.dirty = true;\r\n        }\r\n        if(render_stats_text != null) {\r\n            render_stats_text.pos = new Vector(debug.padding.x*2,debug.padding.y*3);\r\n            render_stats_text.geometry.dirty = true;\r\n        }\r\n\r\n    } //onwindowsized\r\n\r\n    public override function refresh() {\r\n\r\n        var texture_lists = '';\r\n        var shader_lists = '';\r\n        var font_lists = '';\r\n\r\n        for(res in Luxe.resources.resourcelist) {\r\n            switch (res.type) {\r\n                case ResourceType.texture:\r\n                    var t : phoenix.Texture = cast res;\r\n                    texture_lists += '\\t' + t.id + '    (' +  t.width_actual + 'x' + t.height_actual + '  '+ t.estimated_memory() +' )\\n';\r\n                case ResourceType.font:\r\n                    font_lists += '\\t' + res.id + '\\n';\r\n                case ResourceType.shader:\r\n                    shader_lists += '\\t' + res.id + '\\n';\r\n                default:\r\n            }\r\n        }\r\n\r\n        var lists = 'Fonts\\n';\r\n            lists += font_lists;\r\n            lists += 'Shader\\n';\r\n            lists += shader_lists;\r\n            lists += 'Textures\\n';\r\n            lists += texture_lists;\r\n\r\n        resource_list_text.text = lists;\r\n        if(resource_list_text.geometry != null) {\r\n            resource_list_text.geometry.dirty = true;\r\n        }\r\n    }\r\n\r\n\r\n\r\n    public override function process() {\r\n\r\n        if(!visible) return;\r\n\r\n        var dirty = false;\r\n\r\n            //Update the local statistics\r\n        update_render_stats();\r\n\r\n        if(_last_render_stats.batchers != _render_stats.batchers)\r\n            { dirty = true; _last_render_stats.batchers = _render_stats.batchers; }\r\n        if(_last_render_stats.geometry_count != _render_stats.geometry_count)\r\n            { dirty = true; _last_render_stats.geometry_count = _render_stats.geometry_count; }\r\n        if(_last_render_stats.dynamic_batched_count != _render_stats.dynamic_batched_count)\r\n            { dirty = true; _last_render_stats.dynamic_batched_count = _render_stats.dynamic_batched_count; }\r\n        if(_last_render_stats.static_batched_count != _render_stats.static_batched_count)\r\n            { dirty = true; _last_render_stats.static_batched_count = _render_stats.static_batched_count; }\r\n        if(_last_render_stats.visible_count != _render_stats.visible_count)\r\n            { dirty = true; _last_render_stats.visible_count = _render_stats.visible_count; }\r\n        if(_last_render_stats.draw_calls != _render_stats.draw_calls)\r\n            { dirty = true; _last_render_stats.draw_calls = _render_stats.draw_calls; }\r\n        if(_last_render_stats.group_count != _render_stats.group_count)\r\n            { dirty = true; _last_render_stats.group_count = _render_stats.group_count; }\r\n        if(_last_render_stats.vert_count != _render_stats.vert_count)\r\n            { dirty = true; _last_render_stats.vert_count = _render_stats.vert_count; }\r\n\r\n        if(dirty) {\r\n            refresh_render_stats();\r\n        } //dirty\r\n\r\n    } //process\r\n\r\n    public override function onkeydown(e:KeyEvent) {\r\n        if(e.keycode == Key.key_2 && visible ) {\r\n            toggle_debug_stats();\r\n        }\r\n    } //onkeydown\r\n\r\n    public override function show() {\r\n        super.show();\r\n        refresh();\r\n        render_stats_text.visible = true;\r\n        resource_stats_text.visible = true;\r\n        resource_list_text.visible = true;\r\n    } //show\r\n\r\n    public override function hide() {\r\n        super.hide();\r\n        render_stats_text.visible = false;\r\n        resource_stats_text.visible = false;\r\n        resource_list_text.visible = false;\r\n    } //hide\r\n\r\n   public function refresh_render_stats() {\r\n\r\n        if(!visible) {\r\n            return;\r\n        }\r\n\r\n        render_stats_text.text = get_render_stats_string();\r\n        resource_stats_text.text = get_resource_stats_string();\r\n\r\n        resource_stats_text.locked = true;\r\n        render_stats_text.locked = true;\r\n\r\n        if(render_stats_text.geometry != null) {\r\n            resource_stats_text.geometry.dirty = true;\r\n            render_stats_text.geometry.dirty = true;\r\n        }\r\n\r\n    } //refresh_render_stats\r\n\r\n    public var hide_debug : Bool = true;\r\n    public function toggle_debug_stats() {\r\n         hide_debug = !hide_debug;\r\n    }\r\n\r\n    public function update_render_stats() {\r\n\r\n        debug_geometry_count = Luxe.debug.batcher.geometry.size();\r\n        debug_draw_call_count = Luxe.debug.batcher.draw_calls;\r\n\r\n        _render_stats.batchers = Luxe.renderer.stats.batchers;\r\n        _render_stats.geometry_count = Luxe.renderer.stats.geometry_count;\r\n        _render_stats.visible_count = Luxe.renderer.stats.visible_count;\r\n        _render_stats.dynamic_batched_count = Luxe.renderer.stats.dynamic_batched_count;\r\n        _render_stats.static_batched_count = Luxe.renderer.stats.static_batched_count;\r\n        _render_stats.draw_calls = Luxe.renderer.stats.draw_calls;\r\n        _render_stats.vert_count = Luxe.renderer.stats.vert_count;\r\n\r\n        if(hide_debug) {\r\n\r\n            _render_stats.batchers = _render_stats.batchers - 1;\r\n            _render_stats.geometry_count = _render_stats.geometry_count - debug_geometry_count;\r\n            _render_stats.visible_count = _render_stats.visible_count - Luxe.debug.batcher.visible_count;\r\n            _render_stats.dynamic_batched_count = _render_stats.dynamic_batched_count - Luxe.debug.batcher.dynamic_batched_count;// - Luxe.debug.batcher.static_batched_count;\r\n            _render_stats.static_batched_count = _render_stats.static_batched_count - Luxe.debug.batcher.static_batched_count;\r\n            _render_stats.draw_calls -= debug_draw_call_count;\r\n            _render_stats.vert_count -= Luxe.debug.batcher.vert_count;\r\n\r\n        } //hide debug stats?\r\n\r\n    } //update_render_stats\r\n\r\n} //StatsDebugView\r\n\r\n\r\n","package luxe.debug;\r\n\r\nimport luxe.Screen.WindowEvent;\r\n\r\nclass TraceDebugView extends luxe.debug.DebugView {\r\n\r\n        //log console\r\n    public var logged : Array<String>;\r\n    public var lines : luxe.Text;\r\n    public var max_lines : Int = 35;\r\n\r\n    public function new() {\r\n\r\n        super();\r\n\r\n        name = 'Log';\r\n\r\n        Luxe.debug.add_trace_listener('TraceDebugView', on_trace);\r\n\r\n        logged = new Array<String>();\r\n\r\n        add_line('luxe version ${Luxe.build} Debug Log');\r\n\r\n    } //new\r\n\r\n    public function on_trace( v : Dynamic, ?inf : haxe.PosInfos ) {\r\n        add_line( inf.fileName + ':' + inf.lineNumber + ' ' + v );\r\n    }\r\n\r\n    public override function create() {\r\n\r\n        var debug = Luxe.debug;\r\n        var text_bounds = new luxe.Rectangle( debug.padding.x+20, debug.padding.y+40, Luxe.screen.w-(debug.padding.x*2)-20, Luxe.screen.h-(debug.padding.y*2)-40 );\r\n\r\n        lines = new luxe.Text({\r\n            name : 'debug.log.text',\r\n            no_scene : true,\r\n            depth : 999.3,\r\n            color : new Color().rgb(0x888888),\r\n            bounds : text_bounds,\r\n            bounds_wrap : true,\r\n            font : Luxe.renderer.font,\r\n            text : '',\r\n            align_vertical : luxe.Text.TextAlign.bottom,\r\n            point_size : 12,\r\n            batcher : debug.batcher,\r\n            visible : false\r\n        });\r\n\r\n        if(lines.geometry != null) {\r\n            lines.geometry.clip_rect = text_bounds;\r\n            lines.geometry.locked = true;\r\n        }\r\n    }\r\n\r\n    override function onwindowsized(e:WindowEvent) {\r\n        var debug = Luxe.debug;\r\n        var text_bounds = new luxe.Rectangle( debug.padding.x+20, debug.padding.y+40, Luxe.screen.w-(debug.padding.x*2)-20, Luxe.screen.h-(debug.padding.y*2)-40 );\r\n        lines.bounds = text_bounds;\r\n        lines.clip_rect = text_bounds;\r\n            //flush the sizes\r\n        if(lines.geometry != null) {\r\n            lines.geometry.locked = true;\r\n            lines.geometry.dirty = true;\r\n        }\r\n    }\r\n\r\n    public function add_line(_t:String) {\r\n\r\n        if(logged == null) {\r\n            return;\r\n        }\r\n\r\n            //store in the list of pushed lines\r\n        logged.push(_t);\r\n\r\n            //update the line geometry\r\n        if(!visible) {\r\n            return;\r\n        }\r\n\r\n        refresh_lines();\r\n\r\n    } //add_line\r\n\r\n    var _last_logged_length : Int = 0;\r\n    function refresh_lines() {\r\n\r\n        if(_last_logged_length == logged.length) {\r\n            return;\r\n        }\r\n\r\n            //we go though each line in the logged list,\r\n            //and create a string from them.\r\n            //then we set the lines text to that\r\n        var _final = '';\r\n\r\n        if(logged.length <= max_lines) {\r\n            for(_line in logged) {\r\n                _final += _line + '\\n';\r\n            }\r\n        } else {\r\n            var _start = logged.length - max_lines;\r\n            var _total = logged.length;\r\n            for(i in _start ... logged.length) {\r\n                var _line = logged[i];\r\n                _final += _line + '\\n';\r\n            }\r\n        }//\r\n\r\n        lines.text = _final;\r\n\r\n        if(lines.geometry != null) {\r\n            lines.geometry.locked = true;\r\n            lines.geometry.dirty = true;\r\n        }\r\n\r\n        _last_logged_length = logged.length;\r\n\r\n    } //refresh_lines\r\n\r\n\r\n    public override function refresh() {\r\n\r\n    }\r\n\r\n    public override function process() {\r\n\r\n    }\r\n\r\n    public override function show() {\r\n        super.show();\r\n        refresh_lines();\r\n        lines.visible = true;\r\n    }\r\n\r\n    public override function hide() {\r\n        super.hide();\r\n        lines.visible = false;\r\n    }\r\n\r\n}\r\n","package luxe.macros;\r\n\r\nimport haxe.macro.Expr;\r\nimport haxe.macro.Context;\r\n\r\nimport haxe.io.Bytes;\r\nimport haxe.io.Path;\r\n\r\n\r\n#if macro\r\nimport sys.io.File;\r\nimport sys.FileSystem;\r\n#end\r\n\r\n@:noCompletion class BuildVersion {\r\n\r\n    public static var _save : Bool = false;\r\n\r\n    macro public static function save() : haxe.macro.Expr {\r\n\r\n        _save = true;\r\n\r\n        return macro null;\r\n\r\n    } //save\r\n\r\n        //This is always called from Luxe.hx in the root folder,\r\n        //which contains the .git repo, and build file directly\r\n    macro public static function latest() {\r\n\r\n        var location : String = Context.getPosInfos(Context.currentPos()).file;\r\n        var root : String = Path.addTrailingSlash(Path.directory(location));\r\n        var out : String = Path.join([root,'build']);\r\n\r\n        var build : String = try_git( root );\r\n\r\n        if(build != '') {\r\n\r\n                //the + is for semantic versioning\r\n            build = '+' + build.substr(0,10);\r\n\r\n            if(_save) {\r\n                File.saveContent(out, build);\r\n            }\r\n\r\n            Context.addResource('build', Bytes.ofString(build));\r\n        }\r\n\r\n        return Context.makeExpr(build, Context.currentPos());\r\n\r\n    } //latest\r\n\r\n    static function try_git(root:String) {\r\n\r\n\r\n\t\t#if macro\r\n\t\t\tvar git_path : String = Path.join([root,'.git/']);\r\n\t\t\t\tgit_path = Path.normalize(git_path);\r\n\r\n\t\t\tif(FileSystem.exists(git_path) && FileSystem.isDirectory(git_path)) {\r\n\t\t\t\tvar ref_file = Path.normalize(Path.join([git_path,'refs/heads/master']));\r\n\t\t\t\tif(FileSystem.exists(ref_file)) {\r\n                    return File.getContent(ref_file);\r\n                } else {\r\n                    return '';\r\n                }\r\n\t\t\t}\r\n\t\t#end\r\n\r\n        return '';\r\n\r\n    } //try_git\r\n\r\n} //BuildVersion","package luxe.resource;\r\n\r\nimport snow.io.typedarray.Uint8Array;\r\n\r\nimport luxe.resource.Resources;\r\n\r\n\r\n@:enum\r\nabstract ResourceType(Int) from Int to Int {\r\n    var unknown = 0;\r\n    var text = 1;\r\n    var json = 2;\r\n    var data = 3;\r\n    var texture = 4;\r\n    var sound = 5;\r\n    var render_texture = 6;\r\n    var font = 7;\r\n    var shader = 8;\r\n}\r\n\r\nclass Resource {\r\n\r\n\r\n    public var manager : Resources;\r\n    public var type : ResourceType;\r\n    public var id : String;\r\n    public var persistent : Bool = false;\r\n    public var time_to_load : Float = 0;\r\n    public var time_created : Float = 0;\r\n    public var dropped : Bool = false;\r\n\r\n\r\n    public function new( _manager : Resources, _type:ResourceType, ?_load_time:Float ) {\r\n\r\n        manager = _manager == null ? Luxe.resources : _manager;\r\n        type = _type;\r\n\r\n        time_to_load = _load_time;\r\n        time_created = Luxe.time;\r\n\r\n        manager.add( this );\r\n\r\n    } //new\r\n\r\n    public function drop() {\r\n        if(!dropped) {\r\n            dropped = true;\r\n            manager.remove( this );\r\n        }\r\n    } //drop\r\n\r\n\r\n} //Resource\r\n\r\n\r\nclass TextResource extends Resource {\r\n\r\n\r\n    public var text : String;\r\n\r\n\r\n    public function new( _id:String, _text:String, _manager:Resources ) {\r\n\r\n        id = _id;\r\n\r\n        super( _manager, ResourceType.text );\r\n\r\n        text = _text;\r\n\r\n    } //new\r\n\r\n\r\n} //TextResource\r\n\r\nclass JSONResource extends Resource {\r\n\r\n\r\n    public var json : Dynamic;\r\n\r\n\r\n    public function new( _id:String, _json:Dynamic, _manager:Resources ) {\r\n\r\n        id = _id;\r\n\r\n        super( _manager, ResourceType.json );\r\n\r\n        json = _json;\r\n\r\n    } //new\r\n\r\n\r\n} //JSONResource\r\n\r\nclass DataResource extends Resource {\r\n\r\n\r\n    public var data : Uint8Array;\r\n\r\n\r\n    public function new( _id:String, _data:Uint8Array, _manager:Resources ) {\r\n\r\n        id = _id;\r\n\r\n        super( _manager, ResourceType.data );\r\n\r\n        data = _data;\r\n\r\n    } //new\r\n\r\n\r\n} //DataResource\r\n\r\n\r\nclass SoundResource extends Resource {\r\n\r\n\r\n    public var name : String;\r\n\r\n\r\n    public function new( _id:String, _name:String, _manager:Resources ) {\r\n\r\n        id = _id;\r\n\r\n        super( _manager, ResourceType.sound );\r\n\r\n        name = _name;\r\n\r\n    } //new\r\n\r\n\r\n} //SoundResource\r\n","package luxe.structural;\r\n\r\n\r\n/**\r\n    Copyright 2014 Sven Bergström\r\n\r\n    A balanced binary search tree,\r\n    implemented based on various stack overflow answers,\r\n    wikipedia articles and books read over the years.\r\n    some other references : https://github.com/polygonal/ds\r\n\r\n    Part of the structural library for haxe\r\n    http://github.com/underscorediscovery/structural\r\n\r\n    MIT License\r\n*/\r\n\r\n@:generic\r\nclass BalancedBST<K,T> {\r\n\r\n        /** The tree root node */\r\n    public var root : BalancedBSTNode<K,T>;\r\n        /** The current comparison functoin */\r\n    public var compare : K->K->Int;\r\n        /** Whether or not the tree is empty (i.e root == null) */\r\n    public var empty (get, null) : Bool;\r\n\r\n        /** Internal array cache for iterator :todo : short term */\r\n    @:noCompletion public var _array:Array<T>;\r\n\r\n        /** Create a new balanced BST with the given comparison function */\r\n    public function new( compare_function : K->K->Int ) {\r\n\r\n        compare = compare_function;\r\n        _array = [];\r\n\r\n    } //new\r\n\r\n//Public API\r\n\r\n        /** Return the number of nodes in the tree */\r\n    public function size() {\r\n\r\n        return node_count(root);\r\n\r\n    } //size\r\n\r\n        /** Return the depth of the tree */\r\n    public function depth() {\r\n\r\n        return node_depth(root);\r\n\r\n    } //depth\r\n\r\n        /** Insert a node into the tree */\r\n    public function insert( _key:K, _value:T ) {\r\n\r\n        root = node_insert( root, _key, _value );\r\n        root.color = NodeColor.black;\r\n\r\n        _array = null;\r\n        _array = toArray();\r\n\r\n    } //insert\r\n\r\n        /** Returns true if the tree contains the key for this node */\r\n    public function contains( _key:K ) : Bool {\r\n\r\n            //if the find functions returns non-null it's here\r\n        return find(_key) != null;\r\n\r\n    } //contains\r\n\r\n        /** Returns a node by key, if found. null otherwise */\r\n    public function find( _key:K ) : T {\r\n\r\n        return node_find( root, _key );\r\n\r\n    } //find\r\n\r\n        /** Return the number of nodes to the left of this node, by key.   \r\n            http://en.wikipedia.org/wiki/Order_statistic_tree */\r\n    public function rank( _key:K ) : Int {\r\n\r\n        return node_rank(_key, root);\r\n\r\n    } //rank\r\n\r\n        /** Find a key by rank in the tree, i.e given a number of nodes, the key at this point.   \r\n            http://en.wikipedia.org/wiki/Order_statistic_tree */\r\n    public function select( _rank:Int ) : K {\r\n\r\n        var _node = node_select(root,_rank);\r\n\r\n        if(_node != null) {\r\n            return _node.key;\r\n        } else {\r\n            return null;\r\n        }\r\n\r\n    } //select\r\n\r\n        /** return the smallest node (key) in the tree (most left) */\r\n    public function smallest() : K {\r\n\r\n        var _node = node_smallest(root);\r\n\r\n        if(_node != null) {\r\n            return _node.key;\r\n        } else {\r\n            return null;\r\n        }\r\n\r\n    } //smallest\r\n\r\n        /** return the largest node (key) in the tree (most right)*/\r\n   public function largest() : K {\r\n\r\n        var _node = node_largest(root);\r\n\r\n        if(_node != null) {\r\n            return _node.key;\r\n        } else {\r\n            return null;\r\n        }\r\n\r\n    } //largest\r\n\r\n        /** remove a node by key. return false if the operation fails (i.e the node is not stored in this tree) */\r\n    public function remove( _key:K ) : Bool {\r\n\r\n        if( !is_red(root.left) && !is_red(root.right) ) {\r\n            root.color = NodeColor.red;\r\n        }\r\n\r\n        if(!contains(_key)) {\r\n            return false;\r\n        }\r\n\r\n        root = node_remove(root, _key);\r\n\r\n        if( root != null  ) {\r\n            root.color = NodeColor.black;\r\n        }\r\n\r\n        _array = null;\r\n        _array = toArray();\r\n\r\n        return true;\r\n\r\n    } //remove\r\n\r\n        /** remove the smallest node in the tree (most left) */\r\n    public function remove_smallest() {\r\n\r\n        if( !is_red(root.left) && !is_red(root.right) ) {\r\n            root.color = NodeColor.red;\r\n        }\r\n\r\n        root = node_remove_smallest(root);\r\n\r\n        if(root != null) {\r\n            root.color = NodeColor.black;\r\n        }\r\n\r\n        _array = null;\r\n        _array = toArray();\r\n\r\n        return true;\r\n\r\n    } //remove_smallest\r\n\r\n        /** remove the largest node in the tree (most right) */\r\n    public function remove_largest() {\r\n\r\n            // if both children of root are black, set root to red\r\n        if (!is_red(root.left) && !is_red(root.right)) {\r\n            root.color = NodeColor.red;\r\n        }\r\n\r\n        root = node_remove_largest(root);\r\n\r\n        if(root != null ) {\r\n            root.color = NodeColor.black;\r\n        }\r\n\r\n        _array = null;\r\n        _array = toArray();\r\n\r\n        return true;\r\n\r\n    } //remove_largest\r\n\r\n        /** tree floor http://en.wikipedia.org/wiki/Floor_and_ceiling_functions */\r\n    public function floor( _key:K ) : Null<K> {\r\n\r\n        var _node = node_floor(root, _key);\r\n\r\n        if(_node == null) {\r\n            return null;\r\n        }\r\n\r\n        return _node.key;\r\n\r\n    } //floor\r\n\r\n        /** tree ceiling http://en.wikipedia.org/wiki/Floor_and_ceiling_functions */\r\n    public function ceil( _key:K ) : Null<K> {\r\n\r\n        var _node = node_ceil( root, _key );\r\n\r\n        if (_node == null) {\r\n            return null;\r\n        }\r\n\r\n        return _node.key;\r\n\r\n    } //ceil\r\n\r\n        /** return an array of the values in this tree */\r\n    public function toArray() : Array<T> {\r\n\r\n        var a = new Array<T>();\r\n\r\n        traverse_node( root, order_retain, function( _node : BalancedBSTNode<K,T> ) {\r\n            a.push( _node.value );\r\n        });\r\n\r\n        return a;\r\n\r\n    } //toArray\r\n\r\n        /** Return an array of the keys in this tree */\r\n    public function keys() : Array<K> {\r\n\r\n        var a = new Array<K>();\r\n\r\n        traverse_node( root, order_retain, function( _node : BalancedBSTNode<K,T> ) {\r\n            a.push( _node.key );\r\n        });\r\n\r\n        return a;\r\n\r\n    } //keys\r\n\r\n        /** returns an iterator from a conversion to array of this tree. Usable as `for(item in tree)`   \r\n            :todo: This should traverse directly and implement IIterator */\r\n    public function iterator() : Iterator<T> {\r\n\r\n        return _array.iterator();\r\n        // return toArray().iterator();\r\n\r\n    } //iterator\r\n\r\n        /** Traverse a node with the given method, and call the given function for each node traversed */\r\n    public function traverse_node( _node:BalancedBSTNode<K,T>, _method:BalancedBSTTraverseMethod, _on_traverse : BalancedBSTNode<K,T> ->Void ) {\r\n\r\n        if (_node != null) {\r\n\r\n            switch(_method) {\r\n\r\n                case order_pre:\r\n                    _on_traverse(_node);\r\n                    traverse_node(_node.left, _method, _on_traverse);\r\n                    traverse_node(_node.right, _method, _on_traverse);\r\n\r\n                case order_retain:\r\n                    traverse_node(_node.left, _method, _on_traverse);\r\n                    _on_traverse(_node);\r\n                    traverse_node(_node.right, _method, _on_traverse);\r\n\r\n                case order_post:\r\n                    traverse_node(_node.left, _method, _on_traverse);\r\n                    traverse_node(_node.right, _method, _on_traverse);\r\n                    _on_traverse(_node);\r\n\r\n            } //_method\r\n\r\n        } //_node\r\n\r\n    } //traverse\r\n\r\n//Internal API\r\n\r\n        //getter\r\n    function get_empty() {\r\n\r\n        return root == null;\r\n\r\n    }\r\n\r\n        /** the depth of a single node */\r\n    function node_depth( _node:BalancedBSTNode<K,T>  ) {\r\n\r\n        if (_node == null) {\r\n            return 0;\r\n        }\r\n\r\n        var _n_depth = Math.max(\r\n                         node_depth(_node.left),\r\n                         node_depth(_node.right)\r\n                       );\r\n\r\n        return 1 + Std.int( _n_depth );\r\n\r\n    } //node_depth\r\n\r\n        /** the node count/children of a single node */\r\n    function node_count( _node:BalancedBSTNode<K,T> ) {\r\n\r\n        return _node == null ? 0 : _node.nodecount;\r\n\r\n    } //node_count\r\n\r\n        /** insert a single node */\r\n    function node_insert( _node:BalancedBSTNode<K,T>, _key:K, _value:T ) : BalancedBSTNode<K,T> {\r\n\r\n        if(_node == null) {\r\n\r\n            return new BalancedBSTNode<K,T>(_key, _value, 1, NodeColor.red);\r\n\r\n        } //_node\r\n\r\n                //use the comparison function\r\n            var comparison = compare(_key, _node.key);\r\n\r\n            if(comparison < 0) {\r\n\r\n                _node.left = node_insert(_node.left, _key, _value);\r\n\r\n            } else if(comparison > 0) {\r\n\r\n                _node.right = node_insert(_node.right, _key, _value);\r\n\r\n            } else {\r\n\r\n                _node.value = _value;\r\n\r\n            }\r\n\r\n            if(is_red(_node.right) && !is_red(_node.left)) {\r\n                _node = rotate_left(_node);\r\n            }\r\n\r\n            if(is_red(_node.left) && is_red(_node.left.left)) {\r\n                _node = rotate_right(_node);\r\n            }\r\n\r\n            if(is_red(_node.left) && is_red(_node.right)) {\r\n                swap_color(_node);\r\n            }\r\n\r\n            node_update_count(_node);\r\n\r\n        return _node;\r\n\r\n    } //node_insert\r\n\r\n        /* make sure the node count is up to date on a given node */\r\n    function node_update_count( _node:BalancedBSTNode<K,T> ) {\r\n\r\n        _node.nodecount = node_count(_node.left) + node_count(_node.right) + 1;\r\n\r\n        return _node;\r\n\r\n    } //node_update_count\r\n\r\n        /** find a single node */\r\n    function node_find( _node:BalancedBSTNode<K,T>, _key:K ) : T {\r\n\r\n        if(_node == null) {\r\n            return null;\r\n        }\r\n\r\n        var comparison = compare( _key, _node.key );\r\n\r\n        if(comparison < 0) {\r\n            return node_find(_node.left, _key);\r\n        } else if(comparison > 0) {\r\n            return node_find(_node.right, _key);\r\n        } else { //comparison > 0\r\n            return _node.value;\r\n        }\r\n\r\n    } //node_find\r\n\r\n        /** find rank of single node */\r\n    function node_rank( _key:K, _node:BalancedBSTNode<K,T> ) : Int {\r\n\r\n        if(_node == null) {\r\n            return 0;\r\n        }\r\n\r\n        var comparison = compare(_key, _node.key);\r\n\r\n        if(comparison < 0) {\r\n            return node_rank(_key, _node.left);\r\n        } else if(comparison > 0) {\r\n            return 1 + node_count(_node.left) + node_rank( _key, _node.right );\r\n        } else {\r\n            return node_count(_node.left);\r\n        }\r\n\r\n    } //node_rank\r\n\r\n        /** find key of node by rank */\r\n    function node_select( _node:BalancedBSTNode<K,T>, _rank:Int ) : BalancedBSTNode<K,T> {\r\n\r\n        if(_node == null) {\r\n            return null;\r\n        }\r\n\r\n        var _r = node_count(_node.left);\r\n\r\n        if(_r > _rank) {\r\n            return node_select(_node.left, _rank);\r\n        } else if(_r < _rank) {\r\n            return node_select(_node.right, _rank - _r - 1);\r\n        } else {\r\n            return _node;\r\n        }\r\n\r\n    } //node_select\r\n\r\n        /** find smallest of the given node */\r\n    function node_smallest( _node:BalancedBSTNode<K,T> ) : BalancedBSTNode<K,T> {\r\n\r\n        if(_node.left == null) {\r\n            return _node;\r\n        }\r\n\r\n        return node_smallest( _node.left );\r\n\r\n    } //node_smallest\r\n\r\n        /** find largest of the given node */\r\n    function node_largest( _node : BalancedBSTNode<K,T> ) : BalancedBSTNode<K,T> {\r\n\r\n        if (_node.right == null) {\r\n            return _node;\r\n        } else {\r\n            return node_largest(_node.right);\r\n        }\r\n\r\n    } //node_largest\r\n\r\n        /** node floor http://en.wikipedia.org/wiki/Floor_and_ceiling_functions */\r\n    function node_floor(_node:BalancedBSTNode<K,T>, _key:K ) : BalancedBSTNode<K,T> {\r\n\r\n        if(_node == null) {\r\n            return null;\r\n        }\r\n\r\n        var comparison = compare(_key, _node.key);\r\n\r\n        if(comparison == 0) {\r\n            return _node;\r\n        } else if(comparison < 0) {\r\n            return node_floor(_node.left, _key);\r\n        }\r\n\r\n        var _n = node_floor(_node.right, _key);\r\n\r\n        if(_n != null) {\r\n            return _n;\r\n        } else {\r\n            return _node;\r\n        }\r\n\r\n    } //node_floor\r\n\r\n        /** node ceiling http://en.wikipedia.org/wiki/Floor_and_ceiling_functions */\r\n    function node_ceil( _node:BalancedBSTNode<K,T> , _key:K ) : BalancedBSTNode<K,T> {\r\n\r\n        if (_node == null) {\r\n            return null;\r\n        }\r\n\r\n        var comparison = compare(_key, _node.key);\r\n\r\n        if(comparison == 0) {\r\n\r\n            return _node;\r\n\r\n        } else if(comparison < 0) {\r\n\r\n            var _n = node_ceil(_node.left, _key);\r\n\r\n            if (_n != null) {\r\n                return _n;\r\n            } else {\r\n                return _node;\r\n            }\r\n\r\n        } //comparison < 0\r\n\r\n        return node_ceil(_node.right, _key);\r\n\r\n    } //node_ceil\r\n\r\n        /** remove the smallest node in the tree (most left) */\r\n    function node_remove_smallest( _node:BalancedBSTNode<K,T> ) : BalancedBSTNode<K,T> {\r\n\r\n        if(_node.left == null) {\r\n            return null;\r\n        }\r\n\r\n        if( !is_red(_node.left) && !is_red(_node.left.left)) {\r\n            _node = move_red_left( _node );\r\n        }\r\n\r\n        _node.left = node_remove_smallest(_node.left);\r\n        node_update_count(_node);\r\n\r\n        return balance(_node);\r\n\r\n    } //remove_smallest\r\n\r\n        /** remove the largest node in the tree (most right) */\r\n    function node_remove_largest( _node:BalancedBSTNode<K,T> ) : BalancedBSTNode<K,T> {\r\n\r\n        if( is_red(_node.left) ) {\r\n            _node = rotate_right(_node);\r\n        }\r\n\r\n        if (_node.right == null) {\r\n            return null;\r\n        }\r\n\r\n        if( !is_red(_node.right) && !is_red(_node.right.left) ) {\r\n            _node = move_red_right(_node);\r\n        }\r\n\r\n        _node.right = node_remove_largest(_node.right);\r\n        node_update_count(_node);\r\n\r\n        return balance(_node);\r\n\r\n    } //node_remove_largest\r\n\r\n        /** remove a single node by key */\r\n    function node_remove( _node:BalancedBSTNode<K,T>, _key:K ) : BalancedBSTNode<K,T> {\r\n\r\n        var comparison = compare( _key, _node.key );\r\n\r\n        if( comparison < 0 )  {\r\n\r\n            if( !is_red(_node.left) && !is_red(_node.left.left) ) {\r\n                _node = move_red_left(_node);\r\n            }\r\n\r\n            _node.left = node_remove(_node.left, _key);\r\n\r\n        } else {\r\n\r\n            if( is_red(_node.left) ) {\r\n                _node = rotate_right(_node);\r\n            }\r\n\r\n            var comparison = compare( _key, _node.key );\r\n\r\n            if ((comparison == 0) && (_node.right == null)) {\r\n                return null;\r\n            }\r\n\r\n            if (!is_red(_node.right) && !is_red(_node.right.left)) {\r\n                _node = move_red_right(_node);\r\n            }\r\n\r\n            var comparison = compare( _key, _node.key );\r\n            if(comparison == 0) {\r\n\r\n                var _n = node_smallest(_node.right);\r\n                    _node.key = _n.key;\r\n                    _node.value = _n.value;\r\n\r\n                _node.right = node_remove_smallest(_node.right);\r\n\r\n            } else {\r\n                _node.right = node_remove(_node.right, _key);\r\n            }\r\n\r\n        }\r\n\r\n        return balance(_node);\r\n\r\n    } //_delete\r\n\r\n    inline function is_red( _node:BalancedBSTNode<K,T> ) {\r\n\r\n        if(_node == null) {\r\n            return NodeColor.black;\r\n        }\r\n\r\n        return _node.color == NodeColor.red;\r\n\r\n    } //is_red\r\n\r\n    @:noCompletion public function rotate_left( _node:BalancedBSTNode<K,T> ) {\r\n\r\n        var _n = _node.right;\r\n\r\n                //update colors\r\n            _n.color = _node.color;\r\n            _node.color = NodeColor.red;\r\n                //swap the right with left node\r\n            _node.right = _n.left;\r\n            _n.left = _node;\r\n\r\n                //update the node count values\r\n            _n.nodecount = _node.nodecount;\r\n            node_update_count(_node);\r\n\r\n        return _n;\r\n\r\n    } //rotate_left\r\n\r\n    @:noCompletion public function rotate_right( _node:BalancedBSTNode<K,T> ) {\r\n\r\n        var _n = _node.left;\r\n\r\n                //update node colors\r\n            _n.color = _node.color;\r\n            _node.color = NodeColor.red;\r\n                //swap the left and right node\r\n            _node.left = _n.right;\r\n            _n.right = _node;\r\n\r\n                //update the nodecount values\r\n            _n.nodecount = _node.nodecount;\r\n            node_update_count(_node);\r\n\r\n        return _n;\r\n\r\n    } //rotate_left\r\n\r\n    @:noCompletion public function swap_color( _node:BalancedBSTNode<K,T> ) {\r\n\r\n        _node.color = !_node.color;\r\n        _node.left.color = !_node.left.color;\r\n        _node.right.color = !_node.right.color;\r\n\r\n    } //swap_color\r\n\r\n    function move_red_left( _node:BalancedBSTNode<K,T> ) : BalancedBSTNode<K,T> {\r\n\r\n        swap_color(_node);\r\n\r\n        if( is_red(_node.right.left) ) {\r\n            _node.right = rotate_right(_node.right);\r\n            _node = rotate_left(_node);\r\n        }\r\n\r\n        return _node;\r\n    }\r\n\r\n    function move_red_right( _node:BalancedBSTNode<K,T> ) : BalancedBSTNode<K,T> {\r\n\r\n        swap_color(_node);\r\n\r\n        if (is_red(_node.left.left)) {\r\n            _node = rotate_right(_node);\r\n        }\r\n\r\n        return _node;\r\n    }\r\n\r\n    function balance( _node:BalancedBSTNode<K,T> ) : BalancedBSTNode<K,T> {\r\n\r\n        if (is_red(_node.right))    {\r\n            _node = rotate_left(_node);\r\n        }\r\n\r\n        if (is_red(_node.left) && is_red(_node.left.left)) {\r\n            _node = rotate_right(_node);\r\n        }\r\n\r\n        if (is_red(_node.left) && is_red(_node.right)) {\r\n            swap_color(_node);\r\n        }\r\n\r\n        node_update_count(_node);\r\n\r\n        return _node;\r\n\r\n    } //balance\r\n\r\n} //BalancedBST\r\n\r\n@:noCompletion\r\nprivate class NodeColor {\r\n    public static inline var red = true;\r\n    public static inline var black = false;\r\n}\r\n\r\n    /** A balanced binary search tree node by `K` key and `T` value (type) */\r\n@:generic\r\nclass BalancedBSTNode<K,T> {\r\n\r\n\r\n        /** The node left of this node (less than) */\r\n    public var left         : BalancedBSTNode<K,T>;\r\n        /** The node right of this node (bigger than) */\r\n    public var right        : BalancedBSTNode<K,T>;\r\n        /** The node count of this node, including itself */\r\n    public var nodecount    : Int;\r\n        /** The node color, red or black, for maintaining balance */\r\n    public var color        : Bool;\r\n\r\n        /** The key used to compare this node */\r\n    public var key          : K;\r\n        /** The value this node holds */\r\n    public var value        : T;\r\n\r\n        /** Create a new node with given key, value, count and color. Use `insert` on the tree instead. */\r\n    public function new( _key:K, _value:T, _node_count:Int, _color:Bool ) {\r\n\r\n        left = null;\r\n        right = null;\r\n\r\n        key = _key;\r\n        value = _value;\r\n\r\n        nodecount = _node_count;\r\n        color = _color;\r\n\r\n    } //new\r\n\r\n\r\n} //BalancedBSTNode\r\n\r\n    /** A traversal method for iterating a node in the tree */\r\nenum BalancedBSTTraverseMethod {\r\n\r\n    order_pre;\r\n    order_retain;\r\n    order_post;\r\n\r\n} //enum\r\n","/**\r\n  @author Joshua Granick   \r\n  @version 1.2   \r\n */\r\n\r\n\r\npackage luxe.tween.actuators;\r\n\r\n\r\nimport luxe.tween.easing.IEasing;\r\nimport luxe.tween.Actuate;\r\n\r\n\r\n@:keepSub\r\nclass GenericActuator implements IGenericActuator {\r\n\r\n\r\n    public var duration:Float;\r\n    public var id:String;\r\n    public var properties:Dynamic;\r\n    public var target:Dynamic;\r\n\r\n    var _autoVisible:Bool;\r\n    var _delay:Float;\r\n    var _ease:IEasing;\r\n    var _onComplete:Dynamic;\r\n    var _onCompleteParams:Array <Dynamic>;\r\n    var _onRepeat:Dynamic;\r\n    var _onRepeatParams:Array <Dynamic>;\r\n    var _onUpdate:Dynamic;\r\n    var _onUpdateParams:Array <Dynamic>;\r\n    var _reflect:Bool;\r\n    var _repeat:Int;\r\n    var _reverse:Bool;\r\n    var _smartRotation:Bool;\r\n    var _snapping:Bool;\r\n    var special:Bool;\r\n\r\n\r\n    public function new (target:Dynamic, duration:Float, properties:Dynamic) {\r\n\r\n        _autoVisible = true;\r\n        _delay = 0;\r\n        _reflect = false;\r\n        _repeat = 0;\r\n        _reverse = false;\r\n        _smartRotation = false;\r\n        _snapping = false;\r\n        special = false;\r\n\r\n        this.target = target;\r\n        this.properties = properties;\r\n        this.duration = duration;\r\n\r\n        _ease = Actuate.defaultEase;\r\n\r\n    }\r\n\r\n\r\n    public function apply ():Void {\r\n\r\n        for (i in Reflect.fields (properties)) {\r\n\r\n            if (#if flash false && #end Reflect.hasField (target, i)) {\r\n\r\n                Reflect.setField (target, i, Reflect.field (properties, i));\r\n\r\n            } else {\r\n\r\n                Reflect.setProperty (target, i, Reflect.field (properties, i));\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n    /**\r\n      Sometimes drawing performs faster when objects are set to visible = false rather than only alpha = 0. autoVisible toggles automatically based on alpha values   \r\n      @param   value       Whether autoVisible should be enabled (Default is true)   \r\n      @return      The current actuator instance   \r\n     */\r\n    public function autoVisible (?value:Null<Bool>):IGenericActuator {\r\n\r\n        if (value == null) {\r\n\r\n            value = true;\r\n\r\n        }\r\n\r\n        _autoVisible = value;\r\n\r\n        return this;\r\n\r\n    }\r\n\r\n\r\n    inline function callMethod (method:Dynamic, params:Array<Dynamic> = null):Dynamic {\r\n\r\n        if (params == null) {\r\n\r\n            params = [];\r\n\r\n        }\r\n\r\n        #if neko\r\n\r\n        var diff = untyped ($nargs)(method) - params.length;\r\n\r\n        if (diff > 0) {\r\n\r\n            params = params.copy ();\r\n\r\n            for (i in 0...diff) {\r\n\r\n                params.push (null);\r\n\r\n            }\r\n\r\n        }\r\n\r\n        #end\r\n\r\n        return Reflect.callMethod (method, method, params);\r\n\r\n    }\r\n\r\n\r\n    function change ():Void {\r\n\r\n        if (_onUpdate != null) {\r\n\r\n            callMethod (_onUpdate, _onUpdateParams);\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n    function complete (sendEvent:Bool = true):Void {\r\n\r\n        if (sendEvent) {\r\n\r\n            change ();\r\n\r\n            if (_onComplete != null) {\r\n\r\n                callMethod (_onComplete, _onCompleteParams);\r\n\r\n            }\r\n\r\n        }\r\n\r\n        Actuate.unload (this);\r\n\r\n    }\r\n\r\n\r\n    /**\r\n      Increases the delay before a tween is executed   \r\n      @param   duration        The amount of seconds to delay   \r\n      @return      The current actuator instance   \r\n     */\r\n    public function delay (duration:Float):IGenericActuator {\r\n\r\n        _delay = duration;\r\n\r\n        return this;\r\n\r\n    }\r\n\r\n\r\n    /**\r\n      Sets the easing which is used when running the tween   \r\n      @param   easing      An easing equation, like Elastic.easeIn or Quad.easeOut   \r\n      @return      The current actuator instance   \r\n     */\r\n    public function ease (easing:IEasing):IGenericActuator {\r\n\r\n        _ease = easing;\r\n\r\n        return this;\r\n\r\n    }\r\n\r\n\r\n    public function move ():Void {\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n    /**\r\n      Specify whether this should be scaled by the global timescale   \r\n      @param   _value      Whether or not it should be   \r\n      @return      The current actuator instance   \r\n     */\r\n\r\n    public var timescaled : Bool = false;\r\n    public function timescale( _value:Bool = true ):IGenericActuator {\r\n        timescaled = _value;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n      Defines a function which will be called when the tween finishes   \r\n      @param   handler     The function you would like to be called   \r\n      @param   parameters      Parameters you would like to pass to the handler function when it is called   \r\n      @return      The current actuator instance   \r\n     */\r\n    public function onComplete (handler:Dynamic, parameters:Array <Dynamic> = null):IGenericActuator {\r\n\r\n        _onComplete = handler;\r\n\r\n        if (parameters == null) {\r\n\r\n            _onCompleteParams = [];\r\n\r\n        } else {\r\n\r\n            _onCompleteParams = parameters;\r\n\r\n        }\r\n\r\n        if (duration == 0) {\r\n\r\n            complete ();\r\n\r\n        }\r\n\r\n        return this;\r\n\r\n    }\r\n\r\n\r\n    /**\r\n      Defines a function which will be called when the tween repeats   \r\n      @param   handler     The function you would like to be called   \r\n      @param   parameters      Parameters you would like to pass to the handler function when it is called   \r\n      @return      The current actuator instance   \r\n     */\r\n    public function onRepeat (handler:Dynamic, parameters:Array <Dynamic> = null):IGenericActuator {\r\n\r\n        _onRepeat = handler;\r\n\r\n        if (parameters == null) {\r\n\r\n            _onRepeatParams = [];\r\n\r\n        } else {\r\n\r\n            _onRepeatParams = parameters;\r\n\r\n        }\r\n\r\n        return this;\r\n\r\n    }\r\n\r\n\r\n    /**\r\n      Defines a function which will be called when the tween updates   \r\n      @param   handler     The function you would like to be called   \r\n      @param   parameters      Parameters you would like to pass to the handler function when it is called   \r\n      @return      The current actuator instance   \r\n     */\r\n    public function onUpdate (handler:Dynamic, parameters:Array <Dynamic> = null):IGenericActuator {\r\n\r\n        _onUpdate = handler;\r\n\r\n        if (parameters == null) {\r\n\r\n            _onUpdateParams = [];\r\n\r\n        } else {\r\n\r\n            _onUpdateParams = parameters;\r\n\r\n        }\r\n\r\n        return this;\r\n\r\n    }\r\n\r\n\r\n    public function pause ():Void {\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n    /**\r\n      Automatically changes the reverse value when the tween repeats. Repeat must be enabled for this to have any effect   \r\n      @param   value       Whether reflect should be enabled (Default is true)   \r\n      @return      The current actuator instance   \r\n     */\r\n    public function reflect (?value:Null<Bool>):IGenericActuator {\r\n\r\n        if (value == null) {\r\n\r\n            value = true;\r\n\r\n        }\r\n\r\n        _reflect = value;\r\n        special = true;\r\n\r\n        return this;\r\n\r\n    }\r\n\r\n\r\n    /**\r\n      Repeats the tween after it finishes   \r\n      @param   times       The number of times you would like the tween to repeat, or -1 if you would like to repeat the tween indefinitely (Default is -1)   \r\n      @return      The current actuator instance   \r\n     */\r\n    public function repeat (?times:Null<Int>):IGenericActuator {\r\n\r\n        if (times == null) {\r\n\r\n            times = -1;\r\n\r\n        }\r\n\r\n        _repeat = times;\r\n\r\n        return this;\r\n\r\n    }\r\n\r\n\r\n    public function resume ():Void {\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n    /**\r\n      Sets if the tween should be handled in reverse   \r\n      @param   value       Whether the tween should be reversed (Default is true)   \r\n      @return      The current actuator instance   \r\n     */\r\n    public function reverse (?value:Null<Bool>):IGenericActuator {\r\n\r\n        if (value == null) {\r\n\r\n            value = true;\r\n\r\n        }\r\n\r\n        _reverse = value;\r\n        special = true;\r\n\r\n        return this;\r\n\r\n    }\r\n\r\n\r\n    /**\r\n      Enabling smartRotation can prevent undesired results when tweening rotation values   \r\n      @param   value       Whether smart rotation should be enabled (Default is true)   \r\n      @return      The current actuator instance   \r\n     */\r\n    public function smartRotation (?value:Null<Bool>):IGenericActuator {\r\n\r\n        if (value == null) {\r\n\r\n            value = true;\r\n\r\n        }\r\n\r\n        _smartRotation = value;\r\n        special = true;\r\n\r\n        return this;\r\n\r\n    }\r\n\r\n\r\n    /**\r\n      Snapping causes tween values to be rounded automatically   \r\n      @param   value       Whether tween values should be rounded (Default is true)   \r\n      @return      The current actuator instance   \r\n     */\r\n    public function snapping (?value:Null<Bool>):IGenericActuator {\r\n\r\n        if (value == null) {\r\n\r\n            value = true;\r\n\r\n        }\r\n\r\n        _snapping = value;\r\n        special = true;\r\n\r\n        return this;\r\n\r\n    }\r\n\r\n\r\n    public function stop (properties:Dynamic, complete:Bool, sendEvent:Bool):Void {\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n@:noCompletion interface IGenericActuator {\r\n\r\n    /**\r\n      Flash performs faster when objects are set to visible = false rather than only alpha = 0. autoVisible toggles automatically based on alpha values   \r\n      @param   value       Whether autoVisible should be enabled (Default is true)   \r\n      @return      The current actuator instance   \r\n     */\r\n    public function autoVisible (?value:Null<Bool>):IGenericActuator;\r\n\r\n    /**\r\n      Increases the delay before a tween is executed   \r\n      @param   duration        The amount of seconds to delay   \r\n      @return      The current actuator instance   \r\n     */\r\n    public function delay (duration:Float):IGenericActuator;\r\n\r\n    /**\r\n      Sets the easing which is used when running the tween   \r\n      @param   easing      An easing equation, like Elastic.easeIn or Quad.easeOut   \r\n      @return      The current actuator instance   \r\n     */\r\n    public function ease (easing:IEasing):IGenericActuator;\r\n\r\n    /**\r\n      Defines a function which will be called when the tween finishes   \r\n      @param   handler     The function you would like to be called   \r\n      @param   parameters      Parameters you would like to pass to the handler function when it is called   \r\n      @return      The current actuator instance   \r\n     */\r\n    public function onComplete (handler:Dynamic, ?parameters:Array <Dynamic>):IGenericActuator;\r\n\r\n    /**\r\n      Defines a function which will be called when the tween repeats   \r\n      @param   handler     The function you would like to be called   \r\n      @param   parameters      Parameters you would like to pass to the handler function when it is called   \r\n      @return      The current actuator instance   \r\n     */\r\n    public function onRepeat (handler:Dynamic, ?parameters:Array <Dynamic>):IGenericActuator;\r\n\r\n    /**\r\n      Defines a function which will be called when the tween updates   \r\n      @param   handler     The function you would like to be called   \r\n      @param   parameters      Parameters you would like to pass to the handler function when it is called   \r\n      @return      The current actuator instance   \r\n     */\r\n    public function onUpdate (handler:Dynamic, ?parameters:Array <Dynamic>):IGenericActuator;\r\n\r\n    /**\r\n      Automatically changes the reverse value when the tween repeats. Repeat must be enabled for this to have any effect   \r\n      @param   value       Whether reflect should be enabled (Default is true)   \r\n      @return      The current actuator instance   \r\n     */\r\n    public function reflect (?value:Null<Bool>):IGenericActuator;\r\n\r\n    /**\r\n      Repeats the tween after it finishes   \r\n      @param   times       The number of times you would like the tween to repeat, or -1 if you would like to repeat the tween indefinitely (Default is -1)   \r\n      @return      The current actuator instance   \r\n     */\r\n    public function repeat (?times:Null<Int>):IGenericActuator;\r\n\r\n    /**\r\n      Sets if the tween should be handled in reverse   \r\n      @param   value       Whether the tween should be reversed (Default is true)   \r\n      @return      The current actuator instance   \r\n     */\r\n    public function reverse (?value:Null<Bool>):IGenericActuator;\r\n\r\n    /**\r\n      Specify whether this should be scaled by the global timescale   \r\n      @param   _value      Whether or not it should be   \r\n      @return      The current actuator instance   \r\n     */\r\n\r\n    public function timescale( _value:Bool = true ):IGenericActuator;\r\n    /**\r\n      Enabling smartRotation can prevent undesired results when tweening rotation values   \r\n      @param   value       Whether smart rotation should be enabled (Default is true)   \r\n      @return      The current actuator instance   \r\n     */\r\n    public function smartRotation (?value:Null<Bool>):IGenericActuator;\r\n\r\n    /**\r\n      Snapping causes tween values to be rounded automatically   \r\n      @param   value       Whether tween values should be rounded (Default is true)   \r\n      @return      The current actuator instance   \r\n     */\r\n    public function snapping (?value:Null<Bool>):IGenericActuator;\r\n\r\n}\r\n","package luxe.tween.actuators;\r\n\r\n\r\nimport luxe.tween.actuators.GenericActuator;\r\n\r\n#if neko\r\nimport haxe.Log;\r\nimport haxe.PosInfos;\r\n#end\r\nimport haxe.Timer;\r\n\r\n\r\n\r\n/**\r\n  @author Joshua Granick   \r\n  @version 1.2   \r\n */\r\nclass SimpleActuator extends GenericActuator {\r\n\r\n\r\n    var timeOffset:Float;\r\n\r\n    static var actuators:Array <SimpleActuator> = new Array <SimpleActuator> ();\r\n    static var actuatorsLength:Int = 0;\r\n    static var addedEvent:Bool = false;\r\n\r\n    static var timer:Timer;\r\n\r\n    var active:Bool;\r\n    var cacheVisible:Bool;\r\n    var detailsLength:Int;\r\n    var initialized:Bool;\r\n    var paused:Bool;\r\n    var pauseTime:Float;\r\n    var propertyDetails:Array <PropertyDetails>;\r\n    var sendChange:Bool;\r\n    var setVisible:Bool;\r\n    var startTime:Float;\r\n    var toggleVisible:Bool;\r\n\r\n    var has_timescaled_starttime : Bool = false;\r\n\r\n    public function new (target:Dynamic, duration:Float, properties:Dynamic) {\r\n\r\n        active = true;\r\n        propertyDetails = new Array <PropertyDetails> ();\r\n        sendChange = false;\r\n        paused = false;\r\n        cacheVisible = false;\r\n        initialized = false;\r\n        setVisible = false;\r\n        toggleVisible = false;\r\n\r\n        startTime = Luxe.time;\r\n\r\n        super (target, duration, properties);\r\n\r\n        if (!addedEvent) {\r\n\r\n            addedEvent = true;\r\n            Luxe.on(Luxe.Ev.update, on_internal_update );\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n    /**\r\n      @inheritDoc   \r\n     */\r\n    public override function autoVisible (?value:Null<Bool>):IGenericActuator {\r\n\r\n        if (value == null) {\r\n\r\n            value = true;\r\n\r\n        }\r\n\r\n        _autoVisible = value;\r\n\r\n        if (!value) {\r\n\r\n            toggleVisible = false;\r\n\r\n            if (setVisible) {\r\n\r\n                setField (target, \"visible\", cacheVisible);\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return this;\r\n\r\n    }\r\n\r\n\r\n    /**\r\n      @inheritDoc   \r\n     */\r\n    public override function delay (duration:Float):IGenericActuator {\r\n\r\n        _delay = duration;\r\n        timeOffset = startTime + duration;\r\n\r\n        return this;\r\n\r\n    }\r\n\r\n\r\n    inline function getField (target:Dynamic, propertyName:String):Dynamic {\r\n\r\n\r\n        var value = null;\r\n\r\n        if (Reflect.hasField (target, propertyName)) {\r\n\r\n            value = Reflect.field (target, propertyName);\r\n\r\n        } else {\r\n\r\n            value = Reflect.getProperty (target, propertyName);\r\n\r\n        }\r\n\r\n        return value;\r\n\r\n    }\r\n\r\n\r\n    function initialize ():Void {\r\n\r\n        var details:PropertyDetails;\r\n        var start:Float;\r\n\r\n        for (i in Reflect.fields (properties)) {\r\n\r\n            var isField = true;\r\n\r\n            if ( Reflect.hasField (target, i)\r\n                    #if web && (!target.__properties__ || untyped !target.__properties__[\"set_\" + i]) #end\r\n               ) {\r\n\r\n                start = Reflect.field (target, i);\r\n\r\n            } else {\r\n\r\n                isField = false;\r\n                start = Reflect.getProperty (target, i);\r\n\r\n            }\r\n\r\n\r\n            if (Std.is (start, Float)) {\r\n\r\n                details = new PropertyDetails (target, i, start, getField (properties, i) - start, isField);\r\n            propertyDetails.push (details);\r\n\r\n            }\r\n\r\n        }\r\n\r\n        detailsLength = propertyDetails.length;\r\n        initialized = true;\r\n\r\n    }\r\n\r\n\r\n    public override function move ():Void {\r\n\r\n        toggleVisible = (Reflect.hasField (properties, \"alpha\") && Reflect.hasField (properties, \"visible\"));\r\n\r\n        if (toggleVisible && properties.alpha != 0 && !getField (target, \"visible\")) {\r\n\r\n            setVisible = true;\r\n            cacheVisible = getField (target, \"visible\");\r\n            setField (target, \"visible\", true);\r\n\r\n        }\r\n\r\n        timeOffset = startTime;\r\n        actuators.push (this);\r\n        ++actuatorsLength;\r\n\r\n    }\r\n\r\n\r\n    /**\r\n      @inheritDoc   \r\n     */\r\n    public override function onUpdate (handler:Dynamic, parameters:Array <Dynamic> = null):IGenericActuator {\r\n\r\n        _onUpdate = handler;\r\n\r\n        if (parameters == null) {\r\n\r\n            _onUpdateParams = [];\r\n\r\n        } else {\r\n\r\n        _onUpdateParams = parameters;\r\n\r\n        }\r\n\r\n        sendChange = true;\r\n\r\n        return this;\r\n\r\n    }\r\n\r\n\r\n    public override function pause ():Void {\r\n\r\n        paused = true;\r\n\r\n        pauseTime = timescaled ? update_timer : current_time;//haxe.Timer.stamp ();\r\n\r\n    }\r\n\r\n\r\n    public override function resume ():Void {\r\n\r\n        if (paused) {\r\n\r\n            paused = false;\r\n\r\n            timeOffset += ( (timescaled ? update_timer : current_time) - pauseTime) / 1000;\r\n            // timeOffset += (haxe.Timer.stamp () - pauseTime) / 1000;\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n    inline function setField (target:Dynamic, propertyName:String, value:Dynamic):Void {\r\n\r\n        if (Reflect.hasField (target, propertyName)) {\r\n\r\n            Reflect.setField (target, propertyName, value);\r\n\r\n        } else {\r\n\r\n            Reflect.setProperty (target, propertyName, value);\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n    inline function setProperty (details:PropertyDetails, value:Dynamic):Void {\r\n\r\n        if (details.isField) {\r\n\r\n            Reflect.setProperty (details.target, details.propertyName, value);\r\n\r\n        } else {\r\n\r\n            Reflect.setProperty (details.target, details.propertyName, value);\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n    public override function stop (properties:Dynamic, complete:Bool, sendEvent:Bool):Void {\r\n\r\n        if (active) {\r\n\r\n            if (properties == null) {\r\n\r\n                active = false;\r\n\r\n                if (complete) {\r\n\r\n                    apply ();\r\n\r\n                }\r\n\r\n                this.complete (sendEvent);\r\n                return;\r\n\r\n            }\r\n\r\n            for (i in Reflect.fields (properties)) {\r\n\r\n                if (Reflect.hasField (this.properties, i)) {\r\n\r\n                    active = false;\r\n\r\n                    if (complete) {\r\n\r\n                        apply ();\r\n\r\n                    }\r\n\r\n                    this.complete (sendEvent);\r\n                    return;\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function update( currentTime:Float ):Void {\r\n\r\n\r\n        if (!paused) {\r\n\r\n            var details:PropertyDetails;\r\n            var easing:Float;\r\n            var i:Int;\r\n\r\n            var tweenPosition:Float = (currentTime - timeOffset) / duration;\r\n\r\n            if (tweenPosition > 1) {\r\n\r\n                tweenPosition = 1;\r\n\r\n            }\r\n\r\n            if (!initialized) {\r\n\r\n                initialize ();\r\n\r\n            }\r\n\r\n            if (!special) {\r\n\r\n                easing = _ease.calculate (tweenPosition);\r\n\r\n                for (i in 0...detailsLength) {\r\n\r\n                    details = propertyDetails[i];\r\n                    setProperty (details, details.start + (details.change * easing));\r\n\r\n                }\r\n\r\n            } else {\r\n\r\n                if (!_reverse) {\r\n\r\n                    easing = _ease.calculate (tweenPosition);\r\n\r\n                } else {\r\n\r\n                    easing = _ease.calculate (1 - tweenPosition);\r\n\r\n                }\r\n\r\n                var endValue:Float;\r\n\r\n                for (i in 0...detailsLength) {\r\n\r\n                    details = propertyDetails[i];\r\n\r\n                    if (_smartRotation && (details.propertyName == \"rotation\" || details.propertyName == \"rotationX\" || details.propertyName == \"rotationY\" || details.propertyName == \"rotationZ\")) {\r\n\r\n                        var rotation:Float = details.change % 360;\r\n\r\n                        if (rotation > 180) {\r\n\r\n                            rotation -= 360;\r\n\r\n                        } else if (rotation < -180) {\r\n\r\n                            rotation += 360;\r\n\r\n                        }\r\n\r\n                        endValue = details.start + rotation * easing;\r\n\r\n                    } else {\r\n\r\n                        endValue = details.start + (details.change * easing);\r\n\r\n                    }\r\n\r\n                    if (!_snapping) {\r\n\r\n                        setProperty (details, endValue);\r\n\r\n                    } else {\r\n\r\n                        setProperty (details, Math.round (endValue));\r\n\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n\r\n            if (tweenPosition == 1) {\r\n\r\n                if (_repeat == 0) {\r\n\r\n                    active = false;\r\n\r\n                    if (toggleVisible && getField (target, \"alpha\") == 0) {\r\n\r\n                        setField (target, \"visible\", false);\r\n\r\n                    }\r\n\r\n                    complete (true);\r\n                    return;\r\n\r\n                } else {\r\n\r\n                    if (_onRepeat != null) {\r\n\r\n                        callMethod (_onRepeat, _onRepeatParams);\r\n\r\n                    }\r\n\r\n                    if (_reflect) {\r\n\r\n                        _reverse = !_reverse;\r\n\r\n                    }\r\n\r\n                    startTime = currentTime;\r\n                    timeOffset = startTime + _delay;\r\n\r\n                    if (_repeat > 0) {\r\n\r\n                        _repeat --;\r\n\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n\r\n            if (sendChange) {\r\n\r\n                change ();\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n    // Event Handlers\r\n\r\n    static var update_timer : Float = 0;\r\n    static var current_time : Float = 0;\r\n    static function on_internal_update( dt : Float) : Void {\r\n\r\n        update_timer += dt;\r\n        current_time = Luxe.time;\r\n\r\n        var currentTime = current_time;\r\n\r\n        var actuator:SimpleActuator;\r\n\r\n        var j:Int = 0;\r\n        var cleanup = false;\r\n\r\n        for (i in 0...actuatorsLength) {\r\n\r\n            actuator = actuators[j];\r\n\r\n            if (actuator != null && actuator.active) {\r\n\r\n                currentTime = actuator.timescaled ? update_timer : current_time;\r\n\r\n                if(actuator.timescaled && !actuator.has_timescaled_starttime) {\r\n                    actuator.has_timescaled_starttime = true;\r\n                    actuator.startTime = update_timer;\r\n                    actuator.timeOffset = actuator.startTime;\r\n                }\r\n\r\n                if(currentTime > actuator.timeOffset) {\r\n                    actuator.update( currentTime );\r\n                }\r\n\r\n                j++;\r\n\r\n            } else {\r\n\r\n                actuators.splice (j, 1);\r\n                --actuatorsLength;\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n}\r\n","/**\r\n * @author Joshua Granick\r\n * @author Robert Penner / http://www.robertpenner.com/easing_terms_of_use.html\r\n */\r\n\r\n\r\npackage luxe.tween.easing;\r\n\r\n\r\n\r\nclass Quad {\r\n\r\n\r\n    static public var easeIn (get_easeIn, never):IEasing;\r\n    static public var easeInOut (get_easeInOut, never):IEasing;\r\n    static public var easeOut (get_easeOut, never):IEasing;\r\n\r\n\r\n    static function get_easeIn ():IEasing {\r\n\r\n        return new QuadEaseIn ();\r\n\r\n    }\r\n\r\n\r\n    static function get_easeInOut ():IEasing {\r\n\r\n        return new QuadEaseInOut ();\r\n\r\n    }\r\n\r\n\r\n    static function get_easeOut ():IEasing {\r\n\r\n        return new QuadEaseOut ();\r\n\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\nclass QuadEaseIn implements IEasing {\r\n\r\n\r\n    public function new () {\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n    public function calculate (k:Float):Float {\r\n\r\n        return k * k;\r\n\r\n    }\r\n\r\n\r\n    public function ease (t:Float, b:Float, c:Float, d:Float):Float {\r\n\r\n        return c * (t /= d) * t + b;\r\n\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\nclass QuadEaseInOut implements IEasing {\r\n\r\n\r\n    public function new () {\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n    public function calculate (k:Float):Float {\r\n\r\n        if ((k *= 2) < 1) {\r\n            return 1 / 2 * k * k;\r\n        }\r\n        return -1 / 2 * ((k - 1) * (k - 3) - 1);\r\n\r\n    }\r\n\r\n\r\n    public function ease (t:Float, b:Float, c:Float, d:Float):Float {\r\n\r\n        if ((t /= d / 2) < 1) {\r\n            return c / 2 * t * t + b;\r\n        }\r\n        return -c / 2 * ((t - 1) * (t - 3) - 1) + b;\r\n\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\nclass QuadEaseOut implements IEasing {\r\n\r\n\r\n    public function new () {\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n    public function calculate (k:Float):Float {\r\n\r\n        return -k * (k - 2);\r\n\r\n    }\r\n\r\n\r\n    public function ease (t:Float, b:Float, c:Float, d:Float):Float {\r\n\r\n        return -c * (t /= d) * (t - 2) + b;\r\n\r\n    }\r\n\r\n\r\n}\r\n","/**\r\n  @author Joshua Granick   \r\n */\r\npackage luxe.tween;\r\n\r\n\r\nimport luxe.tween.actuators.GenericActuator;\r\nimport luxe.tween.actuators.MethodActuator;\r\nimport luxe.tween.actuators.MotionPathActuator;\r\nimport luxe.tween.actuators.SimpleActuator;\r\nimport luxe.tween.easing.IEasing;\r\nimport luxe.tween.easing.Quad;\r\n\r\nclass Actuate {\r\n\r\n\r\n    public static var defaultActuator:Class <GenericActuator> = SimpleActuator;\r\n    public static var defaultEase:IEasing = Quad.easeOut;\r\n    static var targetLibraries:ObjectHash <Array <GenericActuator>> = new ObjectHash <Array <GenericActuator>> ();\r\n\r\n\r\n    /**\r\n      Copies properties from one object to another. Conflicting tweens are stopped automatically   \r\n      @example     <code>Actuate.apply (MyClip, { alpha: 1 } );</code>   \r\n      @param   target      The object to copy to   \r\n      @param   properties      The object to copy from   \r\n      @param   customActuator      A custom actuator to use instead of the default (Optional)   \r\n      @return      The current actuator instance, which can be used to apply properties like onComplete or onUpdate handlers   \r\n     */\r\n    public static function apply (target:Dynamic, properties:Dynamic, customActuator:Class <GenericActuator> = null):IGenericActuator {\r\n\r\n        stop (target, properties);\r\n\r\n        if (customActuator == null) {\r\n\r\n            customActuator = defaultActuator;\r\n\r\n        }\r\n\r\n        var actuator = Type.createInstance (customActuator, [ target, 0, properties ]);\r\n        actuator.apply ();\r\n\r\n        return actuator;\r\n\r\n    }\r\n\r\n\r\n    static function getLibrary (target:Dynamic, allowCreation:Bool = true):Array <GenericActuator> {\r\n\r\n        if (!targetLibraries.exists (target) && allowCreation) {\r\n\r\n            targetLibraries.set (target, new Array <GenericActuator> ());\r\n\r\n        }\r\n\r\n        return targetLibraries.get (target);\r\n\r\n    }\r\n\r\n\r\n    /**\r\n      Creates a new MotionPath tween   \r\n      @param   target      The object to tween   \r\n      @param   duration        The length of the tween in seconds   \r\n      @param   properties      An object containing a motion path for each property you wish to tween   \r\n      @param   overwrite       Sets whether previous tweens for the same target and properties will be overwritten (Default is true)   \r\n      @return      The current actuator instance, which can be used to apply properties like ease, delay, onComplete or onUpdate   \r\n     */\r\n    public static function motionPath (target:Dynamic, duration:Float, properties:Dynamic, overwrite:Bool = true):IGenericActuator {\r\n\r\n        return tween (target, duration, properties, overwrite, MotionPathActuator);\r\n\r\n    }\r\n\r\n\r\n    /**\r\n      Pauses tweens for the specified target objects   \r\n      @param   ... targets     The target objects which will have their tweens paused. Passing no value pauses tweens for all objects   \r\n     */\r\n    //public static function pause (... targets:Array):void {\r\n    public static function pause (target:Dynamic):Void {\r\n\r\n        if (Std.is (target, GenericActuator)) {\r\n\r\n            cast (target, GenericActuator).pause ();\r\n\r\n        } else {\r\n\r\n            var library:Array <GenericActuator> = getLibrary (target, false);\r\n\r\n            if (library != null) {\r\n\r\n            for (actuator in library) {\r\n\r\n                actuator.pause ();\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    }\r\n\r\n\r\n    public static function pauseAll ():Void {\r\n\r\n        for (library in targetLibraries) {\r\n\r\n            for (actuator in library) {\r\n\r\n                actuator.pause ();\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n    /**\r\n      Resets Actuate by stopping and removing tweens for all objects   \r\n     */\r\n    public static function reset ():Void {\r\n\r\n        for (library in targetLibraries) {\r\n\r\n            var i = library.length - 1;\r\n            while (i >= 0) {\r\n                library[i].stop (null, false, false);\r\n                i--;\r\n            }\r\n\r\n        }\r\n\r\n        targetLibraries = new ObjectHash <Array <GenericActuator>> ();\r\n\r\n    }\r\n\r\n\r\n    /**\r\n      Resumes paused tweens for the specified target objects   \r\n      @param   ... targets     The target objects which will have their tweens resumed. Passing no value resumes tweens for all objects   \r\n     */\r\n    public static function resume (target:Dynamic):Void {\r\n\r\n        if (Std.is (target, GenericActuator)) {\r\n\r\n            cast (target, GenericActuator).resume ();\r\n\r\n        } else {\r\n\r\n            var library:Array <GenericActuator> = getLibrary (target, false);\r\n\r\n            if (library != null) {\r\n\r\n            for (actuator in library) {\r\n\r\n                actuator.resume ();\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n    public static function resumeAll ():Void {\r\n\r\n        for (library in targetLibraries) {\r\n\r\n            for (actuator in library) {\r\n\r\n                actuator.resume ();\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n    /**\r\n      Stops all tweens for an individual object   \r\n      @param   target      The target object which will have its tweens stopped, or a generic actuator instance   \r\n      @param   properties      A string, array or object which contains the properties you wish to stop, like \"alpha\", [ \"x\", \"y\" ] or { alpha: null }. Passing no value removes all tweens for the object (Optional)   \r\n      @param   complete        If tweens should apply their final target values before stopping. Default is false (Optional)   \r\n      @param   sendEvent   If a complete() event should be dispatched for the specified target. Default is true (Optional)   \r\n     */\r\n    public static function stop (target:Dynamic, properties:Dynamic = null, complete:Bool = false, sendEvent:Bool = true):Void {\r\n\r\n        if (target != null) {\r\n\r\n            if (Std.is (target, GenericActuator)) {\r\n\r\n                cast (target, GenericActuator).stop (null, complete, sendEvent);\r\n\r\n            } else {\r\n\r\n                var library:Array <GenericActuator> = getLibrary (target, false);\r\n\r\n                if (library != null) {\r\n\r\n                if (Std.is (properties, String)) {\r\n\r\n                    var temp = { };\r\n                    Reflect.setField (temp, properties, null);\r\n                    properties = temp;\r\n\r\n                } else if (Std.is (properties, Array)) {\r\n\r\n                    var temp = {};\r\n\r\n                    for (property in cast (properties, Array <Dynamic>)) {\r\n\r\n                        Reflect.setField (temp, property, null);\r\n\r\n                    }\r\n\r\n                    properties = temp;\r\n\r\n                }\r\n\r\n                var i = library.length - 1;\r\n                while (i >= 0) {\r\n                    library[i].stop (properties, complete, sendEvent);\r\n                    i--;\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    }\r\n\r\n\r\n    /**\r\n      Creates a tween-based timer, which is useful for synchronizing function calls with other animations   \r\n      @example     <code>Actuate.timer (1).onComplete (trace, [ \"Timer is now complete\" ]);</code>   \r\n      @param   duration        The length of the timer in seconds   \r\n      @param   customActuator      A custom actuator to use instead of the default (Optional)   \r\n      @return      The current actuator instance, which can be used to apply properties like onComplete or to gain a reference to the target timer object   \r\n     */\r\n    public static function timer (duration:Float, customActuator:Class <GenericActuator> = null):IGenericActuator {\r\n\r\n        return tween (new TweenTimer (0), duration, new TweenTimer (1), false, customActuator);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n      Creates a new tween   \r\n      @example     <code>Actuate.tween (MyClip, 1, { alpha: 1 } ).onComplete (trace, [ \"MyClip is now visible\" ]);</code>   \r\n      @param   target      The object to tween   \r\n      @param   duration        The length of the tween in seconds   \r\n      @param   properties      The end values to tween the target to   \r\n      @param   overwrite           Sets whether previous tweens for the same target and properties will be overwritten (Default is true)   \r\n      @param   customActuator      A custom actuator to use instead of the default (Optional)   \r\n      @return      The current actuator instance, which can be used to apply properties like ease, delay, onComplete or onUpdate   \r\n     */\r\n    public static function tween (target:Dynamic, duration:Float, properties:Dynamic, overwrite:Bool = true, customActuator:Class <GenericActuator> = null):IGenericActuator {\r\n\r\n        if (target != null) {\r\n\r\n            if (duration > 0) {\r\n\r\n                if (customActuator == null) {\r\n\r\n                    customActuator = defaultActuator;\r\n\r\n                }\r\n\r\n                var actuator = Type.createInstance (customActuator, [ target, duration, properties ]);\r\n                var library = getLibrary (actuator.target);\r\n\r\n                if (overwrite) {\r\n\r\n                    var i = library.length - 1;\r\n\r\n                    while (i >= 0) {\r\n                        library[i].stop (actuator.properties, false, false);\r\n                        i--;\r\n                    }\r\n\r\n                    library = getLibrary (actuator.target);\r\n\r\n                }\r\n\r\n                library.push (actuator);\r\n                actuator.move ();\r\n\r\n                /*var actuator:GenericActuator = createInstance (customActuator, target, duration, properties);\r\n\r\n                if (overwrite) {\r\n\r\n                    stop (target, properties, false, false);\r\n\r\n                }\r\n\r\n                var library:Array <GenericActuator> = getLibrary (target);\r\n                library.push (actuator);\r\n\r\n                actuator.move ();*/\r\n\r\n                return actuator;\r\n\r\n            } else {\r\n\r\n                return apply (target, properties, customActuator);\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return null;\r\n\r\n    }\r\n\r\n\r\n    public static function unload (actuator:GenericActuator):Void {\r\n\r\n        var target = actuator.target;\r\n\r\n        if (targetLibraries.exists (target)) {\r\n\r\n            targetLibraries.get (target).remove (actuator);\r\n\r\n            if (targetLibraries.get (target).length == 0) {\r\n\r\n                targetLibraries.remove (target);\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n    /**\r\n      Creates a new tween that updates a method rather than setting the properties of an object   \r\n      @example     <code>Actuate.update (trace, 1, [\"Value: \", 0], [\"\", 1]).onComplete (trace, [ \"Finished tracing values between 0 and 1\" ]);</code>   \r\n      @param   target      The method to update   \r\n      @param   duration        The length of the tween in seconds   \r\n      @param   start       The starting parameters of the method call. You may use both numeric and non-numeric values   \r\n      @param   end     The ending parameters of the method call. You may use both numeric and non-numeric values, but the signature should match the start parameters   \r\n      @param   overwrite       Sets whether previous tweens for the same target and properties will be overwritten (Default is true)   \r\n      @return      The current actuator instance, which can be used to apply properties like ease, delay, onComplete or onUpdate   \r\n     */\r\n    public static function update (target:Dynamic, duration:Float, start:Array <Dynamic> = null, end:Array <Dynamic> = null, overwrite:Bool = true):IGenericActuator {\r\n\r\n        var properties:Dynamic = { start: start, end: end };\r\n\r\n        return tween (target, duration, properties, overwrite, MethodActuator);\r\n\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n@:noCompletion private class TweenTimer {\r\n\r\n\r\n    public var progress:Float;\r\n\r\n\r\n    public function new (progress:Float):Void {\r\n\r\n        this.progress = progress;\r\n\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\ntypedef ObjectHash<T> = haxe.ds.ObjectMap<Dynamic, T>;\r\n","package luxe.tween;\r\n\r\n\r\n/**\r\n  @author Joshua Granick   \r\n  @author Aleš Tomeček (for RotationPath)   \r\n */\r\nclass MotionPath {\r\n\r\n\r\n    public var rotation (get_rotation, null):RotationPath;\r\n    public var x (get_x, null):IComponentPath;\r\n    public var y (get_y, null):IComponentPath;\r\n\r\n    var _rotation:RotationPath;\r\n    var _x:ComponentPath;\r\n    var _y:ComponentPath;\r\n\r\n\r\n    public function new () {\r\n\r\n        _x = new ComponentPath ();\r\n        _y = new ComponentPath ();\r\n\r\n        _rotation = null;\r\n\r\n    }\r\n\r\n\r\n    /**\r\n      Adds a bezier curve to the current motion path   \r\n      @param   x       The x position of the end point for the curve   \r\n      @param   y       The y position of the end point for the curve   \r\n      @param   controlX        The x position of the control point for the curve, which affects the angle and midpoint   \r\n      @param   controlX        The x position of the control point for the curve, which affects the angle and midpoint   \r\n      @param   strength        The degree of emphasis that should be placed on this segment. If a motion path contains multiple segments with the same strength, they all receive equal emphasis (Default is 1)   \r\n      @return      The current motion path instance   \r\n     */\r\n    public function bezier (x:Float, y:Float, controlX:Float, controlY:Float, strength:Float = 1):MotionPath {\r\n\r\n        _x.addPath (new BezierPath (x, controlX, strength));\r\n        _y.addPath (new BezierPath (y, controlY, strength));\r\n\r\n        return this;\r\n\r\n    }\r\n\r\n\r\n    /**\r\n      Adds a line to the current motion path   \r\n      @param   x       The x position of the end point for the line   \r\n      @param   x       The y position of the end point for the line   \r\n      @param   strength        The degree of emphasis that should be placed on this segment . If a motion path contains multiple segments with the same strength, they all receive equal emphasis (Default is 1)   \r\n      @return      The current motion path instance   \r\n     */\r\n    public function line (x:Float, y:Float, strength:Float = 1):MotionPath {\r\n\r\n        _x.addPath (new LinearPath (x, strength));\r\n        _y.addPath (new LinearPath (y, strength));\r\n\r\n        return this;\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n    // Get & Set Methods\r\n\r\n\r\n\r\n\r\n    function get_rotation ():RotationPath {\r\n\r\n        if (_rotation == null) {\r\n\r\n            _rotation = new RotationPath (_x, _y);\r\n\r\n        }\r\n\r\n        return _rotation;\r\n\r\n    }\r\n\r\n\r\n    function get_x ():IComponentPath {\r\n\r\n        return _x;\r\n\r\n    }\r\n\r\n\r\n    function get_y ():IComponentPath {\r\n\r\n        return _y;\r\n\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\nclass ComponentPath implements IComponentPath {\r\n\r\n\r\n    public var start:Float;\r\n    public var end (get_end, null):Float;\r\n\r\n    var paths:Array <BezierPath>;\r\n    var totalStrength:Float;\r\n\r\n\r\n    public function new () {\r\n\r\n        paths = new Array <BezierPath> ();\r\n        start = 0;\r\n        totalStrength = 0;\r\n\r\n    }\r\n\r\n\r\n    public function addPath (path:BezierPath):Void {\r\n\r\n        paths.push (path);\r\n        totalStrength += path.strength;\r\n\r\n    }\r\n\r\n\r\n    public function calculate (k:Float):Float {\r\n\r\n        if (paths.length == 1) {\r\n\r\n            return paths[0].calculate (start, k);\r\n\r\n        } else {\r\n\r\n            var ratio = k * totalStrength;\r\n            var lastEnd = start;\r\n\r\n            for (path in paths) {\r\n\r\n                if (ratio > path.strength) {\r\n\r\n                    ratio -= path.strength;\r\n                    lastEnd = path.end;\r\n\r\n                } else {\r\n\r\n                    return path.calculate (lastEnd, ratio / path.strength);\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return 0;\r\n\r\n    }\r\n\r\n\r\n\r\n    // Get & Set Methods\r\n\r\n\r\n\r\n\r\n    function get_end ():Float {\r\n\r\n        if (paths.length > 0) {\r\n\r\n            var path = paths[paths.length - 1];\r\n            return path.end;\r\n\r\n        } else {\r\n\r\n            return start;\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n@:noCompletion interface IComponentPath {\r\n\r\n\r\n    var end (get_end, null):Float;\r\n    var start:Float;\r\n\r\n    function calculate (k:Float):Float;\r\n\r\n\r\n}\r\n\r\n\r\nclass BezierPath {\r\n\r\n\r\n    public var control:Float;\r\n    public var end:Float;\r\n    public var strength:Float;\r\n\r\n\r\n    public function new (end:Float, control:Float, strength:Float) {\r\n\r\n        this.end = end;\r\n        this.control = control;\r\n        this.strength = strength;\r\n\r\n    }\r\n\r\n\r\n    public function calculate (start:Float, k:Float):Float {\r\n\r\n        return (1 - k) * (1 - k) * start + 2 * (1 - k) * k * control + k * k * end;\r\n\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\nclass LinearPath extends BezierPath {\r\n\r\n\r\n    public function new (end:Float, strength:Float) {\r\n\r\n        super (end, 0, strength);\r\n\r\n    }\r\n\r\n\r\n    public override function calculate (start:Float, k:Float):Float {\r\n\r\n        return start + k * (end - start);\r\n\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\nclass RotationPath implements IComponentPath {\r\n\r\n\r\n    public var end (get_end, null):Float;\r\n    public var offset:Float;\r\n    public var start:Float;\r\n\r\n    var step = 0.01;\r\n    var _x:ComponentPath;\r\n    var _y:ComponentPath;\r\n\r\n\r\n    public function new (x:ComponentPath, y:ComponentPath) {\r\n\r\n        _x = x;\r\n        _y = y;\r\n\r\n        offset = 0;\r\n\r\n        start = calculate (0.0);\r\n\r\n    }\r\n\r\n\r\n    public function calculate (k:Float):Float {\r\n\r\n        var dX = _x.calculate (k) - _x.calculate (k + step);\r\n        var dY = _y.calculate (k) - _y.calculate (k + step);\r\n\r\n        var angle = Math.atan2(dY, dX) * (180 / Math.PI);\r\n        angle = (angle + offset) % 360;\r\n\r\n        return angle;\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n    // Get & Set Methods\r\n\r\n\r\n\r\n\r\n    public function get_end ():Float {\r\n\r\n        return calculate (1.0);\r\n\r\n    }\r\n\r\n\r\n}\r\n","package luxe.tween.actuators;\r\n\r\n\r\n/**\r\n * @author Joshua Granick\r\n * @version 1.2\r\n */\r\nclass MethodActuator extends SimpleActuator {\r\n\r\n\r\n    var currentParameters:Array <Dynamic>;\r\n    var tweenProperties:Dynamic;\r\n\r\n\r\n    public function new (target:Dynamic, duration:Float, properties:Dynamic) {\r\n\r\n        currentParameters = new Array <Dynamic> ();\r\n        tweenProperties = { };\r\n\r\n        super (target, duration, properties);\r\n\r\n        if (!Reflect.hasField (properties, \"start\")) {\r\n\r\n            this.properties.start = new Array <Dynamic> ();\r\n\r\n        }\r\n\r\n        if (!Reflect.hasField (properties, \"end\")) {\r\n\r\n            this.properties.end = this.properties.start;\r\n\r\n        }\r\n\r\n        for (i in 0...this.properties.start.length) {\r\n\r\n            currentParameters.push (null);\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n    public override function apply ():Void {\r\n\r\n        callMethod (target, properties.end);\r\n\r\n    }\r\n\r\n\r\n    override function complete (sendEvent:Bool = true):Void {\r\n\r\n        for (i in 0...properties.start.length) {\r\n\r\n            currentParameters[i] = Reflect.field (tweenProperties, \"param\" + i);\r\n\r\n        }\r\n\r\n        callMethod (target, currentParameters);\r\n\r\n        super.complete (sendEvent);\r\n\r\n    }\r\n\r\n\r\n    override function initialize ():Void {\r\n\r\n        var details:PropertyDetails;\r\n        var propertyName:String;\r\n        var start:Dynamic;\r\n\r\n        for (i in 0...properties.start.length) {\r\n\r\n            propertyName = \"param\" + i;\r\n            start = properties.start[i];\r\n\r\n            Reflect.setField (tweenProperties, propertyName, start);\r\n\r\n            if (Std.is (start, Float) || Std.is (start, Int)) {\r\n\r\n                details = new PropertyDetails (tweenProperties, propertyName, start, properties.end[i] - start);\r\n                propertyDetails.push (details);\r\n\r\n            }\r\n\r\n        }\r\n\r\n        detailsLength = propertyDetails.length;\r\n        initialized = true;\r\n\r\n    }\r\n\r\n\r\n    override function update (currentTime:Float):Void {\r\n\r\n        super.update (currentTime);\r\n\r\n        if (active) {\r\n\r\n            for (i in 0...properties.start.length) {\r\n\r\n                currentParameters[i] = Reflect.field (tweenProperties, \"param\" + i);\r\n\r\n            }\r\n\r\n            callMethod (target, currentParameters);\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n}\r\n","package luxe.tween.actuators;\r\n\r\n\r\nimport luxe.tween.MotionPath;\r\n\r\n\r\n/**\r\n * @author Joshua Granick\r\n */\r\nclass MotionPathActuator extends SimpleActuator {\r\n\r\n\r\n    public function new (target:Dynamic, duration:Float, properties:Dynamic) {\r\n\r\n        super (target, duration, properties);\r\n\r\n    }\r\n\r\n\r\n    public override function apply ():Void {\r\n\r\n        for (propertyName in Reflect.fields (properties)) {\r\n\r\n            if (#if flash false && #end Reflect.hasField (target, propertyName)) {\r\n\r\n                Reflect.setField (target, propertyName, cast (Reflect.field (properties, propertyName), IComponentPath).end);\r\n\r\n            } else {\r\n\r\n                Reflect.setProperty (target, propertyName, cast (Reflect.field (properties, propertyName), IComponentPath).end);\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n    override function initialize ():Void {\r\n\r\n        var details:PropertyPathDetails;\r\n        var path:IComponentPath;\r\n\r\n        for (propertyName in Reflect.fields (properties)) {\r\n\r\n            path = cast (Reflect.field (properties, propertyName), IComponentPath);\r\n\r\n            if (path != null) {\r\n\r\n                var isField = true;\r\n\r\n                if (#if flash false && #end Reflect.hasField (target, propertyName)) {\r\n\r\n                    path.start = Reflect.field (target, propertyName);\r\n\r\n                } else {\r\n\r\n                    isField = false;\r\n                    path.start = Reflect.getProperty (target, propertyName);\r\n\r\n                }\r\n\r\n\r\n                details = new PropertyPathDetails (target, propertyName, path, isField);\r\n                propertyDetails.push (details);\r\n\r\n            }\r\n\r\n        }\r\n\r\n        detailsLength = propertyDetails.length;\r\n        initialized = true;\r\n\r\n    }\r\n\r\n\r\n    override function update (currentTime:Float):Void {\r\n\r\n        if (!paused) {\r\n\r\n            var details:PropertyPathDetails;\r\n            var easing:Float;\r\n\r\n            var tweenPosition = (currentTime - timeOffset) / duration;\r\n\r\n            if (tweenPosition > 1) {\r\n\r\n                tweenPosition = 1;\r\n\r\n            }\r\n\r\n            if (!initialized) {\r\n\r\n                initialize ();\r\n\r\n            }\r\n\r\n            if (!special) {\r\n\r\n                easing = _ease.calculate (tweenPosition);\r\n\r\n                for (details in propertyDetails) {\r\n\r\n                    if (details.isField) {\r\n\r\n                        Reflect.setField (details.target, details.propertyName, cast (details, PropertyPathDetails).path.calculate (easing));\r\n\r\n                    } else {\r\n\r\n                        Reflect.setProperty (details.target, details.propertyName, cast (details, PropertyPathDetails).path.calculate (easing));\r\n\r\n                    }\r\n\r\n                }\r\n\r\n            } else {\r\n\r\n                if (!_reverse) {\r\n\r\n                    easing = _ease.calculate (tweenPosition);\r\n\r\n                } else {\r\n\r\n                    easing = _ease.calculate (1 - tweenPosition);\r\n\r\n                }\r\n\r\n                var endValue:Float;\r\n\r\n                for (details in propertyDetails) {\r\n\r\n                    if (!_snapping) {\r\n\r\n                        if (details.isField) {\r\n\r\n                            Reflect.setField (details.target, details.propertyName, cast (details, PropertyPathDetails).path.calculate (easing));\r\n\r\n                        } else {\r\n\r\n                            Reflect.setProperty (details.target, details.propertyName, cast (details, PropertyPathDetails).path.calculate (easing));\r\n\r\n                        }\r\n\r\n                    } else {\r\n\r\n                        if (details.isField) {\r\n\r\n                            Reflect.setField (details.target, details.propertyName, Math.round (cast (details, PropertyPathDetails).path.calculate (easing)));\r\n\r\n                        } else {\r\n\r\n                            Reflect.setProperty (details.target, details.propertyName, Math.round (cast (details, PropertyPathDetails).path.calculate (easing)));\r\n\r\n                        }\r\n\r\n\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n\r\n            if (tweenPosition == 1) {\r\n\r\n                if (_repeat == 0) {\r\n\r\n                    active = false;\r\n\r\n                    if (toggleVisible && getField (target, \"alpha\") == 0) {\r\n\r\n                        setField (target, \"visible\", false);\r\n\r\n                    }\r\n\r\n                    complete (true);\r\n                    return;\r\n\r\n                } else {\r\n\r\n                    if (_reflect) {\r\n\r\n                        _reverse = !_reverse;\r\n\r\n                    }\r\n\r\n                    startTime = currentTime;\r\n                    timeOffset = startTime + _delay;\r\n\r\n                    if (_repeat > 0) {\r\n\r\n                        _repeat --;\r\n\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n\r\n            if (sendChange) {\r\n\r\n                change ();\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n#if !haxe3\r\nimport com.eclecticdesignstudio.motion.MotionPath;\r\n#end\r\n\r\n\r\nclass PropertyPathDetails extends PropertyDetails {\r\n\r\n\r\n    public var path:IComponentPath;\r\n\r\n\r\n    public function new (target:Dynamic, propertyName:String, path:IComponentPath, isField:Bool = true) {\r\n\r\n        super (target, propertyName, 0, 0, isField);\r\n\r\n        this.path = path;\r\n\r\n    }\r\n\r\n\r\n}\r\n","﻿/**\r\n * @author Joshua Granick\r\n */\r\n\r\n\r\npackage luxe.tween.actuators;\r\n\r\n\r\nclass PropertyDetails {\r\n    \r\n    \r\n    public var change:Float;\r\n    public var isField:Bool;\r\n    public var propertyName:String;\r\n    public var start:Float;\r\n    public var target:Dynamic;\r\n    \r\n    \r\n    public function new (target:Dynamic, propertyName:String, start:Float, change:Float, isField:Bool = true):Void {\r\n        \r\n        this.target = target;\r\n        this.propertyName = propertyName;\r\n        this.start = start;\r\n        this.change = change;\r\n        this.isField = isField;\r\n        \r\n    }\r\n    \r\n    \r\n}","package luxe.utils;\r\n\r\nimport luxe.Vector;\r\nimport phoenix.geometry.Geometry;\r\n\r\n\r\nclass GeometryUtils {\r\n\r\n    static inline var two_pi : Float = 6.283185307179586;\r\n\r\n    @:allow(luxe.utils.Utils)\r\n    function new() {}\r\n\r\n    public function segments_for_smooth_circle( _radius:Float, _smooth:Float = 6 ) : Int {\r\n\r\n        return Std.int(_smooth * Math.sqrt( _radius ));\r\n\r\n    } //segments_for_smooth_circle\r\n\r\n    public function random_point_in_unit_circle() : Vector {\r\n\r\n            //first get a smoothly distributed point in the radius\r\n        var _r:Float = Math.sqrt( Math.random() );\r\n            //then rotate that point randomly around 360 degrees,\r\n            //the -1 + 2 * means that it shifts from -1 + [0..2] = -1,1 range\r\n            //this centers it around the origin\r\n        var _t:Float = (-1 + (2 * Math.random())) * two_pi;\r\n\r\n            //finally, work out the x and y\r\n        return new Vector( _r*Math.cos(_t), _r*Math.sin(_t) );\r\n\r\n    } //random_point_in_unit_circle\r\n\r\n    public function point_in_polygon(_point:Vector, _offset:Vector, _verts:Array<Vector> ) : Bool {\r\n\r\n        if(_offset == null) _offset = new Vector();\r\n        var c : Bool = false;\r\n        var nvert : Int = _verts.length;\r\n        var j : Int = nvert - 1;\r\n\r\n        for(i in 0 ... nvert) {\r\n\r\n            if ((( (_verts[i].y+_offset.y) > _point.y) != ((_verts[j].y+_offset.y) > _point.y)) &&\r\n               (_point.x < ( (_verts[j].x+_offset.x) - (_verts[i].x+_offset.x)) * (_point.y - (_verts[i].y+_offset.y))\r\n                 / ( (_verts[j].y+_offset.y) - (_verts[i].y+_offset.y)) + (_verts[i].x+_offset.x)) ) {\r\n                c = !c;\r\n            }\r\n\r\n            j = i;\r\n        }\r\n\r\n        return c;\r\n\r\n    } //point_in_polygon\r\n\r\n        //Note this function assumes _geometry is a 2D polygon,\r\n        //and is currently slightly less efficient due to geometry not keeping\r\n        //a transformed vert cache in it, which will be needed later :todo :\r\n    public function point_in_geometry( _point:Vector, _geometry:Geometry ) : Bool {\r\n\r\n        var c : Bool = false;\r\n        var nvert : Int = _geometry.vertices.length;\r\n        var j : Int = nvert - 1;\r\n\r\n        for(i in 0 ... nvert) {\r\n\r\n            var _vert_i_pos = _geometry.vertices[i].pos.clone().transform( _geometry.transform.world.matrix );\r\n            var _vert_j_pos = _geometry.vertices[j].pos.clone().transform( _geometry.transform.world.matrix );\r\n\r\n            if ((( (_vert_i_pos.y) > _point.y) != ((_vert_j_pos.y) > _point.y)) &&\r\n               (_point.x < ( (_vert_j_pos.x) - (_vert_i_pos.x)) * (_point.y - (_vert_i_pos.y))\r\n                 / ( (_vert_j_pos.y) - (_vert_i_pos.y)) + (_vert_i_pos.x)) ) {\r\n                c = !c;\r\n            }\r\n\r\n            j = i;\r\n        }\r\n\r\n        return c;\r\n\r\n    } //point_in_geometry\r\n\r\n\r\n        //plane_point is a point on the plane (anywhere) , can be 0,0,0 for infinite plane.\r\n    public function intersect_ray_plane( _ray_start:Vector, _ray_dir:Vector, _plane_normal:Vector, _plane_point:Vector ) : Vector {\r\n\r\n            //T = [planeNormal•(pointOnPlane - rayOrigin)]/planeNormal•rayDirection;\r\n            //pointInPlane = rayOrigin + (rayDirection * T);\r\n\r\n            //for [ ]\r\n        var part1 = _plane_normal.dot( Vector.Subtract(_plane_point, _ray_start) );\r\n        var part2 = _plane_normal.dot( _ray_dir );\r\n\r\n        var T = part1 / part2;\r\n\r\n        return Vector.Add(_ray_start, Vector.Multiply(_ray_dir, T));\r\n\r\n    } //intersect_ray_plane\r\n\r\n\r\n } //GeometryUtils\r\n","package luxe.utils;\r\n\r\n//Portions ported from Three.js http://github.com/mrdoob/three.js\r\n\r\nclass Maths {\r\n\r\n    function new() {}\r\n\r\n    static inline public function fixed( value:Float, precision:Int ) {\r\n\r\n        var n = Math.pow( 10, precision );\r\n        return ( Std.int(value * n) / n );\r\n\r\n    } //fixed'\r\n\r\n    static inline public function lerp( value:Float, target:Float, t:Float ) {\r\n\r\n        t = clamp(t, 0, 1);\r\n\r\n        return (value + t * (target - value));\r\n\r\n    } //lerp\r\n\r\n    static inline public function weighted_avg( value:Float, target:Float, slowness:Float ) {\r\n\r\n            //:todo: use an epsilon\r\n        if( slowness == 0 ) { slowness = 0.00000001; }\r\n\r\n        return ((value * (slowness - 1)) + target) / slowness;\r\n\r\n    } //weighted_avg\r\n\r\n    static inline public function clamp( value:Float, a:Float, b:Float ) : Float {\r\n        return ( value < a ) ? a : ( ( value > b ) ? b : value );\r\n    } //clamp\r\n\r\n    static inline public function clamp_bottom(value:Float, a:Float) : Float {\r\n        return value < a ? a : value;\r\n    } //clamp_bottom\r\n\r\n    static inline public function within_range(value:Float, start_range:Float, end_range:Float ) {\r\n        return value >= start_range && value <= end_range;\r\n    } //within_range\r\n\r\n    public static inline function wrap_angle( degrees:Float, lower:Float, upper:Float ) {\r\n\r\n        var _radians:Float = radians(degrees);\r\n        var _distance:Float = upper - lower;\r\n        var _times:Float = Math.floor((degrees - lower) / _distance);\r\n\r\n        return degrees - (_times * _distance);\r\n\r\n    } //wrap_angle\r\n\r\n    public static inline function nearest_power_of_two(_value:Int) {\r\n\r\n        _value--;\r\n        _value |= _value >> 1;\r\n        _value |= _value >> 2;\r\n        _value |= _value >> 4;\r\n        _value |= _value >> 8;\r\n        _value |= _value >> 16;\r\n        _value++;\r\n\r\n        return _value;\r\n\r\n    } //nearest_power_of_two\r\n\r\n    static inline public function map_linear( value:Float, a1:Float, a2:Float, b1:Float, b2:Float ) : Float {\r\n        return b1 + ( value - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\r\n    } //map_linear\r\n\r\n    static inline public function smoothstep( x:Float, min:Float, max:Float ) : Float {\r\n\r\n        if (x <= min) {\r\n            return 0;\r\n        }\r\n\r\n        if (x >= max) {\r\n            return 1;\r\n        }\r\n\r\n        x = ( x - min ) / ( max - min );\r\n\r\n        return x * x * ( 3 - 2 * x );\r\n\r\n    } //smoothstep\r\n\r\n    static inline public function smootherstep( x:Float, min:Float, max:Float ) : Float {\r\n\r\n        if (x <= min) {\r\n            return 0;\r\n        }\r\n\r\n        if (x >= max) {\r\n            return 1;\r\n        }\r\n\r\n        x = ( x - min ) / ( max - min );\r\n\r\n        return x * x * x * ( x * ( x * 6 - 15 ) + 10 );\r\n\r\n    } //smootherstep\r\n\r\n    static inline public function random16() : Float {\r\n        return ( 65280 * Math.random() + 255 * Math.random() ) / 65535;\r\n    } //random16\r\n\r\n    static inline public function random_int( low:Int, high:Int ) : Int {\r\n        return low + Math.floor(Math.random() * (high - low + 1));\r\n    } //random_int\r\n\r\n    static inline public function random_float( low:Float, high:Float ) : Float {\r\n        return low + Math.random() * (high - low);\r\n    } //random_float\r\n\r\n    static inline public function random_float_spread( range:Float ) : Float {\r\n        return range * (0.5 - Math.random());\r\n    } //random_float_spread\r\n\r\n    static inline public function sign( x:Float ) : Int {\r\n        return (x < 0) ? -1 : ((x > 0) ? 1 : 0);\r\n    } //sign\r\n\r\n    static inline public function radians( degrees:Float ) : Float {\r\n        return degrees * _PI_OVER_180;\r\n    } //radians\r\n\r\n    static inline public function degrees( radians:Float ) : Float {\r\n        return radians * _180_OVER_PI;\r\n    } //degrees\r\n\r\n\r\n//Internal constants\r\n\r\n        /** Used by `degrees()` and `radians()`, use those to convert, unless needed */\r\n    static inline public var _PI_OVER_180:Float = 3.14159265358979 / 180;\r\n        /** Used by `degrees()` and `radians()`, use those to convert, unless needed */\r\n    static inline public var _180_OVER_PI:Float = 180 / 3.14159265358979;\r\n\r\n} //Maths\r\n","package luxe.utils;\r\n\r\n//Adapted from code by Grant Skinner, see bottom of file.\r\n\r\n/**\r\n Given an `initial` value for the seed, subsequent generated numbers will be predictable,\r\n and the `seed` value updated to reflect the current seed which can be used to resume predictability\r\n from an ongoing set. Uses a Park–Miller pseudo random number generator.\r\n\r\n Accessible through Luxe.utils.random.get(), or used as a class in your own code.\r\n*/\r\nclass Random {\r\n\r\n    public function new( _initial_seed:UInt ) {\r\n        seed = initial = _initial_seed;\r\n    }\r\n\r\n//Public API\r\n\r\n        /** Returns a float number between [0,1) */\r\n    public inline function get() : Float {\r\n        return (seed = (seed * 16807) % 2147483647)/0x7FFFFFFF+0.000000000233;\r\n    }\r\n\r\n        /** Returns a number between [min,max).\r\n            max is optional, returning a number between [0,min) */\r\n    public inline function float( min:Float, ?max:Null<Float>=null ) : Float {\r\n        if(max == null) { max = min; min = 0; }\r\n        return get() * ( max - min ) + min;\r\n    }\r\n\r\n        /** Return a number between [min, max).\r\n            max is optional, returning a number between [0,min) */\r\n    public inline function int( min:Float, ?max:Null<Float>=null ) : Int {\r\n        if(max == null) { max = min; min=0; }\r\n        return Math.floor( float(min,max) );\r\n    }\r\n\r\n        /** Returns true or false based on a chance of [0..1] percent.\r\n            Given 0.5, 50% chance of true, with 0.9, 90% chance of true and so on. */\r\n    public inline function bool( chance:Float = 0.5 ) : Bool {\r\n        return (get() < chance);\r\n    }\r\n\r\n        /** Returns 1 or -1 based on a chance of [0..1] percent.\r\n            Given 0.5, 50% chance of 1, with 0.9, 90% chance of 1 and so on. */\r\n    public inline function sign( chance:Float = 0.5) : Int {\r\n        return (get() < chance) ? 1 : -1;\r\n    }\r\n\r\n        /** Returns 1 or 0 based on a chance of [0..1] percent.\r\n            Given 0.5, 50% chance of 1, with 0.9, 90% chance of 1 and so on. */\r\n    public inline function bit( chance:Float = 0.5) : Int {\r\n        return (get() < chance) ? 1 : 0;\r\n    }\r\n\r\n        /** Reset the initial value to that of the current seed. */\r\n    public inline function reset() {\r\n        var s = seed;\r\n        initial = s;\r\n    }\r\n\r\n        /** get the current seed (read only, change via `initial`)*/\r\n    @:isVar public var seed (default,null): UInt;\r\n        /** get/set the initial base seed */\r\n    @:isVar public var initial (default,set): UInt;\r\n\r\n        inline function set_initial( _initial : UInt ) {\r\n            initial = seed = _initial;\r\n            return initial;\r\n        }\r\n\r\n} //Random\r\n\r\n\r\n//Based on code from http://blog.gskinner.com/archives/2008/01/source_code_see.html\r\n//With license:\r\n\r\n/**\r\n* Rndm by Grant Skinner. Jan 15, 2008\r\n* Visit www.gskinner.com/blog for documentation, updates and more free code.\r\n*\r\n* Incorporates implementation of the Park Miller (1988) \"minimal standard\" linear\r\n* congruential pseudo-random number generator by Michael Baczynski, www.polygonal.de.\r\n* (seed * 16807) % 2147483647\r\n*\r\n*\r\n*\r\n* Copyright (c) 2008 Grant Skinner\r\n*\r\n* Permission is hereby granted, free of charge, to any person\r\n* obtaining a copy of this software and associated documentation\r\n* files (the \"Software\"), to deal in the Software without\r\n* restriction, including without limitation the rights to use,\r\n* copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n* copies of the Software, and to permit persons to whom the\r\n* Software is furnished to do so, subject to the following\r\n* conditions:\r\n*\r\n* The above copyright notice and this permission notice shall be\r\n* included in all copies or substantial portions of the Software.\r\n*\r\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\r\n* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\r\n* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\r\n* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\r\n* OTHER DEALINGS IN THE SOFTWARE.\r\n*/\r\n","package luxe.utils;\r\n\r\nimport luxe.Core;\r\n\r\nimport haxe.CallStack;\r\n\r\nclass Utils {\r\n\r\n    public var geometry : luxe.utils.GeometryUtils;\r\n    public var random : luxe.utils.Random;\r\n\r\n    @:noCompletion public var core:Core;\r\n\r\n    var _byte_levels : Array<String>;\r\n\r\n    @:allow(luxe.Core)\r\n    function new( _luxe:Core ) {\r\n\r\n            //store the reference\r\n        core = _luxe;\r\n            //initialise the helpers\r\n        geometry = new luxe.utils.GeometryUtils();\r\n        random = new luxe.utils.Random(Std.int(Math.random()*0x3FFFFFFF));\r\n            //initialize the byte text helpers\r\n        _byte_levels = ['bytes', 'Kb', 'MB', 'GB', 'TB'];\r\n\r\n    }  //new\r\n\r\n        /** Return a formatted string from a PosInfos */\r\n    public function pos_info( pos:haxe.PosInfos ) {\r\n        return '${pos.fileName}:${pos.lineNumber}:(${pos.className}:${pos.methodName})';\r\n    }\r\n\r\n        /** Generate a short, unique string ID for use (\"base62\"). */\r\n    #if release inline #end\r\n    public function uniqueid(?val:Null<Int>) : String {\r\n\r\n        // http://www.anotherchris.net/csharp/friendly-unique-id-generation-part-2/#base62\r\n\r\n        if(val == null) {\r\n            #if neko val = Std.random(0x3FFFFFFF);\r\n            #else val = Std.random(0x7fffffff);\r\n            #end\r\n        }\r\n\r\n        function to_char(value:Int) : String {\r\n            if (value > 9) {\r\n                var ascii = (65 + (value - 10));\r\n                if (ascii > 90) { ascii += 6; }\r\n                return String.fromCharCode(ascii);\r\n            } else return Std.string(value).charAt(0);\r\n        } //to_char\r\n\r\n        var r = Std.int(val % 62);\r\n        var q = Std.int(val / 62);\r\n        if (q > 0) return uniqueid(q) + to_char(r);\r\n        else return Std.string(to_char(r));\r\n\r\n    } //uniqueid\r\n\r\n        /** Generates and returns a uniqueid converted to a hashed integer for convenience.\r\n            Uses the default `uniqueid` and `hash` implementation detail. */\r\n    #if release inline #end\r\n    public function uniquehash() : UInt {\r\n        return hash( uniqueid() );\r\n    } //uniquehash\r\n\r\n        /** Generates a integer hash from a string using the default algorithm (murmur3) */\r\n    #if release inline #end\r\n    public function hash( string:String ) : UInt {\r\n        return hashdjb2( string );\r\n    } //hash\r\n\r\n        /** Generates an integer hash of a string using the djb2 algorithm */\r\n    #if release inline #end\r\n    public function hashdjb2(string:String) : UInt {\r\n\r\n            //http://www.cse.yorku.ca/~oz/hash.html\r\n        var _hash : Int = 5381;\r\n        for(i in 0...string.length) {\r\n            _hash = ((_hash << 5) + _hash) + string.charCodeAt(i);\r\n        }\r\n\r\n        return _hash;\r\n\r\n    } //hashdjb2\r\n\r\n    #if release inline #end\r\n    public function uniqueid2() : String {\r\n\r\n        return haxe.crypto.Md5.encode(Std.string(Luxe.time*Math.random()));\r\n\r\n    } //uniqueid2\r\n\r\n    #if release inline #end\r\n    public function stacktrace( ?_depth:Int = 100 ) : String {\r\n\r\n        var result = '\\n';\r\n\r\n            var stack = haxe.CallStack.callStack();\r\n\r\n            stack.shift();\r\n            stack.reverse();\r\n\r\n            var total : Int = Std.int(Math.min(stack.length, _depth));\r\n\r\n            for(i in 0 ... total) {\r\n                var stackitem : haxe.CallStack.StackItem = stack[i];\r\n\r\n                switch(stack[i]) {\r\n                    case FilePos(s, file, line):\r\n                        switch(s) {\r\n                            case Method(classname, method):\r\n                                result += '   at $file:$line: $classname.$method';\r\n                            case _:\r\n                        }\r\n                    case _:{}\r\n                }\r\n\r\n                if(i != total - 1) {\r\n                    result += '\\n';\r\n                }\r\n            } //total\r\n\r\n        return result;\r\n\r\n    } //stacktrace\r\n\r\n    #if release inline #end\r\n    public function path_is_relative(_path:String) {\r\n\r\n        return _path.charAt(0) != \"#\"\r\n            && _path.charAt(0) != \"/\"\r\n            && _path.indexOf(\":\\\\\") == -1\r\n            && _path.indexOf(\":/\") == -1\r\n\r\n          && ( _path.indexOf(\"//\") == -1\r\n            || _path.indexOf(\"//\") > _path.indexOf(\"#\")\r\n            || _path.indexOf(\"//\") > _path.indexOf(\"?\"));\r\n\r\n    } //path_is_relative\r\n\r\n    public function find_assets_image_sequence( _name:String, _ext:String='.png', _start:String='1' ) : Array<String> {\r\n\r\n        var _final : Array<String> = [];\r\n\r\n            var _sequence_type = '';\r\n            var _pattern_regex : EReg = null;\r\n\r\n            var _type0 = _name + _start + _ext;\r\n            var _type0_re : EReg = new EReg('('+_name+')(\\\\d\\\\b)', 'gi');\r\n            var _type1 = _name + '_' + _start + _ext;\r\n            var _type1_re : EReg  = new EReg('('+_name+')(_\\\\d\\\\b)', 'gi');\r\n            var _type2 = _name + '-' + _start + _ext;\r\n            var _type2_re : EReg  = new EReg('('+_name+')(-\\\\d\\\\b)', 'gi');\r\n\r\n                //check name0 ->\r\n            if(core.app.assets.listed(_type0)) {\r\n                _sequence_type = _type0;\r\n                _pattern_regex = _type0_re;\r\n            } else if(core.app.assets.listed(_type1)) {\r\n                _sequence_type = _type1;\r\n                _pattern_regex = _type1_re;\r\n            } else if(core.app.assets.listed(_type2)) {\r\n                _sequence_type = _type2;\r\n                _pattern_regex = _type2_re;\r\n            } else {\r\n                trace(\"Sequence requested from \" + _name + \" but no assets found like `\" + _type0 + \"` or `\" + _type1 + \"` or `\" + _type2 + \"`\" );\r\n            }\r\n\r\n        if(_sequence_type != '') {\r\n            for(_asset in core.app.assets.list) {\r\n                //check for continuations of the sequence, matching by pattern rather than just brute force, so we can catch missing frames etc\r\n                if(_pattern_regex.match(_asset.id)) {\r\n                    _final.push( _asset.id );\r\n                }\r\n            }\r\n\r\n            _final.sort(function(a:String,b:String):Int { if(a == b) return 0; if(a < b) return -1; return 1; });\r\n        }\r\n\r\n        return _final;\r\n\r\n    } //find_assets_image_sequence\r\n\r\n        /** :WIP: Wrap text using a knuth plass algorithm for column breaking. */\r\n    #if release inline #end\r\n    public function text_wrap_column_knuth_plass( _string:String, _column:Int=80) {\r\n\r\n        var result = [];\r\n\r\n        inline function splitwords(_str:String, _into:Array<String>) {\r\n            var s = _str;\r\n            var rgx = new EReg('(\\\\b[^\\\\s]+\\\\b)', 'gm');\r\n            while (rgx.match(s)) {\r\n                _into.push(rgx.matched(1));\r\n                s = rgx.matchedRight();\r\n            }\r\n                //no matches?\r\n            if(_into.length == 0) _into.push(_str);\r\n            return _into;\r\n        } //splitwords\r\n\r\n        inline function findlen(_lens:Array<Int>, _start:Int, _end:Int) {\r\n            var total = 0;\r\n            for(i in (_start-1) ... _end) total += _lens[i];\r\n            return total + (_end - _start + 1);\r\n        } //findlen\r\n\r\n        inline function getmin(_from:Map<Int,Int>):Int {\r\n            var min = 0x3FFFFFFF;\r\n            for(item in _from.keys()) if(item < min) min = item;\r\n            return min;\r\n        } //getmin\r\n\r\n        var words = [];\r\n        var lengths = [];\r\n        var badness = [ 0 => 0 ];\r\n        var extra = new Map<Int,Int>();\r\n\r\n        splitwords(_string, words);\r\n        words.map(function(w){ lengths.push(w.length); });\r\n\r\n        var n = words.length;\r\n\r\n        for( i in 1 ... n+1 ) {\r\n\r\n            var sums = new Map<Int,Int>();\r\n            var k = i;\r\n\r\n            while( findlen(lengths, k, i) <= _column && k > 0) {\r\n                var a = (_column - findlen(lengths, k, i));\r\n                sums[ Std.int(Math.pow(a,3) + badness[k - 1]) ] = k;\r\n                k -= 1;\r\n            }\r\n\r\n            var mn = getmin(sums);\r\n            badness[i] = mn;\r\n            extra[i] = sums[mn];\r\n\r\n        } //each word\r\n\r\n        var line = 1;\r\n        while(n > 1) {\r\n            result.unshift( words.slice(extra[n]-1, n).join(' ') );\r\n            n = extra[n] - 1;\r\n            line += 1;\r\n        }\r\n\r\n        if(result.length == 0) result.push(_string);\r\n        return result;\r\n\r\n    } //text_wrap_column_knuth\r\n\r\n        /** Soft wrap a string by maximum character count. brk default:'\\n', col default:80 */\r\n    #if release inline #end\r\n    public function text_wrap_column( _text:String, _brk:String='\\n', _column:Int=80) {\r\n\r\n            //based on http://blog.macromates.com/2006/wrapping-text-with-regular-expressions/\r\n            //take note that the ${_column} is string interpolation, not part of the regex.\r\n            //i.e (.{1,80})( +|$)\\n?|(.{80})\r\n\r\n        var result = new EReg('(.{1,${_column}})(?: +|$)\\n?|(.{${_column}})','gimu').replace(_text, '$1$2${_brk}');\r\n\r\n        return StringTools.rtrim(result);\r\n\r\n    } //text_wrap_column\r\n\r\n    #if release inline #end\r\n    public function bytes_to_string( bytes:Int, ?precision:Int=3 ) : String {\r\n\r\n        var index : Int = Math.floor( Math.log(bytes) / Math.log(1024) );\r\n        var _byte_value = ( bytes / Math.pow(1024, index));\r\n            _byte_value = luxe.utils.Maths.fixed(_byte_value, precision);\r\n\r\n        return _byte_value + ' ' + _byte_levels[index];\r\n\r\n    } //bytes_to_string\r\n\r\n    #if release inline #end\r\n    public function array_to_bytes(array:Array<Int>):haxe.io.Bytes {\r\n\r\n        if (array == null) return null;\r\n        var bytes:haxe.io.Bytes = haxe.io.Bytes.alloc(array.length);\r\n        for (n in 0 ... bytes.length) bytes.set(n, array[n]);\r\n\r\n        return bytes;\r\n\r\n    } //array_to_bytes\r\n\r\n} //Utils\r\n","package luxe.utils.unifill;\r\n\r\nabstract CodePoint(Int) {\r\n\r\n    @:op(A + B)\r\n    public static inline function cons(a : CodePoint, b : String) : String\r\n        return a.toString() + b;\r\n\r\n    @:op(A + B)\r\n    public static inline function snoc(a : String, b : CodePoint) : String\r\n        return a + b.toString();\r\n\r\n    @:op(A + B)\r\n    public static inline function addInt(a : CodePoint, b : Int) : CodePoint\r\n        return cast (a.toInt() + b);\r\n\r\n    @:op(A - B)\r\n    public static inline function sub(a : CodePoint, b : CodePoint) : Int\r\n        return (a.toInt()) - (b.toInt());\r\n\r\n    @:op(A - B)\r\n    public static inline function subInt(a : CodePoint, b : Int) : CodePoint\r\n        return cast (a.toInt() - b);\r\n\r\n    @:op(A == B) public static function eq(a : CodePoint, b : CodePoint) : Bool;\r\n    @:op(A != B) public static function ne(a : CodePoint, b : CodePoint) : Bool;\r\n    @:op(A < B) public static function lt(a : CodePoint, b : CodePoint) : Bool;\r\n    @:op(A <= B) public static function lte(a : CodePoint, b : CodePoint) : Bool;\r\n    @:op(A > B) public static function gt(a : CodePoint, b : CodePoint) : Bool;\r\n    @:op(A >= B) public static function gte(a : CodePoint, b : CodePoint) : Bool;\r\n\r\n    public inline function new(code : Int) : Void {\r\n        if (!Unicode.isScalar(code)) {\r\n            throw Exception.InvalidCodePoint(code);\r\n        }\r\n        this = code;\r\n    }\r\n\r\n    public inline function toString() : String\r\n        return InternalEncoding.fromCodePoint(this);\r\n\r\n    public inline function toInt() : Int\r\n        return this;\r\n}\r\n","package luxe.utils.unifill;\r\n\r\nclass CodePointIter {\r\n    var s : String;\r\n    var itr : InternalEncodingIter;\r\n\r\n    public inline function new(s : String) {\r\n        this.s = s;\r\n        this.itr = new InternalEncodingIter(s, 0, s.length);\r\n    }\r\n\r\n    public inline function hasNext() : Bool {\r\n        return itr.hasNext();\r\n    }\r\n\r\n    public inline function next() : CodePoint {\r\n        return cast InternalEncoding.codePointAt(s, itr.next());\r\n    }\r\n}\r\n","package luxe.utils.unifill;\r\n\r\n#if (neko || php || cpp || macro)\r\n    private typedef UtfX = Utf8;\r\n#elseif python\r\n    private typedef UtfX = Utf32;\r\n#else\r\n    private typedef UtfX = Utf16;\r\n#end\r\n\r\n/**\r\n   InternalEncoding provides primitive API to deal with strings across\r\n   all platforms. You should consider adopting Unifill before this.\r\n **/\r\nclass InternalEncoding {\r\n\r\n    /**\r\n       Returns Encoding strings on the platform are encoded in.\r\n     **/\r\n    public static var internalEncoding(get, never) : String;\r\n\r\n    static inline function get_internalEncoding() : String\r\n    #if (neko || php || cpp || macro)\r\n        return \"UTF-8\";\r\n    #elseif python\r\n        return \"UTF-32\";\r\n    #else\r\n        return \"UTF-16\";\r\n    #end\r\n\r\n    /**\r\n       Returns the UTF-8/16/32 code unit at position `index` of\r\n       String `s`.\r\n     **/\r\n    public static inline function codeUnitAt(s : String, index : Int) : Int {\r\n        var u = UtfX.fromString(s);\r\n        return u.codeUnitAt(index);\r\n    }\r\n\r\n    /**\r\n       Returns the Unicode code point at position `index` of\r\n       String `s`.\r\n     **/\r\n    public static inline function codePointAt(s : String, index : Int) : Int {\r\n        var u = UtfX.fromString(s);\r\n        return u.codePointAt(index);\r\n    }\r\n\r\n    /**\r\n       Returns the character as a String at position `index` of\r\n       String `s`.\r\n     **/\r\n    public static inline function charAt(s : String, index : Int) : String {\r\n        var u = UtfX.fromString(s);\r\n        return u.charAt(index).toString();\r\n    }\r\n\r\n    /**\r\n       Returns the number of Unicode code points from `beginIndex`\r\n       to `endIndex` in String `s`.\r\n     **/\r\n    public static inline function codePointCount(s : String, beginIndex : Int, endIndex : Int) : Int {\r\n        var u = UtfX.fromString(s);\r\n        return u.codePointCount(beginIndex, endIndex);\r\n    }\r\n\r\n    /**\r\n       Returns the number of units of the code point at position\r\n       `index` of String `s`.\r\n     **/\r\n    public static inline function codePointWidthAt(s : String, index : Int) : Int {\r\n        var u = UtfX.fromString(s);\r\n        return u.codePointWidthAt(index);\r\n    }\r\n\r\n    /**\r\n       Returns the number of units of the code point before\r\n       position `index` of String `s`.\r\n     **/\r\n    public static inline function codePointWidthBefore(s : String, index : Int) : Int {\r\n        var u = UtfX.fromString(s);\r\n        return u.codePointWidthBefore(index);\r\n    }\r\n\r\n    /**\r\n       Returns the index within String `s` that is offset from\r\n       position `index` by `codePointOffset` code points.\r\n     **/\r\n    public static inline function offsetByCodePoints(s : String, index : Int, codePointOffset : Int) : Int {\r\n        var u = UtfX.fromString(s);\r\n        return u.offsetByCodePoints(index, codePointOffset);\r\n    }\r\n\r\n    /**\r\n       Returns the index within String `s` that is offset from\r\n       position `index` by `codePointOffset` code points counting\r\n       backward.\r\n     **/\r\n    public static inline function backwardOffsetByCodePoints(s : String, index : Int, codePointOffset : Int) : Int {\r\n        var u = UtfX.fromString(s);\r\n        return u.offsetByCodePoints(index, -codePointOffset);\r\n    }\r\n\r\n    /**\r\n       Converts the code point `code` to a character as String.\r\n     **/\r\n    public static inline function fromCodePoint(codePoint : Int) : String {\r\n        return UtfX.fromCodePoint(codePoint).toString();\r\n    }\r\n\r\n    /**\r\n       Converts `codePoints` to a String.\r\n     **/\r\n    public static inline function fromCodePoints(codePoints : Iterable<Int>) : String {\r\n        return UtfX.fromCodePoints(codePoints).toString();\r\n    }\r\n\r\n    /**\r\n       Validates String `s`.\r\n\r\n       If the code unit sequence of `s` is invalid,\r\n       `Exception.InvalidCodeUnitSequence` is throwed.\r\n     **/\r\n    public static inline function validate(s : String) : Void {\r\n        var u = UtfX.fromString(s);\r\n        u.validate();\r\n    }\r\n\r\n    /**\r\n       Returns if String `s` is valid.\r\n     **/\r\n    public static function isValidString(s : String) : Bool {\r\n        try {\r\n            validate(s);\r\n            return true;\r\n        } catch (e : Exception) {\r\n            switch (e) {\r\n            case InvalidCodeUnitSequence(index):\r\n                return false;\r\n            default:\r\n                throw e;\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n","package luxe.utils.unifill;\r\n\r\nclass InternalEncodingIter {\r\n\r\n    public var string : String;\r\n    public var index : Int;\r\n    public var endIndex : Int;\r\n\r\n    public inline function new(s : String, beginIndex : Int, endIndex : Int) {\r\n        string = s;\r\n        this.index = beginIndex;\r\n        this.endIndex = endIndex;\r\n    }\r\n\r\n    public inline function hasNext() : Bool {\r\n        return index < endIndex;\r\n    }\r\n\r\n    public inline function next() : Int {\r\n        var i = index;\r\n        index += InternalEncoding.codePointWidthAt(string, index);\r\n        return i;\r\n    }\r\n\r\n}\r\n","package luxe.utils.unifill;\r\n\r\nclass Unicode {\r\n\r\n    public static inline var minCodePoint : Int = 0x0000;\r\n    public static inline var maxCodePoint : Int = 0x10FFFF;\r\n    public static inline var minHighSurrogate : Int = 0xD800;\r\n    public static inline var maxHighSurrogate : Int = 0xDBFF;\r\n    public static inline var minLowSurrogate : Int = 0xDC00;\r\n    public static inline var maxLowSurrogate : Int = 0xDFFF;\r\n\r\n    public static inline function decodeSurrogate(hi : Int, lo : Int) : Int\r\n        return (hi - 0xD7C0 << 10) | (lo & 0x3FF);\r\n\r\n    public static inline function encodeHighSurrogate(c : Int) : Int\r\n        return (c >> 10) + 0xD7C0;\r\n\r\n    public static inline function encodeLowSurrogate(c : Int) : Int\r\n        return (c & 0x3FF) | 0xDC00;\r\n\r\n    public static inline function isScalar(code : Int) : Bool {\r\n        return minCodePoint <= code && code <= maxCodePoint && !isHighSurrogate(code) && !isLowSurrogate(code);\r\n    }\r\n\r\n    public static inline function isHighSurrogate(code : Int) : Bool {\r\n        return minHighSurrogate <= code && code <= maxHighSurrogate;\r\n    }\r\n\r\n    public static inline function isLowSurrogate(code : Int) : Bool {\r\n        return minLowSurrogate <= code && code <= maxLowSurrogate;\r\n    }\r\n\r\n}\r\n","package luxe.utils.unifill;\r\n\r\n/**\r\n   Unifill provides Unicode-code-point-wise methods on Strings. It is\r\n   ideally used with 'using Unifill' and then acts as an extension to\r\n   the String class.\r\n **/\r\nclass Unifill {\r\n\r\n    /**\r\n       Returns the number of Unicode code points of String `s`.\r\n     **/\r\n    public static inline function uLength(s : String) : Int\r\n        return InternalEncoding.codePointCount(s, 0, s.length);\r\n\r\n    /**\r\n       Returns the character at position `index` by code points of String `s`.\r\n     **/\r\n    public static inline function uCharAt(s : String, index : Int) : String {\r\n    #if (neko || php || cpp)\r\n        return InternalEncoding.fromCodePoint(haxe.Utf8.charCodeAt(s, index));\r\n    #else\r\n        var i = InternalEncoding.offsetByCodePoints(s, 0, index);\r\n        return InternalEncoding.charAt(s, i);\r\n    #end\r\n    }\r\n\r\n    /**\r\n       Returns the code point as Int at position `index` by code points of String `s`.\r\n     **/\r\n    public static inline function uCharCodeAt(s : String, index : Int) : Int {\r\n    #if (neko || php || cpp || macro)\r\n        return cast haxe.Utf8.charCodeAt(s, index);\r\n    #else\r\n        var i = InternalEncoding.offsetByCodePoints(s, 0, index);\r\n        return InternalEncoding.codePointAt(s, i);\r\n    #end\r\n    }\r\n\r\n    /**\r\n       Returns the code point at position `index` by code points of String `s`.\r\n     **/\r\n    public static inline function uCodePointAt(s : String, index : Int) : CodePoint {\r\n        return cast uCharCodeAt(s, index);\r\n    }\r\n\r\n    /**\r\n       Returns the position of the leftmost occurence of the str within String `s`.\r\n\r\n       `startIndex` is counted by code points.\r\n     **/\r\n    public static inline function uIndexOf(s : String, value : String, startIndex : Int = 0) : Int {\r\n        var index = s.indexOf(value, InternalEncoding.offsetByCodePoints(s, 0, startIndex));\r\n        return if (index >= 0) InternalEncoding.codePointCount(s, 0, index) else -1;\r\n    }\r\n\r\n    /**\r\n       Returns the position of the rightmost occurence of the str within String `s`.\r\n\r\n       `startIndex` is counted by code points.\r\n     **/\r\n    public static inline function uLastIndexOf(s : String, value : String, ?startIndex) : Int {\r\n        if (startIndex == null)\r\n            startIndex = s.length - 1;\r\n        var index = s.lastIndexOf(value, InternalEncoding.offsetByCodePoints(s, 0, startIndex));\r\n        return if (index >= 0) InternalEncoding.codePointCount(s, 0, index) else -1;\r\n    }\r\n\r\n    /**\r\n       Splits String `s` at each occurence of `delimiter`.\r\n     **/\r\n    public static inline function uSplit(s : String, delimiter : String) : Array<String> {\r\n        return if (delimiter.length == 0) {\r\n            [for (i in new InternalEncodingIter(s, 0, s.length)) InternalEncoding.charAt(s, i)];\r\n        } else {\r\n            s.split(delimiter);\r\n        }\r\n    }\r\n\r\n    /**\r\n       Returns `length` characters of String `s`, starting at position `startIndex`.\r\n\r\n       `startIndex` and `length` are counted by code points.\r\n     **/\r\n    public static inline function uSubstr(s : String, startIndex : Int, ?length : Int) : String {\r\n        var si = InternalEncoding.offsetByCodePoints(s,\r\n            if (startIndex >= 0) 0 else s.length,\r\n            startIndex);\r\n        var ei = if (length == null) s.length\r\n            else if (length < 0) si\r\n            else InternalEncoding.offsetByCodePoints(s, si, length);\r\n        return s.substring(si, ei);\r\n    }\r\n\r\n    /**\r\n       Returns the part of String `s` from `startIndex` to `endIndex`.\r\n\r\n       `startIndex` and `endIndex` are counted by code points.\r\n     **/\r\n    public static inline function uSubstring(s : String, startIndex : Int, ?endIndex : Int) : String {\r\n        var si = if (startIndex < 0) 0\r\n            else InternalEncoding.offsetByCodePoints(s, 0, startIndex);\r\n        var ei = if (endIndex == null) s.length\r\n            else if (endIndex < 0) 0\r\n            else InternalEncoding.offsetByCodePoints(s, 0, endIndex);\r\n        return s.substring(si, ei);\r\n    }\r\n\r\n    /**\r\n       Returns an iterator of the code points of String `s`.\r\n     **/\r\n    public static inline function uIterator(s : String) : Iterator<CodePoint> {\r\n        return new CodePointIter(s);\r\n    }\r\n\r\n    /**\r\n       Compares String `a` and `b`.\r\n     **/\r\n    public static function uCompare(a : String, b : String) : Int {\r\n        var aiter = new InternalEncodingIter(a, 0, a.length);\r\n        var biter = new InternalEncodingIter(b, 0, b.length);\r\n        while (aiter.hasNext() && biter.hasNext()) {\r\n            var acode = InternalEncoding.codePointAt(a, aiter.next());\r\n            var bcode = InternalEncoding.codePointAt(b, biter.next());\r\n            if (acode < bcode)\r\n                return -1;\r\n            if (acode > bcode)\r\n                return 1;\r\n        }\r\n        if (biter.hasNext())\r\n            return -1;\r\n        if (aiter.hasNext())\r\n            return 1;\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n       Converts `codePoints` to string.\r\n     **/\r\n    public static inline function uToString(codePoints : Iterable<CodePoint>) : String\r\n        return InternalEncoding.fromCodePoints(cast codePoints);\r\n\r\n}\r\n","package luxe.utils.unifill;\r\n\r\nclass Utf16 implements Utf {\r\n\r\n    /**\r\n       Converts the code point `code` to a character as a Utf16 string.\r\n    **/\r\n    public static inline function fromCodePoint(codePoint : Int) : Utf16 {\r\n        var buf = new StringU16Buffer();\r\n        Utf16Impl.encode_code_point(function (x) buf.addUnit(x), codePoint);\r\n        return new Utf16(buf.getStringU16());\r\n    }\r\n\r\n    /**\r\n       Converts `codePoints` to a Utf16 string.\r\n    **/\r\n    public static inline function fromCodePoints(codePoints : Iterable<Int>) : Utf16 {\r\n        var buf = new StringU16Buffer();\r\n        for (c in codePoints) {\r\n            Utf16Impl.encode_code_point(function (x) buf.addUnit(x), c);\r\n        }\r\n        return new Utf16(buf.getStringU16());\r\n    }\r\n\r\n    public static inline function fromString(s : String) : Utf16 {\r\n        return new Utf16(StringU16.fromString(s));\r\n    }\r\n\r\n    public static inline function fromArray(a : Array<Int>) : Utf16 {\r\n        return new Utf16(StringU16.fromArray(a));\r\n    }\r\n\r\n    public var length(get, never) : Int;\r\n\r\n    /**\r\n       Returns the UTF-16 code unit at position `index` of `this`.\r\n    **/\r\n    public inline function codeUnitAt(index : Int) : Int {\r\n        return this.str.codeUnitAt(index);\r\n    }\r\n\r\n    /**\r\n       Returns the Unicode code point at position `index` of\r\n       `this`.\r\n    **/\r\n    public function codePointAt(index : Int) : Int {\r\n        return Utf16Impl.decode_code_point(length, codeUnitAt, index);\r\n    }\r\n\r\n    /**\r\n       Returns the character as a String at position `index` of\r\n       `this`.\r\n    **/\r\n    public inline function charAt(index : Int) : Utf16 {\r\n        return new Utf16(this.str.substr(index, codePointWidthAt(index)));\r\n    }\r\n\r\n    /**\r\n       Returns the number of Unicode code points from `beginIndex`\r\n       to `endIndex` in `this`.\r\n    **/\r\n    public function codePointCount(beginIndex : Int, endIndex : Int) : Int {\r\n        var index = beginIndex;\r\n        var i = 0;\r\n        while (index < endIndex) {\r\n            index += codePointWidthAt(index);\r\n            ++i;\r\n        }\r\n        return i;\r\n    }\r\n\r\n    /**\r\n       Returns the number of units of the code point at position\r\n       `index` of `this`.\r\n    **/\r\n    public inline function codePointWidthAt(index : Int) : Int {\r\n        var c = codeUnitAt(index);\r\n        return Utf16Impl.code_point_width(c);\r\n    }\r\n\r\n    /**\r\n       Returns the number of units of the code point before\r\n       position `index` of `this`.\r\n    **/\r\n    public inline function codePointWidthBefore(index : Int) : Int {\r\n        return Utf16Impl.find_prev_code_point(codeUnitAt, index);\r\n    }\r\n\r\n    /**\r\n       Returns the index within `this` that is offset from\r\n       position `index` by `codePointOffset` code points.\r\n    **/\r\n    public inline function offsetByCodePoints(index : Int, codePointOffset : Int) : Int {\r\n        return if (codePointOffset >= 0) {\r\n            forward_offset_by_code_points(index, codePointOffset);\r\n        } else {\r\n            backward_offset_by_code_points(index, -codePointOffset);\r\n        }\r\n    }\r\n\r\n    /**\r\n       Returns `len` code units of `this`, starting at position pos.\r\n    **/\r\n    public inline function substr(index : Int, ?len : Int) : Utf16 {\r\n        return new Utf16(this.str.substr(index, len));\r\n    }\r\n\r\n    /**\r\n       Validates `this` Utf16 string.\r\n\r\n       If the code unit sequence of `this` is invalid,\r\n       `Exception.InvalidCodeUnitSequence` is throwed.\r\n    **/\r\n    public function validate() : Void {\r\n        var len = this.str.length;\r\n        var accessor = codeUnitAt;\r\n        var i = 0;\r\n        while  (i < len) {\r\n            Utf16Impl.decode_code_point(len, accessor, i);\r\n            i += codePointWidthAt(i);\r\n        }\r\n    }\r\n\r\n    public inline function toString() : String {\r\n        return this.str.toString();\r\n    }\r\n\r\n    public inline function toArray() : Array<Int> {\r\n        return this.str.toArray();\r\n    }\r\n\r\n    var str : StringU16;\r\n\r\n    inline function new(s : StringU16) {\r\n        this.str = s;\r\n    }\r\n\r\n    inline function get_length() : Int {\r\n        return this.str.length;\r\n    }\r\n\r\n    inline function forward_offset_by_code_points(index : Int, codePointOffset : Int) : Int {\r\n        var len = this.str.length;\r\n        var i = 0;\r\n        while (i < codePointOffset && index < len) {\r\n            index += codePointWidthAt(index);\r\n            ++i;\r\n        }\r\n        return index;\r\n    }\r\n\r\n    inline function backward_offset_by_code_points(index : Int, codePointOffset : Int) : Int {\r\n        var count = 0;\r\n        while (count < codePointOffset && 0 < index) {\r\n            index -= codePointWidthBefore(index);\r\n            ++count;\r\n        }\r\n        return index;\r\n    }\r\n\r\n}\r\n\r\nprivate class Utf16Impl {\r\n\r\n    public static inline function code_point_width(c : Int) : Int {\r\n        return (!Unicode.isHighSurrogate(c)) ? 1 : 2;\r\n    }\r\n\r\n    public static inline function find_prev_code_point(accessor : Int -> Int, index : Int) : Int {\r\n        var c = accessor(index - 1);\r\n        return (!Unicode.isLowSurrogate(c)) ? 1 : 2;\r\n    }\r\n\r\n    public static function encode_code_point(addUnit : Int -> Void, codePoint : Int) : Void {\r\n        if (codePoint <= 0xFFFF) {\r\n            addUnit(codePoint);\r\n        } else {\r\n            addUnit(Unicode.encodeHighSurrogate(codePoint));\r\n            addUnit(Unicode.encodeLowSurrogate(codePoint));\r\n        }\r\n    }\r\n\r\n    public static function decode_code_point(len : Int, accessor : Int -> Int, index : Int) : Int {\r\n        if (index < 0 || len <= index)\r\n            throw Exception.InvalidCodeUnitSequence(index);\r\n        var hi = accessor(index);\r\n        if (Unicode.isHighSurrogate(hi)) {\r\n            if (index + 1 < 0 || len <= index + 1) {\r\n                throw Exception.InvalidCodeUnitSequence(index);\r\n            }\r\n            var lo = accessor(index + 1);\r\n            if (Unicode.isLowSurrogate(lo)) {\r\n                return Unicode.decodeSurrogate(hi, lo);\r\n            } else {\r\n                throw Exception.InvalidCodeUnitSequence(index);\r\n            }\r\n        } else if (Unicode.isLowSurrogate(hi)) {\r\n            throw Exception.InvalidCodeUnitSequence(index);\r\n        } else {\r\n            return hi;\r\n        }\r\n    }\r\n\r\n}\r\n\r\n#if !(neko || php || cpp || macro || python)\r\n\r\nprivate abstract StringU16Buffer(StringBuf) {\r\n\r\n    public inline function new() {\r\n        this = new StringBuf();\r\n    }\r\n\r\n    public inline function addUnit(unit : Int) : Void {\r\n        this.addChar(unit);\r\n    }\r\n\r\n    public inline function getStringU16() : StringU16 {\r\n        return StringU16.fromString(this.toString());\r\n    }\r\n\r\n}\r\n\r\nprivate abstract StringU16(String) {\r\n\r\n    public static inline function fromString(s : String) : StringU16 {\r\n        return new StringU16(s);\r\n    }\r\n\r\n    public static inline function ofArray(a : Array<Int>) : StringU16 {\r\n        return fromArray(a);\r\n    }\r\n\r\n    public static inline function fromArray(a : Array<Int>) : StringU16 {\r\n        var buf = new StringBuf();\r\n        for (x in a) {\r\n            buf.addChar(x);\r\n        }\r\n        return new StringU16(buf.toString());\r\n    }\r\n\r\n    public var length(get, never) : Int;\r\n\r\n    public #if !flash inline #end function codeUnitAt(index : Int) : Int {\r\n        return StringTools.fastCodeAt(this, index);\r\n    }\r\n\r\n    public inline function substr(index : Int, ?len : Int) : StringU16 {\r\n        return new StringU16(this.substr(index, len));\r\n    }\r\n\r\n    public inline function toString() : String {\r\n        return this;\r\n    }\r\n\r\n    public inline function toArray() : Array<Int> {\r\n        var i = 0;\r\n        var len = this.length;\r\n        return [while (i < len) StringTools.fastCodeAt(this, i++)];\r\n    }\r\n\r\n    inline function new(s : String) {\r\n        this = s;\r\n    }\r\n\r\n    inline function get_length() : Int {\r\n        return this.length;\r\n    }\r\n\r\n}\r\n\r\n#else\r\n\r\nprivate abstract StringU16Buffer(Array<Int>) {\r\n\r\n    public inline function new() {\r\n        this = [];\r\n    }\r\n\r\n    public inline function addUnit(unit : Int) : Void {\r\n        this.push(unit);\r\n    }\r\n\r\n    public inline function getStringU16() : StringU16 {\r\n        return StringU16.ofArray(this);\r\n    }\r\n\r\n}\r\n\r\nprivate abstract StringU16(Array<Int>) {\r\n\r\n    public static function fromString(s : String) : StringU16 {\r\n        var buf = new StringU16Buffer();\r\n        var addUnit = function (x) buf.addUnit(x);\r\n        for (i in new InternalEncodingIter(s, 0, s.length)) {\r\n            var c = InternalEncoding.codePointAt(s, i);\r\n            Utf16Impl.encode_code_point(addUnit, c);\r\n        }\r\n        return buf.getStringU16();\r\n    }\r\n\r\n    public static inline function ofArray(a : Array<Int>) : StringU16 {\r\n        return new StringU16(a);\r\n    }\r\n\r\n    public static inline function fromArray(a : Array<Int>) : StringU16 {\r\n        return new StringU16(a.copy());\r\n    }\r\n\r\n    public var length(get, never) : Int;\r\n\r\n    public inline function codeUnitAt(index : Int) : Int {\r\n        return this[index];\r\n    }\r\n\r\n    public inline function substr(index : Int, ?len : Int) : StringU16 {\r\n        if (index < 0) {\r\n            index += this.length;\r\n            if (index < 0) index = 0;\r\n        }\r\n        var j = (len != null) ? index + len : this.length;\r\n        var a = this.slice(index, j);\r\n        return new StringU16(a);\r\n    }\r\n\r\n    public function toString() : String {\r\n        var buf = new StringBuf();\r\n        var i = 0;\r\n        var len = this.length;\r\n        var cua = function (i) return this[i];\r\n        while (i < len) {\r\n            var u = Utf16Impl.decode_code_point(len, cua, i);\r\n            buf.add(InternalEncoding.fromCodePoint(u));\r\n            i += Utf16Impl.code_point_width(codeUnitAt(i));\r\n        }\r\n        return buf.toString();\r\n    }\r\n\r\n    public inline function toArray() : Array<Int> {\r\n        return this.copy();\r\n    }\r\n\r\n    inline function new(a : Array<Int>) {\r\n        this = a;\r\n    }\r\n\r\n    inline function get_length() : Int {\r\n        return this.length;\r\n    }\r\n\r\n}\r\n\r\n#end\r\n","package phoenix;\r\n\r\nimport phoenix.Rectangle;\r\nimport phoenix.Texture;\r\nimport phoenix.Batcher;\r\nimport phoenix.geometry.Geometry;\r\nimport phoenix.geometry.GeometryState;\r\n\r\nimport snow.render.opengl.GL;\r\n\r\nclass BatchState {\r\n\r\n    public var batcher : Batcher;\r\n    public var geom_state :  GeometryState;\r\n    public var last_geom_state : GeometryState;\r\n\r\n    public var last_texture_id : Dynamic;\r\n    public var last_shader_id : Dynamic;\r\n    public var last_group : Int = -1;\r\n    public var is_clipping : Bool;\r\n    public var clip_rect : Rectangle;\r\n    public var last_clip_rect : Rectangle;\r\n\r\n    public var log : Bool = false;\r\n\r\n    public function new(_r:Batcher){\r\n        batcher = _r;\r\n        geom_state = new GeometryState();\r\n        last_geom_state = new GeometryState();\r\n    }\r\n\r\n    public inline function active_shader() : phoenix.Shader {\r\n        if(geom_state.shader != null) {\r\n            return geom_state.shader;\r\n        } else {\r\n            if(geom_state.texture != null) {\r\n                return batcher.renderer.shaders.textured.shader;\r\n            } else {\r\n                return batcher.renderer.shaders.plain.shader;\r\n            }\r\n        }\r\n    }\r\n\r\n    public inline function activate(batcher:Batcher) {\r\n\r\n            // Handle texture state changes\r\n        if(geom_state.dirty) {\r\n\r\n            if(geom_state.texture != null) {\r\n\r\n                if(last_texture_id == null) {\r\n\r\n                }\r\n\r\n                if(last_texture_id != geom_state.texture.id){\r\n\r\n                    last_texture_id = geom_state.texture.id;\r\n                    if(geom_state.texture.loaded) {\r\n                        geom_state.texture.bind();\r\n                        geom_state.texture.activate(batcher.tex0_attribute);\r\n                    }\r\n                }\r\n\r\n            } else {\r\n\r\n                Luxe.renderer.state.bindTexture2D(null);\r\n                last_texture_id = null;\r\n\r\n            } //geom_state.texture !=null\r\n\r\n            if(geom_state.shader != null) {\r\n\r\n                if(last_shader_id != geom_state.shader.program) {\r\n                        //activate it and store the reference to it\r\n                    batcher.shader_activate(geom_state.shader);\r\n                    last_shader_id = geom_state.shader.program;\r\n                }\r\n\r\n            } else {\r\n\r\n                    //fallback onto the default shaders\r\n                if(geom_state.texture != null) {\r\n                        //if there is a texture attached, use the textured shader\r\n                    batcher.shader_activate( batcher.renderer.shaders.textured.shader );\r\n                    last_shader_id = batcher.renderer.shaders.textured.shader.program;\r\n                } else {\r\n                    batcher.shader_activate( batcher.renderer.shaders.plain.shader );\r\n                    last_shader_id = batcher.renderer.shaders.plain.shader.program;\r\n                }\r\n\r\n            }\r\n\r\n\r\n                // Handle group state changes\r\n            if(geom_state.group != last_group) {\r\n                // trace(\"group state change \" + last_group + ' -> ' + geom_state.group  );\r\n\r\n                // finalize the previous group.\r\n                var previous = batcher.groups.get(last_group);\r\n                if(previous != null) {\r\n                    // trace('\\t--post render for ' + last_group );\r\n                    for(_batch_group in previous) {\r\n                        if(_batch_group.post_render != null) _batch_group.post_render(batcher);\r\n                    } //for batch_group in previous\r\n                } //is there?\r\n\r\n\r\n                // activate the current group.\r\n                var current = batcher.groups.get(geom_state.group);\r\n                if(current != null) {\r\n                    // trace('\\t--pre render for ' + geom_state.group);\r\n                    for(_batch_group in current) {\r\n                        if(_batch_group.pre_render != null) _batch_group.pre_render(batcher);\r\n                    }\r\n                } //is there?\r\n\r\n                last_group = geom_state.group;\r\n            }\r\n\r\n        } //state.dirty\r\n\r\n            // excluded from isDirty because rect can change every time without the state being dirty */\r\n            // Handle clipping state changes\r\n\r\n            if(geom_state.clip){\r\n\r\n                if( !is_clipping ){\r\n                    GL.enable( GL.SCISSOR_TEST );\r\n                    is_clipping = true;\r\n                }\r\n\r\n                    // update scissor test if needed.\r\n                if(clip_rect != null) {\r\n\r\n                    if(!clip_rect.equal(last_clip_rect)) {\r\n\r\n                            // translate from top-left coords to bottom-left cords\r\n                        var _y = batcher.view.viewport.h - (clip_rect.y + clip_rect.h);\r\n                            // set the scissor rect\r\n                        GL.scissor( Std.int(clip_rect.x) , Std.int(_y), Std.int(clip_rect.w), Std.int(clip_rect.h) );\r\n\r\n                    } //last clip_rect\r\n\r\n                } //clip_rect\r\n\r\n            } else { //clip is false\r\n\r\n                if( is_clipping ){\r\n                    GL.disable( GL.SCISSOR_TEST );\r\n                    is_clipping = false;\r\n                }\r\n\r\n            } //clip is off\r\n\r\n            // finally, mark the state as clean.\r\n        geom_state.clean();\r\n    }\r\n\r\n    public function deactivate(batcher:Batcher) {\r\n\r\n        if(last_texture_id != null) {\r\n                //undo any textures we bound last\r\n            Luxe.renderer.state.bindTexture2D(null);\r\n        }\r\n\r\n            //for now we just disable any shader because other\r\n            //batchers are not aware of us yet.\r\n        Luxe.renderer.state.useProgram(null);\r\n\r\n        var previous = batcher.groups.get(last_group);\r\n        if(previous != null) {\r\n            // trace('\\t--post render for '+ last_group);\r\n            for(_batch_group in previous) {\r\n                if(_batch_group.post_render != null) _batch_group.post_render(batcher);\r\n            }\r\n        }\r\n        // remove clipping\r\n        if( is_clipping ) GL.disable( GL.SCISSOR_TEST );\r\n    }\r\n\r\n    public function update( geom:Geometry ) : Bool {\r\n\r\n        geom_state.clone_onto( last_geom_state );\r\n        geom_state.update(geom.state);\r\n\r\n        if(geom_state.clip){\r\n            last_clip_rect = clip_rect;\r\n            clip_rect = geom.clip_rect;\r\n        }\r\n\r\n        return geom_state.dirty || (last_clip_rect != clip_rect);\r\n    }\r\n\r\n\r\n//noisy debug stuff\r\n    public function str() {\r\n\r\n        if(!log) return;\r\n\r\n        trace('\\t+ BATCHSTATE LAST ');\r\n            trace(\"\\t\\tdepth - \"+last_geom_state.depth);\r\n            trace(\"\\t\\tgroup - \"+last_geom_state.group);\r\n            trace(\"\\t\\ttexture - \" + (( last_geom_state.texture == null) ? 'null' :  last_geom_state.texture.id ));\r\n            if(last_geom_state.texture != null) {\r\n                trace(\"\\t\\t\\t \" + last_geom_state.texture.texture);\r\n            }\r\n            trace(\"\\t\\tshader - \" + (( last_geom_state.shader == null) ? 'null' :  last_geom_state.shader.id ));\r\n            trace(\"\\t\\tprimitive_type - \"+last_geom_state.primitive_type);\r\n            trace(\"\\t\\tclip - \"+last_geom_state.clip);\r\n        trace('\\t- BATCHSTATE LAST');\r\n\r\n        trace('\\t+ BATCHSTATE STATE');\r\n            trace(\"\\t\\tdepth - \"+geom_state.depth);\r\n            trace(\"\\t\\tgroup - \"+geom_state.group);\r\n            trace(\"\\t\\ttexture - \" + (( geom_state.texture == null) ? 'null' :  geom_state.texture.id ));\r\n            if(geom_state.texture != null) {\r\n                trace(\"\\t\\t\\t \" + geom_state.texture.texture);\r\n            }\r\n            trace(\"\\t\\tshader - \" + (( geom_state.shader == null) ? 'null' :  geom_state.shader.id ));\r\n            trace(\"\\t\\tprimitive_type - \"+geom_state.primitive_type);\r\n            trace(\"\\t\\tclip - \"+geom_state.clip);\r\n        trace('\\t- BATCHSTATE STATE');\r\n    }\r\n\r\n}","package phoenix;\r\n\r\nimport phoenix.geometry.Geometry;\r\nimport phoenix.geometry.GeometryState;\r\nimport phoenix.geometry.Vertex;\r\nimport phoenix.Renderer;\r\nimport phoenix.BatchState;\r\n\r\nimport snow.render.opengl.GL;\r\nimport snow.io.typedarray.Float32Array;\r\n\r\nimport luxe.structural.BalancedBST;\r\n\r\nimport luxe.Log.log;\r\nimport luxe.Log._debug;\r\n\r\n@:enum abstract PrimitiveType(Int) from Int to Int {\r\n\r\n    var unknown         = -1;\r\n    var line_strip      = GL.LINE_STRIP;\r\n    var line_loop       = GL.LINE_LOOP;\r\n    var lines           = GL.LINES;\r\n    var triangle_strip  = GL.TRIANGLE_STRIP;\r\n    var triangles       = GL.TRIANGLES;\r\n    var triangle_fan    = GL.TRIANGLE_FAN;\r\n    var points          = GL.POINTS;\r\n\r\n} //PrimitiveType\r\n\r\n@:enum abstract BlendMode(Int) from Int to Int {\r\n\r\n    var zero                    = GL.ZERO;\r\n    var one                     = GL.ONE;\r\n    var src_color               = GL.SRC_COLOR;\r\n    var one_minus_src_color     = GL.ONE_MINUS_SRC_COLOR;\r\n    var src_alpha               = GL.SRC_ALPHA;\r\n    var one_minus_src_alpha     = GL.ONE_MINUS_SRC_ALPHA;\r\n    var dst_alpha               = GL.DST_ALPHA;\r\n    var one_minus_dst_alpha     = GL.ONE_MINUS_DST_ALPHA;\r\n    var dst_color               = GL.DST_COLOR;\r\n    var one_minus_dst_color     = GL.ONE_MINUS_DST_COLOR;\r\n    var src_alpha_saturate      = GL.SRC_ALPHA_SATURATE;\r\n\r\n} //BlendMode\r\n\r\n@:enum abstract BlendEquation(Int) from Int to Int {\r\n\r\n    var add                    = GL.FUNC_ADD;\r\n    var subtract               = GL.FUNC_SUBTRACT;\r\n    var reverse_subtract       = GL.FUNC_REVERSE_SUBTRACT;\r\n\r\n} //BlendEquation\r\n\r\nclass BatchGroup {\r\n    public function new(_pre, _post) {\r\n        pre_render = _pre;\r\n        post_render = _post;\r\n    }\r\n    public var pre_render : Batcher -> Void;\r\n    public var post_render : Batcher -> Void;\r\n}\r\n\r\nclass Batcher {\r\n\r\n    public var id : String;\r\n    @:isVar public var layer (default, set) : Int = 0;\r\n    public var enabled : Bool = true;\r\n\r\n    public var geometry : BalancedBST< GeometryKey, Geometry >;\r\n    public var groups : Map<Int, Array<BatchGroup> >;\r\n    public var tree_changed : Bool = false;\r\n\r\n    public var vertlist     : Float32Array;\r\n    public var tcoordlist   : Float32Array;\r\n    public var colorlist    : Float32Array;\r\n    public var normallist   : Float32Array;\r\n\r\n    public var static_vertlist : Float32Array;\r\n    public var static_tcoordlist : Float32Array;\r\n    public var static_colorlist : Float32Array;\r\n    public var static_normallist : Float32Array;\r\n\r\n        //The current indexes into the memory buffers\r\n    public var vert_floats    : Int = 0;\r\n    public var tcoord_floats  : Int = 0;\r\n    public var color_floats   : Int = 0;\r\n    public var normal_floats  : Int = 0;\r\n\r\n        //The current indexes into the memory buffers\r\n    public var static_vert_floats    : Int = 0;\r\n    public var static_tcoord_floats  : Int = 0;\r\n    public var static_color_floats   : Int = 0;\r\n    public var static_normal_floats  : Int = 0;\r\n\r\n        //the current number of active buffers in the ring\r\n    public var buffer_count : Int = 2;\r\n\r\n        //the index we are on\r\n    public var buffer_index : Int = 0;\r\n    public var max_verts : Int = 0;\r\n    public var max_floats : Int = 0;\r\n    public var vert_count : Int = 0;\r\n\r\n    public var vertexBuffers : Array<GLBuffer>;\r\n    public var tcoordBuffers : Array<GLBuffer>;\r\n    public var vcolorBuffers : Array<GLBuffer>;\r\n    // public var normalBuffers : Array<GLBuffer>;\r\n\r\n    public var projectionmatrix_attribute : GLUniformLocation;\r\n    public var modelviewmatrix_attribute : GLUniformLocation;\r\n\r\n    public var vert_attribute   : Int = 0;\r\n    public var tcoord_attribute : Int = 1;\r\n    public var color_attribute  : Int = 2;\r\n    // public var normal_attribute : Int = 3;\r\n\r\n    public var tex0_attribute : GLUniformLocation;\r\n    public var tex1_attribute : GLUniformLocation;\r\n    public var tex2_attribute : GLUniformLocation;\r\n    public var tex3_attribute : GLUniformLocation;\r\n    public var tex4_attribute : GLUniformLocation;\r\n    public var tex5_attribute : GLUniformLocation;\r\n    public var tex6_attribute : GLUniformLocation;\r\n    public var tex7_attribute : GLUniformLocation;\r\n\r\n    public var renderer : Renderer;\r\n    public var view : Camera;\r\n\r\n    public var draw_calls : Int = 0;\r\n    public var dynamic_batched_count : Int = 0;\r\n    public var static_batched_count : Int = 0;\r\n    public var visible_count : Int = 0;\r\n\r\n    public var log : Bool = false;\r\n    public var name : String = '';\r\n\r\n        //This is a failsafe against identical layer values\r\n        //being sorted differently by target etc. Not reset intentionally.\r\n    static var _sequence_key : Int = -1;\r\n    @:noCompletion public var sequence : Int = -1;\r\n\r\n    public function new( _r : Renderer, ?_name:String = '' ) {\r\n\r\n        id = Luxe.utils.uniqueid();\r\n        renderer = _r;\r\n        sequence = ++_sequence_key;\r\n\r\n        geometry = new BalancedBST<GeometryKey,Geometry>( geometry_compare );\r\n        groups = new Map();\r\n\r\n        max_verts = Std.int(Math.pow(2, 15));\r\n            //4 floats per vert, i.e x y z w\r\n        max_floats = max_verts * 4;\r\n\r\n            //these are expecting elements in floats, so each vert etc has 4 floats\r\n        vertlist = new Float32Array( max_floats );\r\n        tcoordlist = new Float32Array( max_floats );\r\n        colorlist = new Float32Array( max_floats );\r\n        // normallist = new Float32Array( max_floats );\r\n\r\n        static_vertlist = new Float32Array( max_floats );\r\n        static_tcoordlist = new Float32Array( max_floats );\r\n        static_colorlist = new Float32Array( max_floats );\r\n        // static_normallist = new Float32Array( max_floats );\r\n\r\n            //The default view so we see stuff\r\n        view = renderer.camera;\r\n\r\n            //Create the attribute buffers\r\n        vertexBuffers = [];\r\n        tcoordBuffers = [];\r\n        vcolorBuffers = [];\r\n        // normalBuffers = [];\r\n\r\n        for(i in 0 ... buffer_count) {\r\n\r\n            var _vb = GL.createBuffer();\r\n            var _tb = GL.createBuffer();\r\n            var _cb = GL.createBuffer();\r\n            var _nb = GL.createBuffer();\r\n\r\n    //VERTEX\r\n            GL.bindBuffer(GL.ARRAY_BUFFER, _vb);\r\n            GL.bufferData(GL.ARRAY_BUFFER, vertlist, GL.STATIC_DRAW);\r\n    //TCOORD\r\n            GL.bindBuffer(GL.ARRAY_BUFFER, _tb);\r\n            GL.bufferData(GL.ARRAY_BUFFER, tcoordlist, GL.STATIC_DRAW);\r\n    //COLOR\r\n            GL.bindBuffer(GL.ARRAY_BUFFER, _cb);\r\n            GL.bufferData(GL.ARRAY_BUFFER, colorlist, GL.STATIC_DRAW);\r\n    //NORMALS\r\n            // GL.bindBuffer(GL.ARRAY_BUFFER, _nb);\r\n            // GL.bufferData(GL.ARRAY_BUFFER, normallist, GL.STATIC_DRAW);\r\n\r\n            vertexBuffers.push(_vb);\r\n            tcoordBuffers.push(_tb);\r\n            vcolorBuffers.push(_cb);\r\n            // normalBuffers.push(_nb);\r\n\r\n        } //for the total buffer count\r\n\r\n\r\n        GL.enableVertexAttribArray( vert_attribute );\r\n        GL.enableVertexAttribArray( tcoord_attribute );\r\n        GL.enableVertexAttribArray( color_attribute );\r\n        // GL.enableVertexAttribArray( normal_attribute );\r\n\r\n            //A default name\r\n        if(_name.length == 0) {\r\n            name = Luxe.utils.uniqueid();\r\n        } else {\r\n            name = _name;\r\n        }\r\n\r\n    }\r\n\r\n    public function set_layer( _layer:Int ) : Int {\r\n\r\n            //set the value\r\n        layer = _layer;\r\n            //re-sort the list\r\n        renderer.batchers.sort( renderer.sort_batchers );\r\n\r\n            //return value\r\n        return layer;\r\n\r\n    } //set_layer\r\n\r\n    function toString() {\r\n        return \"Batcher(\" + name + \")\";\r\n    }\r\n\r\n        //this sorts the batchers in a list by layer\r\n    public function compare(other:Batcher) {\r\n\r\n        if(layer == other.layer) return 0;\r\n        if(layer < other.layer) return -1;\r\n\r\n        return 1;\r\n\r\n    } //compare\r\n\r\n    public function add_group(_group:Int, ?_pre_render:Batcher->Void, ?_post_render:Batcher->Void ) {\r\n\r\n        if(!groups.exists(_group)) {\r\n            groups.set(_group, new Array<BatchGroup>());\r\n        }\r\n\r\n        groups.get(_group).push( new BatchGroup(_pre_render, _post_render) );\r\n\r\n    } //add_group\r\n\r\n    public function compare_rule_to_string(r:Int) : String {\r\n        switch(r) {\r\n            case 0: {\r\n                return \"same\";\r\n            }\r\n            case 1: {\r\n                return \"depth <\";\r\n            }\r\n            case 2: {\r\n                return \"depth >\";\r\n            }\r\n\r\n            case 3: {\r\n                return \"shader <\";\r\n            }\r\n            case 4: {\r\n                return \"shader >\";\r\n            }\r\n            case 5: {\r\n                return \"shader s._ >\";\r\n            }\r\n            case 6: {\r\n                return \"shader _.s <\";\r\n            }\r\n\r\n            case 7: {\r\n                return \"texture <\";\r\n            }\r\n            case 8: {\r\n                return \"texture >\";\r\n            }\r\n            case 9: {\r\n                return \"texture t._ >\";\r\n            }\r\n            case 10: {\r\n                return \"texture _.t <\";\r\n            }\r\n\r\n            case 11: {\r\n                return \"primitive <\";\r\n            }\r\n            case 12: {\r\n                return \"primitive >\";\r\n            }\r\n            case 13: {\r\n                return \"unclipped\";\r\n            }\r\n            case 14: {\r\n                return \"clipped\";\r\n            }\r\n            case 15: {\r\n                return \"timestamp <\";\r\n            }\r\n            case 16: {\r\n                return \"timestamp >\";\r\n            }\r\n            case 17: {\r\n                return \"timestamp ==\";\r\n            }\r\n            case 18: {\r\n                return \"sequence <\";\r\n            }\r\n            case 19: {\r\n                return \"sequence >\";\r\n            }\r\n            case 20: {\r\n                return \"fallback\";\r\n            }\r\n        }\r\n\r\n        return \"unknown\";\r\n\r\n    }\r\n\r\n    public function compare_rule( a:GeometryKey, b:GeometryKey ) : Int {\r\n\r\n        if(a.uuid == b.uuid)\r\n            { return 0; }\r\n\r\n            //sort by depth first\r\n        if( a.depth < b.depth )\r\n            { return 1; }\r\n        if( a.depth > b.depth )\r\n            { return 2; }\r\n\r\n            //by this point, both group and depth are equal\r\n            //so sort by shader, then texture, then primitive type\r\n\r\n        if(a.shader != null && b.shader != null) {\r\n\r\n                //sort shaders id's by gl id\r\n            if(a.shader.id < b.shader.id)\r\n                { return 3; }\r\n            if(a.shader.id > b.shader.id)\r\n                { return 4; }\r\n\r\n        } else {\r\n            if(a.shader != null && b.shader == null) {\r\n                return 5;\r\n            } else\r\n            if(a.shader == null && b.shader != null) {\r\n                return 6;\r\n            }\r\n        }\r\n\r\n        if(a.texture != null && b.texture != null) {\r\n\r\n                //sort textures id's by gl id\r\n            if(a.texture.id < b.texture.id)\r\n                { return 7; }\r\n            if(a.texture.id > b.texture.id)\r\n                { return 8; }\r\n\r\n        } else {\r\n            if(a.texture != null && b.texture == null) {\r\n                return 9;\r\n            } else\r\n            if(a.texture == null && b.texture != null) {\r\n                return 10;\r\n            }\r\n\r\n        }\r\n\r\n            //same texture and shader, so primitive type\r\n        var a_primitive_index : Int = a.primitive_type;\r\n        var b_primitive_index : Int = b.primitive_type;\r\n\r\n        if( a_primitive_index < b_primitive_index )\r\n            { return 11; }\r\n        if( a_primitive_index > b_primitive_index )\r\n            { return 12; }\r\n\r\n            //if not the same clipping, we want clipped geometry after, and not clipped before\r\n        if(a.clip != b.clip) {\r\n\r\n            if(a.clip == false && b.clip == true) {\r\n                return 13;\r\n            } else\r\n\r\n            if(a.clip == true && b.clip == false) {\r\n                return 14;\r\n            }\r\n\r\n        } //clippin\r\n\r\n            //if all else is indistinguishable,\r\n            //make sure older geometry is before\r\n\r\n        if( a.timestamp < b.timestamp )\r\n            { return 15; }\r\n        if( a.timestamp > b.timestamp )\r\n            { return 16; }\r\n        if( a.timestamp == b.timestamp )\r\n            { return 17; }\r\n\r\n        if( a.sequence < b.sequence )\r\n            { return 18; }\r\n        if( a.sequence > b.sequence )\r\n            { return 19; }\r\n\r\n            //otherwise push down the list because wtf\r\n        return 20;\r\n    }\r\n\r\n    public function geometry_compare( a:GeometryKey, b:GeometryKey ) : Int {\r\n\r\n            //rules :\r\n                //depth\r\n                //shader\r\n                //texture\r\n                //primitive type\r\n                //clipping\r\n                //age\r\n                //sequence/fallback\r\n\r\n            //check equality\r\n        if(a.uuid == b.uuid)\r\n            { return 0; }\r\n\r\n            //sort by depth first\r\n        if( a.depth < b.depth )\r\n            { return -1; }\r\n        if( a.depth > b.depth )\r\n            { return 1; }\r\n\r\n            //by this point, both group and depth are equal\r\n            //so sort by shader, then texture, then primitive type\r\n        if(a.shader != null && b.shader != null) {\r\n\r\n                //sort shaders id's by gl id\r\n            if(a.shader.id < b.shader.id)\r\n                { return -1; }\r\n            if(a.shader.id > b.shader.id)\r\n                { return 1; }\r\n\r\n        } else {\r\n            if(a.shader != null && b.shader == null) {\r\n                return 1;\r\n            } else\r\n            if(a.shader == null && b.shader != null) {\r\n                return -1;\r\n            }\r\n        }\r\n\r\n        if(a.texture != null && b.texture != null) {\r\n\r\n                //sort textures id's by gl id\r\n            if(a.texture.id < b.texture.id)\r\n                { return -1; }\r\n            if(a.texture.id > b.texture.id)\r\n                { return 1; }\r\n\r\n        } else {\r\n            if(a.texture != null && b.texture == null) {\r\n                return 1;\r\n            } else\r\n            if(a.texture == null && b.texture != null) {\r\n                return -1;\r\n            }\r\n        }\r\n\r\n            //same texture and shader, so primitive type\r\n        var a_primitive_index : Int = a.primitive_type;\r\n        var b_primitive_index : Int = b.primitive_type;\r\n\r\n        if( a_primitive_index < b_primitive_index )\r\n            { return -1; }\r\n        if( a_primitive_index > b_primitive_index )\r\n            { return 1; }\r\n\r\n            //if not the same clipping, we want clipped geometry after, and not clipped before\r\n        if(a.clip != b.clip) {\r\n\r\n            if(a.clip == false && b.clip == true) {\r\n                return 1;\r\n            } else\r\n\r\n            if(a.clip == true && b.clip == false) {\r\n                return -1;\r\n            }\r\n\r\n        } //clippin\r\n\r\n            //if all else is indistinguishable,\r\n            //make sure older geometry is before\r\n\r\n        if( a.timestamp < b.timestamp )\r\n            { return -1; }\r\n        if( a.timestamp >= b.timestamp )\r\n            { return 1; }\r\n        if( a.sequence < b.sequence )\r\n            { return -1; }\r\n        if( a.sequence > b.sequence )\r\n            { return 1; }\r\n\r\n            //otherwise push down the list because wtf\r\n        return 1;\r\n\r\n    } //geometry_compare\r\n\r\n    function list_geometry() {\r\n        for(geom in geometry) {\r\n            _debug('\\t   geometry: ' + geom.id + ' / ' + geom.group + ' / ' + geom.depth + ' / ' + geom.uuid );\r\n            _debug('\\t\\t' + geom.key);\r\n        }\r\n    }\r\n\r\n    public function add( _geom:Geometry, _force_add:Bool = false ) {\r\n\r\n        // _debug(\"adding geom to batcher \" + _geom.id + \" at \" + _geom.depth);\r\n        // _debug(\"\\t list before: \");\r\n            // list_geometry();\r\n\r\n        if( geometry.find(_geom.key) == null || _force_add ) {\r\n\r\n                //Only add if not already there\r\n            if( !Lambda.has(_geom.batchers, this) ) {\r\n                _geom.batchers.push(this);\r\n            }\r\n\r\n                //Insert into our list\r\n            geometry.insert( _geom.key, _geom );\r\n\r\n                //Make sure it is flagged\r\n            _geom.added = true;\r\n\r\n                //and this local test flag\r\n            tree_changed = true;\r\n\r\n            // _debug(\"\\t list after: \");\r\n            //     list_geometry();\r\n\r\n        } else {\r\n            // trace(\"Warning : Attempting to add geometry to the same batcher twice. \" + _geom);\r\n        }\r\n\r\n    } //add\r\n\r\n        /** :todo: this is a temporary construct as part of #119 */\r\n    public function empty( _drop:Bool=true ) {\r\n\r\n        if(_drop) {\r\n            for(geom in geometry) {\r\n                geom.drop(true);\r\n                geom = null;\r\n            }\r\n        } else {\r\n            for(geom in geometry) {\r\n                geometry.remove(geom.key);\r\n            }\r\n        }\r\n\r\n    } //empty\r\n\r\n    public function remove( _geom:Geometry, ?_remove_batcher_from_geometry:Bool = true ) {\r\n\r\n        if(_remove_batcher_from_geometry) {\r\n            _geom.batchers.remove(this);\r\n            if(_geom.batchers.length == 0) {\r\n                _geom.added = false;\r\n            }\r\n        } //_remove_batcher_from_geometry\r\n\r\n        var countbefore = geometry.size();\r\n\r\n        geometry.remove( _geom.key );\r\n\r\n        var countafter = geometry.size();\r\n\r\n        if(countbefore == countafter) {\r\n            //:todo: this fail state should never happen but it comes up on web rarely\r\n            // throw(\"GEOMETRY NOT REMOVED \" + _geom.key);\r\n        }\r\n\r\n        tree_changed = true;\r\n\r\n    } //remove\r\n\r\n    public function shader_activate( _shader:Shader ) {\r\n\r\n            //activate (GL.useProgram) the shader\r\n        _shader.activate();\r\n\r\n            //Matrices\r\n        projectionmatrix_attribute  = _shader.projectionmatrix_attribute;\r\n        modelviewmatrix_attribute   = _shader.modelviewmatrix_attribute;\r\n            //Textures\r\n\r\n        tex0_attribute = _shader.tex0_attribute;\r\n        tex1_attribute = _shader.tex1_attribute;\r\n        tex2_attribute = _shader.tex2_attribute;\r\n        tex3_attribute = _shader.tex3_attribute;\r\n        tex4_attribute = _shader.tex4_attribute;\r\n        tex5_attribute = _shader.tex5_attribute;\r\n        tex6_attribute = _shader.tex6_attribute;\r\n        tex7_attribute = _shader.tex7_attribute;\r\n\r\n            //and any uniforms they defined\r\n        _shader.apply_uniforms();\r\n\r\n            //undo any changes to be sure\r\n        Luxe.renderer.state.activeTexture(GL.TEXTURE0);\r\n\r\n    } //shader_activate\r\n\r\n\r\n        //Run the batcher over the current list of geometry\r\n        //and submit it to the graphics card for drawing\r\n    public var state : BatchState;\r\n    public function batch( persist_immediate : Bool = false ) {\r\n\r\n        //reset render stats before we start\r\n        dynamic_batched_count = 0;\r\n        static_batched_count = 0;\r\n        visible_count = 0;\r\n\r\n        vert_floats = 0;\r\n        tcoord_floats = 0;\r\n        color_floats = 0;\r\n        normal_floats = 0;\r\n\r\n            //The current batch state values\r\n        state = new BatchState(this);\r\n            //The current geometry in the set\r\n        var geom : Geometry = null;\r\n\r\n            //For each in the list\r\n        for(_geom in geometry) {\r\n\r\n                //grab the next geometry\r\n            geom = _geom;\r\n\r\n                //If it's valid to be drawn\r\n            if( geom != null && !geom.dropped ) {\r\n\r\n                    //If the update will cause a state change, submit the vertices accumulated\r\n                if( state.update(geom) ) {\r\n\r\n                        //Only submit if there are vertices in our list to draw\r\n                        //but if there are the batch is dirty and needs to be submitted\r\n                    if(vert_floats > 0) {\r\n                        submit_current_vertex_list( state.last_geom_state.primitive_type );\r\n                    } //if vertlist.length > 0\r\n\r\n                } // state.update(geom)\r\n\r\n                    // Now activate state changes (if any)\r\n                state.activate(this);\r\n\r\n                if(geom.visible) {\r\n                        //try\r\n                    visible_count++;\r\n\r\n                        //Static batched geometry gets sent on it's own\r\n                    if(geom.locked) {\r\n                        submit_static_geometry( geom );\r\n                        vert_count += geom.vertices.length;\r\n                    }\r\n\r\n                        // Do not accumulate for tri strips, line strips, line loops, triangle fans, quad strips, or polygons\r\n                    else if( geom.primitive_type == PrimitiveType.line_strip ||\r\n                             geom.primitive_type == PrimitiveType.line_loop ||\r\n                             geom.primitive_type == PrimitiveType.triangle_strip ||\r\n                             geom.primitive_type == PrimitiveType.triangle_fan ) {\r\n\r\n                                // doing this with the same list is fine because the primitive type causes a batch break anyways.\r\n                                // Send it on, this will also clear the list for the next geom so it doesn't acccumlate as usual.\r\n                            geometry_batch(geom);\r\n                                //submit the geometry\r\n                            submit_current_vertex_list( geom.primitive_type );\r\n                                //increase counts\r\n                            vert_count += geom.vertices.length;\r\n\r\n                    } //if it's unbatchable\r\n\r\n                        // Accumulate, this is standard geometry\r\n                    else {\r\n\r\n                        geometry_batch( geom );\r\n\r\n                            //increase counts\r\n                        dynamic_batched_count++;\r\n                        vert_count += geom.vertices.length;\r\n\r\n                    } //standard geometry\r\n\r\n\r\n                        // If the geometry is immediate get rid of it (unless the flag to keep immediate geometry)\r\n                        // in the list was specified...i.e for drawing multiple passes etc\r\n                    if( !persist_immediate && geom.immediate ) {\r\n                        geom.drop();\r\n                    } //!persist_immediate && geom.immediate\r\n\r\n                } //geom.visible\r\n\r\n            } else { //!null && !dropped\r\n                //:todo : If there is null (maybe dropped) geometry shouldn't they be removed or maybe\r\n                //stashed in a diff list? Dropped come from the above drop, but null is invalid state\r\n            }\r\n\r\n        } //geom list\r\n\r\n            //If there is anything left in the vertex buffer, submit it.\r\n        if(vert_floats > 0 && geom != null) {\r\n\r\n                //Make sure the state matches this geometry\r\n            state.update(geom);\r\n                //And the state is active for renderering\r\n            state.activate( this );\r\n                //submit the list for rendering\r\n            submit_current_vertex_list( state.last_geom_state.primitive_type );\r\n\r\n        }\r\n\r\n            //disable any states set by the batches\r\n        state.deactivate(this);\r\n            //cleanup\r\n        state = null;\r\n\r\n    }\r\n\r\n    public function draw( ?persist_immediate:Bool = false ) {\r\n\r\n        //Reset the draw count\r\n        draw_calls = 0;\r\n        vert_count = 0;\r\n\r\n            //update camera if it changes anything\r\n        view.process();\r\n\r\n        // trace('batcher $name / view ${view.name} / viewport:${view.viewport}');\r\n\r\n            //Set the viewport to the view\r\n        renderer.state.viewport( view.viewport.x, view.viewport.y, view.viewport.w, view.viewport.h );\r\n\r\n            //apply geometries\r\n        batch( persist_immediate );\r\n\r\n    } //draw\r\n\r\n    public function submit_static_geometry( geom:Geometry ) {\r\n\r\n            //Don't bother when it's empty\r\n        if( geom.vertices.length == 0 ) {\r\n            return;\r\n        }\r\n\r\n            //and counts\r\n        static_vert_floats = 0; static_tcoord_floats = 0; static_color_floats = 0; \r\n        // static_normal_floats = 0;\r\n\r\n        if(!geom.submitted || geom.dirty) {\r\n\r\n                //now batch the geometry into the static arrays\r\n            geometry_batch_static( geom );\r\n\r\n        } else {\r\n\r\n            static_vert_floats    = geom.vertices.length * 4;\r\n            static_tcoord_floats  = geom.vertices.length * 4;\r\n            static_color_floats   = geom.vertices.length * 4;\r\n            // static_normal_floats  = geom.vertices.length * 4;\r\n\r\n        }\r\n\r\n            //ensure the geometry has buffers already\r\n        if(geom.static_vertex_buffer == null) {\r\n            geom.static_vertex_buffer = GL.createBuffer();\r\n            geom.static_tcoord_buffer = GL.createBuffer();\r\n            geom.static_vcolor_buffer = GL.createBuffer();\r\n            // geom.static_normal_buffer = GL.createBuffer();\r\n        }\r\n\r\n            //enable the shader attributes\r\n        _enable_attributes();\r\n\r\n            //set the vertices positions in the shader, but to static buffers\r\n        GL.bindBuffer(GL.ARRAY_BUFFER, geom.static_vertex_buffer);\r\n        GL.vertexAttribPointer(vert_attribute, 4, GL.FLOAT, false, 0, 0);\r\n\r\n        if(!geom.submitted || geom.dirty) {\r\n            GL.bufferData(GL.ARRAY_BUFFER, static_vertlist, GL.STATIC_DRAW);\r\n        }\r\n\r\n            //set the texture coordinates in the shader, but to static buffers\r\n        GL.bindBuffer(GL.ARRAY_BUFFER, geom.static_tcoord_buffer);\r\n        GL.vertexAttribPointer(tcoord_attribute, 4, GL.FLOAT, false, 0, 0);\r\n\r\n        if(!geom.submitted || geom.dirty) {\r\n            GL.bufferData(GL.ARRAY_BUFFER, static_tcoordlist, GL.STATIC_DRAW);\r\n        }\r\n\r\n            //set the color values in the shader, but to static buffers\r\n        GL.bindBuffer(GL.ARRAY_BUFFER, geom.static_vcolor_buffer);\r\n        GL.vertexAttribPointer(color_attribute, 4, GL.FLOAT, false, 0, 0);\r\n\r\n        if(!geom.submitted || geom.dirty) {\r\n            GL.bufferData(GL.ARRAY_BUFFER, static_colorlist, GL.STATIC_DRAW);\r\n        }\r\n\r\n        //     //set the normal directions in the shader, but to static buffers\r\n        // GL.bindBuffer(GL.ARRAY_BUFFER, geom.static_normal_buffer);\r\n        // GL.vertexAttribPointer(normal_attribute, 4, GL.FLOAT, false, 0, 0);\r\n\r\n        // if(!geom.submitted || geom.dirty) {\r\n        //     GL.bufferData(GL.ARRAY_BUFFER, static_normallist, GL.STATIC_DRAW);\r\n        // }\r\n\r\n            //Draw\r\n        GL.drawArrays(\r\n            geom.primitive_type, 0,\r\n            phoenix.utils.Rendering.get_elements_for_type(geom.primitive_type, static_vert_floats)\r\n        );\r\n\r\n            //Disable attributes\r\n        _disable_attributes();\r\n            //increase the stats\r\n        draw_calls++;\r\n        static_batched_count++;\r\n\r\n            //and counts\r\n        static_vert_floats = 0;\r\n        static_tcoord_floats = 0;\r\n        static_color_floats = 0;\r\n        // static_normal_floats = 0;\r\n\r\n            //clear the geometry flags\r\n        geom.dirty = false;\r\n        geom.submitted = true;\r\n\r\n    } //submit_static_buffer_object\r\n\r\n\r\n    public function submit_current_vertex_list( type : PrimitiveType ) {\r\n\r\n        if( vert_floats == 0 ) {\r\n                //No verts?\r\n            return;\r\n        }\r\n\r\n        if( vert_floats > max_floats ) {\r\n            throw \"uh oh, somehow too many floats are being submitted (max:$max_floats, attempt:$vert_floats).\";\r\n        }\r\n\r\n            //Enable atttributes\r\n        _enable_attributes();\r\n\r\n        GL.bindBuffer(GL.ARRAY_BUFFER, vertexBuffers[buffer_index] );\r\n        GL.vertexAttribPointer( 0, 4, GL.FLOAT, false, 0, 0 );\r\n        GL.bufferSubData( GL.ARRAY_BUFFER , 0, new Float32Array(vertlist.buffer, 0, vert_floats) );\r\n\r\n        GL.bindBuffer(GL.ARRAY_BUFFER, tcoordBuffers[buffer_index] );\r\n        GL.vertexAttribPointer( 1, 4, GL.FLOAT, false, 0, 0 );\r\n        GL.bufferSubData( GL.ARRAY_BUFFER , 0, new Float32Array(tcoordlist.buffer, 0, tcoord_floats) );\r\n\r\n        GL.bindBuffer(GL.ARRAY_BUFFER, vcolorBuffers[buffer_index] );\r\n        GL.vertexAttribPointer( 2, 4, GL.FLOAT, false, 0, 0 );\r\n        GL.bufferSubData( GL.ARRAY_BUFFER , 0, new Float32Array(colorlist.buffer, 0, color_floats) );\r\n\r\n        // GL.bindBuffer(GL.ARRAY_BUFFER, normalBuffers[buffer_index] );\r\n        // GL.vertexAttribPointer( 3, 4, GL.FLOAT, false, 0, 0 );\r\n        // GL.bufferSubData( GL.ARRAY_BUFFER , 0, new Float32Array(normallist.buffer, 0, normal_floats) );\r\n\r\n            //Draw\r\n        GL.drawArrays(\r\n            type, 0,\r\n            phoenix.utils.Rendering.get_elements_for_type(type, vert_floats)\r\n        );\r\n\r\n            //Disable attributes\r\n        _disable_attributes();\r\n\r\n        // cycle the buffers in use\r\n        buffer_index++;\r\n        if(buffer_index >= buffer_count) {\r\n            buffer_index = 0;\r\n        }\r\n\r\n            //Reset counts\r\n        vert_floats = 0; tcoord_floats = 0; color_floats = 0; normal_floats= 0;\r\n            //Increase stats\r\n        draw_calls++;\r\n\r\n    } //submit_current_vertex_list\r\n\r\n//Batch related helper functions\r\n\r\n    function geometry_batch( geom:Geometry ) {\r\n\r\n            //vert_floats is in element count (so/4)\r\n        var _count_after = geom.vertices.length+(vert_floats/4);\r\n\r\n            //submit the current batch if we exceed the max buffer size\r\n        if(_count_after > max_verts) {\r\n            submit_current_vertex_list( geom.primitive_type );\r\n        }\r\n\r\n        geom.batch(\r\n            vert_floats,    tcoord_floats,  color_floats,   normal_floats,\r\n            vertlist,       tcoordlist,     colorlist,      normallist\r\n        );\r\n\r\n        vert_floats      += geom.vertices.length * 4;\r\n        tcoord_floats    += geom.vertices.length * 4;\r\n        color_floats     += geom.vertices.length * 4;\r\n        // normal_floats    += geom.vertices.length * 4;\r\n\r\n    } //geometry_batch\r\n\r\n    function geometry_batch_static( geom:Geometry ) {\r\n\r\n        geom.batch(\r\n            static_vert_floats,     static_tcoord_floats,   static_color_floats,    static_normal_floats,\r\n            static_vertlist,        static_tcoordlist,      static_colorlist,       static_normallist\r\n        );\r\n\r\n        static_vert_floats      += geom.vertices.length * 4;\r\n        static_tcoord_floats    += geom.vertices.length * 4;\r\n        static_color_floats     += geom.vertices.length * 4;\r\n        // static_normal_floats    += geom.vertices.length * 4;\r\n\r\n    } //geometry_batch_static\r\n\r\n//Shader related attribute setup\r\n\r\n    @:noCompletion public function _enable_attributes() {\r\n\r\n            //Update the GL Matrices\r\n        GL.uniformMatrix4fv( projectionmatrix_attribute, false, view.projection_float32array );\r\n        GL.uniformMatrix4fv( modelviewmatrix_attribute, false, view.view_inverse_float32array );\r\n\r\n    } //_enable_attributes\r\n\r\n    function _disable_attributes() {\r\n\r\n            //Unset\r\n\r\n    } //_disable_attributes\r\n\r\n}\r\n","package snow.io.typedarray;\r\n\r\n#if js\r\n\r\n    @:forward\r\n    @:arrayAccess\r\n    abstract Float32Array(js.html.Float32Array)\r\n        from js.html.Float32Array\r\n        to js.html.Float32Array {\r\n\r\n        @:generic\r\n        public inline function new<T>(\r\n            ?elements:Int,\r\n            ?array:Array<T>,\r\n            ?view:ArrayBufferView,\r\n            ?buffer:ArrayBuffer, ?byteoffset:Int = 0, ?len:Null<Int>\r\n        ) {\r\n            if(elements != null) {\r\n                this = new js.html.Float32Array( elements );\r\n            } else if(array != null) {\r\n                this = new js.html.Float32Array( untyped array );\r\n            } else if(view != null) {\r\n                this = new js.html.Float32Array( untyped view );\r\n            } else if(buffer != null) {\r\n                len = (len == null) ? untyped __js__('undefined') : len;\r\n                this = new js.html.Float32Array( buffer, byteoffset, len );\r\n            } else {\r\n                this = null;\r\n            }\r\n        }\r\n\r\n        @:arrayAccess inline function __set(idx:Int, val:Float) return this[idx] = val;\r\n        @:arrayAccess inline function __get(idx:Int) : Float return this[idx];\r\n\r\n\r\n            //non spec haxe conversions\r\n        public static function fromBytes( bytes:haxe.io.Bytes, ?byteOffset:Int=0, ?len:Int ) : Float32Array {\r\n            return new js.html.Float32Array(cast bytes.getData(), byteOffset, len);\r\n        }\r\n\r\n        public function toBytes() : haxe.io.Bytes {\r\n            #if (haxe_ver < 3.2)\r\n                return @:privateAccess new haxe.io.Bytes( this.byteLength, cast new js.html.Uint8Array(this.buffer) );\r\n            #else\r\n                return @:privateAccess new haxe.io.Bytes( cast new js.html.Uint8Array(this.buffer) );\r\n            #end\r\n        }\r\n\r\n    }\r\n\r\n#else\r\n\r\n    import snow.io.typedarray.ArrayBufferView;\r\n    import snow.io.typedarray.TypedArrayType;\r\n\r\n    @:forward()\r\n    @:arrayAccess\r\n    abstract Float32Array(ArrayBufferView) from ArrayBufferView to ArrayBufferView {\r\n\r\n        public inline static var BYTES_PER_ELEMENT : Int = 4;\r\n\r\n        public var length (get, never):Int;\r\n\r\n        @:generic\r\n        public inline function new<T>(\r\n            ?elements:Int,\r\n            ?array:Array<T>,\r\n            ?view:ArrayBufferView,\r\n            ?buffer:ArrayBuffer, ?byteoffset:Int = 0, ?len:Null<Int>\r\n        ) {\r\n\r\n            if(elements != null) {\r\n                this = new ArrayBufferView( elements, Float32 );\r\n            } else if(array != null) {\r\n                this = new ArrayBufferView(0, Float32).initArray(array);\r\n            } else if(view != null) {\r\n                this = new ArrayBufferView(0, Float32).initTypedArray(view);\r\n            } else if(buffer != null) {\r\n                this = new ArrayBufferView(0, Float32).initBuffer(buffer, byteoffset, len);\r\n            } else {\r\n                throw \"Invalid constructor arguments for Float32Array\";\r\n            }\r\n        }\r\n\r\n    //Public API\r\n\r\n        public inline function subarray( begin:Int, end:Null<Int> = null) : Float32Array return this.subarray(begin, end);\r\n\r\n\r\n            //non spec haxe conversions\r\n        public static function fromBytes( bytes:haxe.io.Bytes, ?byteOffset:Int=0, ?len:Int ) : Float32Array {\r\n            return new Float32Array(bytes, byteOffset, len);\r\n        }\r\n\r\n        public function toBytes() : haxe.io.Bytes {\r\n            return this.buffer;\r\n        }\r\n\r\n    //Internal\r\n\r\n        inline function get_length() return this.length;\r\n\r\n\r\n        @:noCompletion\r\n        @:arrayAccess\r\n        public inline function __get(idx:Int) : Float {\r\n            return ArrayBufferIO.getFloat32(this.buffer, this.byteOffset+(idx*BYTES_PER_ELEMENT) );\r\n        }\r\n\r\n        @:noCompletion\r\n        @:arrayAccess\r\n        public inline function __set(idx:Int, val:Float) : Float {\r\n            return ArrayBufferIO.setFloat32(this.buffer, this.byteOffset+(idx*BYTES_PER_ELEMENT), val);\r\n        }\r\n\r\n    }\r\n\r\n#end //!js","package phoenix;\r\n\r\nimport luxe.Vector;\r\nimport luxe.resource.Resource;\r\nimport luxe.resource.Resources;\r\n\r\nimport luxe.options.FontOptions;\r\nimport luxe.options.TextOptions;\r\n\r\nimport phoenix.Batcher;\r\nimport phoenix.BitmapFont.TextAlign;\r\nimport phoenix.geometry.CompositeGeometry;\r\nimport phoenix.geometry.Geometry;\r\nimport phoenix.geometry.QuadGeometry;\r\nimport phoenix.geometry.TextureCoord;\r\nimport phoenix.geometry.Vertex;\r\nimport phoenix.geometry.TextGeometry;\r\nimport phoenix.Rectangle;\r\nimport phoenix.Texture;\r\n\r\nimport luxe.Log.log;\r\nimport luxe.Log._debug;\r\nimport luxe.Log._verbose;\r\n\r\nusing luxe.utils.unifill.Unifill;\r\n\r\n@:enum abstract TextAlign(Int) from Int to Int {\r\n    var left = 0;\r\n    var right = 1;\r\n    var center = 2;\r\n    var top = 3;\r\n    var bottom = 4;\r\n} //TextAlign\r\n\r\ntypedef Character = {\r\n    var id: Int;\r\n    var x: Float;\r\n    var y: Float;\r\n    var width: Float;\r\n    var height: Float;\r\n    var xoffset: Float;\r\n    var yoffset: Float;\r\n    var xadvance: Float;\r\n    var page: Int;\r\n}\r\n\r\n\r\ntypedef FontInfo = {\r\n    var face: String;\r\n    var point_size: Float;\r\n    var base_size: Float;\r\n    var chars: Map<Int, Character>;\r\n    var char_count: Int;\r\n    var pages: Array<{ id : Int, file : String }>;\r\n    var line_height: Float;\r\n    var kernings: Map< Int, Map<Int, Float> >;\r\n}\r\n\r\n\r\nclass BitmapFont extends Resource {\r\n\r\n    public var pages : Map<Int, Texture>;\r\n    public var info : FontInfo;\r\n    public var options : BitmapFontOptions;\r\n\r\n    public var onload : BitmapFont -> Void;\r\n    public var loaded : Bool = false;\r\n\r\n        //cached refrence of the ' '(32)\r\n        //character for sizing on tabs/spaces\r\n    public var space_char: Character;\r\n        //for loading pages and reporting done\r\n    var items_loaded: Int = 0;\r\n    var items_total: Int = 0;\r\n\r\n    static var generic_names : Array<String> = ['font','', ' '];\r\n\r\n    public function new( ?_options:BitmapFontOptions ) {\r\n\r\n        options = if(_options == null) {\r\n                    { id:'font.${Luxe.utils.uniqueid()}' }\r\n                } else {\r\n                    _options;\r\n                }\r\n\r\n        id = options.id;\r\n\r\n        default_options();\r\n\r\n        super( options.resources, ResourceType.font );\r\n\r\n        pages = new Map();\r\n\r\n    } //new\r\n\r\n    //Public api\r\n\r\n            /** Create this bitmap font from the given string data, using the options given in the constructor. \r\n                optional: onload callback and custom texture pages, if already loaded. */\r\n        public function from_string(\r\n            _bitmapfont_data : String,\r\n            ?_onload: BitmapFont->Void ,\r\n            ?_custom_pages: Array<Texture>,\r\n            ?_silent: Bool = false )\r\n        {\r\n\r\n                //store the listener\r\n            if(_onload != null) onload = _onload;\r\n                //parse the file\r\n            info = Parser.parse(_bitmapfont_data);\r\n\r\n                //check validity of the font\r\n            if( info.char_count == 0 || \r\n                (info.pages.length == 0 && _custom_pages.length == 0)\r\n            ) {\r\n                log('error / $id / invalid font data specified for this font, cannot load. This font will not be valid.');\r\n                do_onload( false );\r\n                return;\r\n            }\r\n\r\n                //store cached values\r\n            space_char = info.chars.get(32);\r\n                //load any texture pages\r\n            load_pages(_custom_pages);\r\n\r\n            if(generic_names.indexOf(id) != -1) {\r\n                var _warning = 'warning / font loaded with a generic or no name as \"$id\". ';\r\n                    _warning += 'This could lead to bugs or confusion, or not being able to retrieve the font ';\r\n                    _warning += 'later from the resources.';\r\n                log(_warning);\r\n            }\r\n\r\n        } //from_string\r\n\r\n\r\n            /** Get the kerning between two glyphs, 0 if none.\r\n                A glyph int id is the value from 'c'.charCodeAt(0) */\r\n        public inline function kerning(_first:Int, _second:Int) {\r\n\r\n            var _map = info.kernings.get(_first);\r\n\r\n            if(_map != null && _map.exists(_second)) {\r\n                return _map.get(_second);\r\n            }\r\n\r\n            return 0;\r\n\r\n        } //kerning\r\n\r\n    public function wrap_string_to_bounds( _string:String, _bounds:Rectangle, _point_size:Float=1.0, _letter_spc:Float=0.0 ) : String {\r\n\r\n        if(_bounds == null) {\r\n            return _string;\r\n        }\r\n\r\n        var _cur_x = 0.0; var _idx = 0;\r\n        var _final_str = '';\r\n\r\n        inline function _wordw(_str:String) {\r\n            return width_of(_str, _point_size, _letter_spc);\r\n        }\r\n\r\n        var _spacew = _wordw(' ');\r\n\r\n        inline function _dowrap(_w:Float, _str:String) {\r\n            if(_cur_x + _w > _bounds.w) {\r\n                _cur_x = 0;\r\n                _final_str += '\\n';\r\n            }\r\n\r\n            _cur_x += _w;\r\n            _final_str += _str;\r\n        } //_dowrap\r\n\r\n            var _strings = _string.split(' ');\r\n            var _count = _strings.length;\r\n\r\n            for(_str in _strings) {\r\n                if(_str.uIndexOf('\\n') == -1) {\r\n                    if(_str == '') _str = ' ';\r\n                    _dowrap( _wordw(_str), _str );\r\n                } else {\r\n                    var _widx = 0;\r\n                    var _words = _str.split('\\n');\r\n                    for(_word in _words) {\r\n\r\n                        if(_word != '') {\r\n                            _dowrap( _wordw(_word), _word );\r\n                        } else {\r\n                            _cur_x = 0;\r\n                        }\r\n\r\n                        if(_widx < _words.length-1) {\r\n                            _final_str += '\\n';\r\n                            _cur_x = 0;\r\n                        }\r\n\r\n                        _widx++;\r\n\r\n                    } //each word\r\n                } //no spaces\r\n\r\n                if(_idx < _count-1) {\r\n                    _final_str += ' ';\r\n                    _cur_x += _spacew + _letter_spc;\r\n                }\r\n\r\n                _idx++;\r\n\r\n            } //each word\r\n\r\n        return _final_str;\r\n\r\n    } //wrap_string_to_bounds\r\n\r\n    public function width_of_line( _string:String, _point_size:Float=1.0, _letter_spc:Float=0.0 ) {\r\n\r\n            //current x pos\r\n        var _cur_x = 0.0;\r\n            //current w pos\r\n        var _cur_w = 0.0;\r\n            //the size ratio between font and given size\r\n        var _ratio = _point_size / info.point_size;\r\n\r\n        var i = 0;\r\n        var _len = _string.uLength();\r\n\r\n        for( _uglyph in _string.uIterator() ) {\r\n\r\n            var _index = _uglyph.toInt();\r\n            var _char = info.chars.get(_index);\r\n            if(_char == null) _char = space_char;\r\n\r\n                //some characters (like spaces) have no width but an advance\r\n                //which is relevant/needed\r\n            var _cw = (_char.xoffset + Math.max(_char.width, _char.xadvance)) * _ratio;\r\n            var _cx = _cur_x + (_char.xoffset * _ratio);\r\n\r\n            var _spacing = _char.xadvance;\r\n            if( i < _len-1 ) {\r\n                var _next_index = _string.uCharCodeAt(i+1);\r\n                _spacing += kerning( _index, _next_index );\r\n                if(_next_index >= 32) { _spacing += _letter_spc; }\r\n            }\r\n\r\n            _cur_x += _spacing * _ratio;\r\n            _cur_w = Math.max(_cur_w, _cx+_cw);\r\n\r\n            ++i;\r\n        } //each char\r\n\r\n        return _cur_w;\r\n\r\n    } //width_of_line\r\n\r\n    public inline function width_of( _string:String, _point_size:Float = 1.0, _letter_spc:Float = 0.0, ?_line_widths:Array<Float> ) : Float {\r\n\r\n            //if given an array to cache line widths into\r\n        var _max_w = 0.0;\r\n        var _push_widths = (_line_widths != null);\r\n        var _lines = _string.uSplit('\\n');\r\n\r\n        for(_line in _lines) {\r\n\r\n            var _cur_w = width_of_line(_line, _point_size, _letter_spc);\r\n\r\n            _max_w = Math.max( _max_w, _cur_w );\r\n\r\n            if(_push_widths) {\r\n                _line_widths.push(_cur_w);\r\n            }\r\n\r\n        } //each line\r\n\r\n            //return the max width found\r\n        return _max_w;\r\n\r\n    } //width_of\r\n\r\n    public inline function height_of( _string:String, _point_size:Float, _line_spc:Float=0.0 ) : Float {\r\n\r\n        return height_of_lines(_string.split('\\n'), _point_size, _line_spc);\r\n\r\n    } //height_of\r\n\r\n\r\n        /** Return the dimensions of a given string, at the specified point size.\r\n            You can also use width_of or height_of, this is a convenience for those */\r\n    public inline function dimensions_of( _string:String, _point_size:Float, _into:Vector, _letter_spc:Float=0.0, _line_spc:Float=0.0 ) : Vector {\r\n\r\n        var _width = width_of(_string, _point_size, _letter_spc);\r\n        var _height = height_of(_string, _point_size, _line_spc);\r\n\r\n        return _into.set_xy( _width, _height );\r\n\r\n    } //dimensions\r\n\r\n    //Public static api\r\n\r\n        public static function load( ?_options:BitmapFontOptions ) : BitmapFont {\r\n\r\n            if(_options == null || _options.id == null ) {\r\n                throw \"BitmapFont: `load` cannot work without a file id to load from.\";\r\n            }\r\n\r\n            if(_options.silent == null) _options.silent = false;\r\n\r\n            var font = new BitmapFont( _options );\r\n\r\n            Luxe.loadText( font.id, function( font_data:luxe.resource.TextResource ) {\r\n\r\n                font.from_string( font_data.text, font.options.onload, null, font.options.silent );\r\n                font.options.resources.cache(font);\r\n\r\n            });\r\n\r\n            return font;\r\n\r\n        } //load\r\n\r\n    //internal\r\n\r\n        public inline function height_of_lines( _lines:Array<String>, _point_size:Float, _line_spc:Float=0.0 ) : Float {\r\n\r\n            var _ratio = _point_size / info.point_size;\r\n\r\n            return _lines.length * ((info.line_height + _line_spc) * _ratio);\r\n\r\n        } //height_of\r\n\r\n        function default_options() {\r\n\r\n            if(options.id == null) {\r\n                options.id = id;\r\n            }\r\n\r\n            if(options.resources == null) {\r\n                options.resources = Luxe.resources;\r\n            }\r\n\r\n            if(options.mipmaps == null) {\r\n                options.mipmaps = false;\r\n            }\r\n\r\n            if(options.filter == null) {\r\n                options.filter = FilterType.linear;\r\n            }\r\n\r\n            if(options.filter_min == null) {\r\n                options.filter_min = FilterType.linear;\r\n            }\r\n\r\n            if(options.filter_mag == null) {\r\n                options.filter_mag = FilterType.linear;\r\n            }\r\n\r\n        } //default_options\r\n\r\n    //internal load handlers\r\n\r\n        function do_onload(success:Bool=true) {\r\n\r\n            loaded = success;\r\n\r\n            if(onload != null) {\r\n                onload( this );\r\n            }\r\n\r\n        } //do_onload\r\n\r\n        function page_loaded(t:Texture) {\r\n\r\n                //increment the current count\r\n            items_loaded++;\r\n\r\n                //if completely done\r\n            if(items_loaded == items_total) {\r\n                do_onload();\r\n            }\r\n\r\n        } //page_loaded\r\n\r\n        function load_pages( ?_custom_pages:Array<Texture> ) {\r\n\r\n            var _path = if(options.texture_path == null) {\r\n                            haxe.io.Path.directory(id);\r\n                        } else {\r\n                            options.texture_path;\r\n                        }\r\n\r\n            if(_custom_pages == null) {\r\n\r\n                _debug('loading texture pages from $_path');\r\n\r\n                items_total = Lambda.count(info.pages);\r\n\r\n                for(_page in info.pages) {\r\n\r\n                    var _page_path = haxe.io.Path.join([_path, _page.file]);\r\n\r\n                    _debug('\\tpage : $_page_path');\r\n\r\n                    var _t = Luxe.loadTexture( _page_path, null, options.silent );\r\n                    if(_t != null) {\r\n                        _t.onload = function(_) {\r\n\r\n                            pages.set(_page.id, _t);\r\n\r\n                            _t.slot = _page.id;\r\n                            _t.filter = options.filter;\r\n                            _t.filter_min = options.filter_min;\r\n                            _t.filter_mag = options.filter_mag;\r\n\r\n                            if(options.mipmaps) {\r\n                                _t.generate_mipmaps();\r\n                            }\r\n\r\n                            page_loaded(_t);\r\n\r\n                        } //onload\r\n                    } else {\r\n                        throw 'BitmapFont: \"$id (${info.face})\" specified a page \"${_page.file}\" with a missing texture at $_page_path';\r\n                    }\r\n\r\n                } //each page\r\n\r\n            } else {\r\n\r\n                items_total = _custom_pages.length;\r\n\r\n                var _id : Int = 0;\r\n                for(_page in _custom_pages) {\r\n                    _page.slot = _id;\r\n                    pages.set(_id, _page);\r\n                    ++_id;\r\n                }\r\n\r\n                    //still need the callback for explicit textures\r\n                do_onload();\r\n\r\n            } //if custom pages\r\n\r\n        } //load_pages\r\n\r\n            //Wip refactoring, see #98\r\n    public function draw_text( opt : TextGeometryOptions ) {\r\n\r\n        if(opt.batcher == null) opt.batcher = Luxe.renderer.batcher;\r\n\r\n            opt.font = this;\r\n\r\n        return new TextGeometry(opt);\r\n\r\n    } //draw_text\r\n\r\n    function toString() {\r\n        return \"BitmapFont(\" + id + \")\";\r\n    }\r\n\r\n} //BitmapFont\r\n\r\n\r\nprivate class Parser {\r\n\r\n    //public api\r\n\r\n        public static function parse( _font_data:String ) : FontInfo {\r\n\r\n            if(_font_data.length == 0) {\r\n                throw \"BitmapFont:Parser: _font_data is 0 length\";\r\n            }\r\n\r\n            var _info : FontInfo = {\r\n                face : null,\r\n                chars : new Map(),\r\n                point_size : 0, base_size : 0,\r\n                char_count : 0, line_height : 0,\r\n                pages : [], kernings : new Map()\r\n            };\r\n\r\n            var _lines : Array<String> = _font_data.split(\"\\n\");\r\n\r\n            if(_lines.length == 0) throw \"BitmapFont; invalid font data specified for parser.\";\r\n\r\n            var _first = _lines[0];\r\n            if( StringTools.ltrim(_first).substr(0, 4) != 'info') {\r\n                throw \"BitmapFont; invalid font data specified for parser. Format should be plain ascii text .fnt file only currently.\";\r\n            }\r\n\r\n            for(_line in _lines) {\r\n                var _tokens = _line.split(\" \");\r\n                for(_current in _tokens) {\r\n                    parse_token(_current, _tokens, _info);\r\n                }\r\n            }\r\n\r\n            return _info;\r\n\r\n        } //parse\r\n\r\n    //internal\r\n\r\n        static function parse_token( _token:String, _tokens:Array<String>, _info:FontInfo ) {\r\n\r\n                //remove the first token\r\n            _tokens.shift();\r\n                //fetch the items from the line\r\n            var _items = tokenize_line(_tokens);\r\n\r\n            switch (_token) {\r\n\r\n                case 'info': {\r\n                    _info.face = unquote(_items['face']);\r\n                    _info.point_size = Std.parseFloat(_items['size']);\r\n                }\r\n\r\n                case 'common': {\r\n                    _info.line_height = Std.parseFloat(_items['lineHeight']);\r\n                    _info.base_size = Std.parseFloat(_items['base']);\r\n                }\r\n\r\n                case 'page': {\r\n                    _info.pages.push({\r\n                        id : Std.parseInt(_items['id']),\r\n                        file : trim(unquote(_items['file']))\r\n                    });\r\n                }\r\n\r\n                case 'chars': {\r\n                    _info.char_count = Std.parseInt(_items[\"count\"]);\r\n                }\r\n\r\n                case 'char': {\r\n\r\n                    var _char : Character = {\r\n                        id : Std.parseInt(_items[\"id\"]),\r\n                        x : Std.parseFloat(_items[\"x\"]),\r\n                        y : Std.parseFloat(_items[\"y\"]),\r\n                        width : Std.parseFloat(_items[\"width\"]),\r\n                        height : Std.parseFloat(_items[\"height\"]),\r\n                        xoffset : Std.parseFloat(_items[\"xoffset\"]),\r\n                        yoffset : Std.parseFloat(_items[\"yoffset\"]),\r\n                        xadvance : Std.parseFloat(_items[\"xadvance\"]),\r\n                        page : Std.parseInt(_items[\"page\"])\r\n                    }\r\n\r\n                    _info.chars.set(_char.id, _char);\r\n\r\n                }\r\n\r\n                case 'kerning': {\r\n\r\n                    var _first = Std.parseInt(_items[\"first\"]);\r\n                    var _second = Std.parseInt(_items[\"second\"]);\r\n                    var _amount = Std.parseFloat(_items[\"amount\"]);\r\n\r\n                    var _map = _info.kernings.get(_first);\r\n                    if(_map == null) {\r\n                        _map = new Map();\r\n                        _info.kernings.set(_first, _map);\r\n                    }\r\n\r\n                    _map.set(_second, _amount);\r\n\r\n                }\r\n\r\n                default:\r\n            }\r\n\r\n        } //parse_token\r\n\r\n        static function tokenize_line( _tokens:Array<String> ) {\r\n\r\n            var _item_map : Map<String, String> = new Map();\r\n\r\n                for(_token in _tokens) {\r\n                    var _items = _token.split(\"=\");\r\n                    _item_map.set( _items[0], _items[1] );\r\n                }\r\n\r\n            return _item_map;\r\n\r\n        } //tokenize_line\r\n\r\n        inline static function trim(_s:String) { return StringTools.trim(_s); }\r\n        inline static function unquote(_s:String) {\r\n            if(_s.indexOf('\"') != -1) {\r\n                _s = StringTools.replace(_s,'\"', '');\r\n            } return _s;\r\n        } //unquote\r\n\r\n} //BitmapFontParser\r\n\r\n","package phoenix;\r\n\r\n\r\nimport phoenix.utils.Rendering;\r\nimport snow.render.opengl.GL;\r\nimport snow.io.typedarray.Float32Array;\r\n\r\nimport phoenix.Matrix;\r\n\r\nimport phoenix.Quaternion;\r\nimport phoenix.Rectangle;\r\nimport phoenix.Transform;\r\nimport phoenix.Vector;\r\nimport phoenix.Ray;\r\n\r\nimport luxe.options.CameraOptions;\r\n\r\nenum ProjectionType {\r\n    ortho;\r\n    perspective;\r\n    custom;\r\n}\r\n\r\n\r\nclass Camera {\r\n\r\n    public var name : String = 'camera';\r\n\r\n    @:isVar public var viewport (get,set) : Rectangle;\r\n    @:isVar public var center (get,set) : Vector;\r\n    @:isVar public var zoom (default,set) : Float = 1.0;\r\n\r\n    @:isVar public var near (default,set) : Float = 1000;\r\n    @:isVar public var far (default,set) : Float = -1000;\r\n        //specific to perspective\r\n    @:isVar public var fov      (default, set) : Float = 60;\r\n    @:isVar public var fov_type (default, set) : FOVType = FOVType.horizontal;\r\n    @:isVar public var aspect   (default,set) : Float = 1.5;\r\n    @:isVar public var target   (default,set) : Vector;\r\n\r\n        //we keep a local pos variable as an unaltered position\r\n        //to keep the center relative to the viewport, and allow setting position as 0,0 not center\r\n    @:isVar public var pos (get,set) : Vector;\r\n        //the other transforms defer directly to the transform so aren't variables\r\n    public var scale (get,set) : Vector;\r\n    public var rotation (get,set) : Quaternion;\r\n    public var transform : Transform;\r\n\r\n    public var minimum_zoom : Float = 0.01;\r\n    public var projection_matrix : Matrix;\r\n    public var view_matrix : Matrix;\r\n    public var view_matrix_inverse : Matrix;\r\n        //if any, a rotation matrix for the look at rotation\r\n    public var look_at_matrix : Matrix;\r\n\r\n    public var options : CameraOptions;\r\n    public var projection : ProjectionType;\r\n    public var up : Vector;\r\n\r\n    @:noCompletion public var projection_float32array : Float32Array;\r\n    @:noCompletion public var view_inverse_float32array : Float32Array;\r\n\r\n        //Internal rendering fov, always vertical\r\n    var fov_y:Float;\r\n        //when the transform changes, the camera needs to refresh the view matrix\r\n    var transform_dirty : Bool = true;\r\n        //when the projection changes we need to update refresh the matrix\r\n    var projection_dirty : Bool = true;\r\n        //when the target changes we can update the look at matrix\r\n    var look_at_dirty : Bool = true;\r\n        //when we are still busy setting up\r\n    var _setup : Bool = true;\r\n\r\n        //A phoenix camera will default to ortho set to screen size\r\n    public function new( ?_options:CameraOptions ) {\r\n\r\n        transform = new Transform();\r\n\r\n            //save for later\r\n        options = _options;\r\n\r\n            //have sane defaults\r\n        if(options == null) {\r\n            options = default_camera_options();\r\n        }\r\n\r\n            //store the name if any\r\n        if(options.camera_name != null) {\r\n            name = options.camera_name;\r\n        }\r\n\r\n            //default to ortho unless specified otherwise\r\n        if(options.projection != null) {\r\n            projection = options.projection;\r\n        } else {\r\n            projection = ProjectionType.ortho;\r\n        }\r\n\r\n        center = new Vector(Luxe.screen.w/2, Luxe.screen.h/2);\r\n        pos = new Vector();\r\n\r\n            //default to screensize or use given viewport\r\n        if(options.viewport != null) {\r\n            viewport = options.viewport;\r\n        } else {\r\n            viewport = new Rectangle( 0, 0, Luxe.screen.w, Luxe.screen.h );\r\n        }\r\n\r\n        up = new Vector(0,1,0);\r\n\r\n        projection_matrix = new Matrix();\r\n        view_matrix = new Matrix();\r\n        view_matrix_inverse = new Matrix();\r\n        look_at_matrix = new Matrix();\r\n\r\n        transform.listen(on_transform_cleaned);\r\n\r\n        apply_default_camera_options();\r\n\r\n        switch (projection) {\r\n\r\n            case ProjectionType.ortho:\r\n                set_ortho( options );\r\n            case ProjectionType.perspective:\r\n                set_perspective( options );\r\n            case ProjectionType.custom: {\r\n\r\n            }\r\n\r\n        } //switch projection\r\n\r\n        _setup = false;\r\n\r\n    } //new\r\n\r\n\r\n//Public API\r\n\r\n\r\n    public function set_ortho( _options:CameraOptions ) {\r\n\r\n            //\r\n        projection = ProjectionType.ortho;\r\n            //\r\n        _merge_options( _options );\r\n\r\n    } //set_ortho\r\n\r\n    public function set_perspective( _options:CameraOptions ) {\r\n\r\n            //\r\n        projection = ProjectionType.perspective;\r\n            //\r\n        _merge_options( _options );\r\n            //reset the view origin\r\n        transform.origin.set_xyz(0,0,0);\r\n\r\n    } //set_perspective\r\n\r\n        //from 3D to 2D\r\n    public function project( _vector:Vector ) {\r\n\r\n        update_view_matrix();\r\n\r\n        var _transform = new Matrix().multiplyMatrices( projection_matrix, view_matrix_inverse );\r\n        return _vector.clone().applyProjection( _transform );\r\n\r\n    } //project\r\n\r\n        //from 2D to 3D\r\n    public function unproject( _vector:Vector ) {\r\n\r\n        update_view_matrix();\r\n\r\n        var _inverted = new Matrix().multiplyMatrices( projection_matrix, view_matrix_inverse );\r\n        return _vector.clone().applyProjection( _inverted.getInverse(_inverted) );\r\n\r\n    } //unproject\r\n\r\n    public function screen_point_to_ray( _vector:Vector ) : Ray {\r\n\r\n        return new Ray( _vector, this );\r\n\r\n    } //screen_point_as_ray\r\n\r\n    public function screen_point_to_world( _vector:Vector ) : Vector {\r\n\r\n        if( projection == ProjectionType.ortho ) {\r\n            return ortho_screen_to_world(_vector);\r\n        } else if( projection == ProjectionType.perspective ){\r\n            return screen_point_to_ray( _vector ).end;\r\n        }\r\n\r\n            //given the default is ortho, for now\r\n        return ortho_screen_to_world(_vector);\r\n\r\n    } //screen_point_to_world\r\n\r\n    public function world_point_to_screen( _vector:Vector, ?_viewport:Rectangle=null ) : Vector {\r\n\r\n        if( projection == ProjectionType.ortho ) {\r\n            return ortho_world_to_screen( _vector );\r\n        } else if( projection == ProjectionType.perspective ) {\r\n            return persepective_world_to_screen(_vector, _viewport);\r\n        }\r\n\r\n            //given the default is ortho, for now\r\n        return ortho_world_to_screen( _vector );\r\n\r\n    } //world_point_to_screen\r\n\r\n\r\n//Internal API\r\n\r\n\r\n    @:noCompletion public function process() {\r\n\r\n            //If we have a target, override the rotation\r\n            //before we update the matrix, so it can be applied immediately if changing\r\n            //:todo: target needs a test and should only update if the target changes\r\n        if(target != null) {\r\n            update_look_at();\r\n        } //target not null\r\n\r\n            //update transforms and projection\r\n        update_projection_matrix();\r\n        update_view_matrix();\r\n\r\n            //apply states\r\n        apply_state(GL.CULL_FACE, options.cull_backfaces);\r\n        apply_state(GL.DEPTH_TEST, options.depth_test);\r\n\r\n    } //process\r\n\r\n//Transforms\r\n\r\n\r\n    function on_transform_cleaned( t:Transform ) {\r\n\r\n        transform_dirty = true;\r\n\r\n    } //on_transform_cleaned\r\n\r\n    function update_look_at() {\r\n\r\n        if(look_at_dirty && target != null) {\r\n\r\n            look_at_matrix.lookAt( target, pos, up );\r\n\r\n            rotation.setFromRotationMatrix( look_at_matrix );\r\n\r\n        } //dirty & !null\r\n\r\n    } //update_look_at\r\n\r\n    function update_view_matrix() {\r\n\r\n        view_matrix = transform.world.matrix;\r\n\r\n        if(!transform_dirty) {\r\n            return;\r\n        }\r\n\r\n        view_matrix_inverse = view_matrix.inverse();\r\n        view_inverse_float32array = view_matrix_inverse.float32array();\r\n\r\n        transform_dirty = false;\r\n\r\n    } //update_view_matrix\r\n\r\n    function update_projection_matrix() {\r\n\r\n        if(!projection_dirty) {\r\n            return;\r\n        }\r\n\r\n        switch(projection) {\r\n\r\n            case ProjectionType.perspective:\r\n                projection_matrix.makePerspective( fov_y, aspect, near, far );\r\n            case ProjectionType.ortho:\r\n                projection_matrix.makeOrthographic( 0, viewport.w, 0, viewport.h, near, far );\r\n            case ProjectionType.custom: {}\r\n\r\n        } //switch\r\n\r\n        projection_float32array = projection_matrix.float32array();\r\n\r\n        projection_dirty = false;\r\n\r\n    } //update_projection_matrix\r\n\r\n\r\n//Helpers\r\n\r\n\r\n    function apply_state(state:Int, value:Bool) {\r\n\r\n        if(value) {\r\n            Luxe.renderer.state.enable(state);\r\n        } else {\r\n            Luxe.renderer.state.disable(state);\r\n        }\r\n\r\n    } //apply_state\r\n\r\n    function apply_default_camera_options() {\r\n\r\n        switch (projection) {\r\n\r\n            case ProjectionType.ortho: {\r\n\r\n                options.cull_backfaces = false;\r\n                options.depth_test = false;\r\n\r\n            } //ortho\r\n\r\n            case ProjectionType.perspective: {\r\n\r\n                options.cull_backfaces = true;\r\n                options.depth_test = true;\r\n\r\n            } //perspective\r\n\r\n            case ProjectionType.custom: {}\r\n\r\n        } //switch\r\n\r\n    } //apply_default_camera_options\r\n\r\n    function default_camera_options() : CameraOptions {\r\n\r\n        return {\r\n            projection : ProjectionType.ortho,\r\n            depth_test : false,\r\n            cull_backfaces : false,\r\n            near : 1000,\r\n            far: -1000\r\n        };\r\n\r\n    } //default_camera_options\r\n\r\n\r\n//Conversions\r\n\r\n\r\n    function ortho_screen_to_world( _vector:Vector ) : Vector {\r\n\r\n        update_view_matrix();\r\n\r\n        return _vector.clone().transform(view_matrix);\r\n\r\n    } //ortho_screen_to_world\r\n\r\n    function ortho_world_to_screen( _vector:Vector ) : Vector {\r\n\r\n        update_view_matrix();\r\n\r\n        return _vector.clone().transform( view_matrix_inverse );\r\n\r\n    } //ortho_world_to_screen\r\n\r\n    function persepective_world_to_screen( _vector:Vector, ?_viewport:Rectangle=null ) {\r\n\r\n        if(_viewport == null) { _viewport = viewport; }\r\n\r\n        var _projected = project( _vector );\r\n\r\n        var width_half = _viewport.w/2;\r\n        var height_half = _viewport.h/2;\r\n\r\n        return new Vector(\r\n             ( _projected.x * width_half ) + width_half,\r\n            -( _projected.y * height_half ) + height_half\r\n        );\r\n\r\n    } //persepective_world_point_to_screen\r\n\r\n\r\n//Properties\r\n\r\n    function set_target( _target:Vector ) : Vector {\r\n\r\n        if(_target != null) {\r\n            look_at_dirty = true;\r\n        }\r\n\r\n        return target = _target;\r\n\r\n    } //set_target\r\n\r\n    function set_fov( _fov:Float ) : Float {\r\n\r\n        projection_dirty = true;\r\n        options.fov = _fov;\r\n\r\n        if (fov_type == FOVType.horizontal) {\r\n            fov_y = Rendering.fovx_to_y(_fov, aspect);\r\n        } else {\r\n            fov_y = _fov;\r\n        }\r\n\r\n        return fov = _fov;\r\n\r\n    } //set_fov\r\n\r\n    function set_fov_type(_fov_type:FOVType) : FOVType {\r\n        options.fov_type = _fov_type;\r\n        fov_type = _fov_type;\r\n        //trigger fov_y update\r\n        set_fov(fov);\r\n        return fov_type;\r\n    }\r\n\r\n    function set_aspect( _aspect:Float ) : Float {\r\n\r\n        projection_dirty = true;\r\n        options.aspect = _aspect;\r\n\r\n        return aspect = _aspect;\r\n\r\n    } //set_aspect\r\n\r\n    function set_near( _near:Float ) : Float {\r\n\r\n        projection_dirty = true;\r\n        options.near = _near;\r\n\r\n        return near = _near;\r\n\r\n    } //set_near\r\n\r\n    function set_far( _far:Float ) : Float {\r\n\r\n        projection_dirty = true;\r\n        options.far = _far;\r\n\r\n        return far = _far;\r\n\r\n    } //set_far\r\n\r\n\r\n        //0.5 = smaller , 2 = bigger\r\n    function set_zoom( _z:Float ) : Float {\r\n\r\n            //a temp value to manipulate\r\n        var _new_zoom = _z;\r\n\r\n            //new zoom value shouldn't be allowed beyond a minimum\r\n            //but maybe this should be optional if you want negative zoom?\r\n        if(_new_zoom < minimum_zoom) {\r\n            _new_zoom = minimum_zoom;\r\n        }\r\n\r\n        switch(projection) {\r\n\r\n            case ProjectionType.ortho:\r\n\r\n                    //scale the visual view based on the value\r\n                transform.scale.x = 1/_new_zoom;\r\n                transform.scale.y = 1/_new_zoom;\r\n                transform.scale.z = 1/_new_zoom;\r\n\r\n            case ProjectionType.perspective: {\r\n\r\n                // :todo: nothing happens when zooming perspective\r\n\r\n            }\r\n\r\n            case ProjectionType.custom: {}\r\n\r\n        } //switch projection\r\n\r\n            //return the real value\r\n        return zoom = _new_zoom;\r\n\r\n    } //set_zoom\r\n\r\n    var _refresh_pos : Bool = false;\r\n    function set_center( _p:Vector ) : Vector {\r\n\r\n        center = _p;\r\n\r\n        switch(projection) {\r\n\r\n            case ProjectionType.ortho:\r\n\r\n                if(!_refresh_pos && !_setup) {\r\n                        //setting the center is the same as setting\r\n                        //the position relative to the viewport\r\n                    pos.ignore_listeners = true;\r\n                        pos.x = _p.x - (viewport.w/2);\r\n                        pos.y = _p.y - (viewport.h/2);\r\n                    pos.ignore_listeners = false;\r\n\r\n                } //!_refresh_pos && !_setup\r\n\r\n            case ProjectionType.perspective: {}\r\n\r\n            case ProjectionType.custom: {}\r\n\r\n        } //switch projection\r\n\r\n        Vector.Listen(center, _center_changed);\r\n\r\n        return center;\r\n\r\n    } //set_center\r\n\r\n    function get_center() : Vector {\r\n        return center;\r\n    } //get_center\r\n\r\n    function get_pos() : Vector {\r\n        return pos;\r\n    } //get_pos\r\n\r\n    function get_rotation() : Quaternion {\r\n        return transform.rotation;\r\n    } //get_rotation\r\n\r\n    function get_scale() : Vector {\r\n        return transform.scale;\r\n    } //get_scale\r\n\r\n    function get_viewport() : Rectangle {\r\n        return viewport;\r\n    } //get_viewport\r\n\r\n    function set_viewport(_r:Rectangle) : Rectangle {\r\n\r\n        projection_dirty = true;\r\n\r\n        viewport = _r;\r\n\r\n        switch(projection) {\r\n\r\n            case ProjectionType.ortho:\r\n\r\n                    //update the actual origin center of transform\r\n                transform.origin = new Vector( _r.w/2, _r.h/2 );\r\n                    //refresh the position and center etc\r\n                set_pos(pos);\r\n\r\n            case ProjectionType.perspective: {}\r\n\r\n            case ProjectionType.custom: {}\r\n\r\n        } //switch projection\r\n\r\n\r\n        return viewport;\r\n\r\n    } //set_viewport\r\n\r\n    function set_rotation( _q:Quaternion ) : Quaternion {\r\n\r\n        return transform.rotation = _q;\r\n\r\n    } //set_rotation\r\n\r\n    function set_scale( _s:Vector ) : Vector {\r\n\r\n        return transform.scale = _s;\r\n\r\n    } //set_scale\r\n\r\n    function set_pos( _p:Vector ) : Vector {\r\n\r\n        pos = _p;\r\n\r\n        switch(projection) {\r\n\r\n            case ProjectionType.ortho:\r\n\r\n            var _cx = center.x;\r\n            var _cy = center.y;\r\n\r\n            if(viewport != null) {\r\n                _cx = _p.x + (viewport.w/2);\r\n                _cy = _p.y + (viewport.h/2);\r\n            }\r\n\r\n                _refresh_pos = true;\r\n                    center.ignore_listeners = true;\r\n                        center.x = _cx;\r\n                        center.y = _cy;\r\n                    center.ignore_listeners = false;\r\n                _refresh_pos = false;\r\n\r\n                transform.pos.x = _cx;\r\n                transform.pos.y = _cy;\r\n\r\n            case ProjectionType.perspective:\r\n\r\n                transform.pos = pos;\r\n\r\n            case ProjectionType.custom: {}\r\n\r\n        } //switch projection\r\n\r\n        Vector.Listen(pos, _pos_changed);\r\n\r\n        return pos;\r\n\r\n    } //set_pos\r\n\r\n\r\n    function _merge_options( _options:CameraOptions ) {\r\n\r\n        if(_options.aspect != null) {\r\n            options.aspect = _options.aspect;\r\n            aspect = options.aspect;\r\n        }\r\n\r\n        if(_options.far != null) {\r\n            options.far = _options.far;\r\n            far = options.far;\r\n        }\r\n\r\n\r\n        if(_options.fov != null) {\r\n            options.fov = _options.fov;\r\n            fov = options.fov;\r\n        }\r\n\r\n        if (_options.fov_type != null) {\r\n            options.fov_type = _options.fov_type;\r\n            fov_type = _options.fov_type;\r\n        }\r\n        else {\r\n            //apply default to make sure fov_y is set\r\n            options.fov_type = FOVType.horizontal;\r\n            fov_type = FOVType.horizontal;\r\n        }\r\n\r\n        if(_options.near != null) {\r\n            options.near = _options.near;\r\n            near = options.near;\r\n        }\r\n\r\n        if(_options.viewport != null) {\r\n            options.viewport = _options.viewport;\r\n            viewport = options.viewport;\r\n        }\r\n\r\n            //start at defaults\r\n        apply_default_camera_options();\r\n\r\n        if(_options.cull_backfaces != null) {\r\n            options.cull_backfaces = _options.cull_backfaces;\r\n        }\r\n\r\n        if(_options.depth_test != null) {\r\n            options.depth_test = _options.depth_test;\r\n        }\r\n\r\n    } //_merge_options\r\n\r\n    function _pos_changed(v:Float) {\r\n\r\n        set_pos(pos);\r\n\r\n    } //_pos_changed\r\n\r\n    function _center_changed(v:Float) {\r\n\r\n        set_center(center);\r\n\r\n    } //_center_changed\r\n\r\n} //Camera\r\n\r\nenum FOVType {\r\n    vertical;\r\n    horizontal;\r\n} //FOVType\r\n","package phoenix;\r\n\r\n\r\nclass Circle {\r\n\r\n    public var x:Float;\r\n    public var y:Float;\r\n    public var r:Float;\r\n\r\n    public function new(?_x:Float = 0,?_y:Float = 0,?_r:Float = 0) {\r\n        x = _x;\r\n        y = _y;\r\n        r = _r;\r\n    } //new\r\n\r\n    function toString() {\r\n        return \"{ x:\"+x + \", y:\" + y + \", r:\" + r + \" }\" ;\r\n    } //toString\r\n\r\n    public function point_inside(_p:Vector) {\r\n\r\n        var diff = new Vector(_p.x - x, _p.y - y);\r\n\r\n        return diff.length <= r;\r\n\r\n    } //point_inside\r\n\r\n    public function clone() {\r\n        return new Circle(x,y,r);\r\n    } //clone\r\n\r\n    public function set(?_x:Float, ?_y:Float, ?_r:Float) {\r\n        var _setx = x;\r\n        var _sety = y;\r\n        var _setr = r;\r\n\r\n            //assign new values\r\n        if(_x != null) _setx = _x;\r\n        if(_y != null) _sety = _y;\r\n        if(_r != null) _setr = _r;\r\n\r\n        x = _setx;\r\n        y = _sety;\r\n        r = _setr;\r\n\r\n        return this;\r\n    } //set\r\n\r\n} //Circle\r\n","package phoenix;\r\n\r\nimport luxe.tween.Actuate;\r\nimport luxe.tween.actuators.SimpleActuator;\r\n\r\n//Pieces of the color conversion code come from\r\n// http://haxe.org/doc/snip/colorconverter\r\nimport luxe.options.ColorOptions;\r\n\r\nclass Color {\r\n\r\n    @:isVar public var r (default, set) : Float = 1.0;\r\n    @:isVar public var g (default, set) : Float = 1.0;\r\n    @:isVar public var b (default, set) : Float = 1.0;\r\n\r\n    public var a : Float = 1.0;\r\n\r\n    var is_hsl : Bool = false;\r\n    var is_hsv : Bool = false;\r\n    var refreshing : Bool = false;\r\n\r\n    public function new( _r:Float = 1.0, _g:Float = 1.0, _b:Float = 1.0, _a:Float = 1.0 ) {\r\n\r\n        r = _r;\r\n        g = _g;\r\n        b = _b;\r\n        a = _a;\r\n\r\n    }\r\n\r\n    function set_r(_r:Float) {\r\n        r = _r;\r\n\r\n        if(!refreshing) {\r\n            if(is_hsl) {\r\n                var colorhsl : ColorHSL = cast this;\r\n                colorhsl.fromColor(this);\r\n            } else if(is_hsv) {\r\n                var colorhsv : ColorHSV = cast this;\r\n                colorhsv.fromColor(this);\r\n            }\r\n        } //refreshing\r\n\r\n        return r;\r\n    }\r\n    function set_g(_g:Float) {\r\n        g = _g;\r\n\r\n        if(!refreshing) {\r\n            if(is_hsl) {\r\n                var colorhsl : ColorHSL = cast this;\r\n                colorhsl.fromColor(this);\r\n            } else if(is_hsv) {\r\n                var colorhsv : ColorHSV = cast this;\r\n                colorhsv.fromColor(this);\r\n            }\r\n        } //!refreshing\r\n\r\n        return g;\r\n    }\r\n    function set_b(_b:Float) {\r\n        b = _b;\r\n\r\n        if(!refreshing) {\r\n            if(is_hsl) {\r\n                var colorhsl : ColorHSL = cast this;\r\n                colorhsl.fromColor(this);\r\n            } else if(is_hsv) {\r\n                var colorhsv : ColorHSV = cast this;\r\n                colorhsv.fromColor(this);\r\n            }\r\n        } //refreshing\r\n\r\n        return b;\r\n    }\r\n\r\n\r\n    public static function random(?_include_alpha:Bool=false) : Color {\r\n        return new Color(Math.random(), Math.random(), Math.random(), _include_alpha ? Math.random() : 1.0 );\r\n    }\r\n\r\n    public function set( ?_r : Float, ?_g : Float, ?_b : Float, ?_a : Float ) : Color {\r\n\r\n        var _setr = r;\r\n        var _setg = g;\r\n        var _setb = b;\r\n        var _seta = a;\r\n\r\n            //assign new values\r\n        if(_r != null) _setr = _r;\r\n        if(_g != null) _setg = _g;\r\n        if(_b != null) _setb = _b;\r\n        if(_a != null) _seta = _a;\r\n\r\n        r = _setr;\r\n        g = _setg;\r\n        b = _setb;\r\n        a = _seta;\r\n\r\n        return this;\r\n    }\r\n\r\n    public function maxRGB() : Float {\r\n        return Math.max(r, Math.max(g, b));\r\n    }\r\n\r\n    public function minRGB() : Float {\r\n        return Math.min(r, Math.min(g, b));\r\n    }\r\n\r\n    public function tween( ?_time_in_seconds:Float = 0.5, ?_properties_to_tween:ColorOptions = null, _override:Bool = true ) {\r\n\r\n        if(_properties_to_tween != null) {\r\n\r\n            var _dest_r = r;\r\n            var _dest_g = g;\r\n            var _dest_b = b;\r\n            var _dest_a = a;\r\n\r\n            var _change_r = false;\r\n            var _change_g = false;\r\n            var _change_b = false;\r\n            var _change_a = false;\r\n\r\n            if(Std.is(_properties_to_tween, Color)) {\r\n\r\n                _dest_r = _properties_to_tween.r;\r\n                _dest_g = _properties_to_tween.g;\r\n                _dest_b = _properties_to_tween.b;\r\n                _dest_a = _properties_to_tween.a;\r\n\r\n                _change_r = true;\r\n                _change_g = true;\r\n                _change_b = true;\r\n                _change_a = true;\r\n\r\n            } else {\r\n\r\n                if(_properties_to_tween.r != null) { _dest_r = _properties_to_tween.r; _change_r = true; }\r\n                if(_properties_to_tween.g != null) { _dest_g = _properties_to_tween.g; _change_g = true; }\r\n                if(_properties_to_tween.b != null) { _dest_b = _properties_to_tween.b; _change_b = true; }\r\n                if(_properties_to_tween.a != null) { _dest_a = _properties_to_tween.a; _change_a = true; }\r\n\r\n            }\r\n\r\n            var _properties : Dynamic = {};\r\n\r\n            if(_change_r) _properties.r = _dest_r;\r\n            if(_change_g) _properties.g = _dest_g;\r\n            if(_change_b) _properties.b = _dest_b;\r\n            if(_change_a) _properties.a = _dest_a;\r\n\r\n            return Actuate.tween( this, _time_in_seconds, _properties, _override );\r\n\r\n        } else { //dest is null?\r\n            throw \" Warning: Color.tween passed a null destination \";\r\n        }\r\n\r\n    } //tween\r\n\r\n    public function clone() : Color {\r\n        return new Color(r,g,b,a);\r\n    } //clone\r\n\r\n    public function rgb(_rgb:Int = 0xFFFFFF) : Color {\r\n        from_int(_rgb);\r\n        return this;\r\n    } //rgb\r\n\r\n    public function toColorHSL() : ColorHSL {\r\n        return new ColorHSL().fromColor(this);\r\n    } //toColorHSL\r\n\r\n    public function toColorHSV() : ColorHSV {\r\n        return new ColorHSV().fromColor(this);\r\n    } //toColorHSV\r\n\r\n    public function fromColorHSV( _color_hsv:ColorHSV ) {\r\n\r\n        var d:Float = (_color_hsv.h%360) / 60;\r\n\r\n        if (d < 0) {\r\n            d += 6;\r\n        }\r\n\r\n        var hf:Int = Math.floor(d);\r\n        var hi:Int = hf % 6;\r\n        var f:Float = d - hf;\r\n\r\n        var v:Float = _color_hsv.v;\r\n        var p:Float = _color_hsv.v * (1 - _color_hsv.s);\r\n        var q:Float = _color_hsv.v * (1 - f * _color_hsv.s);\r\n        var t:Float = _color_hsv.v * (1 - (1 - f) * _color_hsv.s);\r\n\r\n        switch(hi) {\r\n            case 0: { r = v; g = t; b = p; };\r\n            case 1: { r = q; g = v; b = p; };\r\n            case 2: { r = p; g = v; b = t; };\r\n            case 3: { r = p; g = q; b = v; };\r\n            case 4: { r = t; g = p; b = v; };\r\n            case 5: { r = v; g = p; b = q; };\r\n        }\r\n\r\n        a = _color_hsv.a;\r\n\r\n    } //fromColorHSV\r\n\r\n    public function fromColorHSL( _color_hsl:ColorHSL ) : Color {\r\n\r\n        var q:Float = 1;\r\n\r\n        if (_color_hsl.l < 1 / 2) {\r\n            q = _color_hsl.l * (1 + _color_hsl.s);\r\n        } else {\r\n            q = _color_hsl.l + _color_hsl.s - (_color_hsl.l * _color_hsl.s);\r\n        }\r\n\r\n        var p:Float = 2 * _color_hsl.l - q;\r\n        var hk:Float = (_color_hsl.h % 360) / 360;\r\n\r\n        var tr:Float = hk + 1 / 3;\r\n        var tg:Float = hk;\r\n        var tb:Float = hk - 1 / 3;\r\n\r\n        var tc:Array<Float> = [ tr, tg, tb ];\r\n\r\n            for (n in 0...tc.length) {\r\n\r\n                var t:Float = tc[n];\r\n\r\n                if (t < 0) t += 1;\r\n                if (t > 1) t -= 1;\r\n\r\n                tc[n] = if (t < 1 / 6) {\r\n                    p + ((q - p) * 6 * t);\r\n                } else if (t < 1 / 2) {\r\n                    q;\r\n                } else if (t < 2 / 3) {\r\n                    p + ((q - p) * 6 * (2 / 3 - t));\r\n                } else {\r\n                    p;\r\n                }\r\n\r\n            } //for each in tc\r\n\r\n            //store in rgb\r\n        r = tc[0];\r\n        g = tc[1];\r\n        b = tc[2];\r\n            //alpha is passed straight through\r\n        a = _color_hsl.a;\r\n\r\n        return this;\r\n\r\n    } // fromColorHSL\r\n\r\n        //make it traceable\r\n    function toString() : String {\r\n        return \"{ r:\"+r+\" , g:\"+g+\" , b:\"+b+\" , a:\"+a+\" }\";\r\n    }\r\n\r\n    function from_int(_i:Int) {\r\n\r\n        var _r = _i >> 16;\r\n        var _g = _i >> 8 & 0xFF;\r\n        var _b = _i & 0xFF;\r\n\r\n            //convert to 0-1\r\n        r = _r / 255;\r\n        g = _g / 255;\r\n        b = _b / 255;\r\n\r\n            //alpha not specified in 0xFFFFFF\r\n            //but we don't need to clobber it,\r\n            //it was set in the member list\r\n        // a = 1.0;\r\n    }\r\n\r\n} //Color\r\n\r\nclass ColorHSL extends Color {\r\n\r\n    @:isVar public var h (default,set) : Float = 0.0;\r\n    @:isVar public var s (default,set) : Float = 1.0;\r\n    @:isVar public var l (default,set) : Float = 1.0;\r\n\r\n    function set_h(_h:Float) {\r\n        h = _h;\r\n        _refresh();\r\n        return _h;\r\n    }\r\n    function set_s(_s:Float) {\r\n        s = _s;\r\n        _refresh();\r\n        return _s;\r\n    }\r\n    function set_l(_l:Float) {\r\n        l = _l;\r\n        _refresh();\r\n        return _l;\r\n    }\r\n\r\n    public function new( _h:Float = 0.0, _s:Float = 1.0, _l:Float = 1.0, _a:Float = 1.0 ) {\r\n\r\n        super();\r\n\r\n        is_hsl = true;\r\n\r\n        h = _h;\r\n        s = _s;\r\n        l = _l;\r\n        a = _a;\r\n\r\n        _refresh();\r\n\r\n    } //new\r\n\r\n    public override function set( ?_h : Float, ?_s : Float, ?_l : Float, ?_a : Float ) : ColorHSL {\r\n\r\n        var _seth = h;\r\n        var _sets = s;\r\n        var _setl = l;\r\n        var _seta = a;\r\n\r\n            //assign new values\r\n        if(_h != null) _seth = _h;\r\n        if(_s != null) _sets = _s;\r\n        if(_l != null) _setl = _l;\r\n        if(_a != null) _seta = _a;\r\n\r\n            h = _seth;\r\n            s = _sets;\r\n            l = _setl;\r\n            a = _seta;\r\n\r\n        _refresh();\r\n\r\n        return this;\r\n\r\n    } //set\r\n\r\n    public override function tween( ?_time_in_seconds:Float = 0.5, ?_dest:ColorOptions = null, _override:Bool = true ) {\r\n\r\n        super.tween(_time_in_seconds, _dest, _override);\r\n\r\n        if(_dest != null) {\r\n\r\n            var _dest_h = h;\r\n            var _dest_s = s;\r\n            var _dest_l = l;\r\n            var _dest_a = a;\r\n\r\n            var _change_h = false;\r\n            var _change_s = false;\r\n            var _change_l = false;\r\n            var _change_a = false;\r\n\r\n            if(Std.is(_dest, ColorHSL)) {\r\n\r\n                _dest_h = _dest.h;\r\n                _dest_s = _dest.s;\r\n                _dest_l = _dest.l;\r\n                _dest_a = _dest.a;\r\n\r\n                _change_h = true;\r\n                _change_s = true;\r\n                _change_l = true;\r\n                _change_a = true;\r\n\r\n            } else {\r\n\r\n                if(_dest.h != null) { _dest_h = _dest.h; _change_h = true; }\r\n                if(_dest.s != null) { _dest_s = _dest.s; _change_s = true; }\r\n                if(_dest.l != null) { _dest_l = _dest.l; _change_l = true; }\r\n                if(_dest.a != null) { _dest_a = _dest.a; _change_a = true; }\r\n\r\n            }\r\n\r\n            var _properties : Dynamic = {};\r\n\r\n            if(_change_h) _properties.h = _dest_h;\r\n            if(_change_s) _properties.s = _dest_s;\r\n            if(_change_l) _properties.l = _dest_l;\r\n            if(_change_a) _properties.a = _dest_a;\r\n\r\n            return Actuate.tween( this, _time_in_seconds, _properties, _override );\r\n\r\n        } else { //dest is null?\r\n            throw \" Warning: Color.tween passed a null destination \";\r\n        }\r\n\r\n    } //tween\r\n\r\n    public function _refresh() : ColorHSL {\r\n\r\n        refreshing = true;\r\n            super.fromColorHSL(this);\r\n        refreshing = false;\r\n\r\n        return this;\r\n    } //_refresh\r\n\r\n    public override function clone() : ColorHSL {\r\n        return new ColorHSL(h,s,l,a);\r\n    } //clone\r\n\r\n    public function toColor() : Color {\r\n        return cast _refresh();\r\n    } //toColor\r\n\r\n    public function fromColor( _color:Color ) : ColorHSL {\r\n\r\n        var max:Float = _color.maxRGB();\r\n        var min:Float = _color.minRGB();\r\n        var add:Float = max + min;\r\n        var sub:Float = max - min;\r\n\r\n        var _h:Float = 0;\r\n        if (max == min) {\r\n            _h = 0;\r\n        } else if (max == _color.r) {\r\n            _h = ((60 * (_color.g - _color.b) / sub + 360) % 360);\r\n        } else if (max == _color.g) {\r\n            _h = (60 * (_color.b - _color.r) / sub + 120);\r\n        } else if (max == _color.b) {\r\n            _h = (60 * (_color.r - _color.g) / sub + 240);\r\n        }\r\n\r\n        var _l:Float = add / 2;\r\n\r\n        var _s:Float = if (max == min) {\r\n            0;\r\n        } else if (l <= 1 / 2) {\r\n            sub / add;\r\n        } else {\r\n            sub / (2 - add);\r\n        }\r\n\r\n            h = _h;\r\n            s = _s;\r\n            l = _l;\r\n            a = _color.a;\r\n\r\n        return this;\r\n\r\n    } //fromColor\r\n\r\n    public override function toString() : String {\r\n        return \"{ h:\"+h+\" , s:\"+s+\" , l:\"+l+\" , a:\"+a+\" }\";\r\n    }\r\n\r\n\r\n} //ColorHSL\r\n\r\n\r\nclass ColorHSV extends Color {\r\n\r\n    @:isVar public var h (default,set) : Float = 0.0;\r\n    @:isVar public var s (default,set) : Float = 0.0;\r\n    @:isVar public var v (default,set) : Float = 1.0;\r\n\r\n    function set_h(_h:Float) {\r\n        h = _h;\r\n        _refresh();\r\n        return _h;\r\n    }\r\n    function set_s(_s:Float) {\r\n        s = _s;\r\n        _refresh();\r\n        return s;\r\n    }\r\n    function set_v(_v:Float) {\r\n        v = _v;\r\n        _refresh();\r\n        return v;\r\n    }\r\n\r\n    public function new( _h:Float = 0.0, _s:Float = 0.0, _v:Float = 1.0, _a:Float = 1.0 ) {\r\n\r\n        super();\r\n\r\n        is_hsv = true;\r\n\r\n        h = _h;\r\n        s = _s;\r\n        v = _v;\r\n        a = _a;\r\n\r\n        _refresh();\r\n\r\n    } //new\r\n\r\n    public override function set( ?_h : Float, ?_s : Float, ?_v : Float, ?_a : Float ) : Color {\r\n\r\n        var _seth = h;\r\n        var _sets = s;\r\n        var _setv = v;\r\n        var _seta = a;\r\n\r\n            //assign new values\r\n        if(_h != null) _seth = _h;\r\n        if(_s != null) _sets = _s;\r\n        if(_v != null) _setv = _v;\r\n        if(_a != null) _seta = _a;\r\n\r\n            h = _seth;\r\n            s = _sets;\r\n            v = _setv;\r\n            a = _seta;\r\n\r\n            //update parent rgba values\r\n        _refresh();\r\n\r\n        return this;\r\n\r\n    } //set\r\n\r\n    public override function tween( ?_time_in_seconds:Float = 0.5, ?_dest:ColorOptions = null, _override:Bool = true ) {\r\n\r\n        super.tween(_time_in_seconds, _dest, _override);\r\n\r\n        if(_dest != null) {\r\n\r\n            var _dest_h = h;\r\n            var _dest_s = s;\r\n            var _dest_v = v;\r\n            var _dest_a = a;\r\n\r\n            var _change_h = false;\r\n            var _change_s = false;\r\n            var _change_v = false;\r\n            var _change_a = false;\r\n\r\n            if(Std.is(_dest, ColorHSV)) {\r\n\r\n                _dest_h = _dest.h;\r\n                _dest_s = _dest.s;\r\n                _dest_v = _dest.v;\r\n                _dest_a = _dest.a;\r\n\r\n                _change_h = true;\r\n                _change_s = true;\r\n                _change_v = true;\r\n                _change_a = true;\r\n\r\n            } else {\r\n\r\n                if(_dest.h != null) { _dest_h = _dest.h; _change_h = true; }\r\n                if(_dest.s != null) { _dest_s = _dest.s; _change_s = true; }\r\n                if(_dest.v != null) { _dest_v = _dest.v; _change_v = true; }\r\n                if(_dest.a != null) { _dest_a = _dest.a; _change_a = true; }\r\n\r\n            }\r\n\r\n            var _properties : Dynamic = {};\r\n\r\n            if(_change_h) _properties.h = _dest_h;\r\n            if(_change_s) _properties.s = _dest_s;\r\n            if(_change_v) _properties.v = _dest_v;\r\n            if(_change_a) _properties.a = _dest_a;\r\n\r\n            return Actuate.tween( this, _time_in_seconds, _properties, _override );\r\n\r\n        } else { //dest is null?\r\n            throw \" Warning: Color.tween passed a null destination \";\r\n        }\r\n\r\n    } //tween\r\n\r\n    public function _refresh() {\r\n\r\n        refreshing = true;\r\n            super.fromColorHSV(this);\r\n        refreshing = false;\r\n\r\n        return this;\r\n    }\r\n\r\n    public override function clone() : ColorHSV {\r\n        return new ColorHSV(h,s,v,a);\r\n    } //clone\r\n\r\n    public function toColor() : Color {\r\n        //make sure the values are passed up to parent color\r\n        return cast _refresh();\r\n    } //toColor\r\n\r\n    public override function toColorHSL() : ColorHSL {\r\n        _refresh();\r\n        return super.toColorHSL();\r\n    } //to hsl\r\n\r\n    public override function fromColorHSL( _color_hsl:ColorHSL ) : ColorHSV {\r\n            //make sure that it it's updated in the parent\r\n        _color_hsl._refresh();\r\n        return fromColor( cast _color_hsl );\r\n    } //from hsl\r\n\r\n    public function fromColor( _color:Color ) : ColorHSV {\r\n\r\n        var max:Float = _color.maxRGB();\r\n        var min:Float = _color.minRGB();\r\n        var add:Float = max + min;\r\n        var sub:Float = max - min;\r\n\r\n        var _h:Float = 0;\r\n\r\n        if (max == min) {\r\n            _h = 0;\r\n        } else if (max == _color.r) {\r\n            _h = (60 * (_color.g - _color.b) / sub + 360) % 360;\r\n        } else if (max == _color.g) {\r\n            _h = 60 * (_color.b - _color.r) / sub + 120;\r\n        } else if (max == _color.b) {\r\n            _h = 60 * (_color.r - _color.g) / sub + 240;\r\n        }\r\n\r\n        var _s:Float = if (max == 0) {\r\n            0;\r\n        } else {\r\n            1 - min / max;\r\n        }\r\n\r\n        h = _h;\r\n        s = _s;\r\n        v = max;\r\n        a = _color.a;\r\n\r\n        return this;\r\n\r\n    } //fromColor\r\n\r\n    public override function toString() : String {\r\n        return \"{ h:\"+h+\" , s:\"+s+\" , v:\"+v+\" , a:\"+a+\" }\";\r\n    }\r\n\r\n} //ColorHSV\r\n","package phoenix;\r\n\r\nimport phoenix.Vector;\r\nimport phoenix.Quaternion;\r\nimport luxe.utils.Maths;\r\n\r\n    //Ported from Three.js https://github.com/mrdoob/three.js\r\n\r\nclass MatrixTransform {\r\n\r\n    public var pos : Vector;\r\n    public var rotation : Quaternion;\r\n    public var scale : Vector;\r\n\r\n    public inline function new(p, r, s) {\r\n        pos = p;\r\n        rotation = r;\r\n        scale = s;\r\n    }\r\n\r\n    inline function destroy() {\r\n        pos = null; rotation = null; scale = null;\r\n    }\r\n\r\n} //MatrixTransform\r\n\r\nclass Matrix {\r\n\r\n    public var elements:Array<Float>;\r\n    var _float32array : snow.io.typedarray.Float32Array;\r\n\r\n    @:isVar public var M11 (get,set) : Float = 1;\r\n    @:isVar public var M21 (get,set) : Float = 0;\r\n    @:isVar public var M31 (get,set) : Float = 0;\r\n    @:isVar public var M41 (get,set) : Float = 0;\r\n\r\n    @:isVar public var M12 (get,set) : Float = 0;\r\n    @:isVar public var M22 (get,set) : Float = 1;\r\n    @:isVar public var M32 (get,set) : Float = 0;\r\n    @:isVar public var M42 (get,set) : Float = 0;\r\n\r\n    @:isVar public var M13 (get,set) : Float = 0;\r\n    @:isVar public var M23 (get,set) : Float = 0;\r\n    @:isVar public var M33 (get,set) : Float = 1;\r\n    @:isVar public var M43 (get,set) : Float = 0;\r\n\r\n    @:isVar public var M14 (get,set) : Float = 0;\r\n    @:isVar public var M24 (get,set) : Float = 0;\r\n    @:isVar public var M34 (get,set) : Float = 0;\r\n    @:isVar public var M44 (get,set) : Float = 1;\r\n\r\n    public inline function new(\r\n        n11:Float = 1, n12:Float = 0, n13:Float = 0, n14:Float = 0,\r\n        n21:Float = 0, n22:Float = 1, n23:Float = 0, n24:Float = 0,\r\n        n31:Float = 0, n32:Float = 0, n33:Float = 1, n34:Float = 0,\r\n        n41:Float = 0, n42:Float = 0, n43:Float = 0, n44:Float = 1)\r\n    {\r\n        elements = new Array<Float>();\r\n\r\n        var i = 0;\r\n        while (i++ < 16) {\r\n            elements.push(0.0);\r\n        }\r\n\r\n        set(\r\n            n11, n12, n13, n14,\r\n            n21, n22, n23, n24,\r\n            n31, n32, n33, n34,\r\n            n41, n42, n43, n44\r\n        );\r\n\r\n        _float32array = new snow.io.typedarray.Float32Array( elements );\r\n\r\n    }\r\n\r\n\r\n    public inline function set(\r\n        n11:Float, n12:Float, n13:Float, n14:Float,\r\n        n21:Float, n22:Float, n23:Float, n24:Float,\r\n        n31:Float, n32:Float, n33:Float, n34:Float,\r\n        n41:Float, n42:Float, n43:Float, n44:Float) : Matrix\r\n    {\r\n\r\n        var e = elements;\r\n\r\n            e[0] = n11; e[4] = n12; e[8]  = n13; e[12] = n14;\r\n            e[1] = n21; e[5] = n22; e[9]  = n23; e[13] = n24;\r\n            e[2] = n31; e[6] = n32; e[10] = n33; e[14] = n34;\r\n            e[3] = n41; e[7] = n42; e[11] = n43; e[15] = n44;\r\n\r\n        return this;\r\n    }\r\n\r\n    inline function toString() {\r\n        var e = elements;\r\n        var str = '{ 11:' + Maths.fixed(e[0], 3) + ', 12:' + Maths.fixed(e[4], 3)  + ', 13:' + Maths.fixed(e[ 8], 3)  + ', 14:' + Maths.fixed(e[12], 3) + ' }, ' +\r\n                  '{ 21:' + Maths.fixed(e[1], 3) + ', 22:' + Maths.fixed(e[5], 3)  + ', 23:' + Maths.fixed(e[ 9], 3)  + ', 24:' + Maths.fixed(e[13], 3) + ' }, ' +\r\n                  '{ 31:' + Maths.fixed(e[2], 3) + ', 32:' + Maths.fixed(e[6], 3)  + ', 33:' + Maths.fixed(e[10], 3)  + ', 34:' + Maths.fixed(e[14], 3) + ' }, ' +\r\n                  '{ 41:' + Maths.fixed(e[3], 3) + ', 42:' + Maths.fixed(e[7], 3)  + ', 43:' + Maths.fixed(e[11], 3)  + ', 44:' + Maths.fixed(e[15], 3) + ' }';\r\n        return str;\r\n    }\r\n\r\n    inline function get_M11() : Float { return elements[0]; }\r\n    inline function get_M12() : Float { return elements[1]; }\r\n    inline function get_M13() : Float { return elements[2]; }\r\n    inline function get_M14() : Float { return elements[3]; }\r\n\r\n    inline function get_M21() : Float { return elements[4]; }\r\n    inline function get_M22() : Float { return elements[5]; }\r\n    inline function get_M23() : Float { return elements[6]; }\r\n    inline function get_M24() : Float { return elements[7]; }\r\n\r\n    inline function get_M31() : Float { return elements[8]; }\r\n    inline function get_M32() : Float { return elements[9]; }\r\n    inline function get_M33() : Float { return elements[10]; }\r\n    inline function get_M34() : Float { return elements[11]; }\r\n\r\n    inline function get_M41() : Float { return elements[12]; }\r\n    inline function get_M42() : Float { return elements[13]; }\r\n    inline function get_M43() : Float { return elements[14]; }\r\n    inline function get_M44() : Float { return elements[15]; }\r\n\r\n    inline function set_M11( _value:Float ) : Float { elements[0] = _value; return _value; }\r\n    inline function set_M12( _value:Float ) : Float { elements[1] = _value; return _value; }\r\n    inline function set_M13( _value:Float ) : Float { elements[2] = _value; return _value; }\r\n    inline function set_M14( _value:Float ) : Float { elements[3] = _value; return _value; }\r\n\r\n    inline function set_M21( _value:Float ) : Float { elements[4] = _value; return _value; }\r\n    inline function set_M22( _value:Float ) : Float { elements[5] = _value; return _value; }\r\n    inline function set_M23( _value:Float ) : Float { elements[6] = _value; return _value; }\r\n    inline function set_M24( _value:Float ) : Float { elements[7] = _value; return _value; }\r\n\r\n    inline function set_M31( _value:Float ) : Float { elements[8] = _value; return _value; }\r\n    inline function set_M32( _value:Float ) : Float { elements[9] = _value; return _value; }\r\n    inline function set_M33( _value:Float ) : Float { elements[10] = _value; return _value; }\r\n    inline function set_M34( _value:Float ) : Float { elements[11] = _value; return _value; }\r\n\r\n    inline function set_M41( _value:Float ) : Float { elements[12] = _value; return _value; }\r\n    inline function set_M42( _value:Float ) : Float { elements[13] = _value; return _value; }\r\n    inline function set_M43( _value:Float ) : Float { elements[14] = _value; return _value; }\r\n    inline function set_M44( _value:Float ) : Float { elements[15] = _value; return _value; }\r\n\r\n    public inline function float32array() : snow.io.typedarray.Float32Array {\r\n\r\n        return new snow.io.typedarray.Float32Array( elements );\r\n\r\n    } //float32array\r\n\r\n    public inline function identity () : Matrix {\r\n\r\n            set(\r\n                1, 0, 0, 0,\r\n                0, 1, 0, 0,\r\n                0, 0, 1, 0,\r\n                0, 0, 0, 1\r\n            );\r\n\r\n        return this;\r\n\r\n    } //identity\r\n\r\n\r\n    public inline function copy( m:Matrix ) : Matrix {\r\n\r\n        var me = m.elements;\r\n\r\n            set(\r\n                me[0], me[4], me[8],  me[12],\r\n                me[1], me[5], me[9],  me[13],\r\n                me[2], me[6], me[10], me[14],\r\n                me[3], me[7], me[11], me[15]\r\n            );\r\n\r\n        return this;\r\n    }\r\n\r\n    public inline function make2D( _x:Float, _y:Float, _scale:Float = 1, _rotation:Float = 0 ) {\r\n\r\n        var theta = Maths.radians(_rotation);\r\n        var c = Math.cos(theta);\r\n        var s = Math.sin(theta);\r\n\r\n        set(\r\n             c * _scale,  s *_scale,  0,  _x,\r\n            -s * _scale,  c *_scale,  0,  _y,\r\n                      0,          0,  1,   0,\r\n                      0,          0,  0,   1\r\n        );\r\n\r\n        return this;\r\n   }\r\n\r\n\r\n    public inline function copyPosition( m:Matrix ) : Matrix {\r\n\r\n        elements[12] = m.elements[12];\r\n        elements[13] = m.elements[13];\r\n        elements[14] = m.elements[14];\r\n\r\n        return this;\r\n    }\r\n\r\n\r\n    public inline function getPosition() : Vector {\r\n        return new Vector(elements[12], elements[13], elements[14],1);\r\n    }\r\n\r\n    public inline function extractRotation( m:Matrix ) : Matrix {\r\n\r\n        var _temp = new Vector();\r\n        var me = m.elements;\r\n\r\n        var _scale_x = 1 / _temp.set_xyz( me[0], me[1], me[2]  ).length;\r\n        var _scale_y = 1 / _temp.set_xyz( me[4], me[5], me[6]  ).length;\r\n        var _scale_z = 1 / _temp.set_xyz( me[8], me[9], me[10] ).length;\r\n\r\n        elements[0] =  me[0]  * _scale_x;\r\n        elements[1] =  me[1]  * _scale_x;\r\n        elements[2] =  me[2]  * _scale_x;\r\n\r\n        elements[4] =  me[4]  * _scale_y;\r\n        elements[5] =  me[5]  * _scale_y;\r\n        elements[6] =  me[6]  * _scale_y;\r\n\r\n        elements[8] =  me[8]  * _scale_z;\r\n        elements[9] =  me[9]  * _scale_z;\r\n        elements[10] = me[10] * _scale_z;\r\n\r\n        return this;\r\n    }\r\n\r\n    public inline function makeRotationFromEuler( _v:Vector, _order:ComponentOrder = XYZ) : Matrix {\r\n\r\n        var te = elements;\r\n\r\n        var x = _v.x;\r\n        var y = _v.y;\r\n        var z = _v.z;\r\n\r\n        var a = Math.cos( x ), b = Math.sin( x );\r\n        var c = Math.cos( y ), d = Math.sin( y );\r\n        var e = Math.cos( z ), f = Math.sin( z );\r\n\r\n        if ( _order == XYZ ) {\r\n\r\n            var ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n\r\n            te[0] = c * e;\r\n            te[4] = - c * f;\r\n            te[8] = d;\r\n\r\n            te[1] = af + be * d;\r\n            te[5] = ae - bf * d;\r\n            te[9] = - b * c;\r\n\r\n            te[2] = bf - ae * d;\r\n            te[6] = be + af * d;\r\n            te[10] = a * c;\r\n\r\n        } else if ( _order == YXZ ) {\r\n\r\n            var ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n\r\n            te[0] = ce + df * b;\r\n            te[4] = de * b - cf;\r\n            te[8] = a * d;\r\n\r\n            te[1] = a * f;\r\n            te[5] = a * e;\r\n            te[9] = - b;\r\n\r\n            te[2] = cf * b - de;\r\n            te[6] = df + ce * b;\r\n            te[10] = a * c;\r\n\r\n        } else if ( _order == ZXY ) {\r\n\r\n            var ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n\r\n            te[0] = ce - df * b;\r\n            te[4] = - a * f;\r\n            te[8] = de + cf * b;\r\n\r\n            te[1] = cf + de * b;\r\n            te[5] = a * e;\r\n            te[9] = df - ce * b;\r\n\r\n            te[2] = - a * d;\r\n            te[6] = b;\r\n            te[10] = a * c;\r\n\r\n        } else if ( _order == ZYX ) {\r\n\r\n            var ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n\r\n            te[0] = c * e;\r\n            te[4] = be * d - af;\r\n            te[8] = ae * d + bf;\r\n\r\n            te[1] = c * f;\r\n            te[5] = bf * d + ae;\r\n            te[9] = af * d - be;\r\n\r\n            te[2] = - d;\r\n            te[6] = b * c;\r\n            te[10] = a * c;\r\n\r\n        } else if ( _order == YZX ) {\r\n\r\n            var ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n\r\n            te[0] = c * e;\r\n            te[4] = bd - ac * f;\r\n            te[8] = bc * f + ad;\r\n\r\n            te[1] = f;\r\n            te[5] = a * e;\r\n            te[9] = - b * e;\r\n\r\n            te[2] = - d * e;\r\n            te[6] = ad * f + bc;\r\n            te[10] = ac - bd * f;\r\n\r\n        } else if ( _order == XZY ) {\r\n\r\n            var ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n\r\n            te[0] = c * e;\r\n            te[4] = - f;\r\n            te[8] = d * e;\r\n\r\n            te[1] = ac * f + bd;\r\n            te[5] = a * e;\r\n            te[9] = ad * f - bc;\r\n\r\n            te[2] = bc * f - ad;\r\n            te[6] = b * e;\r\n            te[10] = bd * f + ac;\r\n\r\n        }\r\n\r\n        // last column\r\n        te[3] = 0;\r\n        te[7] = 0;\r\n        te[11] = 0;\r\n\r\n        // bottom row\r\n        te[12] = 0;\r\n        te[13] = 0;\r\n        te[14] = 0;\r\n        te[15] = 1;\r\n\r\n        return this;\r\n\r\n    } //makeRotationFromEuler\r\n\r\n    public inline function makeRotationFromQuaternion( q:Quaternion ) : Matrix {\r\n\r\n        var te = elements;\r\n\r\n        var x2 = q.x + q.x, y2 = q.y + q.y, z2 = q.z + q.z;\r\n        var xx = q.x * x2,  xy = q.x * y2,  xz = q.x * z2;\r\n        var yy = q.y * y2,  yz = q.y * z2,  zz = q.z * z2;\r\n        var wx = q.w * x2,  wy = q.w * y2,  wz = q.w * z2;\r\n\r\n        te[0] = 1 - ( yy + zz );\r\n        te[4] = xy - wz;\r\n        te[8] = xz + wy;\r\n\r\n        te[1] = xy + wz;\r\n        te[5] = 1 - ( xx + zz );\r\n        te[9] = yz - wx;\r\n\r\n        te[2] = xz - wy;\r\n        te[6] = yz + wx;\r\n        te[10] = 1 - ( xx + yy );\r\n\r\n            // last column\r\n        te[3] = 0;\r\n        te[7] = 0;\r\n        te[11] = 0;\r\n\r\n            // bottom row\r\n        te[12] = 0;\r\n        te[13] = 0;\r\n        te[14] = 0;\r\n        te[15] = 1;\r\n\r\n        return this;\r\n\r\n    } //makeRotationFromQuaternion\r\n\r\n\r\n    public inline function lookAt( _eye:Vector, _target:Vector, _up:Vector ) : Matrix {\r\n\r\n        var _x = new Vector();\r\n        var _y = new Vector();\r\n        var _z = new Vector();\r\n\r\n        var te = elements;\r\n\r\n        _z = Vector.Subtract( _target, _eye ).normalized;\r\n\r\n            if ( _z.length == 0 ) {\r\n                _z.z = 1;\r\n            }\r\n\r\n        _x = Vector.Cross( _up, _z ).normalized;\r\n\r\n            if ( _x.length == 0 ) {\r\n                _z.x += 0.0001;\r\n                _x = Vector.Cross( _up, _z ).normalized;\r\n            }\r\n\r\n        _y = Vector.Cross( _z, _x );\r\n\r\n        te[0] = _x.x; te[4] = _y.x; te[8]  = _z.x;\r\n        te[1] = _x.y; te[5] = _y.y; te[9]  = _z.y;\r\n        te[2] = _x.z; te[6] = _y.z; te[10] = _z.z;\r\n\r\n        return this;\r\n\r\n    } //lookAt\r\n\r\n\r\n    public inline function multiply( _m:Matrix ) : Matrix {\r\n\r\n        return multiplyMatrices(this, _m);\r\n\r\n    } //multiply\r\n\r\n\r\n    public inline function multiplyMatrices( _a:Matrix, _b:Matrix ) : Matrix {\r\n\r\n        var ae = _a.elements;\r\n        var be = _b.elements;\r\n        var te = elements;\r\n\r\n        var a11 = ae[0], a12 = ae[4], a13 = ae[8],  a14 = ae[12];\r\n        var a21 = ae[1], a22 = ae[5], a23 = ae[9],  a24 = ae[13];\r\n        var a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];\r\n        var a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];\r\n\r\n        var b11 = be[0], b12 = be[4], b13 = be[8],  b14 = be[12];\r\n        var b21 = be[1], b22 = be[5], b23 = be[9],  b24 = be[13];\r\n        var b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];\r\n        var b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];\r\n\r\n            te[0] =  a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\r\n            te[4] =  a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\r\n            te[8] =  a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\r\n            te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\r\n\r\n            te[1] =  a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\r\n            te[5] =  a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\r\n            te[9] =  a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\r\n            te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\r\n\r\n            te[2] =  a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\r\n            te[6] =  a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\r\n            te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\r\n            te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\r\n\r\n            te[3] =  a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\r\n            te[7] =  a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\r\n            te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\r\n            te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\r\n\r\n        return this;\r\n\r\n    } //multiplyMatrices\r\n\r\n\r\n    public inline function multiplyToArray( _a:Matrix, _b:Matrix, _r:Array<Float> ) : Matrix {\r\n\r\n        var te = elements;\r\n\r\n            multiplyMatrices(_a, _b);\r\n\r\n            _r[0]  = te[0];   _r[1]  = te[1];   _r[2]  = te[2];  _r[3]  = te[3];\r\n            _r[4]  = te[4];   _r[5]  = te[5];   _r[6]  = te[6];  _r[7]  = te[7];\r\n            _r[8]  = te[8];   _r[9]  = te[9];   _r[10] = te[10]; _r[11] = te[11];\r\n            _r[12] = te[12];  _r[13] = te[13];  _r[14] = te[14]; _r[15] = te[15];\r\n\r\n        return this;\r\n\r\n    } //multiplyToArray\r\n\r\n\r\n    public inline function multiplyScalar( _s:Float ) : Matrix {\r\n\r\n        var te = elements;\r\n\r\n            te[0] *= _s; te[4] *= _s; te[8]  *= _s; te[12] *= _s;\r\n            te[1] *= _s; te[5] *= _s; te[9]  *= _s; te[13] *= _s;\r\n            te[2] *= _s; te[6] *= _s; te[10] *= _s; te[14] *= _s;\r\n            te[3] *= _s; te[7] *= _s; te[11] *= _s; te[15] *= _s;\r\n\r\n        return this;\r\n\r\n    } //multiplyScalar\r\n\r\n\r\n    public inline function multiplyVector3Array( _a:Array<Float> ) : Array<Float> {\r\n\r\n        var v1 = new Vector();\r\n        var i = 0;\r\n        var il = _a.length;\r\n\r\n        while (i < il) {\r\n\r\n            v1.x = _a[i + 0];\r\n            v1.y = _a[i + 1];\r\n            v1.z = _a[i + 2];\r\n\r\n            v1.applyProjection( this );\r\n\r\n            _a[i + 0] = v1.x;\r\n            _a[i + 1] = v1.y;\r\n            _a[i + 2] = v1.z;\r\n\r\n            i += 3;\r\n\r\n        }\r\n\r\n        return _a;\r\n\r\n    } //multiplyVector3Array\r\n\r\n    public inline function determinant() : Float {\r\n\r\n        var te = elements;\r\n\r\n        var n11 = te[0], n12 = te[4], n13 = te[8],  n14 = te[12];\r\n        var n21 = te[1], n22 = te[5], n23 = te[9],  n24 = te[13];\r\n        var n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];\r\n        var n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];\r\n\r\n        return (\r\n            n41 * (\r\n                 n14 * n23 * n32\r\n                -n13 * n24 * n32\r\n                -n14 * n22 * n33\r\n                +n12 * n24 * n33\r\n                +n13 * n22 * n34\r\n                -n12 * n23 * n34\r\n            ) +\r\n            n42 * (\r\n                 n11 * n23 * n34\r\n                -n11 * n24 * n33\r\n                +n14 * n21 * n33\r\n                -n13 * n21 * n34\r\n                +n13 * n24 * n31\r\n                -n14 * n23 * n31\r\n            ) +\r\n            n43 * (\r\n                 n11 * n24 * n32\r\n                -n11 * n22 * n34\r\n                -n14 * n21 * n32\r\n                +n12 * n21 * n34\r\n                +n14 * n22 * n31\r\n                -n12 * n24 * n31\r\n            ) +\r\n            n44 * (\r\n                -n13 * n22 * n31\r\n                -n11 * n23 * n32\r\n                +n11 * n22 * n33\r\n                +n13 * n21 * n32\r\n                -n12 * n21 * n33\r\n                +n12 * n23 * n31\r\n            )\r\n        );\r\n    } //determinant\r\n\r\n    public inline function transpose() : Matrix {\r\n\r\n        var te = elements;\r\n        var tmp:Float;\r\n\r\n        tmp = te[1]; te[1] = te[4]; te[4] = tmp;\r\n        tmp = te[2]; te[2] = te[8]; te[8] = tmp;\r\n        tmp = te[6]; te[6] = te[9]; te[9] = tmp;\r\n\r\n        tmp = te[3];  te[3]  = te[12]; te[12] = tmp;\r\n        tmp = te[7];  te[7]  = te[13]; te[13] = tmp;\r\n        tmp = te[11]; te[11] = te[14]; te[14] = tmp;\r\n\r\n        return this;\r\n\r\n    } //transpose\r\n\r\n    public inline function flattenToArray( _flat:Array<Float> = null ) : Array<Float> {\r\n\r\n        if (_flat == null) {\r\n            _flat = new Array<Float>();\r\n            for(i in 0 ... 16) _flat.push( 0.0 );\r\n        }\r\n\r\n        var te = elements;\r\n\r\n            _flat[ 0 ]  = te[0];  _flat[ 1 ]  = te[1];  _flat[ 2 ]  = te[2];  _flat[ 3 ]  = te[3];\r\n            _flat[ 4 ]  = te[4];  _flat[ 5 ]  = te[5];  _flat[ 6 ]  = te[6];  _flat[ 7 ]  = te[7];\r\n            _flat[ 8 ]  = te[8];  _flat[ 9 ]  = te[9];  _flat[ 10 ] = te[10]; _flat[ 11 ] = te[11];\r\n            _flat[ 12 ] = te[12]; _flat[ 13 ] = te[13]; _flat[ 14 ] = te[14]; _flat[ 15 ] = te[15];\r\n\r\n        return _flat;\r\n\r\n    } //flattenToArray\r\n\r\n\r\n    public inline function flattenToArrayOffset( _flat:Array<Float>, _offset:Int ) : Array<Float> {\r\n\r\n        var te = elements;\r\n\r\n            _flat[ _offset + 0 ]  = te[0];\r\n            _flat[ _offset + 1 ]  = te[1];\r\n            _flat[ _offset + 2 ]  = te[2];\r\n            _flat[ _offset + 3 ]  = te[3];\r\n\r\n            _flat[ _offset + 4 ]  = te[4];\r\n            _flat[ _offset + 5 ]  = te[5];\r\n            _flat[ _offset + 6 ]  = te[6];\r\n            _flat[ _offset + 7 ]  = te[7];\r\n\r\n            _flat[ _offset + 8 ]  = te[8];\r\n            _flat[ _offset + 9 ]  = te[9];\r\n            _flat[ _offset + 10 ] = te[10];\r\n            _flat[ _offset + 11 ] = te[11];\r\n\r\n            _flat[ _offset + 12 ] = te[12];\r\n            _flat[ _offset + 13 ] = te[13];\r\n            _flat[ _offset + 14 ] = te[14];\r\n            _flat[ _offset + 15 ] = te[15];\r\n\r\n        return _flat;\r\n\r\n    } //flattenToArrayOffset\r\n\r\n\r\n    public inline function setPosition( _v:Vector ) : Matrix {\r\n\r\n        var te = elements;\r\n\r\n            te[12] = _v.x;\r\n            te[13] = _v.y;\r\n            te[14] = _v.z;\r\n\r\n        return this;\r\n\r\n    } //setPosition\r\n\r\n    public inline function inverse() : Matrix {\r\n        return clone().getInverse(this);\r\n    }\r\n\r\n    public inline function getInverse( _m:Matrix ) : Matrix {\r\n\r\n        // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\r\n\r\n        var te = elements;\r\n        var me = _m.elements;\r\n\r\n        var n11 = me[0], n12 = me[4], n13 = me[8],  n14 = me[12];\r\n        var n21 = me[1], n22 = me[5], n23 = me[9],  n24 = me[13];\r\n        var n31 = me[2], n32 = me[6], n33 = me[10], n34 = me[14];\r\n        var n41 = me[3], n42 = me[7], n43 = me[11], n44 = me[15];\r\n\r\n            te[0]  = n23*n34*n42 - n24*n33*n42 + n24*n32*n43 - n22*n34*n43 - n23*n32*n44 + n22*n33*n44;\r\n            te[4]  = n14*n33*n42 - n13*n34*n42 - n14*n32*n43 + n12*n34*n43 + n13*n32*n44 - n12*n33*n44;\r\n            te[8]  = n13*n24*n42 - n14*n23*n42 + n14*n22*n43 - n12*n24*n43 - n13*n22*n44 + n12*n23*n44;\r\n            te[12] = n14*n23*n32 - n13*n24*n32 - n14*n22*n33 + n12*n24*n33 + n13*n22*n34 - n12*n23*n34;\r\n            te[1]  = n24*n33*n41 - n23*n34*n41 - n24*n31*n43 + n21*n34*n43 + n23*n31*n44 - n21*n33*n44;\r\n            te[5]  = n13*n34*n41 - n14*n33*n41 + n14*n31*n43 - n11*n34*n43 - n13*n31*n44 + n11*n33*n44;\r\n            te[9]  = n14*n23*n41 - n13*n24*n41 - n14*n21*n43 + n11*n24*n43 + n13*n21*n44 - n11*n23*n44;\r\n            te[13] = n13*n24*n31 - n14*n23*n31 + n14*n21*n33 - n11*n24*n33 - n13*n21*n34 + n11*n23*n34;\r\n            te[2]  = n22*n34*n41 - n24*n32*n41 + n24*n31*n42 - n21*n34*n42 - n22*n31*n44 + n21*n32*n44;\r\n            te[6]  = n14*n32*n41 - n12*n34*n41 - n14*n31*n42 + n11*n34*n42 + n12*n31*n44 - n11*n32*n44;\r\n            te[10] = n12*n24*n41 - n14*n22*n41 + n14*n21*n42 - n11*n24*n42 - n12*n21*n44 + n11*n22*n44;\r\n            te[14] = n14*n22*n31 - n12*n24*n31 - n14*n21*n32 + n11*n24*n32 + n12*n21*n34 - n11*n22*n34;\r\n            te[3]  = n23*n32*n41 - n22*n33*n41 - n23*n31*n42 + n21*n33*n42 + n22*n31*n43 - n21*n32*n43;\r\n            te[7]  = n12*n33*n41 - n13*n32*n41 + n13*n31*n42 - n11*n33*n42 - n12*n31*n43 + n11*n32*n43;\r\n            te[11] = n13*n22*n41 - n12*n23*n41 - n13*n21*n42 + n11*n23*n42 + n12*n21*n43 - n11*n22*n43;\r\n            te[15] = n12*n23*n31 - n13*n22*n31 + n13*n21*n32 - n11*n23*n32 - n12*n21*n33 + n11*n22*n33;\r\n\r\n        var det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 4 ] + me[ 2 ] * te[ 8 ] + me[ 3 ] * te[ 12 ];\r\n\r\n        if (det == 0) {\r\n\r\n            trace('Matrix.getInverse: cant invert matrix, determinant is 0');\r\n\r\n            identity();\r\n\r\n            return this;\r\n\r\n        } //det == 0\r\n\r\n        multiplyScalar( 1 / det );\r\n\r\n        return this;\r\n\r\n    } //getInverse\r\n\r\n\r\n    public inline function scale( _v:Vector ) : Matrix {\r\n\r\n        var te = elements;\r\n\r\n            var _x = _v.x;\r\n            var _y = _v.y;\r\n            var _z = _v.z;\r\n\r\n            te[0] *= _x; te[4] *= _y; te[8]  *= _z;\r\n            te[1] *= _x; te[5] *= _y; te[9]  *= _z;\r\n            te[2] *= _x; te[6] *= _y; te[10] *= _z;\r\n            te[3] *= _x; te[7] *= _y; te[11] *= _z;\r\n\r\n        return this;\r\n\r\n    } //scale\r\n\r\n\r\n    public inline function getMaxScaleOnAxis() : Float {\r\n\r\n        var te = elements;\r\n\r\n            var _scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2]  * te[2];\r\n            var _scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6]  * te[6];\r\n            var _scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];\r\n\r\n        return Math.sqrt( Math.max( _scaleXSq, Math.max( _scaleYSq, _scaleZSq ) ) );\r\n\r\n    } //getMaxScaleOnAxis\r\n\r\n\r\n    public inline function makeTranslation( _x:Float, _y:Float, _z:Float ) : Matrix {\r\n\r\n        set(\r\n            1, 0, 0, _x,\r\n            0, 1, 0, _y,\r\n            0, 0, 1, _z,\r\n            0, 0, 0, 1\r\n        );\r\n\r\n        return this;\r\n\r\n    } //makeTranslation\r\n\r\n\r\n    public inline function makeRotationX( _theta:Float ) : Matrix {\r\n\r\n        var _c = Math.cos(_theta);\r\n        var _s = Math.sin(_theta);\r\n\r\n            set(\r\n                1,  0,   0,  0,\r\n                0, _c, -_s,  0,\r\n                0, _s,  _c,  0,\r\n                0,  0,   0,  1\r\n            );\r\n\r\n        return this;\r\n\r\n    } //makeRotationX\r\n\r\n\r\n    public inline function makeRotationY(_theta:Float) : Matrix {\r\n\r\n        var _c = Math.cos(_theta);\r\n        var _s = Math.sin(_theta);\r\n\r\n            set(\r\n                 _c,  0, _s,  0,\r\n                  0,  1,  0,  0,\r\n                -_s,  0, _c,  0,\r\n                  0,  0,  0,  1\r\n            );\r\n\r\n        return this;\r\n\r\n    } //makeRotationY\r\n\r\n\r\n    public inline function makeRotationZ(_theta:Float) : Matrix {\r\n\r\n        var _c = Math.cos(_theta);\r\n        var _s = Math.sin(_theta);\r\n\r\n            set(\r\n                _c, -_s,  0,  0,\r\n                _s,  _c,  0,  0,\r\n                 0,   0,  1,  0,\r\n                 0,   0,  0,  1\r\n            );\r\n\r\n        return this;\r\n\r\n    } //makeRotationZ\r\n\r\n\r\n    public inline function makeRotationAxis( _axis:Vector, _angle:Float ) : Matrix {\r\n\r\n        var _c = Math.cos( _angle );\r\n        var _s = Math.sin( _angle );\r\n        var _t = 1 - _c;\r\n\r\n        var _ax = _axis.x;\r\n        var _ay = _axis.y;\r\n        var _az = _axis.z;\r\n\r\n        var _tx = _t * _ax;\r\n        var _ty = _t * _ay;\r\n\r\n            set(\r\n                _tx * _ax + _c,         _tx * _ay - _s * _az,   _tx * _az + _s  * _ay,  0,\r\n                _tx * _ay + _s * _az,   _ty * _ay + _c,         _ty * _az - _s  * _ax,  0,\r\n                _tx * _az - _s * _ay,   _ty * _az + _s * _ax,   _t  * _az * _az + _c,   0,\r\n                0, 0, 0, 1\r\n            );\r\n\r\n        return this;\r\n\r\n    } //makeRotationAxis\r\n\r\n\r\n    public inline function makeScale( _x:Float, _y:Float, _z:Float) : Matrix {\r\n\r\n            set(\r\n                _x,  0,  0,  0,\r\n                 0, _y,  0,  0,\r\n                 0,  0, _z,  0,\r\n                 0,  0,  0,  1\r\n            );\r\n\r\n        return this;\r\n\r\n    } //makeScale\r\n\r\n\r\n    public inline function compose_with_origin( _position:Vector, _origin:Vector, _quaternion:Quaternion, _scale:Vector ) : Matrix {\r\n\r\n        //this isn't very optimized\r\n        //translate to origin -> scale -> rotate -> translate -origin -> apply position\r\n\r\n            //origin ->\r\n        makeTranslation(_origin.x, _origin.y, _origin.z);\r\n            //scale ->\r\n        scale(_scale);\r\n            //rotation\r\n        multiply( new Matrix().makeRotationFromQuaternion(_quaternion) );\r\n            //translate -origin\r\n        multiply( new Matrix().makeTranslation(-_origin.x, -_origin.y, -_origin.z) );\r\n            //apply position\r\n        multiply( new Matrix().makeTranslation(_position.x, _position.y, _position.z) );\r\n\r\n        return this;\r\n\r\n    }\r\n\r\n    public inline function compose( _position:Vector, _quaternion:Quaternion, _scale:Vector ) : Matrix {\r\n\r\n            makeRotationFromQuaternion( _quaternion );\r\n            scale( _scale );\r\n            setPosition( _position );\r\n\r\n        return this;\r\n\r\n    } //compose\r\n\r\n    var _transform : MatrixTransform;\r\n\r\n    public inline function decompose( _position:Vector = null, _quaternion:Quaternion = null, _scale:Vector = null ) : MatrixTransform {\r\n\r\n        var te = elements;\r\n        var matrix = new Matrix();\r\n\r\n        var _ax_x = te[0]; var _ax_y = te[1]; var _ax_z = te[2];\r\n        var _ay_x = te[4]; var _ay_y = te[5]; var _ay_z = te[6];\r\n        var _az_x = te[8]; var _az_y = te[9]; var _az_z = te[10];\r\n\r\n        var _ax_length = Math.sqrt( _ax_x * _ax_x + _ax_y * _ax_y + _ax_z * _ax_z );\r\n        var _ay_length = Math.sqrt( _ay_x * _ay_x + _ay_y * _ay_y + _ay_z * _ay_z );\r\n        var _az_length = Math.sqrt( _az_x * _az_x + _az_y * _az_y + _az_z * _az_z );\r\n\r\n\r\n        if (_quaternion == null) {\r\n            _quaternion = new Quaternion();\r\n        }\r\n\r\n        if (_position == null) {\r\n            _position = new Vector(te[12], te[13], te[14]);\r\n        } else {\r\n            _position.x = te[12];\r\n            _position.y = te[13];\r\n            _position.z = te[14];\r\n        }\r\n\r\n        if (_scale == null) {\r\n            _scale = new Vector(_ax_length,_ay_length,_az_length);\r\n        } else {\r\n            _scale.x = _ax_length;\r\n            _scale.y = _ay_length;\r\n            _scale.z = _az_length;\r\n        }\r\n\r\n                //copy them without .copy()\r\n            matrix.elements = elements.concat([]);\r\n\r\n            var me = matrix.elements;\r\n\r\n                me[0]  /= _ax_length;\r\n                me[1]  /= _ax_length;\r\n                me[2]  /= _ax_length;\r\n\r\n                me[4]  /= _ay_length;\r\n                me[5]  /= _ay_length;\r\n                me[6]  /= _ay_length;\r\n\r\n                me[8]  /= _az_length;\r\n                me[9]  /= _az_length;\r\n                me[10] /= _az_length;\r\n\r\n            _quaternion.setFromRotationMatrix( matrix );\r\n\r\n\r\n        if(_transform == null) {\r\n            _transform = new MatrixTransform(_position, _quaternion, _scale);\r\n        } else {\r\n            _transform.pos = _position;\r\n            _transform.rotation = _quaternion;\r\n            _transform.scale = _scale;\r\n        }\r\n\r\n        return _transform;\r\n\r\n    } //decompose\r\n\r\n\r\n    public inline function makeFrustum( _left:Float, _right:Float, _bottom:Float, _top:Float, _near:Float, _far:Float ) : Matrix {\r\n\r\n        var te = elements;\r\n\r\n        var tx = 2 * _near / (_right - _left);\r\n        var ty = 2 * _near / (_top - _bottom);\r\n\r\n        var a =  (_right + _left) / (_right - _left);\r\n        var b =  (_top + _bottom) / (_top - _bottom);\r\n        var c = -(_far + _near)   / (_far - _near);\r\n        var d = -2 * _far * _near / (_far - _near);\r\n\r\n            te[0] = tx;     te[4] = 0;      te[8]  = a;     te[12] = 0;\r\n            te[1] = 0;      te[5] = ty;     te[9]  = b;     te[13] = 0;\r\n            te[2] = 0;      te[6] = 0;      te[10] = c;     te[14] = d;\r\n            te[3] = 0;      te[7] = 0;      te[11] = -1;    te[15] = 0;\r\n\r\n        return this;\r\n\r\n    } //makeFrustum\r\n\r\n\r\n    public inline function makePerspective( _fov:Float, _aspect:Float, _near:Float, _far:Float ) : Matrix {\r\n\r\n        var ymax = _near * Math.tan( Maths.radians(_fov * 0.5) );\r\n        var ymin = -ymax;\r\n        var xmin = ymin * _aspect;\r\n        var xmax = ymax * _aspect;\r\n\r\n        return makeFrustum( xmin, xmax, ymin, ymax, _near, _far );\r\n\r\n    } //makePerspective\r\n\r\n\r\n    public inline function makeOrthographic( _left:Float, _right:Float, _top:Float, _bottom:Float, _near:Float, _far:Float ) : Matrix {\r\n\r\n        var te = elements;\r\n\r\n        var w = _right - _left;\r\n        var h = _top - _bottom;\r\n        var p = _far - _near;\r\n\r\n        var tx = ( _right + _left )   / w;\r\n        var ty = ( _top   + _bottom ) / h;\r\n        var tz = ( _far   + _near )   / p;\r\n\r\n            te[0] = 2 / w;  te[4] = 0;      te[8] = 0;       te[12] = -tx;\r\n            te[1] = 0;      te[5] = 2 / h;  te[9] = 0;       te[13] = -ty;\r\n            te[2] = 0;      te[6] = 0;      te[10] = -2 / p; te[14] = -tz;\r\n            te[3] = 0;      te[7] = 0;      te[11] = 0;      te[15] = 1;\r\n\r\n        return this;\r\n\r\n    } //makeOrthographic\r\n\r\n    public inline function fromArray(_from:Array<Float>) {\r\n\r\n        elements = _from.concat([]);\r\n\r\n    } //fromArray\r\n\r\n    public inline function toArray() : Array<Float> {\r\n\r\n        var te = elements;\r\n\r\n            return [\r\n                te[ 0 ],  te[ 1 ],  te[ 2 ],  te[ 3 ],\r\n                te[ 4 ],  te[ 5 ],  te[ 6 ],  te[ 7 ],\r\n                te[ 8 ],  te[ 9 ],  te[ 10 ], te[ 11 ],\r\n                te[ 12 ], te[ 13 ], te[ 14 ], te[ 15 ]\r\n            ];\r\n\r\n    } //toArray\r\n\r\n    public inline function clone() : Matrix {\r\n\r\n        var te = elements;\r\n\r\n            return new Matrix(\r\n                te[0], te[4], te[8],  te[12],\r\n                te[1], te[5], te[9],  te[13],\r\n                te[2], te[6], te[10], te[14],\r\n                te[3], te[7], te[11], te[15]\r\n            );\r\n\r\n    } //clone\r\n\r\n    public inline function up() {\r\n        return new Vector( elements[4], elements[5], elements[10] );\r\n    } //up\r\n\r\n    public inline function down() : Vector {\r\n        return up().inverted;\r\n    } //down\r\n\r\n    public inline function left() : Vector {\r\n        return right().inverted;\r\n    } //left\r\n\r\n    public inline function right() : Vector {\r\n        return new Vector( elements[0], elements[1], elements[2] );\r\n    } //right\r\n\r\n    public inline function backward() {\r\n        return new Vector( elements[8], elements[9], elements[10] );\r\n    } //backward\r\n\r\n    public inline function forward() : Vector {\r\n        return backward().inverted;\r\n    } //forward\r\n\r\n\r\n} //Matrix\r\n\r\n","package phoenix;\r\n\r\nimport phoenix.Vector;\r\n\r\n    //Ported from Three.js https://github.com/mrdoob/three.js\r\n\r\nclass Quaternion {\r\n\r\n    @:isVar public var x(default,set) : Float = 0.0;\r\n    @:isVar public var y(default,set) : Float = 0.0;\r\n    @:isVar public var z(default,set) : Float = 0.0;\r\n    @:isVar public var w(default,set) : Float = 0.0;\r\n\r\n    var euler : Vector;\r\n\r\n    public var ignore_listeners : Bool = false;\r\n\r\n    @:isVar public var listen_x(default,default) : Float -> Void;\r\n    @:isVar public var listen_y(default,default) : Float -> Void;\r\n    @:isVar public var listen_z(default,default) : Float -> Void;\r\n    @:isVar public var listen_w(default,default) : Float -> Void;\r\n\r\n    var _construct = false;\r\n\r\n    public function new(_x:Float = 0, _y:Float = 0, _z:Float = 0, _w:Float = 1) {\r\n\r\n        _construct = true;\r\n\r\n            x = _x;\r\n            y = _y;\r\n            z = _z;\r\n            w = _w;\r\n\r\n        euler = new Vector();\r\n\r\n        _construct = false;\r\n\r\n    } //new\r\n\r\n    function toString() {\r\n\r\n        return \"{ x:\"+x + \", y:\" + y + \", z:\" + z  + \", w:\" + w  +  \" }\" ;\r\n\r\n    } //toString\r\n\r\n    public function set( _x:Float, _y:Float, _z:Float, _w:Float ) : Quaternion {\r\n\r\n        set_xyzw(_x, _y, _z, _w);\r\n\r\n        return this;\r\n\r\n    } //set\r\n\r\n\r\n    public function copy( _quaternion :Quaternion ) : Quaternion {\r\n\r\n            set_xyzw( _quaternion.x,\r\n                      _quaternion.y,\r\n                      _quaternion.z,\r\n                      _quaternion.w );\r\n\r\n        return this;\r\n\r\n    } //copy\r\n\r\n    public function dot( _other:Quaternion ) {\r\n        return x * _other.x + y * _other.y + z * _other.z + w * _other.w;\r\n    }\r\n\r\n\r\n    public function setFromEuler( _euler:Vector, _order:ComponentOrder = XYZ ) : Quaternion {\r\n\r\n            // http://www.mathworks.com/matlabcentral/fileexchange/\r\n            //  20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\r\n            //  content/SpinCalc.m\r\n\r\n        var _x = x;\r\n        var _y = y;\r\n        var _z = z;\r\n        var _w = w;\r\n\r\n        var c1 = Math.cos( _euler.x / 2 );\r\n        var c2 = Math.cos( _euler.y / 2 );\r\n        var c3 = Math.cos( _euler.z / 2 );\r\n\r\n        var s1 = Math.sin( _euler.x / 2 );\r\n        var s2 = Math.sin( _euler.y / 2 );\r\n        var s3 = Math.sin( _euler.z / 2 );\r\n\r\n            if ( _order == XYZ ) {\r\n\r\n                _x = s1 * c2 * c3 + c1 * s2 * s3;\r\n                _y = c1 * s2 * c3 - s1 * c2 * s3;\r\n                _z = c1 * c2 * s3 + s1 * s2 * c3;\r\n                _w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\r\n            } else if ( _order == YXZ ) {\r\n\r\n                _x = s1 * c2 * c3 + c1 * s2 * s3;\r\n                _y = c1 * s2 * c3 - s1 * c2 * s3;\r\n                _z = c1 * c2 * s3 - s1 * s2 * c3;\r\n                _w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\r\n            } else if ( _order == ZXY ) {\r\n\r\n                _x = s1 * c2 * c3 - c1 * s2 * s3;\r\n                _y = c1 * s2 * c3 + s1 * c2 * s3;\r\n                _z = c1 * c2 * s3 + s1 * s2 * c3;\r\n                _w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\r\n            } else if ( _order == ZYX ) {\r\n\r\n                _x = s1 * c2 * c3 - c1 * s2 * s3;\r\n                _y = c1 * s2 * c3 + s1 * c2 * s3;\r\n                _z = c1 * c2 * s3 - s1 * s2 * c3;\r\n                _w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\r\n            } else if ( _order == YZX ) {\r\n\r\n                _x = s1 * c2 * c3 + c1 * s2 * s3;\r\n                _y = c1 * s2 * c3 + s1 * c2 * s3;\r\n                _z = c1 * c2 * s3 - s1 * s2 * c3;\r\n                _w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\r\n            } else if ( _order == XZY ) {\r\n\r\n                _x = s1 * c2 * c3 - c1 * s2 * s3;\r\n                _y = c1 * s2 * c3 - s1 * c2 * s3;\r\n                _z = c1 * c2 * s3 + s1 * s2 * c3;\r\n                _w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\r\n            }\r\n\r\n        set_xyzw(_x, _y, _z, _w);\r\n\r\n        return this;\r\n\r\n    } //setFromEuler\r\n\r\n\r\n    public function setFromAxisAngle( _axis:Vector, _angle:Float ) : Quaternion {\r\n\r\n        // from http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\r\n        // axis have to be normalized\r\n\r\n        var _halfAngle = _angle / 2;\r\n        var _s = Math.sin( _halfAngle );\r\n\r\n            set_xyzw( _axis.x * _s,\r\n                      _axis.y * _s,\r\n                      _axis.z * _s,\r\n                      Math.cos( _halfAngle ) );\r\n\r\n        return this;\r\n\r\n    } //setFromAxisAngle\r\n\r\n\r\n    public function setFromRotationMatrix( _m:Matrix ) : Quaternion {\r\n\r\n        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\r\n        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n        var te = _m.elements;\r\n\r\n        var m11 = te[0], m12 = te[4], m13 = te[8];\r\n        var m21 = te[1], m22 = te[5], m23 = te[9];\r\n        var m31 = te[2], m32 = te[6], m33 = te[10];\r\n\r\n        var _x = x;\r\n        var _y = y;\r\n        var _z = z;\r\n        var _w = w;\r\n\r\n        var tr = m11 + m22 + m33;\r\n\r\n        var s : Float;\r\n\r\n            if (tr > 0) {\r\n\r\n                s = 0.5 / Math.sqrt( tr + 1.0 );\r\n\r\n                _w = 0.25 / s;\r\n                _x = (m32 - m23) * s;\r\n                _y = (m13 - m31) * s;\r\n                _z = (m21 - m12) * s;\r\n\r\n            } else if (m11 > m22 && m11 > m33) {\r\n\r\n                s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);\r\n\r\n                _w = (m32 - m23) / s;\r\n                _x = 0.25 * s;\r\n                _y = (m12 + m21) / s;\r\n                _z = (m13 + m31) / s;\r\n\r\n            } else if (m22 > m33) {\r\n\r\n                s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);\r\n\r\n                _w = (m13 - m31) / s;\r\n                _x = (m12 + m21) / s;\r\n                _y = 0.25 * s;\r\n                _z = (m23 + m32) / s;\r\n\r\n            } else {\r\n\r\n                s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);\r\n\r\n                _w = (m21 - m12) / s;\r\n                _x = (m13 + m31) / s;\r\n                _y = (m23 + m32) / s;\r\n                _z = 0.25 * s;\r\n\r\n            }\r\n\r\n        set_xyzw(_x, _y, _z, _w);\r\n\r\n        return this;\r\n\r\n    } //setFromRotationMatrix\r\n\r\n\r\n    public function inverse() : Quaternion {\r\n\r\n        return conjugate().normalize();\r\n\r\n    } //inverse\r\n\r\n\r\n    public function conjugate() : Quaternion {\r\n\r\n        set_xyz( x * -1, y * -1, z * -1);\r\n\r\n        return this;\r\n\r\n    } //conjugate\r\n\r\n\r\n    public function lengthSq() : Float {\r\n\r\n        return x * x + y * y + z * z + w * w;\r\n\r\n    } //lengthSq\r\n\r\n\r\n    public function length() : Float {\r\n\r\n        return Math.sqrt(x * x + y * y + z * z + w * w);\r\n\r\n    } //length\r\n\r\n\r\n    public function normalize() : Quaternion {\r\n\r\n        var l = length();\r\n\r\n            if (l == 0) {\r\n\r\n                set_xyzw(0,0,0,1);\r\n\r\n            } else {\r\n\r\n                l = 1 / l;\r\n\r\n                set_xyzw( x*l, y*l, z*l, w*l );\r\n\r\n            }\r\n\r\n        return this;\r\n\r\n    } //normalize\r\n\r\n    public static function Add( _a:Quaternion, _b:Quaternion ):Quaternion {\r\n        return _a.clone().add(_b);\r\n    }\r\n    \r\n    public static function Multiply( _a:Quaternion, _b:Quaternion ):Quaternion {\r\n        return _a.clone().multiply(_b);\r\n    }\r\n    \r\n    public static function MultiplyScalar(_quaternion:Quaternion, _scalar:Float):Quaternion {\r\n        return _quaternion.clone().multiplyScalar(_scalar);\r\n    }\r\n    \r\n    public function multiply( _quaternion:Quaternion ) : Quaternion {\r\n\r\n        return multiplyQuaternions( this, _quaternion );\r\n\r\n    } //multiply\r\n\r\n    public function add( _quaternion:Quaternion ) : Quaternion {\r\n\r\n        return addQuaternions( this, _quaternion );\r\n\r\n    } //add\r\n\r\n    public function addQuaternions( _a:Quaternion, _b:Quaternion ) {\r\n\r\n            x = _a.x + _b.x;\r\n            y = _a.y + _b.y;\r\n            z = _a.z + _b.z;\r\n            w = _a.w + _b.w;\r\n\r\n        return this;\r\n\r\n    } //addQuaternions\r\n\r\n    public function multiplyScalar( _scalar:Float ) : Quaternion {\r\n\r\n            x *= _scalar;\r\n            y *= _scalar;\r\n            z *= _scalar;\r\n            w *= _scalar;\r\n\r\n        return this;\r\n\r\n    } //multiply\r\n\r\n    public function multiplyQuaternions( _a:Quaternion, _b:Quaternion ) : Quaternion {\r\n\r\n        var qax = _a.x, qay = _a.y, qaz = _a.z, qaw = _a.w;\r\n        var qbx = _b.x, qby = _b.y, qbz = _b.z, qbw = _b.w;\r\n\r\n            set_xyzw( qax * qbw + qaw * qbx + qay * qbz - qaz * qby,\r\n                      qay * qbw + qaw * qby + qaz * qbx - qax * qbz,\r\n                      qaz * qbw + qaw * qbz + qax * qby - qay * qbx,\r\n                      qaw * qbw - qax * qbx - qay * qby - qaz * qbz );\r\n\r\n        return this;\r\n\r\n    } //multiplyQuaternions\r\n\r\n\r\n    public function slerp( _qb:Quaternion, _t:Float ) : Quaternion {\r\n\r\n        var _x = x;\r\n        var _y = y;\r\n        var _z = z;\r\n        var _w = w;\r\n\r\n        // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\r\n\r\n        var cosHalfTheta = _w * _qb.w + _x * _qb.x + _y * _qb.y + _z * _qb.z;\r\n\r\n        if ( cosHalfTheta < 0 ) {\r\n\r\n                w = -_qb.w;\r\n                x = -_qb.x;\r\n                y = -_qb.y;\r\n                z = -_qb.z;\r\n\r\n                cosHalfTheta = -cosHalfTheta;\r\n\r\n        } else {\r\n\r\n            this.copy( _qb );\r\n\r\n        }\r\n\r\n        if ( cosHalfTheta >= 1.0 ) {\r\n\r\n            set_xyzw(_x, _y, _z, _w);\r\n\r\n            return this;\r\n\r\n        }\r\n\r\n        var halfTheta = Math.acos( cosHalfTheta );\r\n        var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );\r\n\r\n        if ( Math.abs( sinHalfTheta ) < 0.001 ) {\r\n\r\n            set_xyzw( 0.5 * ( _w + w ),\r\n                      0.5 * ( _x + x ),\r\n                      0.5 * ( _y + y ),\r\n                      0.5 * ( _z + z ) );\r\n\r\n            return this;\r\n\r\n        }\r\n\r\n        var ratioA = Math.sin( ( 1 - _t ) * halfTheta ) / sinHalfTheta,\r\n        ratioB = Math.sin( _t * halfTheta ) / sinHalfTheta;\r\n\r\n            set_xyzw( _w * ratioA + w * ratioB,\r\n                      _x * ratioA + x * ratioB,\r\n                      _y * ratioA + y * ratioB,\r\n                      _z * ratioA + z * ratioB );\r\n\r\n        return this;\r\n\r\n    } //slerp\r\n\r\n\r\n    public function equals( _q:Quaternion ) : Bool {\r\n\r\n        return ( (_q.x == x) && (_q.y == y) && (_q.z == z) && (_q.w == w) );\r\n\r\n    } //equals\r\n\r\n\r\n    public function fromArray( _a:Array<Float> ) : Quaternion {\r\n\r\n        set_xyzw(_a[0], _a[1], _a[2], _a[3]);\r\n\r\n        return this;\r\n\r\n    } //fromArray\r\n\r\n\r\n    public function toArray() : Array<Float> {\r\n\r\n        return [ x,y,z,w ];\r\n\r\n    } //toArray\r\n\r\n    public function clone() : Quaternion {\r\n\r\n        return new Quaternion( x, y, z, w );\r\n\r\n    } //clone\r\n\r\n    public function toeuler() {\r\n        return new Vector().setEulerFromQuaternion(this).degrees();\r\n    }\r\n\r\n    public static function Slerp( _qa:Quaternion , _qb:Quaternion, _qm:Quaternion , _t:Float ) : Quaternion {\r\n\r\n        return _qm.copy( _qa ).slerp( _qb, _t );\r\n\r\n    } //Slerp\r\n\r\n    public static function Dot( _a:Quaternion,  _b:Quaternion ) {\r\n        return new Quaternion(_a.x,_a.y,_a.z,_a.w).dot(_b);\r\n    }\r\n\r\n    inline function update_euler() {\r\n\r\n        if( euler == null || ignore_euler || _construct) {\r\n            return;\r\n        }\r\n\r\n        euler.setEulerFromQuaternion( this );\r\n\r\n    } //update_euler\r\n\r\n    var ignore_euler = false;\r\n\r\n    public inline function set_xyzw(_x:Float, _y:Float, _z:Float, _w:Float) {\r\n\r\n        ignore_euler = true;\r\n\r\n            x = _x;\r\n            y = _y;\r\n            z = _z;\r\n            w = _w;\r\n\r\n        ignore_euler = false;\r\n\r\n        update_euler();\r\n\r\n        if(listen_x != null && !ignore_listeners) listen_x(x);\r\n        if(listen_y != null && !ignore_listeners) listen_y(y);\r\n        if(listen_z != null && !ignore_listeners) listen_z(z);\r\n        if(listen_w != null && !ignore_listeners) listen_w(w);\r\n\r\n    } //set_xyzw\r\n\r\n    public inline function set_xyz(_x:Float, _y:Float, _z:Float) {\r\n\r\n        ignore_euler = true;\r\n\r\n            x = _x;\r\n            y = _y;\r\n            z = _z;\r\n\r\n        ignore_euler = false;\r\n\r\n        update_euler();\r\n\r\n        if(listen_x != null && !ignore_listeners) listen_x(x);\r\n        if(listen_y != null && !ignore_listeners) listen_y(y);\r\n        if(listen_z != null && !ignore_listeners) listen_z(z);\r\n\r\n    } //set_xyzw\r\n\r\n    inline function set_x( _v:Float ) {\r\n\r\n        x = _v;\r\n\r\n        if(_construct) return x;\r\n\r\n        update_euler();\r\n\r\n        if(listen_x != null && !ignore_listeners) listen_x(x);\r\n\r\n        return x;\r\n\r\n    } //set_x\r\n\r\n    inline function set_y( _v:Float ) {\r\n\r\n        y = _v;\r\n\r\n        if(_construct) return y;\r\n\r\n        update_euler();\r\n\r\n        if(listen_y != null && !ignore_listeners) listen_y(y);\r\n\r\n        return y;\r\n\r\n    } //set_y\r\n\r\n    inline function set_z( _v:Float ) {\r\n\r\n        z = _v;\r\n\r\n        if(_construct) return z;\r\n\r\n        update_euler();\r\n\r\n        if(listen_z != null && !ignore_listeners) listen_z(z);\r\n\r\n        return z;\r\n\r\n    } //set_z\r\n\r\n    inline function set_w( _v:Float ) {\r\n\r\n        w = _v;\r\n\r\n        if(_construct) return w;\r\n\r\n        update_euler();\r\n\r\n        if(listen_w != null && !ignore_listeners) listen_w(w);\r\n\r\n        return w;\r\n\r\n    } //set_w\r\n\r\n    public static inline function Listen( _q : Quaternion, listener ) {\r\n\r\n        _q.listen_x = listener;\r\n        _q.listen_y = listener;\r\n        _q.listen_z = listener;\r\n        _q.listen_w = listener;\r\n\r\n    } //listen\r\n\r\n} //Quaternion\r\n\r\n","package phoenix;\r\n\r\nimport phoenix.Rectangle;\r\nimport phoenix.Vector;\r\nimport phoenix.Camera;\r\n\r\nclass Ray { \r\n\r\n    public var origin : Vector;\r\n    public var end : Vector;\r\n    public var dir : Vector;\r\n\r\n    var camera : Camera;\r\n    var viewport : Rectangle;\r\n\r\n        //optional viewport size\r\n    public function new( _screen_pos:Vector, _camera:Camera, ?_viewport:Rectangle=null ) {\r\n\r\n        if(_viewport == null) {\r\n            _viewport = new Rectangle(0,0,Luxe.screen.w, Luxe.screen.h);\r\n        }\r\n\r\n        if(_camera == null) throw \"Camera required for a ray!\";\r\n\r\n        camera = _camera;\r\n        viewport = _viewport;\r\n\r\n       refresh(_screen_pos);\r\n\r\n    } //new\r\n\r\n    public function refresh( _screen_pos:Vector ) {\r\n\r\n            //calculate the x and y in normalized device coordinates first [-1, 1] on both axis\r\n        var ndc_x : Float = (_screen_pos.x/viewport.w  - 0.5) * 2.0;\r\n        var ndc_y : Float = ((viewport.h - _screen_pos.y)/viewport.h - 0.5) * 2.0;\r\n\r\n            //To calculate a ray we use [0,1] for the depth so we can get a direction\r\n        var start_ndc : Vector = new Vector( ndc_x, ndc_y, 0.0, 1.0 );\r\n        var end_ndc : Vector = new Vector( ndc_x, ndc_y, 1.0, 1.0 );\r\n            //So we have a near and a far clipping space coords for the mouse, now unproject it using the camera\r\n        origin = camera.unproject(start_ndc);\r\n        end = camera.unproject(end_ndc);\r\n        dir = Vector.Subtract(end, origin);\r\n\r\n    } //refresh\r\n\r\n} //Ray","package phoenix;\r\n\r\n\r\nclass Rectangle {\r\n\r\n    @:isVar public var x (default, set) : Float = 0;\r\n    @:isVar public var y (default, set) : Float = 0;\r\n    @:isVar public var w (default, set) : Float = 0;\r\n    @:isVar public var h (default, set) : Float = 0;\r\n\r\n    public var ignore_listeners : Bool = false;\r\n\r\n    @:isVar public var listen_x (default,default) : Float -> Void;\r\n    @:isVar public var listen_y (default,default) : Float -> Void;\r\n    @:isVar public var listen_w (default,default) : Float -> Void;\r\n    @:isVar public var listen_h (default,default) : Float -> Void;\r\n\r\n    public function new(?_x:Float = 0,?_y:Float = 0,?_w:Float = 0,?_h : Float = 0) {\r\n\r\n        x = _x;\r\n        y = _y;\r\n        w = _w;\r\n        h = _h;\r\n\r\n    } //new\r\n\r\n    function toString() {\r\n\r\n        return \"{ x:\"+x + \", y:\" + y + \", w:\" + w  + \", h:\" + h  + \" }\" ;\r\n\r\n    } //toString\r\n\r\n    public static function listen( _r:Rectangle, listener ) {\r\n        _r.listen_x = listener;\r\n        _r.listen_y = listener;\r\n        _r.listen_w = listener;\r\n        _r.listen_h = listener;\r\n    } //listen\r\n\r\n    public function point_inside( _p:Vector ) {\r\n\r\n        if(_p.x < x) return false;\r\n        if(_p.y < y) return false;\r\n        if(_p.x > x+w) return false;\r\n        if(_p.y > y+h) return false;\r\n\r\n        return true;\r\n\r\n    } //point_inside\r\n\r\n    public function overlaps( _other:Rectangle ) {\r\n\r\n        if(_other == null) {\r\n            return false;\r\n        }\r\n\r\n            //only need to test extremes\r\n        if( x < (_other.x + _other.w) &&\r\n            y < (_other.y + _other.h) &&\r\n            (x + w) > _other.x        &&\r\n            (y + h) > _other.y ) {\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public function clone() {\r\n\r\n        return new Rectangle(x,y,w,h);\r\n\r\n    } //clone\r\n\r\n        //:todo:, epsilon fp check version\r\n    public function equal( _other:Rectangle ) {\r\n\r\n        if(_other == null) {\r\n            return false;\r\n        }\r\n\r\n        return x == _other.x && y == _other.y && w == _other.w && h == _other.h;\r\n\r\n    } //equal\r\n\r\n    public function copy_from( _rect:Rectangle ) {\r\n\r\n        x = _rect.x;\r\n        y = _rect.y;\r\n        w = _rect.w;\r\n        h = _rect.h;\r\n\r\n    } //copy_from\r\n\r\n    public function set(?_x:Float, ?_y:Float, ?_w:Float, ?_h:Float) {\r\n\r\n        var _setx = x;\r\n        var _sety = y;\r\n        var _setw = w;\r\n        var _seth = h;\r\n\r\n                    //assign new values\r\n                if(_x != null) _setx = _x;\r\n                if(_y != null) _sety = _y;\r\n                if(_w != null) _setw = _w;\r\n                if(_h != null) _seth = _h;\r\n\r\n            x = _setx;\r\n            y = _sety;\r\n            w = _setw;\r\n            h = _seth;\r\n\r\n        return this;\r\n\r\n    } //set\r\n\r\n    function set_x(_x:Float) : Float {\r\n\r\n        x = _x;\r\n\r\n            if(listen_x != null && !ignore_listeners) {\r\n                listen_x(_x);\r\n            }\r\n\r\n        return x;\r\n\r\n    } //set_x\r\n\r\n    function set_y(_y:Float) : Float {\r\n\r\n        y = _y;\r\n\r\n            if(listen_y != null && !ignore_listeners) {\r\n                listen_y(_y);\r\n            }\r\n\r\n        return y;\r\n\r\n    } //set_y\r\n\r\n    function set_w(_w:Float) : Float {\r\n\r\n        w = _w;\r\n\r\n            if(listen_w != null && !ignore_listeners) {\r\n                listen_w(_w);\r\n            }\r\n\r\n        return w;\r\n\r\n    } //set_w\r\n\r\n    function set_h(_h:Float) : Float {\r\n\r\n        h = _h;\r\n\r\n            if(listen_h != null && !ignore_listeners) {\r\n                listen_h(_h);\r\n            }\r\n\r\n        return h;\r\n\r\n    } //set_h\r\n\r\n}","package phoenix;\r\n\r\nimport snow.render.opengl.GL;\r\nimport phoenix.Renderer;\r\nimport phoenix.Batcher;\r\n\r\n//Default base class will do forward rendering\r\n\r\nclass RenderPath {\r\n\r\n    public var renderer : Renderer;\r\n    public function new( _renderer:Renderer ) {\r\n        renderer = _renderer;\r\n    }\r\n\r\n    public function render( _batchers: Array<Batcher>, _stats:RendererStats ) {\r\n\r\n        for(batch in _batchers) {\r\n            if(batch.enabled) {\r\n\r\n                    //Measure the time and graph it in the debug view\r\n                Luxe.debug.start('batch.' + batch.name);\r\n\r\n                    //Tell the batcher to draw\r\n                batch.draw();\r\n\r\n                    //Update Render Stats\r\n                _stats.geometry_count += batch.geometry.size();\r\n                _stats.dynamic_batched_count += batch.dynamic_batched_count;\r\n                _stats.static_batched_count += batch.static_batched_count;\r\n                _stats.visible_count += batch.visible_count;\r\n                _stats.draw_calls += batch.draw_calls;\r\n                _stats.vert_count += batch.vert_count;\r\n                // _stats.group_count += batch.groups.\r\n\r\n                    //Stop Measuring\r\n                Luxe.debug.end('batch.' + batch.name);\r\n\r\n            } //batcher enabled\r\n        } //each batcher\r\n\r\n    } //render\r\n\r\n} //RenderPath\r\n\r\n","package phoenix;\r\n\r\nimport snow.render.opengl.GL;\r\n\r\nclass RenderState {\r\n\r\n    var cull_face : Bool = false;\r\n    var depth_test : Bool = false;\r\n    var depth_mask : Bool = true;\r\n    var renderer : Renderer;\r\n    var _viewport : Rectangle;\r\n\r\n\r\n    public function new( _renderer:Renderer ) {\r\n        renderer = _renderer;\r\n        _viewport = new Rectangle( 0, 0, 0, 0 );\r\n    }\r\n\r\n    public function enable( what:Int ) {\r\n        switch(what) {\r\n            case GL.CULL_FACE:\r\n                if(!cull_face) {\r\n                    cull_face = true;\r\n                    GL.enable(GL.CULL_FACE);\r\n                } //!cull_face\r\n            case GL.DEPTH_TEST:\r\n                if(Luxe.core.app.config.render.depth) {\r\n                    if(!depth_test) {\r\n                        depth_test = true;\r\n                        GL.enable(GL.DEPTH_TEST);\r\n                    }\r\n                } //!depth_test\r\n        } //switch\r\n    } //enable_if_not\r\n\r\n    public function disable( what:Int ) {\r\n        switch(what) {\r\n            case GL.CULL_FACE:\r\n                if(cull_face) {\r\n                    cull_face = false;\r\n                    GL.disable(GL.CULL_FACE);\r\n                } //cull_face\r\n            case GL.DEPTH_TEST:\r\n                if(Luxe.core.app.config.render.depth) {\r\n                    if(depth_test) {\r\n                        depth_test = false;\r\n                        GL.disable(GL.DEPTH_TEST);\r\n                    }\r\n                } //depth_test\r\n        } //switch\r\n    } //disable_if_not\r\n\r\n    var depth_func : Int = -1;\r\n    public function depth_function( what:Int ) {\r\n        if(depth_func != depth_func) {\r\n            GL.depthFunc( what );\r\n            depth_func = what;\r\n        }\r\n    } //depth_function\r\n\r\n    public function viewport( x:Float, y:Float, w:Float, h:Float ) {\r\n\r\n        if(\r\n            _viewport.x != x ||\r\n            _viewport.y != y ||\r\n            _viewport.w != w ||\r\n            _viewport.h != h\r\n        ) {\r\n\r\n            _viewport.x = x;\r\n            _viewport.y = y;\r\n            _viewport.w = w;\r\n            _viewport.h = h;\r\n\r\n                //In OpenGL the viewport is bottom left origin, so we flip the y\r\n                //when submitting our top left based coordinates.\r\n                //We use the target size property of the renderer, which\r\n                //when rendering to the screen matches the window and when\r\n                //rendering to a texture/render target, matches the target.\r\n            var _y : Float = renderer.target_size.y - (y + h);\r\n\r\n            GL.viewport( Std.int(x), Std.int(_y), Std.int(w), Std.int(h) );\r\n\r\n        }  //if it's changed\r\n\r\n    } //viewport\r\n\r\n    var _current_fbo : GLFramebuffer = null;\r\n    public function bindFramebuffer( ?buffer:GLFramebuffer=null ) {\r\n\r\n        if(_current_fbo != buffer) {\r\n\r\n            if(buffer == null) {\r\n                buffer = renderer.default_fbo;\r\n            }\r\n\r\n            GL.bindFramebuffer( GL.FRAMEBUFFER, buffer );\r\n            _current_fbo = buffer;\r\n        }\r\n\r\n    } //bindFrameBuffer\r\n\r\n    var _current_rbo : GLRenderbuffer = null;\r\n    public function bindRenderbuffer( ?buffer:GLRenderbuffer=null ) {\r\n\r\n        if(_current_rbo != buffer) {\r\n\r\n            if(buffer == null) {\r\n                buffer = renderer.default_rbo;\r\n            }\r\n\r\n            GL.bindRenderbuffer( GL.RENDERBUFFER, buffer );\r\n            _current_rbo = buffer;\r\n        }\r\n\r\n    } //bindRenderbuffer\r\n\r\n    var _used_program : GLProgram = null;\r\n    public function useProgram( program:GLProgram ) {\r\n        if(_used_program != program) {\r\n            _used_program = program;\r\n            GL.useProgram( program );\r\n        }\r\n    } //useProgram\r\n\r\n    var _active_texture = -1;\r\n    public function activeTexture( val:Int ) {\r\n        if(_active_texture != val) {\r\n            GL.activeTexture(val);\r\n            _active_texture = val;\r\n        }\r\n    } //activeTexture\r\n\r\n    var _bound_texture_2D : GLTexture = null;\r\n    public function bindTexture2D( tex:GLTexture ) {\r\n        if(_bound_texture_2D != tex) {\r\n            _bound_texture_2D = tex;\r\n            GL.bindTexture(GL.TEXTURE_2D, tex);\r\n        }\r\n    }\r\n\r\n    var _last_line_width:Float = 1;\r\n    public function lineWidth( _width:Float ) {\r\n        if(_last_line_width != _width) {\r\n            _last_line_width = _width;\r\n            GL.lineWidth( _width );\r\n        }\r\n    }\r\n\r\n    var _last_depth_mask:Bool = true;\r\n    public function depthMask( _enable:Bool ) {\r\n        if(_last_depth_mask != _enable) {\r\n            _last_depth_mask = _enable;\r\n            GL.depthMask( _enable );\r\n        }\r\n    }\r\n\r\n} //RenderState\r\n","package phoenix;\r\n\r\nimport snow.assets.AssetImage;\r\nimport snow.render.opengl.GL;\r\nimport snow.utils.Libs;\r\n\r\nimport snow.io.typedarray.Uint8Array;\r\nimport snow.io.typedarray.ArrayBuffer;\r\n\r\nimport phoenix.Color;\r\nimport phoenix.Vector;\r\n\r\nimport luxe.resource.Resource;\r\nimport luxe.resource.Resources;\r\n\r\nimport luxe.Log._verbose;\r\nimport luxe.Log._debug;\r\nimport luxe.Log.log;\r\n\r\nenum FilterType {\r\n    nearest;\r\n    linear;\r\n    mip_nearest_nearest;  //The texel filter, and then the mip filter\r\n    mip_linear_nearest;\r\n    mip_nearest_linear;\r\n    mip_linear_linear;\r\n}\r\n\r\nenum ClampType {\r\n    edge;\r\n    repeat;\r\n    mirror;\r\n}\r\n\r\n\r\nclass Texture extends Resource {\r\n\r\n    public var texture : GLTexture;\r\n    public var asset : AssetImage;\r\n\r\n    public var width_actual : Int = -1;\r\n    public var height_actual : Int = -1;\r\n    public var width : Int = -1;\r\n    public var height : Int = -1;\r\n    public var loaded : Bool = false;\r\n\r\n    public var slot : Int = 0;\r\n\r\n    public var _onload_handlers : Array<Texture -> Void>;\r\n\r\n    public var onload(never,set) : Texture -> Void;\r\n    @:isVar public var filter(default,set) : FilterType;\r\n    @:isVar public var filter_min(default,set) : FilterType;\r\n    @:isVar public var filter_mag(default,set) : FilterType;\r\n    @:isVar public var clamp(default,set) : ClampType;\r\n\r\n\r\n    public function new( _manager : Resources, ?_type : ResourceType = null ) {\r\n\r\n        if(_type == null) _type = ResourceType.texture;\r\n\r\n        super( _manager, _type );\r\n        _onload_handlers = new Array<Texture -> Void>();\r\n\r\n        id = Luxe.utils.uniqueid();\r\n        filter = FilterType.linear;\r\n        clamp = ClampType.edge;\r\n\r\n    } //new\r\n\r\n    public function set_onload( f: Texture -> Void ) {\r\n            //if already loaded when adding an onloaded handler,\r\n            //just call the handler now\r\n        if(loaded) {\r\n            f(this);\r\n            return f;\r\n        } else {\r\n            //otherwise we store it in the list for calling later\r\n            _onload_handlers.push(f);\r\n        }\r\n\r\n        return f;\r\n\r\n    } //set_onload\r\n\r\n    public function do_onload() {\r\n\r\n        loaded = true;\r\n\r\n        for(f in _onload_handlers) {\r\n            if(f != null) {\r\n                f(this);\r\n            }\r\n        }\r\n\r\n        _onload_handlers.splice(0,_onload_handlers.length);\r\n\r\n    } //do_onload\r\n\r\n    function toString() {\r\n        return 'Texture (' + texture + ') ('+ width + 'x' + height +') real size('+ width_actual + 'x' + height_actual +') ' + filter + ' filtering. ' + clamp + ' clamp. id: ' + id;\r\n    } //toString\r\n\r\n    public function estimated_memory() {\r\n\r\n        var _bytes = (width_actual * height_actual * 4);\r\n\r\n        return Luxe.utils.bytes_to_string(_bytes);\r\n\r\n    } //estimated_memory\r\n\r\n    public static function load( _id:String, ?_onloaded:Texture->Void, ?_silent:Bool=false ) {\r\n\r\n            //:todo:which resources\r\n        var resources = Luxe.resources;\r\n\r\n            //Check for existing texture in resource manager\r\n        var _exists = resources.find_texture(_id);\r\n\r\n        if(_exists != null) {\r\n\r\n            _verbose(\"loaded (cached) \" + _exists.id ) ;\r\n\r\n            if(_onloaded != null) {\r\n                _onloaded(_exists);\r\n            }\r\n\r\n            return _exists;\r\n\r\n        } //_exists != null\r\n\r\n        //if not found already, create a new Texture\r\n\r\n        var texture : Texture = new Texture( resources );\r\n\r\n            //append the onload handler\r\n        if(_onloaded != null) {\r\n            texture.onload = _onloaded;\r\n        }\r\n\r\n        var _asset = Luxe.core.app.assets.image(_id, {\r\n            onload : function( asset:AssetImage ) {\r\n                if(asset != null && asset.image != null) {\r\n\r\n                    texture.from_asset(asset);\r\n                    texture.reset();\r\n                    texture.do_onload();\r\n\r\n                    if(!_silent) {\r\n                        log(\"loaded \" + texture.id + ' (' + texture.width + 'x' + texture.height + ') real size ('+ texture.width_actual + 'x' + texture.height_actual +')');\r\n                    }\r\n\r\n                } else { //asset != null\r\n                    if(!_silent) {\r\n                        log(\"failed to load! \" + _id);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        if(_asset != null) {\r\n\r\n            texture.id = _id;\r\n\r\n            resources.cache(texture);\r\n\r\n            return texture;\r\n\r\n        } //_asset != null\r\n\r\n        return null;\r\n\r\n    } //load\r\n\r\n\r\n    public static function load_from_resource( _name:String, ?_cache:Bool = true ) {\r\n\r\n        var texture_bytes : haxe.io.Bytes = haxe.Resource.getBytes(_name);\r\n\r\n        if(texture_bytes != null) {\r\n\r\n            var texture = load_from_bytes( _name, Uint8Array.fromBytes(texture_bytes), _cache );\r\n\r\n            texture_bytes = null;\r\n\r\n            return texture;\r\n\r\n        } //texture_bytes != null\r\n\r\n        return null;\r\n\r\n    } //load_texture_from_resource_bytes\r\n\r\n\r\n        /** create and load a texture from a Uint8Array. Take note this accepts encoded image formats, not decoded/raw pixels. Use load_from_pixels for that.  */\r\n    public static function load_from_bytes( _name:String, _bytes:Uint8Array, ?_cache:Bool = true ) {\r\n\r\n        if(_bytes != null) {\r\n\r\n                //:todo: which resource manager...\r\n            var resources = Luxe.resources;\r\n            var texture = new Texture(resources);\r\n\r\n            var _asset = Luxe.core.app.assets.image(_name, { bytes:_bytes });\r\n\r\n            if(_asset != null) {\r\n\r\n                texture.from_asset(_asset);\r\n\r\n                texture.reset();\r\n                texture.do_onload();\r\n\r\n                if(_cache) {\r\n                    resources.cache(texture);\r\n                }\r\n\r\n                return texture;\r\n\r\n            } //_asset != null\r\n\r\n        } //texture_bytes != null\r\n\r\n        return null;\r\n\r\n    } //load_from_bytes\r\n\r\n    public static function load_from_pixels( _id:String, _width:Int, _height:Int, _pixels:snow.io.typedarray.Uint8Array, ?_cache:Bool = true ) {\r\n\r\n        if(_pixels == null) {\r\n            return null;\r\n        }\r\n\r\n        var resources = Luxe.resources;\r\n        var texture = new Texture(resources);\r\n\r\n        var _asset_info = Luxe.core.app.assets.info_from_id(_id, 'image');\r\n        var _asset = new snow.assets.AssetImage( Luxe.core.app.assets, _asset_info );\r\n\r\n        _asset.load_from_pixels(_id, _width, _height, _pixels);\r\n\r\n\r\n            texture.from_asset(_asset);\r\n\r\n            texture.reset();\r\n            texture.do_onload();\r\n\r\n            if(_cache) {\r\n                resources.cache(texture);\r\n            }\r\n\r\n        return texture;\r\n\r\n    } //load_from_pixels\r\n\r\n    function check_size() {\r\n\r\n        var max_size = GL.getParameter(GL.MAX_TEXTURE_SIZE);\r\n\r\n        if(asset.image.width_actual > max_size) throw \"texture bigger than MAX_TEXTURE_SIZE (\" + max_size + \") \" + asset.id;\r\n        if(asset.image.height_actual > max_size) throw \"texture bigger than MAX_TEXTURE_SIZE (\" + max_size + \") \" + asset.id;\r\n\r\n    } //check_size\r\n\r\n        //create and submit the asset information to GL,\r\n        //generating a valid id as well\r\n    public function reset() {\r\n\r\n            //Create the GL id\r\n        texture = GL.createTexture();\r\n            //Now we can bind it,\r\n        bind();\r\n            //And send GL the data\r\n        GL.texImage2D(GL.TEXTURE_2D, 0, GL.RGBA, width_actual, height_actual, 0, GL.RGBA, GL.UNSIGNED_BYTE, asset.image.data );\r\n\r\n            //Set the existing properties on the new texture\r\n        _set_filter( filter );\r\n        _set_clamp( clamp );\r\n\r\n    } //reset\r\n\r\n    public function from_asset( _asset:AssetImage ) {\r\n\r\n        if(_asset == null) {\r\n            throw \"null asset passed to Texture.from_asset\";\r\n        }\r\n\r\n            //store the asset for later use\r\n        asset = _asset;\r\n\r\n        _debug('image.id: ' + asset.image.id);\r\n        _debug('\\t image.bpp: ' + asset.image.bpp);\r\n        _debug('\\t image.bpp_source: ' + asset.image.bpp_source);\r\n        _debug('\\t image.data.length: ' + asset.image.data.length);\r\n        _debug('\\t image.height: ' + asset.image.height);\r\n        _debug('\\t image.height_actual: ' + asset.image.height_actual);\r\n        _debug('\\t image.width: ' + asset.image.width);\r\n        _debug('\\t image.width_actual: ' + asset.image.width_actual);\r\n        _debug('\\t components: ' + asset.components);\r\n\r\n            //check for size limitations\r\n        check_size();\r\n\r\n            //Store the asset id as our resource id\r\n        id = asset.id;\r\n\r\n            //assign sizes\r\n        width = asset.image.width;\r\n        height = asset.image.height;\r\n        width_actual = asset.image.width_actual;\r\n        height_actual = asset.image.height_actual;\r\n\r\n    } //from_asset\r\n\r\n    public function generate_mipmaps() {\r\n\r\n        onload = function(t) {\r\n            //make it active\r\n            bind();\r\n            //Generate mipmaps\r\n            GL.generateMipmap(GL.TEXTURE_2D);\r\n        }\r\n\r\n    } //generate_mipmaps\r\n\r\n    public function bind() {\r\n        Luxe.renderer.state.activeTexture( GL.TEXTURE0+slot );\r\n        Luxe.renderer.state.bindTexture2D( texture );\r\n    }\r\n\r\n    public function get_pixel( _pos : Vector ) {\r\n\r\n        if(asset.image.data == null) return null;\r\n\r\n        var x : Int = Std.int(_pos.x);\r\n        var y : Int = Std.int(_pos.y);\r\n\r\n        return {\r\n            r: asset.image.data[ (((y*width)+x)*4)  ]/255.0,\r\n            g: asset.image.data[ (((y*width)+x)*4)+1]/255.0,\r\n            b: asset.image.data[ (((y*width)+x)*4)+2]/255.0,\r\n            a: asset.image.data[ (((y*width)+x)*4)+3]/255.0\r\n        };\r\n\r\n    } //get_pixel\r\n\r\n    public function set_pixel( _pos:Vector, _color:Color ) {\r\n\r\n        if(asset.image.data == null) return;\r\n\r\n        var x : Int = Std.int(_pos.x);\r\n        var y : Int = Std.int(_pos.y);\r\n\r\n        asset.image.data[ (((y*width)+x)*4)  ] = Std.int(_color.r*255);\r\n        asset.image.data[ (((y*width)+x)*4)+1] = Std.int(_color.g*255);\r\n        asset.image.data[ (((y*width)+x)*4)+2] = Std.int(_color.b*255);\r\n        asset.image.data[ (((y*width)+x)*4)+3] = Std.int(_color.a*255);\r\n\r\n    } //set_pixel\r\n\r\n    public function lock() {\r\n\r\n        //:todo : this is related to glGetTexImage not in WebGL\r\n\r\n        // data = new UInt8Array(new ArrayBuffer( width * height * 4));\r\n\r\n        // glBindTexture(GL_TEXTURE_2D, texture);\r\n        // glGetTexImage( GL_TEXTURE_2D , 0 , GL_RGBA , GL_UNSIGNED_BYTE, data );\r\n\r\n        return true;\r\n    }\r\n\r\n    public function unlock() {\r\n\r\n        if (asset.image.data != null) {\r\n\r\n            Luxe.renderer.state.bindTexture2D(texture);\r\n            GL.texImage2D(GL.TEXTURE_2D, 0, GL.RGBA, width, height, 0, GL.RGBA, GL.UNSIGNED_BYTE, asset.image.data);\r\n\r\n            asset.image.data = null;\r\n\r\n        }\r\n\r\n    } //unlock\r\n\r\n    public override function drop() {\r\n\r\n        super.drop();\r\n        destroy();\r\n\r\n    } //drop\r\n\r\n    public function activate(att) { }\r\n\r\n    public function destroy() {\r\n\r\n        GL.deleteTexture(texture);\r\n        // asset.destroy(); :todo:\r\n\r\n    } //destroy\r\n\r\n\r\n    function _set_clamp( _clamp : ClampType ) {\r\n\r\n        switch (_clamp) {\r\n            case ClampType.edge:\r\n                GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_S, GL.CLAMP_TO_EDGE );\r\n                GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_T, GL.CLAMP_TO_EDGE );\r\n            case ClampType.repeat:\r\n                GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_S, GL.REPEAT );\r\n                GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_T, GL.REPEAT );\r\n           case ClampType.mirror:\r\n                GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_S, GL.MIRRORED_REPEAT );\r\n                GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_T, GL.MIRRORED_REPEAT );\r\n        }\r\n\r\n    } //_set_clamp\r\n\r\n    function set_clamp( _clamp : ClampType ) {\r\n\r\n        if(clamp == null) {\r\n            return clamp = _clamp;\r\n        }\r\n\r\n        if(loaded == false) {\r\n            onload = function(t) {\r\n                bind();\r\n                _set_clamp(_clamp);\r\n            }\r\n        } else {\r\n            bind();\r\n            _set_clamp(_clamp);\r\n        }\r\n\r\n        return _clamp;\r\n\r\n    } //set_clamp\r\n\r\n    function _set_filter( _filter : FilterType ) {\r\n\r\n        switch(_filter) {\r\n\r\n            case FilterType.linear:\r\n                GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.LINEAR);\r\n                GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, GL.LINEAR);\r\n\r\n            case FilterType.nearest:\r\n                GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.NEAREST);\r\n                GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, GL.NEAREST);\r\n\r\n        //mip filters\r\n            case FilterType.mip_nearest_nearest:\r\n                GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.NEAREST_MIPMAP_NEAREST);\r\n                GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, GL.NEAREST_MIPMAP_NEAREST);\r\n            case FilterType.mip_linear_nearest:\r\n                GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.LINEAR_MIPMAP_NEAREST);\r\n                GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, GL.LINEAR_MIPMAP_NEAREST);\r\n            case FilterType.mip_nearest_linear:\r\n                GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.NEAREST_MIPMAP_LINEAR);\r\n                GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, GL.NEAREST_MIPMAP_LINEAR);\r\n            case FilterType.mip_linear_linear:\r\n                GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.LINEAR_MIPMAP_LINEAR);\r\n                GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, GL.LINEAR_MIPMAP_LINEAR);\r\n\r\n        } //switch _filter\r\n\r\n    } //set_filter\r\n\r\n    function _set_filter_min( _filter : FilterType ) {\r\n\r\n        switch(_filter) {\r\n\r\n            case FilterType.linear:\r\n                GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.LINEAR);\r\n            case FilterType.nearest:\r\n                GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.NEAREST);\r\n\r\n        //mip filters\r\n            case FilterType.mip_nearest_nearest:\r\n                GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.NEAREST_MIPMAP_NEAREST);\r\n            case FilterType.mip_linear_nearest:\r\n                GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.LINEAR_MIPMAP_NEAREST);\r\n            case FilterType.mip_nearest_linear:\r\n                GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.NEAREST_MIPMAP_LINEAR);\r\n            case FilterType.mip_linear_linear:\r\n                GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.LINEAR_MIPMAP_LINEAR);\r\n\r\n        } //switch _filter\r\n\r\n    } //set_filter_min\r\n\r\n    function _set_filter_mag( _filter : FilterType ) {\r\n\r\n        switch(_filter) {\r\n\r\n            case FilterType.linear:\r\n                GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, GL.LINEAR);\r\n            case FilterType.nearest:\r\n                GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, GL.NEAREST);\r\n\r\n        //mip filters\r\n            case FilterType.mip_nearest_nearest:\r\n                GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, GL.NEAREST_MIPMAP_NEAREST);\r\n            case FilterType.mip_linear_nearest:\r\n                GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, GL.LINEAR_MIPMAP_NEAREST);\r\n            case FilterType.mip_nearest_linear:\r\n                GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, GL.NEAREST_MIPMAP_LINEAR);\r\n            case FilterType.mip_linear_linear:\r\n                GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, GL.LINEAR_MIPMAP_LINEAR);\r\n        } //switch _filter\r\n\r\n    } //set_filter_min\r\n\r\n    function set_filter( _filter : FilterType ) {\r\n\r\n        if(filter == null) {\r\n            return filter = _filter;\r\n        }\r\n\r\n        if(loaded == false) {\r\n            onload = function(t) {\r\n                bind();\r\n                _set_filter(_filter);\r\n            }\r\n        } else {\r\n            bind();\r\n            _set_filter(_filter);\r\n        }\r\n\r\n        return filter = _filter;\r\n\r\n    } //set_filter\r\n\r\n    function set_filter_min( _filter : FilterType ) {\r\n\r\n        if(loaded == false) {\r\n            onload = function(t) {\r\n                bind();\r\n                _set_filter_min(_filter);\r\n            }\r\n        } else {\r\n            bind();\r\n            _set_filter_min(_filter);\r\n        }\r\n\r\n        return filter_min = _filter;\r\n\r\n    } //set_filter_min\r\n\r\n    function set_filter_mag( _filter : FilterType ) {\r\n\r\n        if(loaded == false) {\r\n            onload = function(t) {\r\n                bind();\r\n                _set_filter_mag(_filter);\r\n            }\r\n        } else {\r\n            bind();\r\n            _set_filter_mag(_filter);\r\n        }\r\n\r\n        return filter_mag = _filter;\r\n\r\n    } //set_filter_mag\r\n\r\n} //Texture\r\n","package phoenix;\r\n\r\nimport snow.render.opengl.GL;\r\nimport phoenix.Batcher;\r\nimport phoenix.Texture;\r\n\r\nimport luxe.resource.Resource;\r\nimport luxe.resource.Resources;\r\n\r\n\r\n    //A render texture just extends texture so it can be assigned to meshes etc\r\nclass RenderTexture extends Texture {\r\n\r\n    public var fbo : GLFramebuffer;\r\n    public var renderbuffer : GLRenderbuffer;\r\n\r\n    public function new( _manager:Resources, ?_size:Vector = null ) {\r\n\r\n        super( _manager, ResourceType.render_texture );\r\n\r\n            //Set it to the buffer\r\n        _size == null ? new Vector( Luxe.screen.w, Luxe.screen.h ) : _size ;\r\n            //Width and height of this texture item\r\n        width = width_actual = Std.int(_size.x);\r\n        height = height_actual = Std.int(_size.y);\r\n\r\n            //Create the render texture for the fbo\r\n        texture = GL.createTexture();\r\n            //Bind the texture\r\n        bind();\r\n            //Create the actual texture in memory\r\n        GL.texImage2D( GL.TEXTURE_2D, 0, GL.RGBA, width, height, 0, GL.RGBA, GL.UNSIGNED_BYTE, null );\r\n            //these must be set to be texture complete\r\n        _set_filter(phoenix.FilterType.linear);\r\n        _set_clamp(phoenix.ClampType.edge);\r\n\r\n            //Create the FBO\r\n        fbo = GL.createFramebuffer();\r\n            //Bind the FBO\r\n        bindBuffer();\r\n\r\n            //create the render buffer\r\n        renderbuffer = GL.createRenderbuffer();\r\n            //Bind it so we can attach stuff\r\n        bindRenderBuffer();\r\n\r\n\r\n            //Create storage for the depth buffer :todo: optionize\r\n        GL.renderbufferStorage(GL.RENDERBUFFER, GL.DEPTH_COMPONENT16, width, height);\r\n            //Attach the framebuffer texture to the buffer\r\n        GL.framebufferTexture2D( GL.FRAMEBUFFER, GL.COLOR_ATTACHMENT0, GL.TEXTURE_2D, texture, 0 );\r\n            //Attach the depth buffer to the render buffer\r\n        GL.framebufferRenderbuffer( GL.FRAMEBUFFER, GL.DEPTH_ATTACHMENT, GL.RENDERBUFFER, renderbuffer);\r\n\r\n\r\n        var status = GL.checkFramebufferStatus( GL.FRAMEBUFFER );\r\n\r\n        switch (status) {\r\n\r\n            case GL.FRAMEBUFFER_COMPLETE:\r\n\r\n            case GL.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\r\n                throw(\"Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT\");\r\n\r\n            case GL.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\r\n                throw(\"Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT\");\r\n\r\n            case GL.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:\r\n                throw(\"Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS\");\r\n\r\n            case GL.FRAMEBUFFER_UNSUPPORTED:\r\n                throw(\"Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED\");\r\n\r\n            default:\r\n                throw(\"Incomplete framebuffer: \" + status);\r\n        }\r\n\r\n            //no lingering\r\n        unbindBuffer();\r\n        unbindRenderBuffer();\r\n\r\n        loaded = true;\r\n\r\n    } //new\r\n\r\n    public override function destroy() {\r\n\r\n        GL.deleteFramebuffer( fbo );\r\n        GL.deleteRenderbuffer( renderbuffer );\r\n\r\n        super.destroy();\r\n\r\n    } //destroy\r\n\r\n    @:noCompletion public function bindBuffer() {\r\n\r\n        Luxe.renderer.state.bindFramebuffer(fbo);\r\n\r\n    } //bind\r\n\r\n    @:noCompletion public function unbindBuffer( ?_other:GLFramebuffer=null ) {\r\n\r\n        Luxe.renderer.state.bindFramebuffer( _other );\r\n\r\n    } //unbind\r\n\r\n    @:noCompletion public function bindRenderBuffer() {\r\n\r\n        Luxe.renderer.state.bindRenderbuffer( renderbuffer );\r\n\r\n    } //bind\r\n\r\n    @:noCompletion public function unbindRenderBuffer( ?_other:GLRenderbuffer=null ) {\r\n\r\n        Luxe.renderer.state.bindRenderbuffer( _other );\r\n\r\n    } //unbind\r\n\r\n\r\n} //RenderTexture","package phoenix;\r\n\r\nimport snow.render.opengl.GL;\r\nimport snow.utils.Libs;\r\n\r\nimport luxe.Log.log;\r\nimport luxe.Log._debug;\r\nimport luxe.Log._verbose;\r\n\r\nimport luxe.Core;\r\nimport luxe.Rectangle;\r\n\r\nimport phoenix.Batcher;\r\nimport phoenix.RenderPath;\r\nimport phoenix.geometry.Geometry;\r\n\r\nimport phoenix.RenderTexture;\r\nimport phoenix.Shader;\r\nimport phoenix.Color;\r\nimport phoenix.Camera;\r\nimport phoenix.Texture;\r\nimport phoenix.BitmapFont;\r\n\r\ntypedef BatcherKey = {\r\n    uuid : String,\r\n    layer : Int\r\n}\r\n\r\nprivate typedef DefaultShader = {\r\n    source: { vert:String, frag:String },\r\n    shader : Shader\r\n}\r\n\r\nprivate typedef DefaultShaders = {\r\n    plain : DefaultShader,\r\n    textured : DefaultShader,\r\n    bitmapfont : DefaultShader\r\n}\r\n\r\nclass Renderer {\r\n\r\n    public var batchers : Array<Batcher>;\r\n\r\n    public var core : Core;\r\n    public var state : RenderState;\r\n    public var default_fbo : GLFramebuffer;\r\n    public var default_rbo : GLRenderbuffer;\r\n        //Default rendering\r\n    public var shaders : DefaultShaders;\r\n        //Default view and batching renderer\r\n    public var batcher : Batcher;\r\n    public var camera : Camera;\r\n        //Default font for debug stuff etc\r\n    public var font : BitmapFont;\r\n        //Default render path is a forward renderer, and acts as a fallback for deferred\r\n        //render path is the active render path, can replace it to render in a different manner\r\n        //It will pass all batchers to be processed etc for you to do whatever with\r\n    public var render_path : RenderPath;\r\n    public var default_render_path : RenderPath;\r\n\r\n    @:isVar public var vsync (get,set) : Bool;\r\n    @:isVar public var target (get,set) : RenderTexture;\r\n    public var target_size : Vector;\r\n\r\n    public var should_clear : Bool = true;\r\n    public var stop : Bool = false;\r\n    public var stop_count : Int = 0;\r\n    public var clear_color : Color;\r\n\r\n    public var stats : RendererStats;\r\n\r\n    public function new( _core:luxe.Core ) {\r\n\r\n        core = _core;\r\n\r\n            //store the default FBO as on some platforms\r\n            //it is not the same as 0\r\n\r\n        default_fbo = GL.getParameter(GL.FRAMEBUFFER_BINDING);\r\n        default_rbo = GL.getParameter(GL.RENDERBUFFER_BINDING);\r\n\r\n        _debug(\"default Framebuffer set to \" + default_fbo);\r\n        _debug(\"default Renderbuffer set to \" + default_rbo);\r\n\r\n    } //new\r\n\r\n    public function init() {\r\n\r\n        state = new RenderState(this);\r\n        clear_color = new Color().rgb(0x1a1a1a);\r\n        stats = new RendererStats();\r\n        batchers = [];\r\n\r\n            //The default view\r\n        target_size = new Vector(Luxe.screen.w, Luxe.screen.h);\r\n        camera = new Camera();\r\n            //Create the default render path\r\n        default_render_path = new RenderPath( this );\r\n            //Apply it\r\n        render_path = default_render_path;\r\n\r\n            //init shaders\r\n        create_default_shaders();\r\n\r\n            //create the default batcher\r\n        batcher = new Batcher( this, 'default batcher' );\r\n        batcher.layer = 1;\r\n        add_batch(batcher);\r\n\r\n        #if !no_default_font\r\n\r\n            create_default_font();\r\n\r\n        #end //no_default_font\r\n\r\n        if(Luxe.core.app.config.render.depth) {\r\n                // Enable z buffer use\r\n            state.enable(GL.DEPTH_TEST);\r\n                // Accept fragment if it closer or equal away from the other\r\n            state.depth_function(GL.LEQUAL);\r\n                //Clear the depth buffer\r\n            GL.clearDepth(1.0);\r\n        }\r\n\r\n            //Enable blending\r\n        GL.enable(GL.BLEND);\r\n        GL.blendFunc(GL.SRC_ALPHA, GL.ONE_MINUS_SRC_ALPHA);\r\n\r\n            //Make sure that we aren't premultiplying the backbuffer\r\n        #if luxe_web\r\n            GL.pixelStorei(GL.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);\r\n        #end //luxe_web\r\n\r\n    } //init\r\n\r\n    public function destroy() {\r\n\r\n        clear( new luxe.Color().rgb(0xff440b) );\r\n\r\n    } //destroy\r\n\r\n    @:allow(phoenix.Batcher)\r\n    function sort_batchers( a:Batcher, b:Batcher ) {\r\n        if(a.layer < b.layer) return -1;\r\n        if(a.layer > b.layer) return 1;\r\n        if(a.sequence < b.sequence) return -1;\r\n        if(a.sequence > b.sequence) return 1;\r\n        return 1;\r\n    } //sort_batchers\r\n\r\n    public function add_batch( batch:Batcher ) {\r\n\r\n        batchers.push( batch );\r\n        batchers.sort( sort_batchers );\r\n\r\n    } //add_batch\r\n\r\n    public function remove_batch( batch:Batcher ) {\r\n\r\n        batchers.remove( batch );\r\n\r\n    } //remove_batch\r\n\r\n        /** Create a batcher, convenience for create batcher, add batcher (option), and create a camera for the batcher. */\r\n    public function create_batcher( ? options:luxe.options.BatcherOptions ) : Batcher {\r\n\r\n        var _new_batcher_layer = 2;\r\n\r\n        if(options != null) {\r\n\r\n            if(options.name == null) {\r\n                options.name = 'batcher';\r\n            }\r\n            if(options.layer == null) {\r\n                options.layer = _new_batcher_layer;\r\n            }\r\n            if(options.camera == null) {\r\n                options.camera = new phoenix.Camera();\r\n            }\r\n\r\n        } else {\r\n            options = {\r\n                name : 'batcher',\r\n                camera : new phoenix.Camera(),\r\n                layer : _new_batcher_layer\r\n            }\r\n        }\r\n\r\n        var _batcher = new Batcher( this, options.name );\r\n            _batcher.view = options.camera;\r\n            _batcher.layer = options.layer;\r\n\r\n        if( options.no_add == null || options.no_add == false ) {\r\n            add_batch( _batcher );\r\n        }\r\n\r\n        return _batcher;\r\n\r\n    } //create_batcher\r\n\r\n\r\n    public function clear( _color:Color ) {\r\n\r\n        if(_color == null) {\r\n            _color = clear_color;\r\n        }\r\n\r\n        GL.clearColor( _color.r, _color.g, _color.b, _color.a );\r\n\r\n        if( Luxe.core.app.config.render.depth ) {\r\n            GL.clear( GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT );\r\n            GL.clearDepth(1.0);\r\n        } else {\r\n            GL.clear( GL.COLOR_BUFFER_BIT );\r\n        }\r\n\r\n    } //clear\r\n\r\n    public function blend_mode(?_src_mode:BlendMode = BlendMode.src_alpha, _dst_mode:BlendMode = BlendMode.one_minus_src_alpha) {\r\n\r\n        GL.blendFunc(_src_mode, _dst_mode);\r\n\r\n    } //set blendmode\r\n\r\n    public function blend_equation(?_equation:BlendEquation = BlendEquation.add) {\r\n\r\n        GL.blendEquation(_equation);\r\n\r\n    } //set blend equation\r\n\r\n        //The resize handler\r\n    @:allow(luxe.Core)\r\n    function internal_resized(_w:Int, _h:Int) {\r\n\r\n        if(target == null) {\r\n            target_size.set_xy(_w, _h);\r\n        }\r\n\r\n    } //internal_resized\r\n\r\n        //The main render function\r\n    @:allow(luxe.Core)\r\n    function process() {\r\n\r\n        if(stop) { return; }\r\n\r\n        if(should_clear) {\r\n            clear( clear_color );\r\n        }\r\n\r\n        stats.batchers = batchers.length;\r\n        stats.reset();\r\n\r\n            //render\r\n        render_path.render( batchers, stats );\r\n\r\n        // stop_count++;\r\n        // if(stop_count >= 3) {\r\n        //     stop = true;\r\n        // }\r\n\r\n    } //process\r\n\r\n    public function onresize(e:Dynamic) {\r\n\r\n    } //onresize\r\n\r\n    function set_vsync( _vsync:Bool ) : Bool {\r\n\r\n        Luxe.core.app.windowing.enable_vsync( _vsync );\r\n\r\n        return vsync = _vsync;\r\n\r\n    } //set_vsync\r\n\r\n    function get_vsync() : Bool {\r\n\r\n        return vsync;\r\n\r\n    } //get_vsync\r\n\r\nfunction get_target() : RenderTexture {\r\n\r\n        return target;\r\n\r\n    } //get_target\r\n\r\n    function set_target( _target:RenderTexture ) {\r\n\r\n        if(_target != null) {\r\n\r\n            target_size.x = _target.width;\r\n            target_size.y = _target.height;\r\n\r\n            state.bindFramebuffer( _target.fbo );\r\n\r\n        } else {\r\n\r\n            target_size.x = Luxe.screen.w;\r\n            target_size.y = Luxe.screen.h;\r\n\r\n            state.bindFramebuffer();\r\n\r\n        }\r\n\r\n        return target = _target;\r\n\r\n    } //set_target\r\n\r\n    function create_default_shaders() {\r\n\r\n        _debug('creating default shaders...');\r\n\r\n        var vert = haxe.Resource.getString('default.vert.glsl');\r\n        var frag = haxe.Resource.getString('default.frag.glsl');\r\n        var frag_textured = haxe.Resource.getString('default.frag.textured.glsl');\r\n        var frag_bitmapfont = haxe.Resource.getString('default.frag.bitmapfont.glsl');\r\n\r\n        #if luxe_web\r\n            var ext = snow.platform.web.render.opengl.GL.current_context.getExtension('OES_standard_derivatives');\r\n        #end\r\n\r\n            //for web + mobile, these are required\r\n        #if !desktop\r\n            frag = \"precision mediump float;\\n\" + frag;\r\n            frag_textured = \"precision mediump float;\\n\" + frag_textured;\r\n            frag_bitmapfont = \"#extension GL_OES_standard_derivatives : enable\\n#extension OES_standard_derivatives : enable\\nprecision mediump float;\\n\" + frag_bitmapfont;\r\n        #end\r\n\r\n        var _plain = new Shader( core.resources );\r\n        var _textured = new Shader( core.resources );\r\n        var _font = new Shader( core.resources );\r\n\r\n        //set the id's\r\n\r\n            var _dvs = 'default vertex shader';\r\n\r\n            _plain.id = 'default_shader';\r\n            _textured.id = 'default_shader_textured';\r\n            _font.id = 'default_shader_bitmapfont';\r\n\r\n        //create compile and link the shaders\r\n\r\n            _plain.from_string( vert, frag, _dvs, 'default fragment shader', false );\r\n            _textured.from_string( vert, frag_textured, _dvs, 'default textured shader', false );\r\n            _font.from_string( vert, frag_bitmapfont, _dvs, 'default bitmapfont shader', false );\r\n\r\n        //store for use\r\n\r\n        shaders = {\r\n            plain : { shader : _plain, source : { vert:vert, frag:frag } },\r\n            textured : { shader : _textured, source : { vert:vert, frag:frag_textured } },\r\n            bitmapfont : { shader : _font, source : { vert:vert, frag:frag_bitmapfont } },\r\n        };\r\n\r\n        _debug('done.');\r\n\r\n    } //create_default_shaders\r\n\r\n    function create_default_font() {\r\n\r\n        _debug(\"creating the default font...\");\r\n\r\n            font = new BitmapFont({ id:'default', resources:core.resources });\r\n\r\n                //create the font texture\r\n            var _font_texture = Texture.load_from_resource('default.png');\r\n                _font_texture.filter_min = FilterType.linear;\r\n\r\n                //load the font string data\r\n            font.from_string( haxe.Resource.getString('default.fnt'), null, [_font_texture] );\r\n\r\n        _debug(\"done. \" + _font_texture.width + 'x' + _font_texture.height );\r\n\r\n    } //create_default_font\r\n\r\n} //renderer\r\n\r\n\r\n\r\nclass RendererStats {\r\n\r\n    public function new(){}\r\n    public var batchers : Int = 0;\r\n    public var geometry_count : Int = 0;\r\n    public var dynamic_batched_count : Int = 0;\r\n    public var static_batched_count : Int = 0;\r\n    public var visible_count : Int = 0;\r\n    public var draw_calls : Int = 0;\r\n    public var group_count : Int = 0;\r\n    public var vert_count : Int = 0;\r\n\r\n    public function reset() {\r\n        geometry_count = 0;\r\n        dynamic_batched_count = 0;\r\n        static_batched_count = 0;\r\n        visible_count = 0;\r\n        group_count = 0;\r\n        draw_calls = 0;\r\n        vert_count = 0;\r\n    }\r\n\r\n    function toString() {\r\n        return\r\n            'Renderer Statistics\\n' +\r\n            '\\tbatcher count : ' + batchers + '\\n' +\r\n            '\\ttotal geometry : ' + geometry_count + '\\n' +\r\n            '\\tvisible geometry : ' + visible_count + '\\n' +\r\n            '\\tdynamic batched geometry : ' + dynamic_batched_count + '\\n' +\r\n            '\\tstatic batched geometry : ' + static_batched_count + '\\n' +\r\n            '\\ttotal draw calls : ' + draw_calls + '\\n' +\r\n            '\\ttotal vertices : ' + vert_count;\r\n    }\r\n\r\n}\r\n\r\n","package phoenix;\r\n\r\n\r\nimport luxe.resource.Resource;\r\nimport luxe.resource.Resources;\r\n\r\nimport luxe.Log.log;\r\nimport luxe.Log._debug;\r\nimport luxe.Log._verbose;\r\n\r\nimport phoenix.Vector;\r\nimport phoenix.Texture;\r\n\r\nimport snow.render.opengl.GL;\r\n\r\nprivate typedef Location = GLUniformLocation;\r\n\r\nclass Shader extends Resource {\r\n\r\n    public var errors : String = '';\r\n    public var log : String = '';\r\n\r\n    public var vertex_source : String = '';\r\n    public var frag_source : String = '';\r\n    public var vertex_source_name : String = '';\r\n    public var frag_source_name : String = '';\r\n\r\n    public var vert_shader : GLShader;\r\n    public var frag_shader : GLShader;\r\n    public var program : GLProgram;\r\n    public var shader : GLShader;\r\n\r\n    public var vert_attribute   : Int = 0;\r\n    public var tcoord_attribute : Int = 1;\r\n    public var color_attribute  : Int = 2;\r\n    public var normal_attribute : Int = 3;\r\n\r\n    public var projectionmatrix_attribute : Location;\r\n    public var modelviewmatrix_attribute : Location;\r\n    public var tex0_attribute : Location;\r\n    public var tex1_attribute : Location;\r\n    public var tex2_attribute : Location;\r\n    public var tex3_attribute : Location;\r\n    public var tex4_attribute : Location;\r\n    public var tex5_attribute : Location;\r\n    public var tex6_attribute : Location;\r\n    public var tex7_attribute : Location;\r\n\r\n    public var uniforms : Map<String, Uniform<Dynamic> >;\r\n\r\n    var uniform_textures : Map<String,Texture>;\r\n\r\n    public function new( _manager : Resources ) {\r\n\r\n        super( _manager, ResourceType.shader );\r\n        uniforms = new Map<String, Uniform<Dynamic> >();\r\n        uniform_textures = new Map();\r\n\r\n    } //new\r\n\r\n    public function activate() {\r\n        if(program != null) {\r\n            Luxe.renderer.state.useProgram( program );\r\n        }\r\n    } //activate\r\n\r\n    public function deactivate() {\r\n        Luxe.renderer.state.useProgram( null );\r\n    } //deactivate\r\n\r\n        /** Create a new shader based on the source of this shader. */\r\n    public function clone() {\r\n\r\n        var _clone = new Shader( manager );\r\n\r\n            _clone.id = id + '.clone.' + Luxe.utils.uniqueid();\r\n            _clone.from_string( vertex_source, frag_source, vertex_source_name, frag_source_name, false );\r\n\r\n        return _clone;\r\n\r\n    } //clone\r\n\r\n   public function set_int( _name:String, _value:Int ) : Void {\r\n        if(uniforms.exists(_name)) {\r\n            var _uniform : Uniform<Int> = uniforms.get(_name);\r\n                _uniform.value = _value;\r\n        } else {\r\n\r\n            var _uniform = {\r\n                name : _name,\r\n                value : _value,\r\n                type : UniformType.int,\r\n                location : location( _name )\r\n            }\r\n\r\n            uniforms.set(_name, _uniform);\r\n        }\r\n    } //set_int\r\n   public function set_float( _name:String, _value:Float ) : Void {\r\n        if(uniforms.exists(_name)) {\r\n            var _uniform : Uniform<Float> = uniforms.get(_name);\r\n                _uniform.value = _value;\r\n        } else {\r\n\r\n            var _uniform = {\r\n                name : _name,\r\n                value : _value,\r\n                type : UniformType.float,\r\n                location : location( _name )\r\n            }\r\n\r\n            uniforms.set(_name, _uniform);\r\n        }\r\n    } //set_float\r\n\r\n    public function set_vector2( _name:String, _value:Vector ) : Void {\r\n\r\n        if(uniforms.exists(_name)) {\r\n\r\n            var _uniform : Uniform<Vector> = uniforms.get(_name);\r\n                _uniform.value = _value;\r\n\r\n        } else {\r\n\r\n            var _uniform = {\r\n                name : _name,\r\n                value : _value,\r\n                type : UniformType.vector2,\r\n                location : location( _name )\r\n            }\r\n\r\n            uniforms.set(_name, _uniform);\r\n        }\r\n    } //set_vector2\r\n\r\n    public function set_vector3( _name:String, _value:Vector ) : Void {\r\n\r\n        if(uniforms.exists(_name)) {\r\n\r\n            var _uniform : Uniform<Vector> = uniforms.get(_name);\r\n                _uniform.value = _value;\r\n\r\n        } else {\r\n\r\n            var _uniform = {\r\n                name : _name,\r\n                value : _value,\r\n                type : UniformType.vector3,\r\n                location : location( _name )\r\n            }\r\n\r\n            uniforms.set(_name, _uniform);\r\n\r\n        }\r\n\r\n    } //set_vector3\r\n\r\n    public function set_vector4( _name:String, _value:Vector ) : Void {\r\n\r\n        if(uniforms.exists(_name)) {\r\n\r\n            var _uniform : Uniform<Vector> = uniforms.get(_name);\r\n                _uniform.value = _value;\r\n\r\n        } else {\r\n\r\n            var _uniform = {\r\n                name : _name,\r\n                value : _value,\r\n                type : UniformType.vector4,\r\n                location : location( _name )\r\n            }\r\n\r\n            uniforms.set(_name, _uniform);\r\n\r\n        } //if exists\r\n\r\n    } //set_vector4\r\n\r\n    public function set_color( _name:String, _value:Color ) : Void {\r\n\r\n        if(uniforms.exists(_name)) {\r\n\r\n            var _uniform : Uniform<Color> = uniforms.get(_name);\r\n                _uniform.value = _value;\r\n\r\n        } else {\r\n\r\n            var _uniform = {\r\n                name : _name,\r\n                value : _value,\r\n                type : UniformType.color,\r\n                location : location( _name )\r\n            }\r\n\r\n            uniforms.set(_name, _uniform);\r\n\r\n        }\r\n\r\n    } //set_color\r\n\r\n    public function set_texture( _name:String, _value:Texture ) : Void {\r\n        if(uniforms.exists(_name)) {\r\n\r\n            var _uniform : Uniform<Texture> = uniforms.get(_name);\r\n                _uniform.value = _value;\r\n                uniform_textures.set(_name, _value);\r\n\r\n        } else {\r\n\r\n            var _uniform : Uniform<Texture> = {\r\n                name : _name, value : _value,\r\n                type : UniformType.texture,\r\n                location : location( _name )\r\n            }\r\n\r\n            uniforms.set(_name, _uniform);\r\n            uniform_textures.set(_name, _value);\r\n        }\r\n    } //set_texture\r\n\r\n\r\n    public function compile( _type : Int, _source:String, _verbose:Bool = false ) : GLShader {\r\n\r\n        var _shader = GL.createShader( _type );\r\n\r\n            GL.shaderSource( _shader,  _source);\r\n            GL.compileShader(_shader);\r\n\r\n        var shader_log = '';\r\n\r\n        if(_verbose) {\r\n            shader_log = GL.getShaderInfoLog(_shader);\r\n\r\n            if(shader_log.length > 0) {\r\n\r\n                add_log(\"\\n\\t :: start -- (\" + ((_type == GL.FRAGMENT_SHADER) ? \"fragment\" : \"vertex\" ) + \") Shader compile log -- \" + id + '\\n');\r\n\r\n                add_log(\"\\t\\t\" + shader_log + '\\n');\r\n\r\n                add_log(\"\\t :: end -- (\" + ((_type == GL.FRAGMENT_SHADER) ? \"fragment\" : \"vertex\" ) + \") Shader compile log -- \" + id);\r\n\r\n            } //shader_log.length\r\n\r\n        } //_verbose\r\n\r\n        if (GL.getShaderParameter(_shader, GL.COMPILE_STATUS) == 0) {\r\n\r\n            var _info = ((_type == GL.FRAGMENT_SHADER) ? \"fragment\" : \"vertex\" );\r\n                _info += ((_type == GL.FRAGMENT_SHADER) ? '($frag_source_name)' : '($vertex_source_name)' );\r\n\r\n            add_error(\"\\tFailed to compile shader (\" + _info + \") : \\n\");\r\n\r\n                //only fetch if we haven't already above\r\n            if(!_verbose) {\r\n                shader_log = GL.getShaderInfoLog(_shader);\r\n            }\r\n\r\n            add_error( \"\\t\\t\"+ shader_log );\r\n\r\n            GL.deleteShader(_shader);\r\n            _shader = null;\r\n\r\n            return null;\r\n\r\n        } //compile_status\r\n\r\n        return _shader;\r\n    }\r\n\r\n    public function link() {\r\n\r\n        program = GL.createProgram();\r\n\r\n        GL.attachShader(program, vert_shader);\r\n        GL.attachShader(program, frag_shader);\r\n\r\n            //Now we want to ensure that our locations are static\r\n        GL.bindAttribLocation( program, vert_attribute,    'vertexPosition');\r\n        GL.bindAttribLocation( program, tcoord_attribute,  'vertexTCoord');\r\n        GL.bindAttribLocation( program, color_attribute,   'vertexColor');\r\n        GL.bindAttribLocation( program, normal_attribute,  'vertexNormal');\r\n\r\n        GL.linkProgram(program);\r\n\r\n        if( GL.getProgramParameter(program, GL.LINK_STATUS) == 0) {\r\n            add_error(\"\\tFailed to link shader program:\");\r\n            add_error( \"\\t\\t\"+ GL.getProgramInfoLog(program) );\r\n            GL.deleteProgram(program);\r\n            program = null;\r\n            return;\r\n        }\r\n\r\n            //first bind it\r\n        activate();\r\n\r\n            //:todo: this is being refactored for the new\r\n            //way more flexible shaders and rendering :}\r\n\r\n                //Matrices\r\n            projectionmatrix_attribute = location(\"projectionMatrix\");\r\n            modelviewmatrix_attribute = location(\"modelViewMatrix\");\r\n\r\n                //Textures\r\n            tex0_attribute = location( \"tex0\" );\r\n            tex1_attribute = location( \"tex1\" );\r\n            tex2_attribute = location( \"tex2\" );\r\n            tex3_attribute = location( \"tex3\" );\r\n            tex4_attribute = location( \"tex4\" );\r\n            tex5_attribute = location( \"tex5\" );\r\n            tex6_attribute = location( \"tex6\" );\r\n            tex7_attribute = location( \"tex7\" );\r\n\r\n    }\r\n\r\n    public override function drop() {\r\n        super.drop();\r\n        destroy();\r\n    }\r\n\r\n    public function destroy() {\r\n        if( vert_shader != null ) GL.deleteShader( vert_shader );\r\n        if( frag_shader != null ) GL.deleteShader( frag_shader );\r\n        if( program != null )     GL.deleteProgram( program );\r\n    }\r\n\r\n    public static function load( _psid:String, ?_vsid:String, ?_onload:Shader->Void, ?_silent:Bool=false ) : Shader {\r\n\r\n            //:todo: which resource manager...\r\n        var _shader = new Shader( Luxe.resources );\r\n\r\n        _debug('loading $_psid / $_vsid');\r\n\r\n        var _frag_shader = '';\r\n        var _vert_shader = '';\r\n\r\n        if(_vsid == 'default' || _vsid == '') {\r\n            _vert_shader = Luxe.renderer.shaders.plain.source.vert;\r\n            _debug('\\t using default vert');\r\n        }\r\n\r\n        if(_psid == 'default' || _psid == '') {\r\n            _frag_shader = Luxe.renderer.shaders.plain.source.frag;\r\n            _debug('\\t using default frag');\r\n        } else if(_psid == 'textured') {\r\n            _frag_shader = Luxe.renderer.shaders.textured.source.frag;\r\n            _debug('\\t using default textured frag');\r\n        }\r\n\r\n        inline function try_load() {\r\n\r\n            if(_vert_shader.length == 0) { return; }\r\n            if(_frag_shader.length == 0) { return; }\r\n\r\n            _shader.from_string( _vert_shader, _frag_shader, _vsid, _psid, false );\r\n\r\n            Luxe.resources.cache( _shader );\r\n\r\n            if(_onload != null) {\r\n                _onload( _shader );\r\n            }\r\n\r\n            if(!_silent) _debug(\"shader loaded \" + _shader.id );\r\n\r\n        } //finish_load\r\n\r\n        if(_vert_shader.length == 0) {\r\n\r\n            _debug('\\t attempting to load $_vsid');\r\n            Luxe.loadText(_vsid, function(_vert_asset){\r\n\r\n                _vert_shader = _vert_asset.text;\r\n\r\n                try_load();\r\n\r\n            }); //load vert\r\n\r\n        } //no vert shader yet\r\n\r\n        if(_frag_shader.length == 0) {\r\n\r\n            _debug('\\t attempting to load $_psid');\r\n            Luxe.loadText(_psid, function(_frag_asset) {\r\n\r\n                    //:todo:hxsw: this must go\r\n                var prefixes = #if luxe_web \"precision mediump float;\\n\" #else '' #end;\r\n\r\n                _frag_shader = prefixes + _frag_asset.text;\r\n\r\n                try_load();\r\n\r\n            }); //load frag\r\n\r\n        } //no frag shader yet\r\n\r\n        _shader.id = _psid + '|' + _vsid;\r\n\r\n        return _shader;\r\n\r\n    } //load_shader\r\n\r\n        /** Loads shaders from a string, compiles, and links them */\r\n    public function from_string( _vertex_source:String, _fragment_source:String, _vertex_name:String='', _frag_name:String='', _verbose:Bool = false ) {\r\n\r\n            //First clean up\r\n        destroy();\r\n\r\n            //store the names\r\n        frag_source = _fragment_source;\r\n        vertex_source = _vertex_source;\r\n        frag_source_name = _frag_name;\r\n        vertex_source_name = _vertex_name;\r\n\r\n            //compile the sources\r\n        vert_shader = compile( GL.VERTEX_SHADER, vertex_source, _verbose );\r\n        frag_shader = compile( GL.FRAGMENT_SHADER, frag_source, _verbose );\r\n\r\n        inline function fail() {\r\n            luxe.Log.log(\"failed to create shader : \" + id + \"\\n\\n\" + log + '\\n' + errors);\r\n            throw \":( shader errors \";\r\n        }\r\n\r\n            //Any errors? fail\r\n        if( vert_shader == null || frag_shader == null ) {\r\n            fail();\r\n        }\r\n\r\n            //Link shader\r\n        link();\r\n\r\n            //Check compile status and throw errors if there are any\r\n        if(program == null) {\r\n            fail();\r\n        } else {\r\n            if(_verbose && log.length > 0) {\r\n                luxe.Log.log(log);\r\n            }\r\n        }\r\n\r\n            //if it fails return false\r\n        if( program == null ) return false;\r\n\r\n        return true;\r\n    }\r\n\r\n    function toString() {\r\n        return 'Shader($id) vert:$vertex_source_name / frag: $frag_source_name';\r\n    }\r\n\r\n    @:noCompletion public function apply_uniforms() {\r\n\r\n        GL.uniform1i( tex0_attribute, 0 );\r\n        GL.uniform1i( tex1_attribute, 1 );\r\n        GL.uniform1i( tex2_attribute, 2 );\r\n        GL.uniform1i( tex3_attribute, 3 );\r\n        GL.uniform1i( tex4_attribute, 4 );\r\n        GL.uniform1i( tex5_attribute, 5 );\r\n        GL.uniform1i( tex6_attribute, 6 );\r\n        GL.uniform1i( tex7_attribute, 7 );\r\n\r\n        for(uniform in uniforms) {\r\n\r\n            switch(uniform.type) {\r\n                case int:       apply_int( uniform.location, uniform.value );\r\n                case float:     apply_float( uniform.location, uniform.value );\r\n                case vector2:   apply_vec2( uniform.location, uniform.value );\r\n                case vector3:   apply_vec3( uniform.location, uniform.value );\r\n                case vector4:   apply_vec4( uniform.location, uniform.value );\r\n                case color:     apply_color( uniform.location, uniform.value );\r\n                case texture:   apply_texture( uniform.location, uniform.value );\r\n                case unknown:\r\n            } //switch type\r\n\r\n        } //for each uniform\r\n    }\r\n\r\n    inline function location( _name : String ) : Location {\r\n        return GL.getUniformLocation( program, _name );\r\n    }\r\n\r\n    inline function apply_int( _location:Location, _int:Int ) {\r\n        GL.uniform1i( _location, _int );\r\n    }\r\n\r\n    inline function apply_float( _location:Location, _float:Float ) {\r\n        GL.uniform1f( _location, _float );\r\n    }\r\n\r\n    inline function apply_vec2( _location:Location, _vec:Vector ) {\r\n        GL.uniform2f( _location, _vec.x, _vec.y);\r\n    }\r\n\r\n    inline function apply_vec3( _location:Location, _vec:Vector ) {\r\n        GL.uniform3f( _location, _vec.x, _vec.y, _vec.z );\r\n    }\r\n\r\n    inline function apply_vec4( _location:Location, _vec:Vector ) {\r\n        GL.uniform4f( _location, _vec.x, _vec.y, _vec.z, _vec.w );\r\n    }\r\n\r\n    inline function apply_color( _location:Location, _color:Color ) {\r\n        GL.uniform4f( _location, _color.r, _color.g, _color.b, _color.a );\r\n    }\r\n\r\n    inline function apply_texture( _location:Location, _tex:Texture ) {\r\n        GL.uniform1i( _location, _tex.slot );\r\n        _tex.bind();\r\n    }\r\n\r\n    inline function add_log( _log:String ) {\r\n        log += _log;\r\n    }\r\n\r\n    inline function add_error( _error:String ) {\r\n        errors += _error;\r\n    }\r\n\r\n} //Shader\r\n\r\n\r\n@:enum abstract UniformType(Int) from Int to Int {\r\n    var unknown = 0;\r\n    var int = 1;\r\n    var float = 2;\r\n    var vector2 = 3;\r\n    var vector3 = 4;\r\n    var vector4 = 5;\r\n    var color = 6;\r\n    var texture = 7;\r\n}\r\n\r\ntypedef Uniform<T> = {\r\n\r\n    var name : String;\r\n    var value : T;\r\n    var type : UniformType;\r\n    var location : Location;\r\n\r\n} //Uniform\r\n\r\n\r\n\r\n","package phoenix;\r\n\r\nimport luxe.Objects;\r\n\r\nimport phoenix.Vector;\r\nimport phoenix.Quaternion;\r\nimport phoenix.Matrix;\r\nimport snow.io.typedarray.Float32Array;\r\n\r\n\r\nclass Transform extends ID {\r\n\r\n    //access\r\n    @:isVar public var parent (get,set) : Transform;\r\n    @:isVar public var local (get,set) : Spatial;\r\n    @:isVar public var world (get,set) : Spatial;\r\n    @:isVar public var origin (get,set) : Vector;\r\n        //true if the transform needs refreshing,\r\n        //starts true since there are no values\r\n    @:isVar public var dirty (default,set) : Bool = true;\r\n\r\n        //alias to local.pos, local.rotation, local.scale\r\n    public var pos                  (get,set) : Vector;\r\n    public var rotation             (get,set) : Quaternion;\r\n    public var scale                (get,set) : Vector;\r\n\r\n    var _origin_undo_matrix : Matrix;\r\n    var _pos_matrix : Matrix;\r\n    var _rotation_matrix : Matrix;\r\n    var _setup : Bool = true;\r\n    var _cleaning : Bool = false;\r\n\r\n        //List of handler functions\r\n    var _clean_handlers : Array< Transform->Void >;\r\n    var _dirty_handlers : Array< Transform->Void >;\r\n    var _pos_handlers : Array< Vector->Void >;\r\n    var _rotation_handlers : Array< Quaternion->Void >;\r\n    var _scale_handlers : Array< Vector->Void >;\r\n    var _origin_handlers : Array< Vector->Void >;\r\n    var _parent_handlers : Array< Transform->Void >;\r\n\r\n    public inline function new() {\r\n\r\n        super('transform');\r\n\r\n        local = new Spatial();\r\n        world = new Spatial();\r\n\r\n        _origin_undo_matrix = new Matrix();\r\n        _pos_matrix = new Matrix();\r\n        _rotation_matrix = new Matrix();\r\n\r\n        origin = new Vector();\r\n\r\n            //Whenever the local transform changes we need to know\r\n        local.pos_changed = on_local_pos_change;\r\n        local.rotation_changed = on_local_rotation_change;\r\n        local.scale_changed = on_local_scale_change;\r\n\r\n        _setup = false;\r\n\r\n    } //new\r\n\r\n\r\n    var _destroying = false;\r\n\r\n    public function destroy() {\r\n\r\n        _destroying = true;\r\n\r\n            //no longer listening\r\n        if(parent != null) {\r\n            parent.unlisten(on_parent_cleaned);\r\n        }\r\n\r\n            //destroy resources and memory\r\n        _clean_handlers = null;\r\n        _dirty_handlers = null;\r\n        _pos_handlers = null;\r\n        _rotation_handlers = null;\r\n        _scale_handlers = null;\r\n        _origin_handlers = null;\r\n        _parent_handlers = null;\r\n\r\n            //clean up\r\n        local.destroy();\r\n        world.destroy();\r\n\r\n        local = null;\r\n        world = null;\r\n        origin = null;\r\n        _origin_undo_matrix = null;\r\n        _pos_matrix = null;\r\n        _rotation_matrix = null;\r\n\r\n    } //destroy\r\n\r\n    inline function set_dirty( _dirty:Bool ) : Bool {\r\n\r\n        dirty = _dirty;\r\n\r\n        if(  dirty &&\r\n            !_setup &&\r\n            _dirty_handlers != null &&\r\n            _dirty_handlers.length > 0\r\n        ) {\r\n            propagate_dirty();\r\n        }\r\n\r\n        return dirty;\r\n\r\n    } //set_dirty\r\n\r\n        //when the local transforms change we become dirty\r\n    inline function on_local_pos_change( v:Vector ) {\r\n\r\n        dirty = true;\r\n\r\n        if(_pos_handlers != null &&\r\n           _pos_handlers.length > 0) {\r\n                propagate_pos( v );\r\n        }\r\n\r\n    } //local pos changed\r\n\r\n    inline function on_local_rotation_change( r:Quaternion ) {\r\n\r\n        dirty = true;\r\n\r\n        if(_rotation_handlers != null &&\r\n           _rotation_handlers.length > 0) {\r\n                propagate_rotation( r );\r\n        }\r\n\r\n    } //local rotation changed\r\n\r\n    inline function on_local_scale_change( s:Vector ) {\r\n\r\n        dirty = true;\r\n\r\n        if(_scale_handlers != null &&\r\n           _scale_handlers.length > 0) {\r\n                propagate_scale( s );\r\n        }\r\n\r\n    } //local scale changed\r\n\r\n    inline function on_parent_cleaned( p:Transform ) {\r\n\r\n        dirty = true;\r\n\r\n    } //on_parent_cleaned\r\n\r\n    inline function get_local() : Spatial {\r\n\r\n        return local;\r\n\r\n    } //get_local\r\n\r\n    inline function set_local( l:Spatial ) : Spatial {\r\n\r\n        if(l != null) {\r\n\r\n            dirty = true;\r\n\r\n            l.pos_changed = on_local_pos_change;\r\n            l.rotation_changed = on_local_rotation_change;\r\n            l.scale_changed = on_local_scale_change;\r\n\r\n        }\r\n\r\n        return local = l;\r\n\r\n    } //set_local\r\n\r\n        //whenever the world transform is requested, make sure it's up to date\r\n    inline function get_world() : Spatial {\r\n\r\n        if( !_destroying ) {\r\n            clean_check();\r\n        }\r\n\r\n        return world;\r\n\r\n    } //get_world\r\n\r\n    @:noCompletion public inline function clean_check() {\r\n\r\n            //make sure the parent is updated\r\n        if(parent != null) {\r\n\r\n            if(parent.dirty) {\r\n                parent.clean();\r\n            } //parent.dirty\r\n\r\n        } //parent != null\r\n\r\n        if(dirty && !_cleaning) {\r\n            clean();\r\n        } //dirty\r\n\r\n    }//clean_check\r\n\r\n    @:noCompletion public inline function clean() {\r\n\r\n        if(!dirty) {\r\n            return;\r\n        }\r\n\r\n            //flag to avoid loops\r\n        _cleaning = true;\r\n\r\n            //update local matrices\r\n        _pos_matrix.makeTranslation( local.pos.x, local.pos.y, local.pos.z );\r\n        _rotation_matrix.makeRotationFromQuaternion( local.rotation );\r\n        _origin_undo_matrix.makeTranslation( -origin.x, -origin.y, -origin.z );\r\n\r\n                //translate to origin\r\n        local.matrix.makeTranslation( origin.x, origin.y, origin.z );\r\n\r\n                //scale up relative to origin\r\n            local.matrix.scale(local.scale);\r\n                //rotation relative to origin\r\n            local.matrix.multiply(_rotation_matrix);\r\n                //apply position\r\n            local.matrix.setPosition( local.pos );\r\n\r\n            //undo origin translation\r\n        local.matrix.multiply(_origin_undo_matrix);\r\n\r\n            //update world matrix\r\n        if(parent != null) {\r\n            world.matrix = world.matrix.multiplyMatrices( parent.world.matrix, local.matrix );\r\n        } else {\r\n            world.matrix = local.matrix.clone();\r\n        }\r\n\r\n            //update world spatial,\r\n            //saying false allows it to decide\r\n            //if this code happens or not\r\n        world.decompose(false);\r\n\r\n            //clear flags\r\n        dirty = false;\r\n        _cleaning = false;\r\n\r\n        if( _clean_handlers != null &&\r\n            _clean_handlers.length > 0) {\r\n                propagate_clean();\r\n        }\r\n\r\n    } //clean\r\n\r\n    inline function toString() {\r\n        return 'Transform ($id)';\r\n    } //toString\r\n\r\n    inline function get_origin() : Vector {\r\n\r\n        return origin;\r\n\r\n    } //get_origin\r\n\r\n    inline function set_origin(o:Vector) : Vector {\r\n\r\n        dirty = true;\r\n\r\n        origin = o;\r\n\r\n        if(_origin_handlers != null &&\r\n           _origin_handlers.length > 0) {\r\n            propagate_origin( origin );\r\n        }\r\n\r\n        return origin;\r\n\r\n    } //set_origin\r\n\r\n    inline function set_world(w:Spatial) : Spatial {\r\n\r\n        if(w == null) {\r\n            return world = w;\r\n        }\r\n\r\n        dirty = true;\r\n\r\n        return world = w;\r\n\r\n    } //set_world\r\n\r\n    inline function get_parent() : Transform {\r\n\r\n        return parent;\r\n\r\n    } //get_parent\r\n\r\n    inline function set_parent( _p:Transform ) {\r\n\r\n        dirty = true;\r\n\r\n            //clear existing listener\r\n        if(parent != null) {\r\n            parent.unlisten(on_parent_cleaned);\r\n        }\r\n\r\n        parent = _p;\r\n\r\n        if(_parent_handlers != null &&\r\n           _parent_handlers.length > 0) {\r\n                propagate_parent( parent );\r\n        }\r\n\r\n        if(parent != null) {\r\n            //we need to know when the parent transform is changed, this makes us dirty,\r\n            //and since each full clean can clear the dirty flag, we use this to make sure it's always synced\r\n            parent.listen(on_parent_cleaned);\r\n        }\r\n\r\n        return parent;\r\n\r\n    } //set_parent\r\n\r\n    inline function get_pos() {\r\n        return local.pos;\r\n    } //get_pos\r\n\r\n    inline function get_rotation() {\r\n        return local.rotation;\r\n    } //get_rotation\r\n\r\n    inline function get_scale() {\r\n        return local.scale;\r\n    } //get_scale\r\n\r\n\r\n    inline function set_pos(value:Vector) {\r\n        return local.pos = value;\r\n    } //set_pos\r\n\r\n    inline function set_rotation(value:Quaternion) {\r\n        return local.rotation = value;\r\n    } //set_rotation\r\n\r\n    inline function set_scale(value:Vector) {\r\n        return local.scale = value;\r\n    } //set_scale\r\n\r\n\r\n    inline function propagate_clean() {\r\n        for(_handler in _clean_handlers) {\r\n            if(_handler != null) {\r\n                _handler(this);\r\n            }\r\n        }\r\n    } //propagate clean\r\n\r\n    inline function propagate_dirty() {\r\n        for(_handler in _dirty_handlers) {\r\n            if(_handler != null) {\r\n                _handler(this);\r\n            }\r\n        }\r\n    } //propagate dirty\r\n\r\n    inline function propagate_pos( _pos:Vector ) {\r\n        for(_handler in _pos_handlers) {\r\n            if(_handler != null) {\r\n                _handler(_pos);\r\n            }\r\n        }\r\n    } //propagate pos\r\n\r\n    inline function propagate_rotation( _rotation:Quaternion ) {\r\n        for(_handler in _rotation_handlers) {\r\n            if(_handler != null) {\r\n                _handler(_rotation);\r\n            }\r\n        }\r\n    } //propagate rotation\r\n\r\n    inline function propagate_scale( _scale:Vector ) {\r\n        for(_handler in _scale_handlers) {\r\n            if(_handler != null) {\r\n                _handler(_scale);\r\n            }\r\n        }\r\n    } //propagate scale\r\n\r\n    inline function propagate_origin( _origin:Vector ) {\r\n        for(_handler in _origin_handlers) {\r\n            if(_handler != null) {\r\n                _handler(_origin);\r\n            }\r\n        }\r\n    } //propagate origin\r\n\r\n    inline function propagate_parent( _parent:Transform ) {\r\n        for(_handler in _parent_handlers) {\r\n            if(_handler != null) {\r\n                _handler(_parent);\r\n            }\r\n        }\r\n    } //propagate parent\r\n\r\n    public inline function listen( _handler : Transform->Void ) {\r\n\r\n        if(_clean_handlers == null) {\r\n            _clean_handlers = [];\r\n        }\r\n\r\n        _clean_handlers.push( _handler );\r\n\r\n    } //listen\r\n\r\n    public inline function unlisten( _handler : Transform->Void ) {\r\n\r\n        if(_clean_handlers == null) {\r\n            return false;\r\n        }\r\n\r\n        return _clean_handlers.remove( _handler );\r\n\r\n    } //unlisten\r\n\r\n    public inline function listen_dirty( _handler : Transform->Void ) {\r\n\r\n        if(_dirty_handlers == null) {\r\n            _dirty_handlers = [];\r\n        }\r\n\r\n        _dirty_handlers.push( _handler );\r\n\r\n    } //listen_dirty\r\n\r\n    public inline function unlisten_dirty( _handler : Transform->Void ) {\r\n\r\n        if(_dirty_handlers == null) {\r\n            return false;\r\n        }\r\n\r\n        return _dirty_handlers.remove( _handler );\r\n\r\n    } //unlisten_dirty\r\n\r\n    public inline function listen_pos( _handler : Vector->Void ) {\r\n\r\n        if(_pos_handlers == null) {\r\n            _pos_handlers = [];\r\n        }\r\n\r\n        _pos_handlers.push( _handler );\r\n\r\n    } //listen_pos\r\n\r\n    public inline function unlisten_pos( _handler : Vector->Void ) {\r\n\r\n        if(_pos_handlers == null) {\r\n            return false;\r\n        }\r\n\r\n        return _pos_handlers.remove( _handler );\r\n\r\n    } //unlisten_pos\r\n\r\n    public inline function listen_scale( _handler : Vector->Void ) {\r\n\r\n        if(_scale_handlers == null) {\r\n            _scale_handlers = [];\r\n        }\r\n\r\n        _scale_handlers.push( _handler );\r\n\r\n    } //listen_scale\r\n\r\n    public inline function unlisten_scale( _handler : Vector->Void ) {\r\n\r\n        if(_scale_handlers == null) {\r\n            return false;\r\n        }\r\n\r\n        return _scale_handlers.remove( _handler );\r\n\r\n    } //unlisten_scale\r\n\r\n    public inline function listen_rotation( _handler : Quaternion->Void ) {\r\n\r\n        if(_rotation_handlers == null) {\r\n            _rotation_handlers = [];\r\n        }\r\n\r\n        _rotation_handlers.push( _handler );\r\n\r\n    } //listen_rotation\r\n\r\n    public inline function unlisten_rotation( _handler : Quaternion->Void ) {\r\n\r\n        if(_rotation_handlers == null) {\r\n            return false;\r\n        }\r\n\r\n        return _rotation_handlers.remove( _handler );\r\n\r\n    } //unlisten_rotation\r\n\r\n    public inline function listen_origin( _handler : Vector->Void ) {\r\n\r\n        if(_origin_handlers == null) {\r\n            _origin_handlers = [];\r\n        }\r\n\r\n        _origin_handlers.push( _handler );\r\n\r\n    } //listen_origin\r\n\r\n    public inline function unlisten_origin( _handler : Vector->Void ) {\r\n\r\n        if(_origin_handlers == null) {\r\n            return false;\r\n        }\r\n\r\n        return _origin_handlers.remove( _handler );\r\n\r\n    } //unlisten_origin\r\n\r\n    public inline function listen_parent( _handler : Transform->Void ) {\r\n\r\n        if(_parent_handlers == null) {\r\n            _parent_handlers = [];\r\n        }\r\n\r\n        _parent_handlers.push( _handler );\r\n\r\n    } //listen_parent\r\n\r\n    public inline function unlisten_parent( _handler : Transform->Void ) {\r\n\r\n        if(_parent_handlers == null) {\r\n            return false;\r\n        }\r\n\r\n        return _parent_handlers.remove( _handler );\r\n\r\n    } //unlisten_parent\r\n\r\n} //Transform\r\n\r\nclass Spatial {\r\n\r\n    @:isVar public var pos                  (default,set) : Vector;\r\n    @:isVar public var rotation             (default,set) : Quaternion;\r\n    @:isVar public var scale                (default,set) : Vector;\r\n\r\n    @:isVar public var matrix               (get,    set) : Matrix;\r\n\r\n    public var floats : Float32Array;\r\n    public var ignore_listeners : Bool = false;\r\n    public var auto_decompose : Bool = false;\r\n\r\n    @:noCompletion public var pos_changed : Vector -> Void;\r\n    @:noCompletion public var rotation_changed : Quaternion -> Void;\r\n    @:noCompletion public var scale_changed : Vector -> Void;\r\n\r\n    var _setup : Bool = true;\r\n\r\n    public inline function new() {\r\n\r\n        matrix = new Matrix();\r\n        floats = matrix.float32array();\r\n\r\n        pos = new Vector();\r\n        rotation = new Quaternion();\r\n        scale = new Vector(1,1,1);\r\n\r\n        _setup = false;\r\n\r\n    } //new\r\n\r\n    public inline function destroy() {\r\n\r\n        matrix = null;\r\n        floats = null;\r\n        pos = null;\r\n        rotation = null;\r\n        scale = null;\r\n\r\n    } //destroy\r\n\r\n        //assigns the local values (pos/rotation/scale) according to the matrix\r\n        //when called manually, will make sure it happens using force.\r\n        //if force is false, auto_decompose will apply\r\n    public inline function decompose( _force:Bool = true ) {\r\n\r\n        if( auto_decompose || _force ) {\r\n\r\n            var _transform = matrix.decompose();\r\n\r\n            pos = _transform.pos;\r\n            rotation = _transform.rotation;\r\n            scale = _transform.scale;\r\n\r\n        } //auto_decompose\r\n\r\n        return this;\r\n\r\n    } //decompose\r\n\r\n    inline function get_matrix() : Matrix {\r\n\r\n        return matrix;\r\n\r\n    } //get_matrix\r\n\r\n    inline function set_matrix(_m:Matrix) {\r\n\r\n        matrix = _m;\r\n\r\n            //when updating, update the float32array\r\n        if( _m != null ) {\r\n            floats = matrix.float32array();\r\n        }\r\n\r\n        return matrix;\r\n\r\n    } //set_matrix\r\n\r\n    inline function propagate_pos( _p:Vector ) {\r\n        if(pos_changed != null && !ignore_listeners) {\r\n            pos_changed(_p);\r\n        }\r\n    } //propagate pos\r\n\r\n    inline function propagate_rotation( _r:Quaternion ) {\r\n        if(rotation_changed != null && !ignore_listeners) {\r\n            rotation_changed(_r);\r\n        }\r\n    } //propagate rotation\r\n\r\n    inline function propagate_scale( _s:Vector ) {\r\n        if(scale_changed != null && !ignore_listeners) {\r\n            scale_changed(_s);\r\n        }\r\n    } //propagate scale\r\n\r\n    inline function set_pos( _p:Vector ) {\r\n\r\n        pos = _p;\r\n\r\n        if( _p != null ) {\r\n\r\n            Vector.Listen( pos, _pos_change );\r\n\r\n            propagate_pos(pos);\r\n\r\n        } //\r\n\r\n        return pos;\r\n\r\n    } //set_pos\r\n\r\n    inline function set_rotation( _r:Quaternion ) {\r\n\r\n        rotation = _r;\r\n\r\n        if( _r != null ) {\r\n\r\n            Quaternion.Listen( rotation, _rotation_change );\r\n\r\n            propagate_rotation(rotation);\r\n\r\n        } //\r\n\r\n        return rotation;\r\n\r\n    } //set_rotation\r\n\r\n    inline function set_scale( _s:Vector ) {\r\n\r\n        scale = _s;\r\n\r\n        if( _s != null ) {\r\n\r\n            Vector.Listen( scale, _scale_change );\r\n\r\n            propagate_scale(scale);\r\n\r\n        } //\r\n\r\n        return scale;\r\n\r\n    } //set_scale\r\n\r\n //Sub component change listeners\r\n\r\n        //An internal callback for when x y or z on a transform changes\r\n    inline function _pos_change(_v:Float) { this.set_pos(pos); }\r\n        //An internal callback for when x y or z on a transform changes\r\n    inline function _scale_change(_v:Float) { this.set_scale(scale); }\r\n        //An internal callback for when x y or z on a transform changes\r\n    inline function _rotation_change(_v:Float) { this.set_rotation(rotation); }\r\n\r\n} //Spatial\r\n","package phoenix;\r\n\r\nimport luxe.utils.Maths;\r\n\r\nclass Vector {\r\n\r\n    @:isVar public var x (default, set) : Float = 0;\r\n    @:isVar public var y (default, set) : Float = 0;\r\n    @:isVar public var z (default, set) : Float = 0;\r\n    @:isVar public var w (default, default) : Float = 0;\r\n\r\n    @:isVar public var length        (get, set) : Float;\r\n    @:isVar public var lengthsq      (get, null) : Float;\r\n    @:isVar public var angle2D       (get, set) : Float;\r\n    @:isVar public var normalized    (get, null) : Vector;\r\n    @:isVar public var inverted      (get, null) : Vector;\r\n\r\n    public var ignore_listeners : Bool = false;\r\n\r\n    @:isVar public var listen_x(default,default) : Float -> Void;\r\n    @:isVar public var listen_y(default,default) : Float -> Void;\r\n    @:isVar public var listen_z(default,default) : Float -> Void;\r\n\r\n    var _construct = false;\r\n\r\n    public inline function new( _x:Float = 0, _y:Float = 0, _z:Float = 0, _w:Float = 0 ) {\r\n\r\n        _construct = true;\r\n\r\n            x = _x;\r\n            y = _y;\r\n            z = _z;\r\n            w = _w;\r\n\r\n        _construct = false;\r\n\r\n    } //new\r\n\r\n    public inline function copy_from( _other:Vector ) {\r\n\r\n        set( _other.x, _other.y, _other.z, _other.w );\r\n\r\n        return this;\r\n\r\n    } //copy_from\r\n\r\n    public inline function set( _x:Float, _y:Float, _z:Float, _w:Float ) {\r\n\r\n        var prev = ignore_listeners;\r\n\r\n        ignore_listeners = true;\r\n\r\n            x = _x;\r\n            y = _y;\r\n            z = _z;\r\n            w = _w;\r\n\r\n        ignore_listeners = prev;\r\n\r\n        if(listen_x != null && !ignore_listeners) listen_x(x);\r\n        if(listen_y != null && !ignore_listeners) listen_y(y);\r\n        if(listen_z != null && !ignore_listeners) listen_z(z);\r\n\r\n        return this;\r\n\r\n    } //set\r\n\r\n    public inline function set_xy( _x:Float, _y:Float ) {\r\n\r\n        var prev = ignore_listeners;\r\n\r\n        ignore_listeners = true;\r\n\r\n            x = _x;\r\n            y = _y;\r\n\r\n        ignore_listeners = prev;\r\n\r\n        if(listen_x != null && !ignore_listeners) listen_x(x);\r\n        if(listen_y != null && !ignore_listeners) listen_y(y);\r\n\r\n        return this;\r\n\r\n    } //set_xy\r\n\r\n    public inline function set_xyz( _x:Float, _y:Float, _z:Float ) {\r\n\r\n        var prev = ignore_listeners;\r\n\r\n        ignore_listeners = true;\r\n\r\n            x = _x;\r\n            y = _y;\r\n            z = _z;\r\n\r\n        ignore_listeners = prev;\r\n\r\n        if(listen_x != null && !ignore_listeners) listen_x(x);\r\n        if(listen_y != null && !ignore_listeners) listen_y(y);\r\n        if(listen_z != null && !ignore_listeners) listen_z(z);\r\n\r\n        return this;\r\n\r\n    } //set_xyz\r\n\r\n        //_t is between 0 and 1\r\n    public inline function lerp_xy( _dest_x:Float, _dest_y:Float, _t: Float ) {\r\n\r\n        set_xy(\r\n            Maths.lerp(x, _dest_x, _t),\r\n            Maths.lerp(y, _dest_y, _t)\r\n        );\r\n\r\n        return this;\r\n\r\n    } //lerp_xy\r\n\r\n        //_t is between 0 and 1\r\n    public inline function lerp_xyz( _dest_x:Float, _dest_y:Float, _dest_z:Float, _t: Float ) {\r\n\r\n        set_xyz(\r\n            Maths.lerp(x, _dest_x, _t),\r\n            Maths.lerp(y, _dest_y, _t),\r\n            Maths.lerp(z, _dest_z, _t)\r\n        );\r\n\r\n        return this;\r\n\r\n    } //lerp_xyz\r\n\r\n    public inline function weighted_average_xy( _dest_x:Float, _dest_y:Float, _slowness:Float ) {\r\n\r\n        set_xy(\r\n            Maths.weighted_avg(x, _dest_x, _slowness),\r\n            Maths.weighted_avg(y, _dest_y, _slowness)\r\n        );\r\n\r\n        return this;\r\n\r\n    } //weighted_average_xy\r\n\r\n    public inline function weighted_average_xyz( _dest_x:Float, _dest_y:Float, _dest_z:Float, _slowness:Float ) {\r\n\r\n        set_xyz(\r\n            Maths.weighted_avg(x, _dest_x, _slowness),\r\n            Maths.weighted_avg(y, _dest_y, _slowness),\r\n            Maths.weighted_avg(z, _dest_z, _slowness)\r\n        );\r\n\r\n        return this;\r\n\r\n    } //weighted_average_xyz\r\n\r\n    public inline function int() {\r\n\r\n        set_xyz( Math.round(x), Math.round(y), Math.round(z) );\r\n\r\n        return this;\r\n\r\n    } //int\r\n\r\n    public inline function int_x() {\r\n\r\n        x = Math.round(x);\r\n\r\n        return this;\r\n\r\n    } //int_z\r\n\r\n    public inline function int_y() {\r\n\r\n        y = Math.round(y);\r\n\r\n        return this;\r\n\r\n    } //int_y\r\n\r\n    public inline function int_z() {\r\n\r\n        z = Math.round(z);\r\n\r\n        return this;\r\n\r\n    } //int_y\r\n\r\n    inline function toString() {\r\n\r\n        return \"{ x:\"+x + \", y:\" + y + \", z:\" + z  + \" }\" ;\r\n\r\n    } //toString\r\n\r\n    public inline function equals(other:Vector) {\r\n        return (x == other.x && y == other.y && z == other.z && w == other.w);\r\n    }\r\n\r\n    public inline function clone() {\r\n        return new Vector(x, y, z, w);\r\n    } //clone\r\n\r\n    public inline function normalize() {\r\n        return divideScalar( length );\r\n    } //normalize\r\n\r\n    public inline function dot(other:Vector) {\r\n\r\n        return x * other.x + y * other.y + z * other.z;\r\n\r\n    } //dot\r\n\r\n\r\n    public inline function cross( a:Vector, b:Vector ) {\r\n\r\n        set_xyz( a.y * b.z - a.z * b.y,\r\n                 a.z * b.x - a.x * b.z,\r\n                 a.x * b.y - a.y * b.x );\r\n\r\n        return this;\r\n\r\n    } //cross\r\n\r\n    public function invert() : Vector {\r\n\r\n            set_xyz(-x, -y, -z);\r\n\r\n        return this;\r\n\r\n    } //invert\r\n\r\n//Static Functions\r\n\r\n    public static inline function Add(a:Vector, b:Vector) {\r\n        return new Vector(\r\n            a.x + b.x,\r\n            a.y + b.y,\r\n            a.z + b.z\r\n        );\r\n    } //Add\r\n\r\n    public static inline function Subtract(a:Vector, b:Vector) {\r\n        return new Vector(\r\n            a.x - b.x,\r\n            a.y - b.y,\r\n            a.z - b.z\r\n        );\r\n    } //Subtract\r\n\r\n    public static inline function MultiplyVector(a:Vector, b:Vector) : Vector {\r\n        return new Vector(\r\n            a.x * b.x,\r\n            a.y * b.y,\r\n            a.z * b.z\r\n        );\r\n    } //MultiplyVector\r\n\r\n    public static inline function DivideVector(a:Vector, b:Vector) {\r\n        return new Vector(\r\n            a.x / b.x,\r\n            a.y / b.y,\r\n            a.z / b.z\r\n        );\r\n    } //DivideVector\r\n\r\n    public static function Multiply(a:Vector, b:Float) {\r\n        return new Vector(\r\n            a.x * b,\r\n            a.y * b,\r\n            a.z * b\r\n        );\r\n    } //Multiply\r\n\r\n    public static inline function Divide(a:Vector, b:Float) {\r\n        return new Vector(\r\n            a.x / b,\r\n            a.y / b,\r\n            a.z / b\r\n        );\r\n    } //Divide\r\n\r\n    public static inline function AddScalar(a:Vector, b:Float) {\r\n        return new Vector(\r\n            a.x + b,\r\n            a.y + b,\r\n            a.z + b\r\n        );\r\n    } //AddScalar\r\n\r\n    public static inline function SubtractScalar(a:Vector, b:Float) {\r\n        return new Vector(\r\n            a.x - b,\r\n            a.y - b,\r\n            a.z - b\r\n        );\r\n    } //SubtractScalar\r\n\r\n    public static inline function Cross(a:Vector, b:Vector) {\r\n        return new Vector(\r\n             a.y * b.z - a.z * b.y,\r\n             a.z * b.x - a.x * b.z,\r\n             a.x * b.y - a.y * b.x\r\n        );\r\n    } //Cross\r\n\r\n    public static inline function RotationTo(a:Vector,b:Vector) {\r\n\r\n        return a.rotationTo(b);\r\n\r\n    } //RotationTo\r\n\r\n    public static function Listen( _v:Vector, listener ) {\r\n\r\n        _v.listen_x = listener;\r\n        _v.listen_y = listener;\r\n        _v.listen_z = listener;\r\n\r\n    } //Listen\r\n\r\n// Operations\r\n\r\n    public inline function add(other:Vector) {\r\n\r\n        if(other == null) {\r\n            throw \"vector.add other was handed in as null\";\r\n        }\r\n\r\n        set_xyz( x + other.x, y + other.y, z + other.z );\r\n\r\n        return this;\r\n\r\n    } //add\r\n\r\n    public inline function add_xyz( _x:Float = 0, _y:Float = 0, _z:Float = 0 ) {\r\n\r\n        set_xyz( x + _x, y + _y, z + _z);\r\n\r\n        return this;\r\n\r\n    } //add_xyz\r\n\r\n\r\n    public inline function subtract(other:Vector) {\r\n\r\n        if(other == null) {\r\n            throw \"vector.subtract other was handed in as null\";\r\n        }\r\n\r\n        set_xyz( x - other.x, y - other.y, z - other.z );\r\n\r\n        return this;\r\n\r\n    } //subtract\r\n\r\n    public inline function subtract_xyz( _x:Float = 0, _y:Float = 0, _z:Float = 0 ) {\r\n\r\n        set_xyz( x - _x, y - _y, z - _z);\r\n\r\n        return this;\r\n\r\n    } //subtract_xyz\r\n\r\n    public inline function multiply(other:Vector) {\r\n\r\n        if(other == null) {\r\n            throw \"vector.multiply other was handed in as null\";\r\n        }\r\n\r\n        set_xyz( x * other.x, y * other.y, z * other.z );\r\n\r\n        return this;\r\n\r\n    } //multiply\r\n\r\n    public inline function multiply_xyz( _x:Float = 1, _y:Float = 1, _z:Float = 1 ) {\r\n\r\n        set_xyz( x * _x, y * _y, z * _z);\r\n\r\n        return this;\r\n\r\n    } //multiply_xyz\r\n\r\n        //:todo: check for division by 0\r\n    public inline function divide(other:Vector) {\r\n\r\n        if(other == null) {\r\n            throw \"vector.divide other was handed in as null\";\r\n        }\r\n\r\n        set_xyz( x / other.x, y / other.y, z / other.z );\r\n\r\n        return this;\r\n\r\n    } //divide\r\n\r\n    public inline function divide_xyz( _x:Float = 1, _y:Float = 1, _z:Float = 1 ) {\r\n\r\n        set_xyz( x / _x, y / _y, z / _z);\r\n\r\n        return this;\r\n\r\n    } //multiply_xyz\r\n\r\n\r\n    public inline function addScalar( v:Float ) {\r\n\r\n        set_xyz( x + v, y + v, z + v );\r\n\r\n        return this;\r\n\r\n    } //addScalar\r\n\r\n    public inline function subtractScalar( v:Float ) {\r\n\r\n        set_xyz( x - v, y - v, z - v );\r\n\r\n        return this;\r\n\r\n    } //subtractScalar\r\n\r\n     public inline function multiplyScalar( v:Float ) {\r\n\r\n        set_xyz( x * v, y * v, z * v );\r\n\r\n        return this;\r\n\r\n    } //multiplyScalar\r\n\r\n    public inline function divideScalar( v:Float ) : Vector {\r\n\r\n        if ( v != 0 ) {\r\n\r\n            set_xyz( x / v, y / v, z / v );\r\n\r\n        } else {\r\n\r\n            set_xyz(0, 0, 0);\r\n\r\n        }\r\n\r\n        return this;\r\n\r\n    } //divideScalar\r\n\r\n\r\n//Properties\r\n\r\n    inline function set_length( value:Float ) : Float {\r\n\r\n        normalize().multiplyScalar( value );\r\n\r\n        return value;\r\n\r\n    } //set_length\r\n\r\n    inline function get_length() : Float {\r\n\r\n        return Math.sqrt( x * x + y * y + z * z );\r\n\r\n    } //get_length\r\n\r\n\r\n    inline function get_lengthsq() : Float {\r\n\r\n        return x * x + y * y + z * z;\r\n\r\n    } //get_lengthsq\r\n\r\n    inline function get_normalized() {\r\n\r\n        return Vector.Divide( this, length );\r\n\r\n    } //get_normalized\r\n\r\n    inline function set_x(_x:Float) : Float {\r\n\r\n        x = _x;\r\n\r\n        if(_construct) return x;\r\n\r\n            if(listen_x != null && !ignore_listeners) listen_x(_x);\r\n\r\n        return x;\r\n\r\n    } //set_x\r\n\r\n    inline function set_y(_y:Float) : Float {\r\n\r\n        y = _y;\r\n\r\n        if(_construct) return y;\r\n\r\n            if(listen_y != null && !ignore_listeners) listen_y(_y);\r\n\r\n        return y;\r\n\r\n    } //set_y\r\n\r\n    inline function set_z(_z:Float) : Float {\r\n\r\n        z = _z;\r\n\r\n        if(_construct) return z;\r\n\r\n            if(listen_z != null && !ignore_listeners) listen_z(_z);\r\n\r\n        return z;\r\n\r\n    } //set_z\r\n\r\n    inline function get_inverted() : Vector {\r\n\r\n        return new Vector(-x,-y,-z);\r\n\r\n    } //get_inverted\r\n\r\n\r\n        //Changes the angle of the vector.\r\n        //X and Y will change, length stays the same.\r\n    inline function set_angle2D( value : Float ) : Float {\r\n\r\n        var len:Float = length;\r\n\r\n            set_xy(Math.cos(value) * len, Math.sin(value) * len);\r\n\r\n        return value;\r\n    }\r\n\r\n        //Get the angle of this vector.\r\n    inline function get_angle2D():Float {\r\n\r\n        return Math.atan2(y, x);\r\n\r\n    }\r\n\r\n//Convenience functions\r\n\r\n        //Sets the length under the given value.\r\n        //Nothing is done if the vector is already shorter.\r\n        //max The max length this vector can be.\r\n    public inline function truncate( max:Float ) : Vector {\r\n\r\n        length = Math.min(max, length);\r\n\r\n        return this;\r\n\r\n    } //truncate\r\n\r\n    public inline function rotationTo( other:Vector ) : Float {\r\n        var theta =  Math.atan2(  other.x - x , other.y - y );\r\n        var r = -(180.0 + (theta*180.0/Math.PI));\r\n        return r;\r\n    }\r\n\r\n//Transforms\r\n\r\n    public inline function applyQuaternion( q:Quaternion ) : Vector {\r\n\r\n        var qx = q.x;\r\n        var qy = q.y;\r\n        var qz = q.z;\r\n        var qw = q.w;\r\n\r\n        var ix = qw * x + qy * z - qz * y;\r\n        var iy = qw * y + qz * x - qx * z;\r\n        var iz = qw * z + qx * y - qy * x;\r\n        var iw = -qx * x - qy * y - qz * z;\r\n\r\n            set_xyz( ix * qw + iw * -qx + iy * -qz - iz * -qy,\r\n                     iy * qw + iw * -qy + iz * -qx - ix * -qz,\r\n                     iz * qw + iw * -qz + ix * -qy - iy * -qx );\r\n\r\n        return this;\r\n\r\n    } //applyQuaternion\r\n\r\n    public inline function applyProjection( m:Matrix ) : Vector {\r\n\r\n        var e = m.elements;\r\n        var x = this.x, y = this.y, z = this.z;\r\n        var d:Float = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);\r\n\r\n            set_xyz( (e[0] * x + e[4] * y + e[8] * z + e[12]) * d,\r\n                     (e[1] * x + e[5] * y + e[9] * z + e[13]) * d,\r\n                     (e[2] * x + e[6] * y + e[10] * z + e[14]) * d );\r\n\r\n        return this;\r\n\r\n    } //applyProjection\r\n\r\n    public inline function transform( _m:Matrix ) : Vector {\r\n\r\n        var _x = x;\r\n        var _y = y;\r\n        var _z = z;\r\n\r\n        var e = _m.elements;\r\n\r\n            set_xyz( e[0] * _x + e[4] * _y + e[8]  * _z + e[12],\r\n                     e[1] * _x + e[5] * _y + e[9]  * _z + e[13],\r\n                     e[2] * _x + e[6] * _y + e[10] * _z + e[14] );\r\n\r\n        return this;\r\n\r\n    } //transform\r\n\r\n    public inline function transformDirection( m:Matrix ) : Vector {\r\n\r\n        var e = m.elements;\r\n        var x = this.x, y = this.y, z = this.z;\r\n\r\n            set_xyz( e[0] * x + e[4] * y + e[8] * z,\r\n                     e[1] * x + e[5] * y + e[9] * z,\r\n                     e[2] * x + e[6] * y + e[10] * z );\r\n\r\n        normalize();\r\n\r\n        return this;\r\n\r\n    } //transformDirection\r\n\r\n    public inline function setEulerFromRotationMatrix (m:Matrix, order:ComponentOrder = XYZ) : Vector {\r\n\r\n        var te = m.elements;\r\n        var m11 = te[0], m12 = te[4], m13 = te[8];\r\n        var m21 = te[1], m22 = te[5], m23 = te[9];\r\n        var m31 = te[2], m32 = te[6], m33 = te[10];\r\n\r\n        var _x = x;\r\n        var _y = y;\r\n        var _z = z;\r\n\r\n        if (order == XYZ) {\r\n\r\n            _y = Math.asin( Maths.clamp( m13, -1, 1 ) );\r\n\r\n            if (Math.abs(m13) < 0.99999)\r\n            {\r\n                _x = Math.atan2( -m23, m33);\r\n                _z = Math.atan2( -m12, m11);\r\n            } else {\r\n                _x = Math.atan2( m32, m22 );\r\n                _z = 0;\r\n            }\r\n\r\n        }  else if ( order == YXZ ) {\r\n\r\n            _x = Math.asin( -Maths.clamp( m23, -1, 1 ) );\r\n\r\n            if ( Math.abs( m23 ) < 0.99999 ) {\r\n                _y = Math.atan2( m13, m33 );\r\n                _z = Math.atan2( m21, m22 );\r\n            } else {\r\n                _y = Math.atan2( -m31, m11 );\r\n                _z = 0;\r\n            }\r\n\r\n        } else if ( order == ZXY ) {\r\n\r\n            _x = Math.asin( Maths.clamp( m32, -1, 1 ) );\r\n\r\n            if ( Math.abs( m32 ) < 0.99999 ) {\r\n                _y = Math.atan2( -m31, m33 );\r\n                _z = Math.atan2( -m12, m22 );\r\n            } else {\r\n                _y = 0;\r\n                _z = Math.atan2( m21, m11 );\r\n            }\r\n\r\n        } else if ( order == ZYX ) {\r\n\r\n            _y = Math.asin( -Maths.clamp( m31, -1, 1 ) );\r\n\r\n            if ( Math.abs( m31 ) < 0.99999 ) {\r\n                _x = Math.atan2( m32, m33 );\r\n                _z = Math.atan2( m21, m11 );\r\n            } else {\r\n                _x = 0;\r\n                _z = Math.atan2( -m12, m22 );\r\n            }\r\n\r\n        } else if ( order == YZX ) {\r\n\r\n            _z = Math.asin( Maths.clamp( m21, -1, 1 ) );\r\n\r\n            if ( Math.abs( m21 ) < 0.99999 ) {\r\n                _x = Math.atan2( -m23, m22 );\r\n                _y = Math.atan2( -m31, m11 );\r\n            } else {\r\n                _x = 0;\r\n                _y = Math.atan2( m13, m33 );\r\n            }\r\n\r\n        } else if ( order == XZY ) {\r\n\r\n            _z = Math.asin( -Maths.clamp( m12, -1, 1 ) );\r\n\r\n            if ( Math.abs( m12 ) < 0.99999 ) {\r\n                _x = Math.atan2( m32, m22 );\r\n                _y = Math.atan2( m13, m11 );\r\n            } else {\r\n                _x = Math.atan2( -m23, m33 );\r\n                _y = 0;\r\n            }\r\n\r\n        } //order\r\n\r\n        set_xyz(_x, _y, _z);\r\n\r\n        return this;\r\n\r\n    } //setEulerFromRotationMatrix\r\n\r\n    public inline function setEulerFromQuaternion (q:Quaternion, order:ComponentOrder = XYZ) : Vector {\r\n\r\n        var sqx : Float = q.x * q.x;\r\n        var sqy : Float = q.y * q.y;\r\n        var sqz : Float = q.z * q.z;\r\n        var sqw : Float = q.w * q.w;\r\n\r\n        var _x = x;\r\n        var _y = y;\r\n        var _z = z;\r\n\r\n        if (order == XYZ) {\r\n            _x = Math.atan2( 2 * ( q.x * q.w - q.y * q.z ), ( sqw - sqx - sqy + sqz ) );\r\n            _y = Math.asin(  Maths.clamp( 2 * ( q.x * q.z + q.y * q.w ), -1, 1 ) );\r\n            _z = Math.atan2( 2 * ( q.z * q.w - q.x * q.y ), ( sqw + sqx - sqy - sqz ) );\r\n        } else if ( order ==  YXZ ) {\r\n            _x = Math.asin(  Maths.clamp( 2 * ( q.x * q.w - q.y * q.z ), -1, 1 ) );\r\n            _y = Math.atan2( 2 * ( q.x * q.z + q.y * q.w ), ( sqw - sqx - sqy + sqz ) );\r\n            _z = Math.atan2( 2 * ( q.x * q.y + q.z * q.w ), ( sqw - sqx + sqy - sqz ) );\r\n        } else if ( order == ZXY ) {\r\n            _x = Math.asin(  Maths.clamp( 2 * ( q.x * q.w + q.y * q.z ), -1, 1 ) );\r\n            _y = Math.atan2( 2 * ( q.y * q.w - q.z * q.x ), ( sqw - sqx - sqy + sqz ) );\r\n            _z = Math.atan2( 2 * ( q.z * q.w - q.x * q.y ), ( sqw - sqx + sqy - sqz ) );\r\n        } else if ( order == ZYX ) {\r\n            _x = Math.atan2( 2 * ( q.x * q.w + q.z * q.y ), ( sqw - sqx - sqy + sqz ) );\r\n            _y = Math.asin(  Maths.clamp( 2 * ( q.y * q.w - q.x * q.z ), -1, 1 ) );\r\n            _z = Math.atan2( 2 * ( q.x * q.y + q.z * q.w ), ( sqw + sqx - sqy - sqz ) );\r\n        } else if ( order == YZX ) {\r\n            _x = Math.atan2( 2 * ( q.x * q.w - q.z * q.y ), ( sqw - sqx + sqy - sqz ) );\r\n            _y = Math.atan2( 2 * ( q.y * q.w - q.x * q.z ), ( sqw + sqx - sqy - sqz ) );\r\n            _z = Math.asin(  Maths.clamp( 2 * ( q.x * q.y + q.z * q.w ), -1, 1 ) );\r\n        } else if ( order == XZY ) {\r\n            _x = Math.atan2( 2 * ( q.x * q.w + q.y * q.z ), ( sqw - sqx + sqy - sqz ) );\r\n            _y = Math.atan2( 2 * ( q.x * q.z + q.y * q.w ), ( sqw + sqx - sqy - sqz ) );\r\n            _z = Math.asin(  Maths.clamp( 2 * ( q.z * q.w - q.x * q.y ), -1, 1 ) );\r\n        } //order\r\n\r\n        set_xyz(_x,_y,_z);\r\n\r\n        return this;\r\n\r\n    } //setEulerFromQuaternion\r\n\r\n    public inline function degrees() : Vector {\r\n\r\n        set_xyz( Maths.degrees(x), Maths.degrees(y), Maths.degrees(z) );\r\n\r\n        return this;\r\n\r\n    } //degrees\r\n\r\n    public inline function radians() : Vector {\r\n\r\n        set_xyz( Maths.radians(x), Maths.radians(y), Maths.radians(z) );\r\n\r\n        return this;\r\n\r\n    } //radians\r\n\r\n    public static function Degrees( _radian_vector:Vector ) : Vector {\r\n\r\n        return _radian_vector.clone().degrees();\r\n\r\n    } //Degrees\r\n\r\n    public static function Radians( _degree_vector:Vector ) : Vector {\r\n\r\n        return _degree_vector.clone().radians();\r\n\r\n    } //Radians\r\n\r\n} //Vector class\r\n\r\n\r\n\r\n@:enum abstract ComponentOrder(Int) from Int to Int {\r\n\r\n    var XYZ = 0;\r\n    var YXZ = 1;\r\n    var ZXY = 2;\r\n    var ZYX = 3;\r\n    var YZX = 4;\r\n    var XZY = 5;\r\n\r\n} //ComponentOrder\r\n\r\n\r\nabstract Vec(Vector) from Vector to Vector {\r\n\r\n    public inline function new(?_x,?_y,?_z,?_w) {\r\n        this = new Vector(_x,_y,_z,_w);\r\n    }\r\n//multiply\r\n    @:communitative @:op(A * B) static public inline function _multiply(lhs:Vec, rhs:Vec) : Vec {\r\n        return Vector.MultiplyVector(lhs, rhs);\r\n    }\r\n    @:communitative @:op(A * B) static public inline function _multiply_scalar(lhs:Vec, rhs:Float) : Vec {\r\n        return Vector.Multiply(lhs, rhs);\r\n    }\r\n    @:communitative @:op(A * B) static public inline function _multiply_scalar_int(lhs:Vec, rhs:Int) : Vec {\r\n        return Vector.Multiply(lhs, rhs);\r\n    }\r\n// divide\r\n    @:communitative @:op(A / B) static public inline function _divide(lhs:Vec, rhs:Vec) : Vec {\r\n        return Vector.DivideVector(lhs, rhs);\r\n    }\r\n    @:communitative @:op(A / B) static public inline function _divide_scalar(lhs:Vec, rhs:Float) : Vec {\r\n        return Vector.Divide(lhs, rhs);\r\n    }\r\n    @:communitative @:op(A / B) static public inline function _divide_scalar_int(lhs:Vec, rhs:Int) : Vec {\r\n        return Vector.Divide(lhs, rhs);\r\n    }\r\n// add\r\n    @:communitative @:op(A + B) static public inline function _add(lhs:Vec, rhs:Vec) : Vec {\r\n        return Vector.Add(lhs, rhs);\r\n    }\r\n    @:communitative @:op(A + B) static public inline function _add_scalar(lhs:Vec, rhs:Float) : Vec {\r\n        return Vector.AddScalar(lhs, rhs);\r\n    }\r\n    @:communitative @:op(A + B) static public inline function _add_scalar_int(lhs:Vec, rhs:Int) : Vec {\r\n        return Vector.AddScalar(lhs, rhs);\r\n    }\r\n// subract\r\n    @:communitative @:op(A - B) static public inline function _subtract(lhs:Vec, rhs:Vec) : Vec {\r\n        return Vector.Subtract(lhs,rhs);\r\n    }\r\n    @:communitative @:op(A - B) static public inline function _subtract_scalar(lhs:Vec, rhs:Float) : Vec {\r\n        return Vector.SubtractScalar(lhs,rhs);\r\n    }\r\n    @:communitative @:op(A - B) static public inline function _subtract_scalar_int(lhs:Vec, rhs:Int) : Vec {\r\n        return Vector.SubtractScalar(lhs,rhs);\r\n    }\r\n} //Vec\r\n","package phoenix.geometry;\r\n\r\n\r\nimport phoenix.geometry.Vertex;\r\nimport phoenix.Quaternion;\r\nimport phoenix.Rectangle;\r\nimport phoenix.Transform;\r\nimport phoenix.Vector;\r\nimport phoenix.Shader;\r\nimport phoenix.Texture;\r\nimport phoenix.Batcher;\r\n\r\nimport luxe.options.GeometryOptions;\r\n\r\nimport snow.io.typedarray.Float32Array;\r\n\r\nimport snow.render.opengl.GL;\r\n\r\nclass GeometryKey {\r\n\r\n    public inline function new() {}\r\n\r\n    public var timestamp : Float = 0;\r\n    public var sequence : Int = 0;\r\n    public var uuid : String = '';\r\n    public var primitive_type : PrimitiveType;\r\n    public var texture : Texture;\r\n    public var shader : Shader;\r\n    public var group : Int = 0;\r\n    public var depth : Float = 0;\r\n    public var clip : Bool = false;\r\n\r\n} //GeometryKey\r\n\r\nclass Geometry {\r\n\r\n        //the positional transform information\r\n    public var transform : Transform;\r\n\r\n        //The list of vertices\r\n    public var vertices : Array<Vertex>;\r\n\r\n        //Statically batched VBO's\r\n    public var submitted : Bool = false;\r\n    public var static_vertex_buffer : GLBuffer;\r\n    public var static_tcoord_buffer : GLBuffer;\r\n    public var static_vcolor_buffer : GLBuffer;\r\n    public var static_normal_buffer : GLBuffer;\r\n\r\n        //Batcher information\r\n    public var added : Bool = false;\r\n    public var batchers : Array<Batcher>;\r\n\r\n        //state\r\n    public var state : GeometryState;\r\n    public var dropped : Bool = false;\r\n    public var uuid : String = '';\r\n    public var id : String = '';\r\n\r\n        //State properties\r\n    @:isVar public var primitive_type (get, set) : PrimitiveType;\r\n    @:isVar public var texture (get, set) : Texture;\r\n    @:isVar public var shader (get, set) : Shader;\r\n    @:isVar public var depth (get, set) : Float;\r\n    @:isVar public var group (get, set) : Int;\r\n    @:isVar public var clip_rect (get, set) : Rectangle;\r\n\r\n    var shadow_primitive_type : PrimitiveType;\r\n    var shadow_texture : Texture;\r\n    var shadow_shader : Shader;\r\n    var shadow_group : Int = 0;\r\n    var shadow_depth : Float = 0.0;\r\n    var shadow_clip : Bool = false;\r\n\r\n    var dirty_primitive_type : Bool = false;\r\n    var dirty_texture : Bool = false;\r\n    var dirty_shader : Bool = false;\r\n    var dirty_group : Bool = false;\r\n    var dirty_depth : Bool = false;\r\n    var dirty_clip : Bool = false;\r\n\r\n        //Geometry properties\r\n    @:isVar public var visible      (default, set) : Bool = true;\r\n    @:isVar public var immediate    (default, default) : Bool = false;\r\n    @:isVar public var locked       (get, set) : Bool = false;\r\n    @:isVar public var dirty        (get, set) : Bool = false;\r\n    @:isVar public var color        (default, set) : Color;\r\n\r\n        //internal bool flag for clip sorting and clipping state\r\n    @:noCompletion @:isVar public var clip (get, set) : Bool;\r\n\r\n        //internal reuse cache value\r\n    var _final_vert_position : Vector;\r\n\r\n    public var key : GeometryKey;\r\n\r\n        //This is a failsafe against all other geometry key values being identical\r\n        //causing comparisons in a binary tree to fail. This value is never reset intentionally.\r\n    static var _sequence_key : Int = -1;\r\n\r\n    public function new( ?options:GeometryOptions ) {\r\n\r\n        uuid = Luxe.utils.uniqueid();\r\n        id = uuid;\r\n\r\n        vertices = new Array<Vertex>();\r\n        state = new GeometryState();\r\n        batchers = new Array<Batcher>();\r\n\r\n            //init transforms\r\n        transform = new Transform();\r\n\r\n            //init the empty vertex reuse\r\n        _final_vert_position = new Vector();\r\n\r\n            //geometry clipping\r\n        clip_rect = null;\r\n        clip = false;\r\n\r\n            //this only applies if batcher is supplied, but is overriden with no_batcher_add\r\n        var _do_add = true;\r\n\r\n\r\n        if(options != null) {\r\n\r\n            state.depth             = (options.depth == null)           ? state.depth           : options.depth;\r\n            state.group             = (options.group == null)           ? state.group           : options.group;\r\n            state.texture           = (options.texture == null)         ? state.texture         : options.texture;\r\n            state.clip_rect         = (options.clip_rect == null)       ? state.clip_rect       : options.clip_rect;\r\n            state.primitive_type    = (options.primitive_type == null)  ? state.primitive_type  : options.primitive_type;\r\n            state.shader            = (options.shader == null)          ? state.shader          : options.shader;\r\n\r\n            id                      = (options.id == null)              ? uuid                  : options.id;\r\n\r\n            transform.pos           = (options.pos == null)             ? transform.pos         : options.pos;\r\n            transform.rotation      = (options.rotation == null)        ? transform.rotation    : options.rotation;\r\n            transform.scale         = (options.scale == null)           ? transform.scale       : options.scale;\r\n            transform.origin        = (options.origin == null)          ? transform.origin      : options.origin;\r\n\r\n            immediate               = (options.immediate == null)       ? false                 : options.immediate;\r\n            visible                 = (options.visible == null)         ? true                  : options.visible;\r\n\r\n            color                   = (options.color == null)           ? new Color()           : options.color;\r\n            _do_add                 = (options.no_batcher_add == null)  ? true                  : options.no_batcher_add;\r\n\r\n        } else { //options != null\r\n\r\n                //assign required\r\n            color = new Color();\r\n\r\n        }\r\n\r\n        _sequence_key++;\r\n\r\n        key = new GeometryKey();\r\n\r\n            key.uuid = uuid;\r\n            key.timestamp = Luxe.time;\r\n            key.sequence = _sequence_key;\r\n            key.primitive_type = state.primitive_type;\r\n            key.texture = state.texture;\r\n            key.shader = state.shader;\r\n            key.group = state.group;\r\n            key.depth = state.depth;\r\n            key.clip = state.clip;\r\n\r\n        transform.id = uuid;\r\n        transform.name = id;\r\n\r\n            //only add it to a batcher if explicitly requested,\r\n            //otherwise do not add to a batcher at all\r\n        if(options != null && options.batcher != null && _do_add) {\r\n            options.batcher.add( this );\r\n        }\r\n\r\n    } //new\r\n\r\n    public function key_string() {\r\n\r\n        return\r\n            'ts: '+ key.timestamp + '\\n' +\r\n            'sequence: '+ key.sequence + '\\n' +\r\n            'primitive_type: '+ key.primitive_type + '\\n' +\r\n            'texture: '+ (key.texture == null ? 'null' : key.texture.id) + '\\n' +\r\n            'shader: '+ (key.shader == null ? 'null' : key.shader.id) + '\\n' +\r\n            'group: '+ key.group + '\\n' +\r\n            'depth: '+ key.depth + '\\n' +\r\n            'clip: '+ key.clip;\r\n\r\n    } //key_string\r\n\r\n    public function refresh_key() {\r\n\r\n        // _sequence_key++;\r\n\r\n        key.uuid = uuid;\r\n        key.timestamp = Luxe.time;\r\n        key.sequence = _sequence_key;\r\n        key.primitive_type = state.primitive_type;\r\n        key.texture = state.texture;\r\n        key.shader = state.shader;\r\n        key.group = state.group;\r\n        key.depth = state.depth;\r\n        key.clip = state.clip;\r\n\r\n    } //refresh_key\r\n\r\n    public function str() {\r\n        if(!state.log) return;\r\n        trace('\\t\\tgeometry ; ' + id);\r\n        state.log = true;\r\n        state.str();\r\n        state.log = false;\r\n    }\r\n\r\n    public function drop( ?remove:Bool = true ) {\r\n\r\n        if( remove && added ) {\r\n\r\n            for(b in batchers) {\r\n                b.remove( this, true );\r\n            } //for each batcher\r\n\r\n        }\r\n\r\n        if(transform != null) {\r\n            transform.destroy();\r\n            transform = null;\r\n        }\r\n\r\n        dropped = true;\r\n\r\n    } //drop\r\n\r\n    public function add( v : Vertex ) {\r\n\r\n        vertices.push( v );\r\n\r\n        if(vertices.length > Luxe.renderer.batcher.max_verts) {\r\n            throw '$id / Currently a single geometry cannot exceed the maximum vert count of ' + Luxe.renderer.batcher.max_verts;\r\n        }\r\n\r\n    } //add\r\n\r\n    public function remove( v : Vertex ) {\r\n\r\n        vertices.remove(v);\r\n\r\n    } //remove\r\n\r\n    public function batch( vert_index : Int, tcoord_index:Int, color_index:Int, normal_index:Int,\r\n                           vertlist : Float32Array, tcoordlist : Float32Array, colorlist : Float32Array, normallist : Float32Array\r\n        ) {\r\n\r\n        for(v in vertices) {\r\n\r\n                //the base position of the vert\r\n            _final_vert_position.set( v.pos.x, v.pos.y, v.pos.z, v.pos.w );\r\n                //apply the transform to the vert\r\n            _final_vert_position.transform( transform.world.matrix );\r\n\r\n                    //submit vertex positions\r\n                    //:todo: ask hugh about hxcpp ArrayImpl not being inline\r\n            // #if luxe_native\r\n            //     vertlist.__set_d((vert_index+0), _final_vert_position.x);\r\n            //     vertlist.__set_d((vert_index+1), _final_vert_position.y);\r\n            //     vertlist.__set_d((vert_index+2), _final_vert_position.z);\r\n            //     vertlist.__set_d((vert_index+3), _final_vert_position.w);\r\n            // #else\r\n                vertlist[(vert_index+0)] = _final_vert_position.x;\r\n                vertlist[(vert_index+1)] = _final_vert_position.y;\r\n                vertlist[(vert_index+2)] = _final_vert_position.z;\r\n                vertlist[(vert_index+3)] = _final_vert_position.w;\r\n            // #end\r\n\r\n            vert_index += 4;\r\n\r\n            //         //texture coordinates :todo: multiple uv sets\r\n            // #if luxe_native\r\n            //     tcoordlist.__set_d((tcoord_index+0), v.uv.uv0.u);\r\n            //     tcoordlist.__set_d((tcoord_index+1), v.uv.uv0.v);\r\n            //     tcoordlist.__set_d((tcoord_index+2), v.uv.uv0.w);\r\n            //     tcoordlist.__set_d((tcoord_index+3), v.uv.uv0.t);\r\n            // #else\r\n                tcoordlist[(tcoord_index+0)] = v.uv.uv0.u;\r\n                tcoordlist[(tcoord_index+1)] = v.uv.uv0.v;\r\n                tcoordlist[(tcoord_index+2)] = v.uv.uv0.w;\r\n                tcoordlist[(tcoord_index+3)] = v.uv.uv0.t;\r\n            // #end\r\n\r\n            tcoord_index += 4;\r\n\r\n                //color values per vertex\r\n\r\n            // #if luxe_native\r\n            //     colorlist.__set_d((color_index+0), v.color.r);\r\n            //     colorlist.__set_d((color_index+1), v.color.g);\r\n            //     colorlist.__set_d((color_index+2), v.color.b);\r\n            //     colorlist.__set_d((color_index+3), v.color.a);\r\n            // #else\r\n                colorlist[(color_index+0)] = v.color.r;\r\n                colorlist[(color_index+1)] = v.color.g;\r\n                colorlist[(color_index+2)] = v.color.b;\r\n                colorlist[(color_index+3)] = v.color.a;\r\n            // #end\r\n\r\n\r\n            color_index += 4;\r\n\r\n            //         //normal directions\r\n            //     normallist[(normal_index+0)] = v.normal.x;\r\n            //     normallist[(normal_index+1)] = v.normal.y;\r\n            //     normallist[(normal_index+2)] = v.normal.z;\r\n            //     normallist[(normal_index+3)] = v.normal.w;\r\n\r\n            // normal_index += 4;\r\n\r\n        } //each vertex\r\n\r\n    } //batch\r\n\r\n    public function batch_into_arrays( vertlist : Array<Float>, tcoordlist : Array<Float>,\r\n                           colorlist : Array<Float>, normallist : Array<Float> ) {\r\n\r\n        for(v in vertices) {\r\n\r\n                // the base position of the vert\r\n            _final_vert_position.set( v.pos.x, v.pos.y, v.pos.z, v.pos.w );\r\n                // apply the transform to the vert\r\n            _final_vert_position.transform( transform.world.matrix );\r\n\r\n                //submit vert positions\r\n            vertlist.push( _final_vert_position.x );\r\n            vertlist.push( _final_vert_position.y );\r\n            vertlist.push( _final_vert_position.z );\r\n            vertlist.push( _final_vert_position.w );\r\n\r\n                //texture coordinates :todo: multiple uv sets\r\n            tcoordlist.push( v.uv.uv0.u );\r\n            tcoordlist.push( v.uv.uv0.v );\r\n            tcoordlist.push( v.uv.uv0.w );\r\n            tcoordlist.push( v.uv.uv0.t );\r\n\r\n                //color values per vertex\r\n            colorlist.push( v.color.r );\r\n            colorlist.push( v.color.g );\r\n            colorlist.push( v.color.b );\r\n            colorlist.push( v.color.a );\r\n\r\n                //normal directions\r\n            normallist.push( v.normal.x );\r\n            normallist.push( v.normal.y );\r\n            normallist.push( v.normal.z );\r\n            normallist.push( v.normal.w );\r\n\r\n        } //each vertex\r\n\r\n    } //batch_into_arrays\r\n\r\n//Transform\r\n\r\n    public function translate( _offset:Vector ) {\r\n\r\n        transform.pos.set_xyz( transform.pos.x+_offset.x, transform.pos.y+_offset.y, transform.pos.x+_offset.z );\r\n\r\n    } // translate\r\n\r\n    function set_locked( _locked:Bool ) : Bool {\r\n\r\n        return locked = _locked;\r\n\r\n    } //set_locked\r\n\r\n    function get_locked() : Bool {\r\n\r\n        return locked;\r\n\r\n    } //get_locked\r\n\r\n    function set_dirty( _dirty:Bool ) : Bool {\r\n\r\n        return dirty = _dirty;\r\n\r\n    } //set_dirty\r\n\r\n    function get_dirty() : Bool {\r\n\r\n        return dirty;\r\n\r\n    } //get_dirty\r\n\r\n//Invariants that cause a shift in the geometry tree\r\n\r\n    function refresh() {\r\n\r\n            //remove from all batchers\r\n        for(b in batchers) {\r\n            b.remove( this, false );\r\n        } //for each batcher\r\n\r\n                //update the values from the shadow values, if needed\r\n            if(dirty_primitive_type) {\r\n                dirty_primitive_type = false;\r\n                state.primitive_type = shadow_primitive_type;\r\n            } //dirty_primitive_type\r\n\r\n            if(dirty_texture) {\r\n                dirty_texture = false;\r\n                state.texture = shadow_texture;\r\n            } //dirty_texture\r\n\r\n            if(dirty_shader) {\r\n                dirty_shader = false;\r\n                state.shader = shadow_shader;\r\n            } //dirty_shader\r\n\r\n            if(dirty_group) {\r\n                dirty_group = false;\r\n                state.group = shadow_group;\r\n            } //dirty_group\r\n\r\n            if(dirty_depth) {\r\n                dirty_depth = false;\r\n                state.depth = shadow_depth;\r\n            } //dirty_depth\r\n\r\n            if(dirty_clip) {\r\n                dirty_clip = false;\r\n                state.clip = shadow_clip;\r\n            } //dirty_clip\r\n\r\n                //make sure the key is updated\r\n           refresh_key();\r\n\r\n        for(b in batchers) {\r\n            b.add( this, false );\r\n        } //for each batcher\r\n\r\n    } //refresh\r\n\r\n//Primitive Type\r\n\r\n    function get_primitive_type() : PrimitiveType {\r\n\r\n        return state.primitive_type;\r\n\r\n    } //get_primitive_type\r\n\r\n    function set_primitive_type( val : PrimitiveType ) : PrimitiveType {\r\n\r\n        if(state.primitive_type != val) {\r\n            shadow_primitive_type = val;\r\n            dirty_primitive_type = true;\r\n            refresh();\r\n        }\r\n\r\n        return primitive_type = val;\r\n\r\n    } //set_primitive_type\r\n\r\n//Texture\r\n\r\n    function get_texture() : Texture {\r\n\r\n        return state.texture;\r\n\r\n    } //get_texture\r\n\r\n    function set_texture(val : Texture) : Texture {\r\n\r\n        if(state.texture != val) {\r\n            shadow_texture = val;\r\n            dirty_texture = true;\r\n            refresh();\r\n        }\r\n\r\n        return texture = val;\r\n\r\n    } //set_texture\r\n\r\n//Visibility\r\n\r\n    function set_visible(val : Bool) : Bool {\r\n\r\n        return visible = val;\r\n\r\n    } //set_visible\r\n\r\n//Color\r\n\r\n    function set_color(val : Color) : Color {\r\n\r\n        for(v in vertices) {\r\n            v.color = val;\r\n        } //for each vertex\r\n\r\n        return color = val;\r\n\r\n    } //set_color\r\n\r\n//Shader\r\n\r\n    function get_shader() : Shader {\r\n\r\n        return state.shader;\r\n\r\n    } //get_shader\r\n\r\n    function set_shader(val : Shader) : Shader {\r\n\r\n        if(state.shader != val) {\r\n            shadow_shader = val;\r\n            dirty_shader = true;\r\n            refresh();\r\n        }\r\n\r\n        return shader = val;\r\n\r\n    } //set_shader\r\n\r\n//Depth\r\n\r\n    function get_depth() : Float {\r\n\r\n        return state.depth;\r\n\r\n    } //get_depth\r\n\r\n\r\n    function set_depth(val : Float) : Float {\r\n\r\n        if(state.depth != val) {\r\n            shadow_depth = val;\r\n            dirty_depth = true;\r\n            refresh();\r\n        }\r\n\r\n        return depth = val;\r\n\r\n    } //set_depth\r\n\r\n//Group\r\n\r\n    function get_group() : Int {\r\n\r\n        return state.group;\r\n\r\n    } //get_group\r\n\r\n    function set_group(val : Int) : Int {\r\n\r\n        if(state.group != val) {\r\n            shadow_group = val;\r\n            dirty_group = true;\r\n            refresh();\r\n        }\r\n\r\n        return group = val;\r\n\r\n    } //set_group\r\n\r\n//Clip\r\n\r\n    function get_clip() : Bool {\r\n\r\n        return state.clip;\r\n\r\n    } //get_clip\r\n\r\n    function set_clip(val : Bool) : Bool {\r\n\r\n        if(state.clip != val) {\r\n            shadow_clip = val;\r\n            dirty_clip = true;\r\n            refresh();\r\n        }\r\n\r\n        return clip = val;\r\n\r\n    } //set_clip\r\n\r\n//Clip rect\r\n\r\n    function get_clip_rect() : Rectangle {\r\n\r\n        return state.clip_rect;\r\n\r\n    } //get_clip_rect\r\n\r\n    function set_clip_rect(val : Rectangle) : Rectangle {\r\n\r\n        if(val == null) {\r\n            clip = false;\r\n        } else {\r\n            clip = true;\r\n        }\r\n\r\n        return state.clip_rect = val;\r\n\r\n    } //set_clip_rect\r\n\r\n\r\n} //Geometry\r\n\r\n\r\n","package phoenix.geometry;\r\n\r\nimport phoenix.geometry.Vertex ;\r\nimport phoenix.Vector;\r\nimport phoenix.geometry.Geometry;\r\nimport phoenix.geometry.TextureCoord;\r\nimport phoenix.Batcher;\r\nimport phoenix.Circle;\r\n\r\nimport luxe.options.GeometryOptions.CircleGeometryOptions;\r\n\r\n\r\nclass CircleGeometry extends Geometry {\r\n\r\n\r\n    public function new( ?options : CircleGeometryOptions ) {\r\n\r\n        super(options);\r\n\r\n        if(options == null) {\r\n            return;\r\n        }\r\n\r\n            //some default values so that the circle is visible with no values\r\n        var _radius_x : Float = 32;\r\n        var _radius_y : Float = 32;\r\n\r\n        if(options.end_angle == null) {\r\n            options.end_angle = 360;\r\n        }\r\n\r\n        if(options.start_angle == null) {\r\n            options.start_angle = 0;\r\n        }\r\n\r\n        if(options.r != null) {\r\n            _radius_x = options.r;\r\n            _radius_y = options.r;\r\n        }\r\n\r\n        if(options.rx != null) {\r\n            _radius_x = options.rx;\r\n        }\r\n\r\n        if(options.ry != null) {\r\n            _radius_y = options.ry;\r\n        }\r\n\r\n        if(options.steps == null) {\r\n            if(options.smooth == null) {\r\n                var _max = Math.max(_radius_x, _radius_y);\r\n                options.steps = Luxe.utils.geometry.segments_for_smooth_circle( _max );\r\n            } else {\r\n                var _smooth : Float = options.smooth;\r\n                var _max = Math.max(_radius_x, _radius_y);\r\n                options.steps = Luxe.utils.geometry.segments_for_smooth_circle( _max, _smooth );\r\n            }\r\n        }\r\n\r\n            //Apply the new options\r\n        set( options.x, options.y, _radius_x, _radius_y, options.steps, options.start_angle, options.end_angle );\r\n\r\n        if(options.visible != null) visible = options.visible;\r\n\r\n    } //new\r\n\r\n    public function set( _x:Float, _y:Float, _rx:Float, _ry:Float, _steps:Int, _start_angle:Float=0, _end_angle:Float=360 ) {\r\n\r\n            //adapted from\r\n            //http://slabode.exofire.net/circle_draw.shtml\r\n\r\n        primitive_type = PrimitiveType.triangles;\r\n\r\n            var half_pi : Float = Math.PI/2;\r\n            var _start_angle_rad = luxe.utils.Maths.radians(_start_angle) - half_pi;\r\n            var _end_angle_rad = luxe.utils.Maths.radians(_end_angle) - half_pi;\r\n\r\n            var _range = _end_angle_rad - _start_angle_rad;\r\n\r\n                //how much % of 360 is this, to limit step count?\r\n            _steps = Math.ceil((Math.abs(_range)/(Math.PI*2)) * _steps );\r\n\r\n                //Precompute the value based on segments\r\n            var theta = _range / _steps;\r\n\r\n            var tangential_factor = Math.tan( theta );\r\n            var radial_factor = Math.cos( theta );\r\n\r\n            var x : Float = _rx * Math.cos(_start_angle_rad);\r\n            var y : Float = _rx * Math.sin(_start_angle_rad);\r\n\r\n            //now work out the ratio between _x and _y\r\n            var radial_ratio : Float = _rx / _ry;\r\n            if(radial_ratio == 0) {\r\n                radial_ratio = 0.000000001;\r\n            }\r\n\r\n            var _index = 0;\r\n            var _segment_pos = [];\r\n            for( i in 0 ... _steps+1 ) {\r\n\r\n                var __x = x;\r\n                var __y = y / radial_ratio;\r\n\r\n                    //the position of this current segment\r\n                var _seg = new Vector( __x,__y );\r\n                    //we store them to reference them behind\r\n                _segment_pos.push(_seg);\r\n\r\n                    //and if past first node, close the prev tri with new seg pos\r\n                if(_index > 0) {\r\n                    add(new Vertex( _seg, color )); //2\r\n                }\r\n\r\n                    //one for the center point\r\n                add( new Vertex( new Vector( 0,0 ), color ) ); //0\r\n\r\n                    //one for the segment position\r\n                add(new Vertex( _seg, color )); //1\r\n\r\n                var tx = -y;\r\n                var ty = x;\r\n\r\n                x += tx * tangential_factor;\r\n                y += ty * tangential_factor;\r\n\r\n                x *= radial_factor;\r\n                y *= radial_factor;\r\n\r\n                _index++;\r\n\r\n            } //for\r\n\r\n        add(new Vertex( _segment_pos[_steps], color )); //1\r\n\r\n            //and finally, set the position\r\n        transform.pos = new Vector( _x, _y );\r\n\r\n    } //set\r\n\r\n\r\n} //CircleGeometry\r\n","package phoenix.geometry;\r\n\r\nimport phoenix.geometry.Vertex ;\r\nimport phoenix.Vector;\r\nimport phoenix.geometry.Geometry;\r\nimport phoenix.geometry.TextureCoord;\r\nimport phoenix.Batcher;\r\nimport phoenix.Circle;\r\n\r\nimport luxe.options.GeometryOptions.CircleGeometryOptions;\r\n\r\nclass RingGeometry extends CircleGeometry {\r\n\r\n\tpublic function new( ?options : CircleGeometryOptions ) {\r\n\r\n\t\tsuper(options);\r\n\r\n\t\t\t//set to line type\r\n\t\tprimitive_type = PrimitiveType.lines;\r\n\r\n\t} //new\r\n\r\n\toverride public function set( _x:Float, _y:Float, _rx:Float, _ry:Float, _steps:Int, _start_angle_degrees:Float=0, _end_angle_degrees:Float=360 ) {\r\n\r\n            //adapted from\r\n            //http://slabode.exofire.net/circle_draw.shtml\r\n\r\n        primitive_type = PrimitiveType.triangles;\r\n\r\n            var _start_angle_rad = luxe.utils.Maths.radians(_start_angle_degrees);\r\n            var _end_angle_rad = luxe.utils.Maths.radians(_end_angle_degrees);\r\n\r\n            var _range = _end_angle_rad - _start_angle_rad;\r\n\r\n                //Precompute the value based on segments\r\n            var theta = _range / _steps;\r\n\r\n            var tangential_factor = Math.tan( theta );\r\n            var radial_factor = Math.cos( theta );\r\n\r\n            var x : Float = _rx * Math.cos(_start_angle_rad);\r\n            var y : Float = _rx * Math.sin(_start_angle_rad);\r\n\r\n            //now work out the ratio between _x and _y\r\n            var radial_ratio : Float = _rx / _ry;\r\n            if(radial_ratio == 0) radial_ratio = 0.000000001;\r\n\r\n            var _index = 0;\r\n            var _segment_pos = [];\r\n            for( i in 0 ... _steps ) {\r\n\r\n                var __x = x;\r\n                var __y = y / radial_ratio;\r\n\r\n                    //the position of this current segment\r\n                var _seg = new Vector( __x,__y );\r\n                    //we store them to reference them behind\r\n                _segment_pos.push(_seg);\r\n\r\n                    //one for the segment position\r\n                add(new Vertex( _seg, color ));\r\n\r\n                    //and if past 0, one for the prev segment to close the tri\r\n                if(_index > 0) {\r\n                    var prevvert = _segment_pos[_index];\r\n                    add(new Vertex( prevvert.clone(), color ));\r\n                }\r\n\r\n                var tx = -y;\r\n                var ty = x;\r\n\r\n                x += tx * tangential_factor;\r\n                y += ty * tangential_factor;\r\n\r\n                x *= radial_factor;\r\n                y *= radial_factor;\r\n\r\n                _index++;\r\n\r\n            } //for\r\n\r\n                //wrap it up\r\n            add( new Vertex( _segment_pos[0], color ) );\r\n\r\n        //and finally, set the position\r\n        transform.pos = new Vector( _x, _y );\r\n\r\n    } //set\r\n\r\n} //RingGeometry\r\n","package phoenix.geometry;\r\n\r\nimport phoenix.geometry.Vertex ;\r\nimport phoenix.geometry.RingGeometry;\r\nimport phoenix.Vector;\r\nimport phoenix.geometry.Geometry;\r\nimport phoenix.geometry.TextureCoord;\r\nimport phoenix.Batcher;\r\nimport phoenix.Circle;\r\n\r\nimport luxe.options.GeometryOptions.CircleGeometryOptions;\r\n\r\nclass ArcGeometry extends RingGeometry {\r\n\r\n\tpublic function new( ?options : CircleGeometryOptions ) {\r\n\r\n\t\tsuper(options);\r\n\r\n\t\t\t//remove the first center point\r\n\t\t\t//and the last extra vert\r\n\t\tvertices.pop();\r\n\t\tvertices.pop();\r\n\r\n\t\t\t//set to line type\r\n\t\tprimitive_type = PrimitiveType.lines;\r\n\r\n\t} //new\r\n\r\n} //RingGeometry\r\n","package phoenix.geometry;\r\n\r\nimport luxe.Log;\r\nimport phoenix.geometry.Geometry;\r\nimport phoenix.Batcher;\r\nimport phoenix.Quaternion;\r\nimport phoenix.Shader;\r\nimport phoenix.Texture;\r\n\r\nimport luxe.Log.log;\r\nimport luxe.Log._verbose;\r\nimport luxe.Log._debug;\r\n\r\nimport luxe.options.GeometryOptions;\r\n\r\nclass CompositeGeometry extends Geometry {\r\n\r\n    public var geometry : Array<Geometry>;\r\n\r\n    public function new( ?_options:GeometryOptions ) {\r\n\r\n        super( _options );\r\n\r\n        geometry = new Array<Geometry>();\r\n\r\n    } //new\r\n\r\n    function toString() {\r\n\r\n        return \"CompositeGeometry \" + geometry + ' : ' + Std.string(geometry);\r\n\r\n    } //toString\r\n\r\n    public function clear() {\r\n\r\n            //:todo: profile these splices vs new assigns in haxe\r\n\t\tfor (geom in geometry) {\r\n\t\t\tgeom.transform.parent = null;\r\n\t\t}\r\n        geometry.splice(0, geometry.length);\r\n\r\n    } //clear\r\n\r\n        //loses the old geometry for new geometry\r\n    public function replace(_geometry:Array<Geometry>) {\r\n\r\n            //remove references\r\n        clear();\r\n            //store the new geometry\r\n        geometry = _geometry;\r\n            //change their parent to this\r\n        for(geom in geometry) {\r\n            geom.transform.parent = transform;\r\n        }\r\n\r\n    } //replace\r\n\r\n    public function has_geometry( geom:Geometry ) {\r\n\r\n        return Lambda.has(geometry, geom);\r\n\r\n    } //has_geometry\r\n\r\n    public function add_geometry( geom:Geometry ) {\r\n\r\n        if(geom != null) {\r\n            geom.transform.parent = transform;\r\n            geometry.push(geom);\r\n        }\r\n\r\n    } //add_geometry\r\n\r\n    public function remove_geometry( g:Geometry ) {\r\n\t\t//Try to remove it, if successful also unlink parent\r\n        if (geometry.remove(g)) {\r\n\t\t\tg.transform.parent = null;\r\n\t\t}\r\n\r\n    } //remove_geometry\r\n\r\n    public function add_to_batcher( _batcher:Batcher ) {\r\n\r\n        for(geom in geometry) {\r\n            _batcher.add(geom);\r\n        }\r\n\r\n    } //add_to_batcher\r\n\r\n    public override function drop( ?remove:Bool = true ) {\r\n\r\n        super.drop( remove );\r\n\r\n        for(geom in geometry) {\r\n            geom.drop( remove );\r\n            geom = null;\r\n        }\r\n\r\n        geometry = null;\r\n        geometry = [];\r\n\r\n    } //drop\r\n\r\n    public override function translate( _offset:Vector ) {\r\n\r\n        if(geometry != null) {\r\n            for(geom in geometry) {\r\n                geom.translate(_offset);\r\n            }\r\n        }\r\n\r\n    } //translate\r\n\r\n\r\n//Properties\r\n\r\n\r\n    override function set_color( _color:Color ) : Color {\r\n\r\n        if(geometry != null) {\r\n            for(geom in geometry) {\r\n                geom.color = _color;\r\n            }\r\n        }\r\n\r\n        return color = _color;\r\n\r\n    } //set_color\r\n\r\n    override function set_primitive_type(val : PrimitiveType) : PrimitiveType {\r\n\r\n        if(geometry != null) {\r\n            for(geom in geometry) {\r\n                geom.primitive_type = val;\r\n            }\r\n        }\r\n\r\n        return primitive_type = val;\r\n\r\n    } //set_primitive_type\r\n\r\n    override function set_shader(val : Shader) : Shader {\r\n\r\n        if(geometry != null) {\r\n            for(geom in geometry) {\r\n                geom.shader = val;\r\n            }\r\n        }\r\n\r\n        return shader = val;\r\n\r\n    } //set_shader\r\n\r\n    override function set_texture(val : Texture) : Texture {\r\n\r\n        if(geometry != null) {\r\n\r\n            for(geom in geometry) {\r\n                geom.texture = val;\r\n            }\r\n        }\r\n\r\n        return texture = val;\r\n\r\n    } //set_texture\r\n\r\n    override function set_depth(val : Float) : Float {\r\n\r\n        if(geometry != null) {\r\n            for(geom in geometry) {\r\n                geom.depth = val;\r\n            }\r\n        }\r\n\r\n        return depth = val;\r\n\r\n    } //set_depth\r\n\r\n    override function set_group(val : Int) : Int {\r\n\r\n        if(geometry != null) {\r\n            for(geom in geometry) {\r\n                geom.group = val;\r\n            }\r\n        }\r\n\r\n        return group = val;\r\n\r\n    } //set_group\r\n\r\n    override function set_locked(val : Bool) : Bool {\r\n\r\n        if(geometry != null) {\r\n            for(geom in geometry) {\r\n                geom.locked = val;\r\n            }\r\n        }\r\n\r\n        return locked = val;\r\n\r\n    } //set_locked\r\n\r\n    override function set_dirty(val : Bool) : Bool {\r\n\r\n        if(geometry != null) {\r\n            for(geom in geometry) {\r\n                geom.dirty = val;\r\n            }\r\n        }\r\n\r\n        return dirty = val;\r\n\r\n    } //set_dirty\r\n\r\n    override function set_clip_rect(val : Rectangle) : Rectangle {\r\n\r\n        if(geometry != null) {\r\n            for(geom in geometry) {\r\n                geom.clip_rect = val;\r\n            }\r\n        }\r\n\r\n        return clip_rect = val;\r\n\r\n    } //set_clip_rect\r\n\r\n    override function set_visible(val : Bool) : Bool {\r\n\r\n        if(geometry != null) {\r\n            for(geom in geometry) {\r\n                geom.visible = val;\r\n            }\r\n        }\r\n\r\n        return visible = val;\r\n\r\n    } //set_visible\r\n\r\n} //CompositeGeometry\r\n","package phoenix.geometry;\r\n\r\nimport phoenix.Rectangle;\r\nimport phoenix.Texture;\r\nimport phoenix.Shader;\r\nimport phoenix.Batcher;\r\n\r\nclass GeometryState {\r\n\r\n    public var dirty:Bool;\r\n\r\n    @:isVar public var primitive_type(default, set) : PrimitiveType;\r\n    @:isVar public var shader(default, set) : Shader;\r\n    @:isVar public var texture(default, set) : Texture;\r\n    @:isVar public var depth(default, set) : Float;\r\n    @:isVar public var group(default, set) : Int;\r\n    @:isVar public var clip(default, set) : Bool;\r\n    @:isVar public var clip_rect(default, set) : Rectangle;\r\n\r\n    public var log : Bool = false;\r\n\r\n    public function new() {\r\n\r\n        clip = false;\r\n        clip_rect = new Rectangle();\r\n        texture = null;\r\n        shader = null;\r\n        group = 0;\r\n        depth = 0.0;\r\n        primitive_type = PrimitiveType.points;\r\n\r\n        dirty = false;\r\n\r\n    } //new\r\n\r\n    public function clone_onto( _other:GeometryState )  {\r\n\r\n        _other.dirty = dirty;\r\n        _other.texture = texture;\r\n        _other.shader = shader;\r\n        _other.group = group;\r\n        _other.depth = depth;\r\n        _other.primitive_type = primitive_type;\r\n        _other.clip = clip;\r\n        _other.clip_rect.copy_from( clip_rect );\r\n\r\n    } //clone_onto\r\n\r\n    public function str() {\r\n\r\n        if(!log) return;\r\n\r\n        trace('\\t+ GEOMETRYSTATE ' + dirty);\r\n            trace(\"\\t\\tdepth - \"+ depth);\r\n            trace(\"\\t\\tgroup - \"+ group);\r\n            trace(\"\\t\\ttexture - \" + (( texture == null) ? 'null' :  texture.id ));\r\n            if(texture != null) {\r\n                trace(\"\\t\\t\\t \" + texture.texture);\r\n            }\r\n            trace(\"\\t\\tshader - \" + (( shader == null) ? 'null' :  shader.id ));\r\n            trace(\"\\t\\tprimitive_type - \"+ primitive_type);\r\n            trace(\"\\t\\tclip - \"+ clip);\r\n            trace(\"\\t\\tclip rect - \"+ clip_rect );\r\n        trace('\\t- GEOMETRYSTATE');\r\n\r\n    } //str\r\n\r\n    public function clean() {\r\n\r\n        dirty = false;\r\n        // trace('cleaned geometry state ');\r\n    } //clean\r\n\r\n    public function update( other : GeometryState ) {\r\n\r\n        if(depth != other.depth) {\r\n            depth = other.depth;\r\n        }\r\n\r\n        if(group != other.group) {\r\n            group = other.group;\r\n        }\r\n\r\n        if(texture != other.texture) {\r\n            texture = other.texture;\r\n        }\r\n\r\n        if(shader != other.shader) {\r\n            shader = other.shader;\r\n        }\r\n\r\n        if(primitive_type != other.primitive_type) {\r\n            primitive_type = other.primitive_type;\r\n        }\r\n\r\n        if(clip != other.clip) {\r\n            clip = other.clip;\r\n        }\r\n\r\n        if(clip_rect != null) {\r\n            if(other.clip_rect != null && !clip_rect.equal(other.clip_rect)) {\r\n                clip_rect.set( other.clip_rect.x, other.clip_rect.y, other.clip_rect.w, other.clip_rect.h );\r\n            }\r\n        } //clip_rect\r\n\r\n    } //update\r\n\r\n//Primitive Type\r\n    public function set_primitive_type(val : PrimitiveType) : PrimitiveType {\r\n        dirty = true;\r\n        return primitive_type = val;\r\n    }\r\n//Texture\r\n    public function set_texture(val : Texture) : Texture {\r\n        dirty = true;\r\n        return texture = val;\r\n    }\r\n//Shader\r\n    public function set_shader(val : Shader) : Shader {\r\n        dirty = true;\r\n        return shader = val;\r\n    }\r\n//Depth\r\n    public function set_depth(val : Float) : Float {\r\n        return depth = val;\r\n    }\r\n//Group\r\n    public function set_group(val : Int) : Int {\r\n        dirty = true;\r\n        return group = val;\r\n    }\r\n//Clip\r\n    public function set_clip(val : Bool) : Bool {\r\n        dirty = true;\r\n        return clip = val;\r\n    }\r\n//Clip rect\r\n    public function set_clip_rect(val : Rectangle) : Rectangle {\r\n        dirty = true;\r\n        return clip_rect = val;\r\n    }\r\n//\r\n\r\n}\r\n","package phoenix.geometry;\r\n\r\nimport luxe.Vector;\r\nimport phoenix.Batcher;\r\nimport phoenix.geometry.Geometry;\r\n\r\nimport luxe.options.GeometryOptions.LineGeometryOptions;\r\n\r\nclass LineGeometry extends Geometry {\r\n\r\n    @:isVar public var p0(default,set) : Vector;\r\n    @:isVar public var p1(default,set) : Vector;\r\n\r\n    public function new( ?options : LineGeometryOptions ) {\r\n\r\n        super(options);\r\n\r\n        if(options == null) {\r\n            return;\r\n        }\r\n\r\n        if(options.color == null)  { options.color  = new Color(); }\r\n        if(options.color0 == null) { options.color0 = options.color; }\r\n        if(options.color1 == null) { options.color1 = options.color; }\r\n\r\n            if(options.p0 != null) {\r\n                p0 = options.p0;\r\n            } else {\r\n                p0 = new Vector();\r\n            }\r\n\r\n            if(options.p1 != null) {\r\n                p1 = options.p1;\r\n            } else {\r\n                p1 = new Vector();\r\n            }\r\n\r\n        set(options);\r\n\r\n    } //new\r\n\r\n    public function set_p0(_p:Vector) : Vector {\r\n\r\n        if(vertices.length == 0) return p0 = _p;\r\n\r\n            vertices[0].pos.x = _p.x;\r\n            vertices[0].pos.y = _p.y;\r\n            vertices[0].pos.z = _p.z;\r\n\r\n        return p0 = _p;\r\n\r\n    } //set_p0\r\n\r\n    public function set_p1(_p:Vector) : Vector {\r\n\r\n        if(vertices.length == 0) return p1 = _p;\r\n\r\n            vertices[1].pos.x = _p.x;\r\n            vertices[1].pos.y = _p.y;\r\n            vertices[1].pos.z = _p.z;\r\n\r\n        return p1 = _p;\r\n\r\n    } //set_p1\r\n\r\n    public function set(options:Dynamic) {\r\n\r\n        vertices.splice(0, vertices.length);\r\n\r\n        //p0\r\n        var vert0 : Vertex = new Vertex( new Vector( options.p0.x, options.p0.y, options.p0.z ), options.color0 );\r\n            vert0.uv.uv0.set_uv(0,0);\r\n\r\n        var vert1 : Vertex = new Vertex( new Vector( options.p1.x, options.p1.y, options.p1.z ), options.color1 );\r\n            vert1.uv.uv0.set_uv(1,0);\r\n\r\n        add(vert0);\r\n        add(vert1);\r\n\r\n        primitive_type = PrimitiveType.lines;\r\n        immediate = options.immediate;\r\n\r\n    } //set\r\n\r\n\r\n} //LineGeometry\r\n","package phoenix.geometry;\r\n\r\nimport luxe.Rectangle;\r\nimport phoenix.Vector;\r\nimport phoenix.geometry.Geometry;\r\nimport phoenix.geometry.TextureCoord;\r\nimport phoenix.Batcher;\r\nimport phoenix.Vector;\r\n\r\nimport luxe.options.GeometryOptions.PlaneGeometryOptions;\r\n\r\nclass PlaneGeometry extends Geometry {\r\n\r\n    @:isVar public var flipx(default, set) : Bool = false;\r\n    @:isVar public var flipy(default, set) : Bool = false;\r\n\r\n    var _uv_cache : luxe.Rectangle;\r\n\r\n    var is_set : Bool = false;\r\n\r\n\tpublic function new( ?options : PlaneGeometryOptions ) {\r\n\r\n\t\tsuper(options);\r\n\r\n        if(options == null) return;\r\n\r\n            //Do these before set, so they can be applied\r\n        if(options.flipx != null) flipx = options.flipx;\r\n        if(options.flipy != null) flipy = options.flipy;\r\n\r\n            //Init\r\n        _uv_cache = new Rectangle(0,0,1,1);\r\n\r\n            //Apply the new options rect\r\n\t\tset( new Rectangle(options.x, options.z, options.w, options.h), options.y );\r\n\r\n        if(options.visible != null) visible = options.visible;\r\n        if(options.immediate != null) immediate = options.immediate;\r\n\r\n\t} //new\r\n\r\n    public function uv( _rect:luxe.Rectangle ) {\r\n\r\n        if(texture == null) {\r\n            trace(\"Warning : calling UV on a geometry with null texture.\");\r\n            return;\r\n        }\r\n\r\n        var tlx = _rect.x/texture.width_actual;\r\n        var tly = _rect.y/texture.height_actual;\r\n        var szx = _rect.w/texture.width_actual;\r\n        var szy = _rect.h/texture.height_actual;\r\n\r\n        uv_space( new luxe.Rectangle( tlx, tly, szx, szy ) );\r\n\r\n    } //uv\r\n\r\n    public function uv_space( _rect:luxe.Rectangle ) {\r\n\r\n            //the uv width and height\r\n        var sz_x = _rect.w;\r\n        var sz_y = _rect.h;\r\n\r\n            //tl\r\n        var tl_x = _rect.x;\r\n        var tl_y = _rect.y;\r\n\r\n            //Keep for later, before changing the values for flipping\r\n        _uv_cache.set( tl_x, tl_y, sz_x, sz_y );\r\n\r\n            //tr\r\n        var tr_x = tl_x + sz_x;\r\n        var tr_y = tl_y;\r\n            //br\r\n        var br_x = tl_x + sz_x;\r\n        var br_y = tl_y + sz_y;\r\n            //bl\r\n        var bl_x = tl_x;\r\n        var bl_y = tl_y + sz_y;\r\n\r\n        var tmp_x = 0.0;\r\n        var tmp_y = 0.0;\r\n\r\n                //flipped y swaps tl and tr with bl and br, only on y\r\n            if(flipy) {\r\n\r\n                    //swap tl and bl\r\n                tmp_y = bl_y;\r\n                    bl_y = tl_y;\r\n                    tl_y = tmp_y;\r\n\r\n                    //swap tr and br\r\n                tmp_y = br_y;\r\n                    br_y = tr_y;\r\n                    tr_y = tmp_y;\r\n\r\n            } //flipy\r\n\r\n                //flipped x swaps tl and bl with tr and br, only on x\r\n            if(flipx) {\r\n\r\n                    //swap tl and tr\r\n                tmp_x = tr_x;\r\n                    tr_x = tl_x;\r\n                    tl_x = tmp_x;\r\n\r\n                    //swap bl and br\r\n                tmp_x = br_x;\r\n                    br_x = bl_x;\r\n                    bl_x = tmp_x;\r\n\r\n            } //flipx\r\n\r\n        vertices[0].uv.uv0.set_uv( tl_x , tl_y );\r\n        vertices[1].uv.uv0.set_uv( tr_x , tr_y );\r\n        vertices[2].uv.uv0.set_uv( br_x , br_y );\r\n\r\n        vertices[3].uv.uv0.set_uv( bl_x , bl_y );\r\n        vertices[4].uv.uv0.set_uv( tl_x , tl_y );\r\n        vertices[5].uv.uv0.set_uv( br_x , br_y );\r\n\r\n            //if it's locked, it needs to be refreshed to the gpu\r\n        dirty = true;\r\n\r\n    } //set uv in uv space directly\r\n\r\n \tpublic function set( quad:luxe.Rectangle, y:Float ) {\r\n\r\n \t\tvertices.splice(0, vertices.length);\r\n\r\n        //Create the rectangle at it's origin,\r\n        //so that when geometry.pos is set it is translated accordingly\r\n\r\n            //First triangle\r\n        var vert0 : Vertex = new Vertex( new Vector( 0, 0, 0 ), color );\r\n        var vert1 : Vertex = new Vertex( new Vector( quad.w, 0, 0 ), color );\r\n        var vert2 : Vertex = new Vertex( new Vector( quad.w, 0, quad.h ), color );\r\n\r\n           //Second triangle\r\n        var vert3 : Vertex = new Vertex( new Vector( 0 , 0, quad.h ), color );\r\n        var vert4 : Vertex = new Vertex( new Vector( 0 , 0, 0 ), color );\r\n        var vert5 : Vertex = new Vertex( new Vector( quad.w , 0, quad.h ), color );\r\n\r\n           //Add to the list\r\n\r\n            //tl\r\n        add( vert5 );\r\n            //tr\r\n        add( vert4 );\r\n            //br\r\n        add( vert3 );\r\n            //bl\r\n        add( vert2 );\r\n            //tl\r\n        add( vert1 );\r\n            //br\r\n        add( vert0 );\r\n\r\n\r\n        primitive_type = PrimitiveType.triangles;\r\n        immediate = false;\r\n\r\n            //And finally move it into place\r\n        transform.pos = new Vector(quad.x, y, quad.y);\r\n\r\n            //Make sure we know we can access the verts now\r\n        is_set = true;\r\n\r\n            //Apply default UV, handles flipping etc\r\n        uv_space( new luxe.Rectangle(0,0,1,1) );\r\n\r\n \t} //set\r\n\r\n    public function set_flipx(_val:Bool) {\r\n            //set before calling uv_space\r\n        flipx = _val;\r\n\r\n        if(is_set) {\r\n            uv_space(_uv_cache);\r\n        }\r\n\r\n        return flipx;\r\n    } //set_flipx\r\n\r\n    public function set_flipy(_val:Bool) {\r\n\r\n            //set before calling uv_space\r\n        flipy = _val;\r\n\r\n        if(is_set) {\r\n            uv_space(_uv_cache);\r\n        }\r\n\r\n        return flipy;\r\n    } //set_flipy\r\n\r\n\r\n\r\n}\r\n","package phoenix.geometry;\r\n\r\nimport phoenix.Vector;\r\nimport phoenix.geometry.Geometry;\r\nimport phoenix.geometry.TextureCoord;\r\nimport phoenix.Batcher;\r\nimport phoenix.Vector;\r\n\r\nimport luxe.options.GeometryOptions.QuadGeometryOptions;\r\n\r\nclass QuadGeometry extends Geometry {\r\n\r\n    @:isVar public var flipx(default, set) : Bool = false;\r\n    @:isVar public var flipy(default, set) : Bool = false;\r\n\r\n    var _uv_cache : luxe.Rectangle;\r\n\r\n    var is_set : Bool = false;\r\n\r\n\tpublic function new( ?options : QuadGeometryOptions ) {\r\n\r\n\t\tsuper(options);\r\n\r\n        if(options == null) return;\r\n\r\n            //Do these before set, so they can be applied\r\n        if(options.flipx != null) flipx = options.flipx;\r\n        if(options.flipy != null) flipy = options.flipy;\r\n\r\n        var _x : Float = options.x;\r\n        var _y : Float = options.y;\r\n        var _w : Float = options.w;\r\n        var _h : Float = options.h;\r\n\r\n        if(options.rect != null) {\r\n            _x = options.rect.x;\r\n            _y = options.rect.y;\r\n            _w = options.rect.w;\r\n            _h = options.rect.h;\r\n        }\r\n\r\n            //Init\r\n        _uv_cache = new luxe.Rectangle(0,0,1,1);\r\n\r\n            //Apply the new options rect\r\n        set( new Rectangle(_x, _y, _w, _h) );\r\n\r\n        if(options.visible != null) visible = options.visible;\r\n        if(options.immediate != null) immediate = options.immediate;\r\n\r\n\t}\r\n\r\n    public function uv( _rect:luxe.Rectangle ) {\r\n\r\n        if(texture == null) {\r\n            trace(\"Warning : calling UV on a geometry with null texture.\");\r\n            return;\r\n        }\r\n\r\n        var tlx = _rect.x/texture.width_actual;\r\n        var tly = _rect.y/texture.height_actual;\r\n        var szx = _rect.w/texture.width_actual;\r\n        var szy = _rect.h/texture.height_actual;\r\n\r\n        uv_space( new luxe.Rectangle( tlx, tly, szx, szy ) );\r\n\r\n    } //uv\r\n\r\n    public function uv_space( _rect:luxe.Rectangle ) {\r\n\r\n            //the uv width and height\r\n        var sz_x = _rect.w;\r\n        var sz_y = _rect.h;\r\n\r\n            //tl\r\n        var tl_x = _rect.x;\r\n        var tl_y = _rect.y;\r\n\r\n            //Keep for later, before changing the values for flipping\r\n        _uv_cache.set( tl_x, tl_y, sz_x, sz_y );\r\n\r\n            //tr\r\n        var tr_x = tl_x + sz_x;\r\n        var tr_y = tl_y;\r\n            //br\r\n        var br_x = tl_x + sz_x;\r\n        var br_y = tl_y + sz_y;\r\n            //bl\r\n        var bl_x = tl_x;\r\n        var bl_y = tl_y + sz_y;\r\n\r\n        var tmp_x = 0.0;\r\n        var tmp_y = 0.0;\r\n\r\n                //flipped y swaps tl and tr with bl and br, only on y\r\n            if(flipy) {\r\n\r\n                    //swap tl and bl\r\n                tmp_y = bl_y;\r\n                    bl_y = tl_y;\r\n                    tl_y = tmp_y;\r\n\r\n                    //swap tr and br\r\n                tmp_y = br_y;\r\n                    br_y = tr_y;\r\n                    tr_y = tmp_y;\r\n\r\n            } //flipy\r\n\r\n                //flipped x swaps tl and bl with tr and br, only on x\r\n            if(flipx) {\r\n\r\n                    //swap tl and tr\r\n                tmp_x = tr_x;\r\n                    tr_x = tl_x;\r\n                    tl_x = tmp_x;\r\n\r\n                    //swap bl and br\r\n                tmp_x = br_x;\r\n                    br_x = bl_x;\r\n                    bl_x = tmp_x;\r\n\r\n            } //flipx\r\n\r\n        vertices[0].uv.uv0.set_uv( tl_x , tl_y );\r\n        vertices[1].uv.uv0.set_uv( tr_x , tr_y );\r\n        vertices[2].uv.uv0.set_uv( br_x , br_y );\r\n\r\n        vertices[3].uv.uv0.set_uv( bl_x , bl_y );\r\n        vertices[4].uv.uv0.set_uv( tl_x , tl_y );\r\n        vertices[5].uv.uv0.set_uv( br_x , br_y );\r\n\r\n            //if it's locked, it needs to be refreshed to the gpu\r\n        dirty = true;\r\n\r\n    } //set uv in uv space directly\r\n\r\n    public function resize( quad:luxe.Vector ) {\r\n\r\n        vertices[0].pos.set_xy( 0,            0         );\r\n        vertices[1].pos.set_xy( 0+quad.x,     0         );\r\n        vertices[2].pos.set_xy( 0+quad.x,     0+quad.y  );\r\n\r\n        vertices[3].pos.set_xy( 0,            0+quad.y  );\r\n        vertices[4].pos.set_xy( 0,            0         );\r\n        vertices[5].pos.set_xy( 0+quad.x,     0+quad.y  );\r\n\r\n    }\r\n\r\n \tpublic function set( quad:luxe.Rectangle ) {\r\n\r\n \t\tvertices.splice(0, vertices.length);\r\n\r\n            //First triangle\r\n        var vert0 : Vertex = new Vertex( new Vector( 0, 0 ), color );\r\n        var vert1 : Vertex = new Vertex( new Vector( quad.w, 0 ), color );\r\n        var vert2 : Vertex = new Vertex( new Vector( quad.w, quad.h ), color );\r\n\r\n           //Second triangle\r\n        var vert3 : Vertex = new Vertex( new Vector( 0 , quad.h ), color );\r\n        var vert4 : Vertex = new Vertex( new Vector( 0 , 0 ), color );\r\n        var vert5 : Vertex = new Vertex( new Vector( quad.w , quad.h ), color );\r\n\r\n           //Add to the list\r\n\r\n            //tl\r\n        add( vert0 );\r\n            //tr\r\n        add( vert1 );\r\n            //br\r\n        add( vert2 );\r\n            //bl\r\n        add( vert3 );\r\n            //tl\r\n        add( vert4 );\r\n            //br\r\n        add( vert5 );\r\n\r\n\r\n        primitive_type = PrimitiveType.triangles;\r\n        immediate = false;\r\n\r\n            //And finally move it into place\r\n        transform.pos = new Vector(quad.x, quad.y);\r\n\r\n            //Make sure we know we can access the verts now\r\n        is_set = true;\r\n\r\n            //Apply default UV, handles flipping etc\r\n        uv_space( new luxe.Rectangle(0,0,1,1) );\r\n\r\n \t} //set\r\n\r\n    function set_flipx(_val:Bool) {\r\n\r\n            //set before calling uv_space\r\n        flipx = _val;\r\n\r\n        if(is_set) {\r\n            uv_space(_uv_cache);\r\n        }\r\n\r\n        return flipx;\r\n    } //set_flipx\r\n\r\n    function set_flipy(_val:Bool) {\r\n\r\n            //set before calling uv_space\r\n        flipy = _val;\r\n\r\n        if(is_set) {\r\n            uv_space(_uv_cache);\r\n        }\r\n\r\n        return flipy;\r\n\r\n    } //set_flipy\r\n\r\n\r\n\r\n}\r\n","package phoenix.geometry;\r\n\r\nimport phoenix.geometry.Geometry;\r\nimport phoenix.Batcher;\r\nimport phoenix.geometry.Vertex;\r\nimport phoenix.geometry.TextureCoord;\r\nimport phoenix.Rectangle;\r\nimport phoenix.Shader;\r\nimport phoenix.Texture;\r\n\r\nimport phoenix.Color;\r\nimport phoenix.Vector;\r\n\r\nimport luxe.options.GeometryOptions;\r\n\r\ntypedef PackedQuad = {\r\n    uid : UInt,\r\n    verts : Array<Vertex>,\r\n    flipx : Bool,\r\n    flipy : Bool,\r\n    visible : Bool,\r\n    _uv_cache : Rectangle\r\n}\r\n\r\ntypedef PackedQuadOptions = {\r\n    x : Float,\r\n    y : Float,\r\n    w : Float,\r\n    h : Float,\r\n\r\n    ?color : Color,\r\n    ?uv : Rectangle,\r\n    ?flipx : Bool,\r\n    ?flipy : Bool,\r\n    ?visible : Bool\r\n}\r\n\r\n//Note that a quad pack geometry has only one texture,\r\n// it is for optimising singular geometry that shares many quads\r\n// and share a shader and texture and state\r\n\r\nclass QuadPackGeometry extends Geometry {\r\n\r\n    public var quads : Map<Int, PackedQuad>;\r\n\r\n    public function new( ?_options : GeometryOptions ) {\r\n\r\n        super( _options );\r\n        primitive_type = PrimitiveType.triangles;\r\n\r\n        quads = new Map();\r\n\r\n    } //new\r\n\r\n    public function clear() {\r\n\r\n        for(q in quads.keys()) {\r\n            quad_remove( q );\r\n        }\r\n\r\n    } //clear\r\n\r\n    public function quad_add( _options:PackedQuadOptions ) : Int {\r\n\r\n        if(_options.visible == null) _options.visible = true;\r\n        if(_options.flipx == null) _options.flipx = false;\r\n        if(_options.flipy == null) _options.flipy = false;\r\n\r\n        var _uid = Luxe.utils.uniquehash();\r\n\r\n            //First triangle\r\n        var vert0 = new Vertex( new Vector( _options.x,            _options.y ), _options.color );\r\n        var vert1 = new Vertex( new Vector( _options.x+_options.w, _options.y ), _options.color );\r\n        var vert2 = new Vertex( new Vector( _options.x+_options.w, _options.y+_options.h ), _options.color );\r\n\r\n           //Second triangle\r\n        var vert3 = new Vertex( new Vector( _options.x , _options.y+_options.h ), _options.color );\r\n        var vert4 = new Vertex( new Vector( _options.x , _options.y ), _options.color );\r\n        var vert5 = new Vertex( new Vector( _options.x+_options.w , _options.y+_options.h ), _options.color );\r\n\r\n                //tl\r\n            add( vert0 );\r\n                //tr\r\n            add( vert1 );\r\n                //br\r\n            add( vert2 );\r\n                //bl\r\n            add( vert3 );\r\n                //tl\r\n            add( vert4 );\r\n                //br\r\n            add( vert5 );\r\n\r\n             //create the packed quad\r\n        var _quad = {\r\n            uid : _uid,\r\n            verts : new Array<Vertex>(),\r\n            flipx : _options.flipx,\r\n            flipy : _options.flipx,\r\n            visible : _options.visible,\r\n            _uv_cache : new Rectangle(0,0,1,1)\r\n        }\r\n\r\n            _quad.verts.push( vert0 );\r\n            _quad.verts.push( vert1 );\r\n            _quad.verts.push( vert2 );\r\n            _quad.verts.push( vert3 );\r\n            _quad.verts.push( vert4 );\r\n            _quad.verts.push( vert5 );\r\n\r\n        quads.set( _uid, _quad );\r\n\r\n        if(_options.uv != null) {\r\n            quad_uv( _uid, _options.uv );\r\n        }\r\n\r\n            //for locked geometry\r\n        dirty = true;\r\n\r\n        return _uid;\r\n\r\n    } //add_quad\r\n\r\n    public function quad_remove( _quad_id:Int ) {\r\n\r\n        var _quad = quads.get( _quad_id );\r\n\r\n        if(_quad != null) {\r\n\r\n            remove( _quad.verts[0] );\r\n            remove( _quad.verts[1] );\r\n            remove( _quad.verts[2] );\r\n            remove( _quad.verts[3] );\r\n            remove( _quad.verts[4] );\r\n            remove( _quad.verts[5] );\r\n\r\n            quads.remove( _quad_id );\r\n\r\n                //for locked geometry\r\n            dirty = true;\r\n\r\n        } //_quad\r\n\r\n    } //quad_remove\r\n\r\n    public function quad_visible( _quad_id:Int, visible:Bool ) {\r\n\r\n        var _quad = quads.get( _quad_id );\r\n\r\n        if(_quad != null) {\r\n\r\n                //add only if not already added\r\n            if(visible && !_quad.visible) {\r\n\r\n                _quad.visible = false;\r\n\r\n                add( _quad.verts[0] );\r\n                add( _quad.verts[1] );\r\n                add( _quad.verts[2] );\r\n                add( _quad.verts[3] );\r\n                add( _quad.verts[4] );\r\n                add( _quad.verts[5] );\r\n\r\n            } else if(!visible && _quad.visible) {\r\n\r\n                _quad.visible = false;\r\n\r\n                remove( _quad.verts[0] );\r\n                remove( _quad.verts[1] );\r\n                remove( _quad.verts[2] );\r\n                remove( _quad.verts[3] );\r\n                remove( _quad.verts[4] );\r\n                remove( _quad.verts[5] );\r\n\r\n            } //visible\r\n\r\n                //for locked geometry\r\n            dirty = true;\r\n\r\n        } //_quad\r\n\r\n    } //quad_visible\r\n\r\n    public function quad_resize( _quad_id:Int, _size : Rectangle ) {\r\n\r\n        var _quad = quads.get( _quad_id );\r\n\r\n        if(_quad != null) {\r\n\r\n            _quad.verts[0].pos = new Vector( _size.x,         _size.y );\r\n            _quad.verts[1].pos = new Vector( _size.x+_size.w, _size.y );\r\n            _quad.verts[2].pos = new Vector( _size.x+_size.w, _size.y+_size.h );\r\n\r\n            _quad.verts[3].pos = new Vector( _size.x,         _size.y+_size.h );\r\n            _quad.verts[4].pos = new Vector( _size.x,         _size.y );\r\n            _quad.verts[5].pos = new Vector( _size.x+_size.w, _size.y+_size.h );\r\n\r\n                //for locked geometry\r\n            dirty = true;\r\n\r\n        } //_quad\r\n\r\n    } //remove_quad\r\n\r\n    public function quad_pos( _quad_id:Int, _p:Vector ) {\r\n\r\n        var _quad = quads.get( _quad_id );\r\n\r\n        if(_quad != null) {\r\n\r\n            var _diffx = _p.x - _quad.verts[0].pos.x;\r\n            var _diffy = _p.y - _quad.verts[0].pos.y;\r\n\r\n            _quad.verts[0].pos.x += _diffx;\r\n            _quad.verts[0].pos.y += _diffy;\r\n\r\n            _quad.verts[1].pos.x += _diffx;\r\n            _quad.verts[1].pos.y += _diffy;\r\n\r\n            _quad.verts[2].pos.x += _diffx;\r\n            _quad.verts[2].pos.y += _diffy;\r\n\r\n            _quad.verts[3].pos.x += _diffx;\r\n            _quad.verts[3].pos.y += _diffy;\r\n\r\n            _quad.verts[4].pos.x += _diffx;\r\n            _quad.verts[4].pos.y += _diffy;\r\n\r\n            _quad.verts[5].pos.x += _diffx;\r\n            _quad.verts[5].pos.y += _diffy;\r\n\r\n                //for locked geometry\r\n            dirty = true;\r\n\r\n        } //_quad != null\r\n\r\n    } //quad_pos\r\n\r\n    public function quad_color( _quad_id:Int, _c:Color ) {\r\n\r\n        var _quad = quads.get( _quad_id );\r\n\r\n        if(_quad != null) {\r\n            _quad.verts[0].color = _c;\r\n            _quad.verts[1].color = _c;\r\n            _quad.verts[2].color = _c;\r\n            _quad.verts[3].color = _c;\r\n            _quad.verts[4].color = _c;\r\n            _quad.verts[5].color = _c;\r\n        } //_quad != null\r\n\r\n    } //quad_color\r\n\r\n    public function quad_alpha( _quad_id:Int, _a:Float ) {\r\n\r\n        var _quad = quads.get( _quad_id );\r\n\r\n        if(_quad != null) {\r\n            _quad.verts[0].color.a = _a;\r\n            _quad.verts[1].color.a = _a;\r\n            _quad.verts[2].color.a = _a;\r\n            _quad.verts[3].color.a = _a;\r\n            _quad.verts[4].color.a = _a;\r\n            _quad.verts[5].color.a = _a;\r\n        } //_quad != null\r\n\r\n    } //quad_alpha\r\n\r\n    public function quad_uv_space( _quad_id:Int, _uv : Rectangle ) {\r\n\r\n        var _quad = quads.get( _quad_id );\r\n\r\n        if(_quad != null) {\r\n\r\n            var flipx = _quad.flipx;\r\n            var flipy = _quad.flipy;\r\n\r\n                //the uv width and height\r\n            var sz_x = _uv.w;\r\n            var sz_y = _uv.h;\r\n\r\n                //tl\r\n            var tl_x = _uv.x;\r\n            var tl_y = _uv.y;\r\n\r\n                //Keep for later, before changing the values for flipping\r\n            _quad._uv_cache.set( tl_x, tl_y, sz_x, sz_y );\r\n\r\n                //tr\r\n            var tr_x = tl_x + sz_x;\r\n            var tr_y = tl_y;\r\n                //br\r\n            var br_x = tl_x + sz_x;\r\n            var br_y = tl_y + sz_y;\r\n                //bl\r\n            var bl_x = tl_x;\r\n            var bl_y = tl_y + sz_y;\r\n\r\n            var tmp_x = 0.0;\r\n            var tmp_y = 0.0;\r\n\r\n                    //flipped y swaps tl and tr with bl and br, only on y\r\n                if(flipy) {\r\n\r\n                        //swap tl and bl\r\n                    tmp_y = bl_y;\r\n                        bl_y = tl_y;\r\n                        tl_y = tmp_y;\r\n\r\n                        //swap tr and br\r\n                    tmp_y = br_y;\r\n                        br_y = tr_y;\r\n                        tr_y = tmp_y;\r\n\r\n                } //flipy\r\n\r\n                    //flipped x swaps tl and bl with tr and br, only on x\r\n                if(flipx) {\r\n\r\n                        //swap tl and tr\r\n                    tmp_x = tr_x;\r\n                        tr_x = tl_x;\r\n                        tl_x = tmp_x;\r\n\r\n                        //swap bl and br\r\n                    tmp_x = br_x;\r\n                        br_x = bl_x;\r\n                        bl_x = tmp_x;\r\n\r\n                } //flipx\r\n\r\n            _quad.verts[0].uv.uv0.set_uv( tl_x , tl_y );\r\n            _quad.verts[1].uv.uv0.set_uv( tr_x , tr_y );\r\n            _quad.verts[2].uv.uv0.set_uv( br_x , br_y );\r\n\r\n            _quad.verts[3].uv.uv0.set_uv( bl_x , bl_y );\r\n            _quad.verts[4].uv.uv0.set_uv( tl_x , tl_y );\r\n            _quad.verts[5].uv.uv0.set_uv( br_x , br_y );\r\n\r\n                //for locked geometry\r\n            dirty = true;\r\n\r\n        } //_quad != null\r\n\r\n    } //quad_uv_space\r\n\r\n    public function quad_uv( _quad_id:Int, _uv : Rectangle ) {\r\n\r\n        if( texture == null ) {\r\n            trace(\"Warning : calling UV on a PackedQuad Geometry with null texture.\");\r\n            return;\r\n        }\r\n\r\n        var tlx = _uv.x/texture.width_actual;\r\n        var tly = _uv.y/texture.height_actual;\r\n        var szx = _uv.w/texture.width_actual;\r\n        var szy = _uv.h/texture.height_actual;\r\n\r\n        quad_uv_space( _quad_id, new luxe.Rectangle( tlx, tly, szx, szy ) );\r\n\r\n    } //quad_uv\r\n\r\n    public function quad_flipx( _quad_id:Int, _flip:Bool ) {\r\n\r\n        var _quad = quads.get( _quad_id );\r\n\r\n        if(_quad != null) {\r\n            _quad.flipx = _flip;\r\n            quad_uv_space( _quad_id, _quad._uv_cache );\r\n        } //_quad != null\r\n\r\n    } //quad_flipx\r\n\r\n    public function quad_flipy( _quad_id:Int, _flip:Bool ) {\r\n\r\n        var _quad = quads.get( _quad_id );\r\n\r\n        if(_quad != null) {\r\n            _quad.flipy = _flip;\r\n            quad_uv_space( _quad_id, _quad._uv_cache );\r\n        } //_quad != null\r\n\r\n    } //quad_flipy\r\n\r\n} //QuadPackGeometry\r\n","package phoenix.geometry;\r\n\r\n\r\nimport luxe.Vector;\r\nimport phoenix.Batcher;\r\nimport phoenix.geometry.Geometry;\r\n\r\nimport luxe.options.GeometryOptions.RectangleGeometryOptions;\r\n\r\nclass RectangleGeometry extends Geometry {\r\n\r\n\r\n    public function new( ?options : RectangleGeometryOptions ) {\r\n\r\n        super(options);\r\n\r\n        if(options == null) {\r\n            return;\r\n        }\r\n\r\n        set(options);\r\n\r\n    } //new\r\n\r\n    public function set( options:RectangleGeometryOptions ) {\r\n\r\n        vertices.splice(0, vertices.length);\r\n\r\n        var _x : Float = options.x;\r\n        var _y : Float = options.y;\r\n        var _w : Float = options.w;\r\n        var _h : Float = options.h;\r\n\r\n        if(options.rect != null) {\r\n            _x = options.rect.x;\r\n            _y = options.rect.y;\r\n            _w = options.rect.w;\r\n            _h = options.rect.h;\r\n        }\r\n\r\n            //tl\r\n        var vert0 : Vertex = new Vertex( new Vector( 0, 0 ) );\r\n            vert0.uv.uv0.set_uv(0,0);\r\n            //tr\r\n        var vert1 : Vertex = new Vertex( new Vector( _w, 0 ) );\r\n            vert1.uv.uv0.set_uv(1,0);\r\n\r\n            //tr\r\n        var vert2 : Vertex = new Vertex( new Vector( _w, 0 ) );\r\n            vert2.uv.uv0.set_uv(1,0);\r\n            //br\r\n        var vert3 : Vertex = new Vertex( new Vector( _w, _h ) );\r\n            vert3.uv.uv0.set_uv(1,1);\r\n\r\n            //br\r\n        var vert4 : Vertex = new Vertex( new Vector( _w, _h ) );\r\n            vert4.uv.uv0.set_uv(1,1);\r\n            //bl\r\n        var vert5 : Vertex = new Vertex( new Vector( 0, _h ) );\r\n            vert5.uv.uv0.set_uv(0,1);\r\n\r\n            //bl\r\n        var vert6 : Vertex = new Vertex( new Vector( 0, _h ) );\r\n            vert6.uv.uv0.set_uv(0,1);\r\n            //tl\r\n        var vert7 : Vertex = new Vertex( new Vector( 0, 0 ) );\r\n            vert7.uv.uv0.set_uv(0,0);\r\n\r\n        add(vert0); add(vert1); add(vert2); add(vert3);\r\n        add(vert4); add(vert5); add(vert6); add(vert7);\r\n\r\n        primitive_type = PrimitiveType.lines;\r\n        immediate = (options.immediate == null) ? false : options.immediate;\r\n        visible = (options.visible == null) ? true : options.visible;\r\n        color = (options.color == null) ? new Color() : options.color;\r\n\r\n        transform.pos = new Vector( _x, _y );\r\n\r\n    } //set\r\n\r\n\r\n} //RectangleGeometry\r\n","package phoenix.geometry;\r\n\r\nimport luxe.options.GeometryOptions;\r\nimport luxe.utils.Maths;\r\n\r\nimport phoenix.BitmapFont;\r\nimport phoenix.geometry.Vertex;\r\nimport phoenix.geometry.Geometry;\r\nimport phoenix.Batcher;\r\nimport phoenix.Color;\r\nimport phoenix.Rectangle;\r\n\r\nimport luxe.Log.log;\r\n\r\nusing luxe.utils.unifill.Unifill;\r\n\r\n@:enum abstract EvTextGeometry(Int) from Int to Int {\r\n    var unknown = 0;\r\n    var update_text = 1;\r\n}\r\n\r\ntypedef TextGeometryOptions = {\r\n\r\n    > GeometryOptions,\r\n\r\n    ? text: String,\r\n    ? font: BitmapFont,\r\n    ? point_size: Float,\r\n    ? line_spacing: Float,\r\n    ? letter_spacing: Float,\r\n\r\n    ? bounds : Rectangle,\r\n    ? bounds_wrap : Bool,\r\n\r\n    ? align : TextAlign,\r\n    ? align_vertical : TextAlign,\r\n\r\n    ? sdf: Bool,\r\n    ? smoothness: Float,\r\n    ? thickness: Float,\r\n\r\n    ? outline: Float,\r\n    ? outline_color: Color,\r\n\r\n    ? glow_threshold: Float,\r\n    ? glow_amount: Float,\r\n    ? glow_color: Color\r\n\r\n}\r\n\r\nclass TextGeometry extends Geometry {\r\n\r\n    //regular font stuff\r\n\r\n        @:isVar public var text (default,set) : String = '';\r\n        @:isVar public var font (default,default) : BitmapFont;\r\n        @:isVar public var point_size (default,set) : Float = 32.0;\r\n        @:isVar public var line_spacing (default,set) : Float = 0.0;\r\n        @:isVar public var letter_spacing (default,set) : Float = 0.0;\r\n\r\n        @:isVar public var bounds (default,set) : Rectangle;\r\n        @:isVar public var bounds_wrap (default,set) : Bool = false;\r\n\r\n        @:isVar public var align (default,set) : TextAlign;\r\n        @:isVar public var align_vertical (default,set) : TextAlign;\r\n\r\n    //distance field specific\r\n\r\n        public var sdf : Bool = false;\r\n        public var unique : Bool = false;\r\n\r\n        @:isVar public var smoothness (default,set) : Float = 0.75;\r\n        @:isVar public var thickness (default,set) : Float = 0.5;\r\n\r\n        @:isVar public var outline (default,set) : Float = 0;\r\n        @:isVar public var outline_color (default,set) : Color;\r\n\r\n        @:isVar public var glow_threshold (default,set) : Float = 0;\r\n        @:isVar public var glow_amount (default,set) : Float = 0;\r\n        @:isVar public var glow_color (default,set) : Color;\r\n\r\n    //sizing cached information\r\n\r\n        public var line_widths : Array<Float>;\r\n        public var text_width : Float = 0;\r\n        public var text_height : Float = 0;\r\n        public var line_offsets : Array< Array<Float> >;\r\n        public var lines : Array<String>;\r\n\r\n    //access to change events\r\n\r\n        @:noCompletion\r\n        public var emitter : luxe.Emitter<EvTextGeometry>;\r\n\r\n    //internal\r\n\r\n        var cache : Array< Array<Vertex> >;\r\n        var options : TextGeometryOptions;\r\n\r\n        var text_h_w : Float = 0;\r\n        var text_h_h : Float = 0;\r\n        public var point_ratio : Float = 1;\r\n\r\n        var dirty_sizing (default,set) : Bool = true;\r\n        var dirty_align: Bool = true;\r\n\r\n    //common\r\n\r\n        static var tab_regex : EReg = new EReg('\\t','gim');\r\n\r\n    public function new( _options:TextGeometryOptions ) {\r\n\r\n        options = _options;\r\n        emitter = new luxe.Emitter<EvTextGeometry>();\r\n\r\n        if(options == null) throw \"TextGeometry: requires non-null options at the moment\";\r\n\r\n        //order here before super() is important\r\n\r\n                //make sure sdf flag is early enough\r\n            if(options.sdf != null) sdf = options.sdf;\r\n                //use the default font if none specified\r\n            font = (options.font == null) ? Luxe.renderer.font : options.font;\r\n                //the default font is always sdf enabled\r\n            if(font == Luxe.renderer.font) { sdf = true; }\r\n\r\n                //if a custom shader is not given,\r\n                //use the default sdf or normal textured\r\n                //but if they have a custom shader, flag\r\n                //the instance as unique so their options are mutable\r\n            if(options.shader == null) {\r\n                if(sdf) {\r\n                    options.shader = Luxe.renderer.shaders.bitmapfont.shader;\r\n                } else {\r\n                    options.shader = Luxe.renderer.shaders.textured.shader;\r\n                }\r\n            } else {\r\n                    //only unique if not the default\r\n                if(options.shader != Luxe.renderer.shaders.bitmapfont.shader) {\r\n                    unique = true;\r\n                }\r\n            }\r\n\r\n            super( options );\r\n            primitive_type = PrimitiveType.triangles;\r\n\r\n        //setup\r\n\r\n        cache = [];\r\n        line_widths = [];\r\n        line_offsets = [[],[]];\r\n        lines = [];\r\n        outline_color = new Color();\r\n        glow_color = new Color();\r\n\r\n        default_options();\r\n\r\n    } //new\r\n\r\n//Public API\r\n\r\n        /** Remove any cached vertices that are unused by the current text. */\r\n    #if release inline #end\r\n    public function tidy() {\r\n\r\n        var _vertidx = Math.floor(vertices.length / 6);\r\n        var _diff = cache.length - _vertidx;\r\n\r\n        if(_diff > 0) {\r\n\r\n            // _verbose('tidy: remove $_diff from cache');\r\n\r\n            var extra = cache.splice(_vertidx, _diff);\r\n            var c = extra.length;\r\n            while(c > 0) {\r\n                c--;\r\n                var vert = extra.pop();\r\n                    vert = null;\r\n            }\r\n\r\n        } //diff>0\r\n\r\n    } //tidy\r\n\r\n\r\n//Internal\r\n\r\n\r\n    function default_options() {\r\n\r\n            //:todo: currently only\r\n            //one page is supported\r\n            //because each vertex would\r\n            //need to know the page it's on\r\n            //and that would be best served\r\n            //by the new batcher attributes\r\n            //as to not muddy everything up\r\n        texture = font.pages[0];\r\n\r\n        //normal font stuff\r\n\r\n            if(options.letter_spacing != null) letter_spacing = options.letter_spacing;\r\n            if(options.line_spacing != null) line_spacing = options.line_spacing;\r\n            if(options.point_size != null) point_size = options.point_size;\r\n\r\n            if(options.bounds != null) bounds = options.bounds;\r\n            if(options.bounds_wrap != null) bounds_wrap = options.bounds_wrap;\r\n\r\n            if(options.align == null) options.align = TextAlign.left;\r\n            if(options.align_vertical == null) options.align_vertical = TextAlign.left;\r\n\r\n            align = options.align;\r\n            align_vertical = options.align_vertical;\r\n\r\n        //sdf based\r\n        //these will be set anyway, but ignored if not sdf\r\n\r\n            if(options.thickness != null) thickness = options.thickness;\r\n            if(options.smoothness != null) smoothness = options.smoothness;\r\n\r\n            if(options.outline != null) outline = options.outline;\r\n            if(options.outline_color != null) outline_color = options.outline_color;\r\n\r\n            if(options.glow_threshold != null) glow_threshold = options.glow_threshold;\r\n            if(options.glow_amount != null) glow_amount = options.glow_amount;\r\n            if(options.glow_color != null) glow_color = options.glow_color;\r\n\r\n            if(sdf) flush_uniforms();\r\n\r\n            //text must be last, as it relies on the rest\r\n        if(options.text != null) text = options.text;\r\n\r\n    } //default_options\r\n\r\n    #if release inline #end\r\n    function set_text(_text:String) : String {\r\n\r\n        if(_text == null) {\r\n            log('null text passed into TextGeometry!');\r\n            _text = '';\r\n        }\r\n\r\n            //don't care if it's the same value\r\n        if(text != _text) {\r\n\r\n                //update the value\r\n            text = _text;\r\n\r\n            if(text != '') {\r\n\r\n                dirty_sizing = true;\r\n                update_text();\r\n\r\n            } else {\r\n                vertices.splice(0, vertices.length);\r\n            }\r\n\r\n        } //same val\r\n\r\n        return text;\r\n\r\n    } //set_text\r\n\r\n    #if release inline #end\r\n    function stats() {\r\n        return 'letters:${(vertices.length/6)} / cache:${ cache.length }';\r\n    }\r\n\r\n    #if release inline #end\r\n    function update_sizes() {\r\n\r\n        if(!dirty_sizing) return false;\r\n\r\n            //:todo: tab width\r\n        var drawn_text = tab_regex.replace(text, '    ');\r\n        if(bounds_wrap && bounds != null) {\r\n            drawn_text = font.wrap_string_to_bounds(drawn_text, bounds, point_size, letter_spacing);\r\n        }\r\n\r\n        lines.splice(0, lines.length);\r\n        lines = drawn_text.split('\\n');\r\n\r\n            line_widths.splice(0, line_widths.length);\r\n\r\n            text_width = font.width_of(drawn_text, point_size, letter_spacing, line_widths);\r\n            text_height = font.height_of_lines(lines, point_size, line_spacing);\r\n            text_h_w = text_width / 2;\r\n            text_h_h = text_height / 2;\r\n            point_ratio = point_size / font.info.point_size;\r\n\r\n            dirty_sizing = false;\r\n\r\n        return true;\r\n\r\n    } //update_sizes\r\n\r\n\r\n    // #if release inline #end\r\n    function update_text() {\r\n\r\n        var _pos_x = 0.0;\r\n        var _pos_y = 0.0;\r\n        var _bounds_based = (bounds != null);\r\n\r\n        if(_bounds_based) {\r\n            transform.pos.x = _pos_x = bounds.x;\r\n            transform.pos.y = _pos_y = bounds.y;\r\n        }\r\n\r\n        var _cur_x = 0.0;\r\n        var _cur_y = 0.0;\r\n        var _line_idx = 0;\r\n        var _total_idx = 0;\r\n        var _is_char = true;\r\n        var _was_dirty = update_sizes();\r\n\r\n        inline function _step() {\r\n            _cur_y += (font.info.line_height + line_spacing) * point_ratio;\r\n            _cur_x = 0;\r\n        }\r\n\r\n        for(_line in lines) {\r\n\r\n                //Calculate alignment offsets\r\n                //Left is at 0, so it's handled already, same as top\r\n            var _line_x_offset = 0.0;\r\n            var _line_y_offset = 0.0;\r\n\r\n            if(dirty_align) {\r\n\r\n                if(!_bounds_based) {\r\n\r\n                    _line_x_offset = switch(align) {\r\n                        case center: -(line_widths[_line_idx]/2.0);\r\n                        case right: -line_widths[_line_idx];\r\n                        default: 0.0;\r\n                    }\r\n\r\n                    _line_y_offset = switch(align_vertical) {\r\n                        case center: -text_h_h;\r\n                        case bottom: -text_height;\r\n                        default: 0.0;\r\n                    }\r\n\r\n                } else {\r\n\r\n                    _line_x_offset = switch(align) {\r\n                        case center: -(line_widths[_line_idx]/2.0) + (bounds.w/2);\r\n                        case right: -line_widths[_line_idx] + (bounds.w);\r\n                        default: 0.0;\r\n                    }\r\n\r\n                    _line_y_offset = switch(align_vertical) {\r\n                        case center: (bounds.h/2) - text_h_h;\r\n                        case bottom: (bounds.h) - text_height;\r\n                        default: 0.0;\r\n                    }\r\n\r\n                }\r\n\r\n                    //store it in the cache for later\r\n                line_offsets[0][_line_idx] = _line_x_offset;\r\n                line_offsets[1][_line_idx] = _line_y_offset;\r\n\r\n            } else {\r\n\r\n                _line_x_offset = line_offsets[0][_line_idx];\r\n                _line_y_offset = line_offsets[1][_line_idx];\r\n\r\n            }\r\n\r\n            if( _line_idx != 0 ){\r\n                _step();\r\n            } //_line_idx\r\n\r\n                //for each character in the line\r\n\r\n            var _idx = 0;\r\n            for(_uglyph in _line.uIterator()) {\r\n\r\n                var _index = _uglyph.toInt();\r\n                var _char = font.info.chars.get(_index);\r\n                _is_char = (_char != null && _index > 32);\r\n\r\n                    //:todo: make this a small preset vert set matching �\r\n                    //or the missing char box style char, rather than just a space\r\n                if(!_is_char) {\r\n                    _char = font.space_char;\r\n                }\r\n\r\n                if(_is_char) {\r\n\r\n                        //the geometry positioning\r\n                    var _quad_x  = _line_x_offset + _cur_x + ( _char.xoffset * point_ratio );\r\n                    var _quad_y  = _line_y_offset + _cur_y + ( _char.yoffset * point_ratio );\r\n                        //the texture page\r\n                    var _page = font.pages[_char.page];\r\n                        //work out the coordinates for the uv's\r\n                    var _u1 = _char.x/_page.width_actual;\r\n                    var _v1 = _char.y/_page.height_actual;\r\n                    var _u2 = (_char.x + _char.width) / _page.width_actual;\r\n                    var _v2 = (_char.y + _char.height) / _page.height_actual;\r\n\r\n                    update_char( _total_idx,\r\n                                 _quad_x, _quad_y, _char.width*point_ratio, _char.height*point_ratio,\r\n                                 _u1, _v1, _u2, _v2, color );\r\n\r\n                        //this should only count\r\n                        //visual characters\r\n                    _total_idx++;\r\n\r\n                } //don't draw non visible char\r\n\r\n                    //after the letter,\r\n                    //the x movement forward\r\n                var _x_inc = _char.xadvance;\r\n\r\n                    //adjust for kerning + tracking(letterspace)\r\n                if( _idx < _line.length-1 ) {\r\n                    _x_inc += font.kerning( _index, _line.uCharCodeAt(_idx+1) );\r\n                    if(_index >= 32) {\r\n                        _x_inc += letter_spacing;\r\n                    }\r\n                }\r\n\r\n                _x_inc *= point_ratio;\r\n\r\n                    //apply it with the point size ratio\r\n                _cur_x += _x_inc;\r\n\r\n                    //increment char index\r\n                _idx++;\r\n\r\n            } //for each letter in string\r\n\r\n                //increase the line counter\r\n            _line_idx++;\r\n\r\n        } //each line\r\n\r\n            //for unused vertices, we remove\r\n            //them from the visible set,\r\n            //keeping them in cache (only tidy() cleans cache)\r\n        var _vertidx = Std.int(vertices.length / 6);\r\n        var _diff = _vertidx - _total_idx;\r\n\r\n        if(_diff > 0) {\r\n            vertices.splice(_total_idx * 6, _diff * 6);\r\n        }\r\n\r\n            //if it was true, it's false now\r\n        dirty_align = false;\r\n        emitter.emit(EvTextGeometry.update_text);\r\n\r\n    } //update_text\r\n\r\n    // #if release inline #end\r\n    function update_char( _letteridx:Int, _x:Float, _y:Float, _w:Float, _h:Float, _u:Float, _v:Float, _u2:Float, _v2:Float, _color:Color ) {\r\n\r\n        var vert0:Vertex; var vert1:Vertex; var vert2:Vertex;\r\n        var vert3:Vertex; var vert4:Vertex; var vert5:Vertex;\r\n\r\n        var quad = cache[_letteridx];\r\n\r\n            //if no cache at this index we need to add vertices\r\n        if(quad == null) {\r\n\r\n            // _debug(' idx $_letteridx out of cache range, adding cache index');\r\n\r\n            vert0 = new Vertex( new Vector( _x, _y ), _color );\r\n            vert1 = new Vertex( new Vector( _x+_w, _y ), _color );\r\n            vert2 = new Vertex( new Vector( _x+_w, _y+_h ), _color );\r\n\r\n            vert3 = new Vertex( new Vector( _x, _y+_h ), _color );\r\n            vert4 = new Vertex( new Vector( _x, _y ), _color );\r\n            vert5 = new Vertex( new Vector( _x+_w, _y+_h), _color );\r\n\r\n            quad = [vert0, vert1, vert2, vert3, vert4, vert5];\r\n            cache[_letteridx] = quad;\r\n\r\n        } else {\r\n\r\n            // _debug(' idx $_letteridx in cache, setting cache index');\r\n            //this cache index existed as vertices so we fetch them\r\n\r\n            vert0 = quad[0]; vert1 = quad[1]; vert2 = quad[2];\r\n            vert3 = quad[3]; vert4 = quad[4]; vert5 = quad[5];\r\n\r\n                //then update the values\r\n            vert0.pos.set_xy( _x    , _y    );\r\n            vert1.pos.set_xy( _x+_w , _y    );\r\n            vert2.pos.set_xy( _x+_w , _y+_h );\r\n            vert3.pos.set_xy( _x    , _y+_h );\r\n            vert4.pos.set_xy( _x    , _y    );\r\n            vert5.pos.set_xy( _x+_w , _y+_h );\r\n\r\n        } //quad != null\r\n\r\n        vert0.uv.uv0.set_uv( _u  , _v  );\r\n        vert1.uv.uv0.set_uv( _u2 , _v  );\r\n        vert2.uv.uv0.set_uv( _u2 , _v2 );\r\n        vert3.uv.uv0.set_uv( _u  , _v2 );\r\n        vert4.uv.uv0.set_uv( _u  , _v  );\r\n        vert5.uv.uv0.set_uv( _u2 , _v2 );\r\n\r\n            //now, if the vert count is lower than the index, add these\r\n            //to the geometry itself. This must be done each time since\r\n            //the vertices length potentially changes after each char\r\n        var _vertidx = Math.floor(vertices.length / 6);\r\n\r\n        if(_vertidx <= _letteridx) {\r\n            add( vert0 ); add( vert1 );  add( vert2 );\r\n            add( vert3 ); add( vert4 );  add( vert5 );\r\n        }\r\n\r\n    } //update_char\r\n\r\n//Setters\r\n\r\n    #if release inline #end\r\n    function set_dirty_sizing(_b:Bool) {\r\n\r\n            dirty_align = true;\r\n\r\n        return dirty_sizing = _b;\r\n\r\n    } //set_dirty_sizing\r\n\r\n    #if release inline #end\r\n    function set_bounds( _bounds:Rectangle ) {\r\n\r\n        bounds = _bounds;\r\n\r\n            dirty_sizing = true;\r\n            update_text();\r\n\r\n        return bounds;\r\n\r\n    } //set_bounds\r\n\r\n    #if release inline #end\r\n    function set_bounds_wrap( _wrap:Bool ) {\r\n\r\n        bounds_wrap = _wrap;\r\n\r\n            dirty_sizing = true;\r\n            update_text();\r\n\r\n        return bounds_wrap;\r\n\r\n    } //set_bounds_wrap\r\n\r\n    #if release inline #end\r\n    function set_line_spacing(_line_spacing:Float) {\r\n\r\n        line_spacing = _line_spacing;\r\n\r\n            dirty_sizing = true;\r\n            update_text();\r\n\r\n        return line_spacing;\r\n\r\n    } //set_line_spacing\r\n\r\n    #if release inline #end\r\n    function set_letter_spacing(_letter_spacing:Float) {\r\n\r\n        letter_spacing = _letter_spacing;\r\n\r\n            dirty_sizing = true;\r\n            update_text();\r\n\r\n        return letter_spacing;\r\n\r\n    } //set_leading\r\n\r\n    #if release inline #end\r\n    function set_align( _align:TextAlign ) {\r\n\r\n        align = _align;\r\n\r\n            dirty_align = true;\r\n            update_text();\r\n\r\n        return align;\r\n\r\n    } //set_align\r\n\r\n    #if release inline #end\r\n    function set_align_vertical( _align_vertical:TextAlign ) {\r\n\r\n        align_vertical = _align_vertical;\r\n\r\n            dirty_align = true;\r\n            update_text();\r\n\r\n        return align_vertical;\r\n\r\n    } //set_align_vertical\r\n\r\n    #if release inline #end\r\n    function set_point_size( s:Float ) {\r\n\r\n        if(s < 0) s = 0;\r\n        point_size = s;\r\n\r\n            dirty_sizing = true;\r\n            update_text();\r\n\r\n        return point_size;\r\n\r\n    } //set_point_size\r\n\r\n\r\n//SDF specific features\r\n\r\n\r\n    #if release inline #end\r\n    function set_smoothness(s:Float) {\r\n\r\n        if(s < 0) s = 0;\r\n\r\n        if(shader != null && sdf && unique) {\r\n            shader.set_float('smoothness',s);\r\n        }\r\n\r\n        return smoothness = s;\r\n\r\n    } //set_smoothness\r\n\r\n    #if release inline #end\r\n    function set_thickness(s:Float) {\r\n\r\n        if(s < 0) s = 0;\r\n\r\n        if(shader != null && sdf && unique) {\r\n            shader.set_float('thickness',s);\r\n        }\r\n\r\n        return thickness = s;\r\n\r\n    } //set_thickness\r\n\r\n    #if release inline #end\r\n    function set_outline(s:Float) {\r\n\r\n        s = Maths.clamp(s, 0.0, 1.0);\r\n\r\n        if(shader != null && sdf && unique) {\r\n            shader.set_float('outline',s);\r\n        }\r\n\r\n        return outline = s;\r\n\r\n    } //set_outline\r\n\r\n    #if release inline #end\r\n    function set_glow_threshold(s:Float) {\r\n\r\n        if(s < 0) s = 0;\r\n\r\n        if(shader != null && sdf && unique) {\r\n            shader.set_float('glow_threshold',s);\r\n        }\r\n\r\n        return glow_threshold = s;\r\n\r\n    } //set_glow_threshold\r\n\r\n    #if release inline #end\r\n    function set_glow_amount(s:Float) {\r\n\r\n        if(s < 0) s = 0;\r\n\r\n        if(shader != null && sdf && unique) {\r\n            shader.set_float('glow_amount',s);\r\n        }\r\n\r\n        return glow_amount = s;\r\n\r\n    } //set_glow_amount\r\n\r\n    #if release inline #end\r\n    function set_outline_color(c:Color) {\r\n\r\n        if(shader != null && sdf && unique) {\r\n            shader.set_color('outline_color', c);\r\n        }\r\n\r\n        return outline_color = c;\r\n\r\n    } //set_outline_color\r\n\r\n    #if release inline #end\r\n    function set_glow_color(c:Color) {\r\n\r\n        if(shader != null && sdf && unique) {\r\n            shader.set_color('glow_color', c);\r\n        }\r\n\r\n        return glow_color = c;\r\n\r\n    } //set_glow_color\r\n\r\n        //internal convenience for when\r\n        //the shader type changes to sdf\r\n        //and values need refreshing\r\n    #if release inline #end\r\n    function flush_uniforms() {\r\n        if(shader != null && sdf) {\r\n            shader.set_float('smoothness', smoothness);\r\n            shader.set_float('thickness', thickness);\r\n            shader.set_float('outline', outline);\r\n            shader.set_float('glow_threshold', glow_threshold);\r\n            shader.set_float('glow_amount', glow_amount);\r\n            shader.set_color('outline_color', outline_color);\r\n            shader.set_color('glow_color', glow_color);\r\n        }\r\n    }\r\n\r\n\r\n} //TextGeometry\r\n","package phoenix.geometry;\r\n\r\n\r\nclass TextureCoordSet {\r\n\r\n\r\n    public var uv0 : TextureCoord;\r\n    public var uv1 : TextureCoord;\r\n    public var uv2 : TextureCoord;\r\n    public var uv3 : TextureCoord;\r\n    public var uv4 : TextureCoord;\r\n    public var uv5 : TextureCoord;\r\n    public var uv6 : TextureCoord;\r\n    public var uv7 : TextureCoord;\r\n\r\n\r\n    public inline function new() {\r\n\r\n        uv0 = new TextureCoord();\r\n        uv1 = new TextureCoord();\r\n        uv2 = new TextureCoord();\r\n        uv3 = new TextureCoord();\r\n        uv4 = new TextureCoord();\r\n        uv5 = new TextureCoord();\r\n        uv6 = new TextureCoord();\r\n        uv7 = new TextureCoord();\r\n\r\n    } //new\r\n\r\n    public inline function clone() {\r\n\r\n        var _set = new TextureCoordSet();\r\n\r\n            _set.uv0.set(uv0.u, uv0.v, uv0.w, uv0.t);\r\n            _set.uv1.set(uv1.u, uv1.v, uv1.w, uv1.t);\r\n            _set.uv2.set(uv2.u, uv2.v, uv2.w, uv2.t);\r\n            _set.uv3.set(uv3.u, uv3.v, uv3.w, uv3.t);\r\n            _set.uv4.set(uv4.u, uv4.v, uv4.w, uv4.t);\r\n            _set.uv5.set(uv5.u, uv5.v, uv5.w, uv5.t);\r\n            _set.uv6.set(uv6.u, uv6.v, uv6.w, uv6.t);\r\n            _set.uv7.set(uv7.u, uv7.v, uv7.w, uv7.t);\r\n\r\n        return _set;\r\n\r\n    } //clone\r\n\r\n\r\n} //TextureCoordSet\r\n\r\n\r\nclass TextureCoord {\r\n\r\n\r\n    public var u : Float = 0.0;\r\n    public var v : Float = 0.0;\r\n    public var w : Float = 0.0;\r\n    public var t : Float = 0.0;\r\n\r\n\r\n    public inline function new(_u:Float = 0.0, _v:Float = 0.0, _w:Float = 0.0, _t:Float = 0.0) {\r\n\r\n        u = _u;\r\n        v = _v;\r\n        w = _w;\r\n        t = _t;\r\n\r\n    } //new\r\n\r\n    public inline function clone() {\r\n\r\n        return new TextureCoord( u, v, w, t );\r\n\r\n    } //clone\r\n\r\n    public inline function set( _u : Float, _v : Float, _w : Float, _t:Float ) : TextureCoord {\r\n\r\n        u = _u;\r\n        v = _v;\r\n        w = _w;\r\n        t = _t;\r\n\r\n        return this;\r\n\r\n    } //set\r\n\r\n    public inline function set_uv( _u : Float, _v : Float ) : TextureCoord {\r\n\r\n        u = _u;\r\n        v = _v;\r\n\r\n        return this;\r\n\r\n    } //set_uv\r\n\r\n    inline function toString() {\r\n\r\n        return  '{ u:$v, v:$v }';\r\n\r\n    } //toString\r\n\r\n\r\n} //TextureCoord\r\n","package phoenix.geometry;\r\n\r\nimport phoenix.geometry.TextureCoord;\r\nimport phoenix.Vector;\r\nimport phoenix.Color;\r\n\r\nimport snow.io.typedarray.Float32Array;\r\n\r\nclass Vertex {\r\n\r\n\r\n\tpublic var pos : Vector;\r\n\tpublic var color : Color;\r\n\tpublic var uv : TextureCoordSet;\r\n\tpublic var normal : Vector;\r\n\r\n\r\n\tpublic inline function new( _pos : Vector, ?_color:Color = null, ?_normal:Vector = null ) {\r\n\r\n\t\tuv = new TextureCoordSet();\r\n\r\n\t\tpos = _pos;\r\n\t\tcolor = (_color == null) ? new Color() : _color;\r\n\t\tnormal = (_normal == null) ? new Vector() : _normal;\r\n\r\n\t} //new\r\n\r\n\tpublic inline function clone() : Vertex {\r\n\r\n\t\tvar _new = new Vertex( pos.clone(), color.clone(), normal.clone() );\r\n\t\t\t_new.uv = uv.clone();\r\n\r\n\t\treturn _new;\r\n\r\n\t} //clone\r\n\r\n\r\n} //Vertex\r\n","package phoenix.utils;\r\n\r\nimport snow.render.opengl.GL;\r\nimport phoenix.Batcher.PrimitiveType;\r\nimport phoenix.Batcher.BlendMode;\r\n\r\nclass Rendering {\r\n\r\n\tpublic static function gl_blend_mode_from_BlendMode(_b:BlendMode) {\r\n\r\n        switch(_b) {\r\n            case zero:\r\n                return GL.ZERO;\r\n            case one:\r\n                return GL.ONE;\r\n            case src_color:\r\n                return GL.SRC_COLOR;\r\n            case one_minus_src_color:\r\n                return GL.ONE_MINUS_SRC_COLOR;\r\n            case src_alpha:\r\n                return GL.SRC_ALPHA;\r\n            case one_minus_src_alpha:\r\n                return GL.ONE_MINUS_SRC_ALPHA;\r\n            case dst_alpha:\r\n                return GL.DST_ALPHA;\r\n            case one_minus_dst_alpha:\r\n                return GL.ONE_MINUS_DST_ALPHA;\r\n            case dst_color:\r\n                return GL.DST_COLOR;\r\n            case one_minus_dst_color:\r\n                return GL.ONE_MINUS_DST_COLOR;\r\n            case src_alpha_saturate:\r\n                return GL.SRC_ALPHA_SATURATE;\r\n        }\r\n    } //BlendMode convert\r\n\r\n\r\n    public static function get_elements_for_type( type:PrimitiveType, length:Int ) {\r\n            // line_strip || line_loop || triangle_strip || triangle_fan are separated from being batched\r\n        switch( type ) {\r\n            case points:\r\n                return Std.int(length/4);\r\n            case lines:\r\n                return Std.int(length/4);\r\n            case line_strip:\r\n                return Std.int(length/4);\r\n            case line_loop:\r\n                return Std.int(length/4);\r\n            case triangle_strip:\r\n                return Std.int(length/4);\r\n            case triangle_fan:\r\n                return Std.int(length/4);\r\n            default:\r\n                return Std.int(length/4);\r\n        }\r\n    } //get_opengl_type_length\r\n    \r\n    public static inline function fovx_to_y(fovx:Float, aspect:Float):Float {\r\n        return (180 / Math.PI) * (2 * Math.atan(Math.tan(fovx * (Math.PI / 180) / 2) * (1 / aspect)));\r\n    } //fovx_to_y\r\n\r\n} //Rendering\r\n","package snow;\r\n\r\nimport snow.utils.AbstractClass;\r\nimport snow.types.Types;\r\n\r\n#if snow_web\r\n\r\n   @:noCompletion typedef Core = snow.platform.web.Core;\r\n\r\n#else\r\n\r\n   @:noCompletion typedef Core = snow.platform.native.Core;\r\n\r\n#end //snow_web\r\n\r\n\r\n/** Implemented in the platform specific concrete versions of this class. */\r\n@:noCompletion class CoreBinding implements AbstractClass {\r\n\r\n        //The snow instance\r\n    var app : Snow;\r\n        /** Called by the snow internals to intiialize the core and subsystems of the framework, with the event handler passed in for where to deliver system events */\r\n    public function init( _event_handler : SystemEvent->Void ) : Void;\r\n        /** Called to explicitly shutdown the framework cleanly. Called by `quit` and `app_terminated` type events by the core, for example. */\r\n    public function shutdown() : Void;\r\n        /** Get the most precise timestamp available on the platform, in seconds (time is always in seconds in snow) */\r\n    public function timestamp() : Float;\r\n\r\n\r\n        /** Return the full path that the application is located */\r\n    public function app_path() : String;\r\n        /** On platforms where this makes sense, get the application specific writeable data path.\r\n            Uses the package from `SnowConfig`, passed through from flow projects or boot config. */\r\n    public function app_path_prefs() : String;\r\n\r\n} //CoreBinding\r\n","package snow.utils;\r\n\r\n// Author : Andy Li\r\n// Sourced from : https://gist.github.com/andyli/5011520\r\n\r\nimport haxe.macro.Context;\r\nimport haxe.macro.Expr;\r\nimport haxe.macro.Type;\r\nusing Lambda;\r\n\r\n/**\r\n\tOld school abstract class.\r\n\tClasses that implements it, and their sub-classes, will be able to declare abstract methods (methods that without body).\r\n\tThere will be a check in compile-time such that no public constructor is allowed without all abstract methods implemented.\r\n*/\r\n@:autoBuild(snow.utils.AbstractClassBuilder.build())\r\ninterface AbstractClass {}\r\n\r\nprivate typedef StringMap<T> = Map<String, T>;\r\n\r\n@:noCompletion class AbstractClassBuilder {\r\n\t#if macro\r\n\t/**\r\n\t\tThe without-body declared methods of an AbstractClass.\r\n\t\tUses fully-qualified class names as keys, stores StringMaps of method name keys.\r\n\t\tFilled in by build() called by @:autoBuild.\r\n\t*/\r\n\tstatic var declAbstracts:StringMap<StringMap<Bool>> = new StringMap();\r\n\r\n\t/**\r\n\t\tAll abstract methods, including the inherited ones, of an AbstractClass.\r\n\t\tUses fully-qualified class names as keys, stores StringMaps of method name keys.\r\n\t\tFilled in by checkAbstractClass() during onGenerate.\r\n\t*/\r\n\tstatic var allAbstracts:StringMap<StringMap<Bool>> = new StringMap();\r\n\r\n\t/**\r\n\t\tThe remainning AbstractClasses that need to be processed by checkAbstractClass().\r\n\t\tUses fully-qualified class names as keys.\r\n\t\tFilled in during onGenerate.\r\n\t*/\r\n\tstatic var typesToProcess:StringMap<ClassType> = new StringMap();\r\n\r\n\t/**\r\n\t\tReturns fully-qualified class name.\r\n\t\tUsed to get a key for StringMap.\r\n\t*/\r\n\tstatic function getFullClassName(cls:ClassType):String {\r\n\t\treturn (cls.pack.length > 0 ? cls.pack.join(\".\") + \".\" : \"\") + cls.name;\r\n\t}\r\n\r\n\tstatic function __init__():Void {\r\n\t\tContext.onGenerate(function (types:Array<Type>):Void {\r\n\t\t\tfor (t in types) {\r\n\t\t\t\tswitch (t) {\r\n\t\t\t\t\tcase TInst(clsr, _):\r\n\t\t\t\t\t\tvar clsName = getFullClassName(clsr.get());\r\n\t\t\t\t\t\tif (declAbstracts.exists(clsName)) {\r\n\t\t\t\t\t\t\ttypesToProcess.set(clsName, clsr.get());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\twhile (!typesToProcess.empty()) {\r\n\t\t\t\tcheckAbstractClass(typesToProcess.iterator().next());\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tstatic function checkAbstractClass(cls:ClassType):Void {\r\n\t\tvar allAbsFields:StringMap<Bool> = new StringMap();\r\n\t\tvar clsName = getFullClassName(cls);\r\n\t\tallAbstracts.set(clsName, allAbsFields);\r\n\r\n\t\t//copy the declared ones\r\n\t\tvar absFields = declAbstracts.get(clsName);\r\n\t\tfor (k in absFields.keys()) {\r\n\t\t\tallAbsFields.set(k, true);\r\n\t\t}\r\n\r\n\t\tif (cls.superClass != null && declAbstracts.exists(getFullClassName(cls.superClass.t.get()))) {\r\n\t\t\t//Super class is AbstractClass.\r\n\t\t\tvar supClsName = getFullClassName(cls.superClass.t.get());\r\n\t\t\tif (!allAbstracts.exists(supClsName)) {\r\n\t\t\t\tcheckAbstractClass(cls.superClass.t.get());\r\n\t\t\t}\r\n\r\n\t\t\t//copy the inherited ones\r\n\t\t\tvar supallAbsFields = allAbstracts.get(supClsName);\r\n\t\t\tfor (k in supallAbsFields.keys()) {\r\n\t\t\t\tallAbsFields.set(k, true);\r\n\t\t\t}\r\n\r\n\t\t\tvar fields = cls.fields.get();\r\n\t\t\tfor (field in fields) {\r\n\t\t\t\tif (!absFields.exists(field.name) && allAbsFields.exists(field.name)) {\r\n\t\t\t\t\tallAbsFields.remove(field.name);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!allAbsFields.empty() && cls.constructor != null && cls.constructor.get().isPublic) {\r\n\t\t\tvar missingFields = [];\r\n\t\t\tfor (k in allAbsFields.keys()) missingFields.push(k);\r\n\t\t\tContext.error(\"Abstract class cannot have public constructor. Missing implementation of: \" + missingFields.join(\", \"), cls.pos);\r\n\t\t}\r\n\r\n\t\ttypesToProcess.remove(clsName);\r\n\t}\r\n\r\n\tstatic public function build():Array<Field> {\r\n\t\tvar fields = Context.getBuildFields();\r\n\t\tvar cls = Context.getLocalClass().get();\r\n\t\tvar clsName = getFullClassName(cls);\r\n\r\n\t\tif (declAbstracts.exists(clsName)){\r\n\t\t\t//The class has been built already.\r\n\t\t\t//It occurs when a class extends an AbstractClass, and it also implements AbstractClass.\r\n\t\t\treturn fields;\r\n\t\t}\r\n\r\n\t\tif (cls.isInterface) {\r\n\t\t\treturn fields;\r\n\t\t}\r\n\r\n\t\tvar absFields = new StringMap();\r\n\t\tdeclAbstracts.set(clsName, absFields);\r\n\r\n\t\tfor (f in fields) {\r\n\t\t\tif (f.access.has(AStatic)) continue; //we only care non-static methods\r\n\r\n\t\t\tswitch (f.kind) {\r\n\t\t\t\tcase FFun(fun):\r\n\t\t\t\t\tif (fun.expr == null) { //method without an implementation\r\n\t\t\t\t\t\tabsFields.set(f.name, true);\r\n\r\n\t\t\t\t\t\t//give a method body so it compiles\r\n\t\t\t\t\t\tfun.expr = if (fun.ret == null || switch (fun.ret) { case TPath(p): p.pack.length == 0 && p.name == \"Void\"; default: false; })\r\n\t\t\t\t\t\t\tmacro throw \"abstract method, must override\";\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tmacro return throw \"abstract method, must override\";\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\tdefault:\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn fields;\r\n\t}\r\n\t#end\r\n}","package snow;\r\n\r\nimport haxe.io.Path;\r\nimport haxe.macro.Context;\r\nimport haxe.macro.Expr;\r\n\r\nprivate enum LogError {\r\n    RequireString(detail:String);\r\n}\r\n\r\nclass Log {\r\n\r\n        //default to `log`\r\n    public static var _level : Int = 1;\r\n    public static var _filter : Array<String>;\r\n    public static var _exclude : Array<String>;\r\n    public static var _log_width : Int = 16;\r\n\r\n    macro public static function get_level() : haxe.macro.Expr {\r\n        return macro $v{ ${snow.Log._level} };\r\n    }\r\n    macro public static function get_filter() : haxe.macro.Expr {\r\n        return macro $v{ ${snow.Log._filter} };\r\n    }\r\n    macro public static function get_exclude() : haxe.macro.Expr {\r\n        return macro $v{ ${snow.Log._exclude} };\r\n    }\r\n\r\n    macro public static function level( __level:Int ) : haxe.macro.Expr {\r\n\r\n        _level = __level;\r\n\r\n        return macro null;\r\n\r\n    } //level\r\n\r\n    macro public static function filter( __filter:String ) : haxe.macro.Expr {\r\n\r\n        _filter = __filter.split(',');\r\n\r\n        var _index = 0;\r\n        for(_f in _filter) {\r\n            _filter[_index] = StringTools.trim(_f);\r\n            _index++;\r\n        }\r\n\r\n        return macro null;\r\n\r\n    } //filter\r\n\r\n    macro public static function exclude( __exclude:String ) : haxe.macro.Expr {\r\n\r\n        _exclude = __exclude.split(',');\r\n\r\n        var _index = 0;\r\n        for(_e in _exclude) {\r\n            _exclude[_index] = StringTools.trim(_e);\r\n            _index++;\r\n        }\r\n\r\n        return macro null;\r\n\r\n    } //exclude\r\n\r\n    macro public static function width( _width:Int ) : haxe.macro.Expr {\r\n\r\n        // trace(\"/ snow / set log width to \" + _width );\r\n\r\n        _log_width = _width;\r\n\r\n        return macro null;\r\n\r\n    } //width\r\n\r\n        //This macro uses the defined log level value to reject code that\r\n        //shouldn't even exist at runtime , like low level debug information\r\n        //and logging by injecting or not injecting code\r\n    macro public static function log( value:Dynamic ) : Expr {\r\n\r\n        var _file = Path.withoutDirectory(_get_log_file());\r\n        var _context = Path.withoutExtension(_file).toLowerCase();\r\n        var _spaces = _get_spacing(_file);\r\n\r\n        for(meta in Context.getLocalClass().get().meta.get()) {\r\n            if(meta.name == ':log_as') {\r\n                var _str = switch(meta.params[0].expr) {\r\n                    case EConst(CString(str)): _context = str;\r\n                    default: throw LogError.RequireString('log_as meta requires a string constant like \"name\"');\r\n                }\r\n            }\r\n        } //for each meta\r\n\r\n        var _log = (_level > 0);\r\n\r\n            if(_filter != null && (_filter.indexOf(_context) == -1)) {\r\n                _log = false;\r\n            }\r\n\r\n            if(_exclude != null && (_exclude.indexOf(_context) != -1)) {\r\n                _log = false;\r\n            }\r\n\r\n        if(_log) {\r\n            return macro @:pos(Context.currentPos()) trace('${_spaces}i / $_context / ' + $value);\r\n        }\r\n\r\n        return macro null;\r\n\r\n    } //log\r\n\r\n    macro public static function _debug( value:Dynamic ) : Expr {\r\n\r\n        var _file = Path.withoutDirectory(_get_log_file());\r\n        var _context = Path.withoutExtension(_file).toLowerCase();\r\n        var _spaces = _get_spacing(_file);\r\n\r\n        for(meta in Context.getLocalClass().get().meta.get()) {\r\n            if(meta.name == ':log_as') {\r\n                var _str = switch(meta.params[0].expr) {\r\n                    case EConst(CString(str)): _context = str;\r\n                    default: throw LogError.RequireString('log_as meta requires a string constant like \"name\"');\r\n                }\r\n            }\r\n        } //for each meta\r\n\r\n        var _log = (_level > 1);\r\n\r\n            if(_filter != null && (_filter.indexOf(_context) == -1)) {\r\n                _log = false;\r\n            }\r\n\r\n            if(_exclude != null && (_exclude.indexOf(_context) != -1)) {\r\n                _log = false;\r\n            }\r\n\r\n        if(_log) {\r\n            return macro @:pos(Context.currentPos()) trace('${_spaces}d / $_context / ' + $value);\r\n        }\r\n\r\n        return macro null;\r\n\r\n    } //_debug\r\n\r\n    macro public static function _verbose( value:Dynamic ) : Expr {\r\n\r\n        var _file = Path.withoutDirectory(_get_log_file());\r\n        var _context = Path.withoutExtension(_file).toLowerCase();\r\n        var _spaces = _get_spacing(_file);\r\n\r\n        for(meta in Context.getLocalClass().get().meta.get()) {\r\n            if(meta.name == ':log_as') {\r\n                var _str = switch(meta.params[0].expr) {\r\n                    case EConst(CString(str)): _context = str;\r\n                    default: throw LogError.RequireString('log_as meta requires a string constant like \"name\"');\r\n                }\r\n            }\r\n        } //for each meta\r\n\r\n        var _log = (_level > 2);\r\n\r\n            if(_filter != null && (_filter.indexOf(_context) == -1)) {\r\n                _log = false;\r\n            }\r\n\r\n            if(_exclude != null && (_exclude.indexOf(_context) != -1)) {\r\n                _log = false;\r\n            }\r\n\r\n        if(_log) {\r\n            return macro @:pos(Context.currentPos()) trace('${_spaces}v / $_context / ' + $value);\r\n        }\r\n\r\n        return macro null;\r\n\r\n    } //_verbose\r\n\r\n    macro public static function _verboser( value:Dynamic ) : Expr {\r\n\r\n        var _file = Path.withoutDirectory(_get_log_file());\r\n        var _context = Path.withoutExtension(_file).toLowerCase();\r\n        var _spaces = _get_spacing(_file);\r\n\r\n        for(meta in Context.getLocalClass().get().meta.get()) {\r\n            if(meta.name == ':log_as') {\r\n                var _str = switch(meta.params[0].expr) {\r\n                    case EConst(CString(str)): _context = str;\r\n                    default: throw LogError.RequireString('log_as meta requires a string constant like \"name\"');\r\n                }\r\n            }\r\n        } //for each meta\r\n\r\n        var _log = (_level > 3);\r\n\r\n            if(_filter != null && (_filter.indexOf(_context) == -1)) {\r\n                _log = false;\r\n            }\r\n\r\n            if(_exclude != null && (_exclude.indexOf(_context) != -1)) {\r\n                _log = false;\r\n            }\r\n\r\n        if(_log) {\r\n            return macro @:pos(Context.currentPos()) trace('${_spaces}V / $_context / ' + $value);\r\n        }\r\n\r\n        return macro null;\r\n\r\n    } //_verboser\r\n\r\n\r\n//Internal Helpers\r\n\r\n\r\n    static function _get_spacing(_file:String ) {\r\n\r\n        var _spaces = '';\r\n\r\n            //the magic number here is File.hx[:1234] for the trace listener log spacing\r\n        var _trace_length = _file.length + 4;\r\n        var _diff : Int = _log_width - _trace_length;\r\n        if(_diff > 0) {\r\n            for(i in 0 ... _diff) {\r\n                _spaces += ' ';\r\n            }\r\n        }\r\n\r\n        return _spaces;\r\n\r\n    } //_get_spacing\r\n\r\n    macro static function _get_log_file() {\r\n        return macro Context.getPosInfos(Context.currentPos()).file;\r\n    } //get_log_context\r\n\r\n} // Log","package snow;\r\n\r\n\r\nimport snow.App;\r\nimport snow.io.typedarray.Uint8Array;\r\nimport snow.types.Types;\r\nimport snow.utils.Timer;\r\n\r\nimport snow.utils.Promise;\r\n\r\nimport snow.io.IO;\r\nimport snow.input.Input;\r\nimport snow.audio.Audio;\r\nimport snow.assets.Assets;\r\nimport snow.window.Window;\r\nimport snow.window.Windowing;\r\n\r\n    //the platform core bindings\r\nimport snow.Core;\r\n\r\nimport snow.Log.log;\r\nimport snow.Log._debug;\r\nimport snow.Log._verbose;\r\nimport snow.Log._verboser;\r\n\r\nclass Snow {\r\n\r\n//Property accessors\r\n\r\n        /** The current timestamp */\r\n    public var time (get,never) : Float;\r\n        /** Generate a unique ID to use */\r\n    public var uniqueid (get,never) : String;\r\n\r\n\r\n//State management\r\n\r\n        /** The host application */\r\n    public var host : App;\r\n        /** The application configuration specifics (like window, runtime, and asset lists) */\r\n    public var config : AppConfig;\r\n        /** The configuration for snow itself, set via build project flags */\r\n    public var snow_config : SnowConfig;\r\n        /** Whether or not we are frozen, ignoring events i.e backgrounded/paused */\r\n    public var freeze (default,set) : Bool = false;\r\n\r\n//Sub systems\r\n\r\n        /** The io system */\r\n    public var io : IO;\r\n        /** The input system */\r\n    public var input : Input;\r\n        /** The asset system */\r\n    public var assets : Assets;\r\n        /** The audio system */\r\n    public var audio : Audio;\r\n        /** The window manager */\r\n    public var windowing : Windowing;\r\n\r\n        /** Set if shut down has commenced */\r\n    public var shutting_down : Bool = false;\r\n        /** Set if shut dow has completed  */\r\n    public var has_shutdown : Bool = false;\r\n        /** If the config specifies a default window, this is it */\r\n    public var window : Window;\r\n\r\n//Internal values\r\n\r\n        //if already passed the ready state\r\n    var was_ready : Bool = false;\r\n        //if ready has completed, so systems can begin safely\r\n    var is_ready : Bool = false;\r\n        //the core platform instance to bind us\r\n    @:noCompletion public static var core : Core;\r\n\r\n\r\n    @:noCompletion public function new() {\r\n\r\n        if(snow.Log.get_level() > 1) {\r\n            log('log / level to ${snow.Log.get_level()}' );\r\n            log('log / filter : ${snow.Log.get_filter()}');\r\n            log('log / exclude : ${snow.Log.get_exclude()}');\r\n        }\r\n\r\n            //We create the core as a concrete platform version of the core\r\n        core = new Core( this );\r\n        next_list = [];\r\n\r\n    } //new\r\n\r\n//Internal API\r\n\r\n    @:noCompletion public function init( _snow_config:SnowConfig, _host : App ) {\r\n\r\n        snow_config = _snow_config;\r\n        if(snow_config.app_package == null) {\r\n            snow_config.app_package = 'org.snowkit.snowdefault';\r\n        }\r\n\r\n        config = {\r\n            has_window : true,\r\n            runtime : {},\r\n            window : null,\r\n            render : null,\r\n            assets : [],\r\n            web : {\r\n                no_context_menu : true,\r\n                prevent_default_keys : [\r\n                    Key.left, Key.right, Key.up, Key.down,\r\n                    Key.backspace, Key.tab, Key.delete\r\n                ],\r\n                prevent_default_mouse_wheel : true,\r\n                true_fullscreen : false\r\n            },\r\n            native : {\r\n                audio_buffer_length : 176400,\r\n                audio_buffer_count : 4\r\n            }\r\n        };\r\n\r\n        host = _host;\r\n        host.app = this;\r\n\r\n        core.init( on_event );\r\n\r\n    } //init\r\n\r\n        /** Shutdown the engine and quit */\r\n    public function shutdown() {\r\n\r\n        shutting_down = true;\r\n\r\n        host.ondestroy();\r\n        io.destroy();\r\n        audio.destroy();\r\n        input.destroy();\r\n        windowing.destroy();\r\n\r\n        core.shutdown();\r\n\r\n        has_shutdown = true;\r\n\r\n    } //shutdown\r\n\r\n    inline function get_time() : Float {\r\n\r\n        return core.timestamp();\r\n\r\n    } //time getter\r\n\r\n    function on_snow_init() {\r\n\r\n        _debug('init / initializing');\r\n\r\n            //ensure that we are in the correct location for asset loading\r\n\r\n        #if snow_native\r\n\r\n            var app_path = core.app_path();\r\n            var pref_path = core.app_path_prefs();\r\n\r\n            Sys.setCwd( app_path );\r\n\r\n            _debug('init / setting up app path $app_path');\r\n            _debug('init / setting up pref path: $pref_path');\r\n\r\n        #end //snow_native\r\n\r\n        _debug('init / pre ready, init host');\r\n\r\n            //any app pre ready init can be handled in here\r\n        host.on_internal_init();\r\n\r\n    } //on_snow_init\r\n\r\n    function on_snow_ready() {\r\n\r\n        if(was_ready) {\r\n            throw Error.error('firing ready event more than once is invalid usage');\r\n        }\r\n\r\n        _debug('init / setting up additional systems...');\r\n\r\n                //create the sub systems\r\n            io = new IO( this );\r\n            input = new Input( this );\r\n            audio = new Audio( this );\r\n            assets = new Assets( this );\r\n            windowing = new Windowing( this );\r\n\r\n            //disllow re-entry\r\n        was_ready = true;\r\n\r\n        setup_default_assets().then(function(_){\r\n\r\n            setup_configs().then(function(_){\r\n\r\n                setup_default_window();\r\n\r\n                _debug('init / calling host ready');\r\n\r\n                is_ready = true;\r\n                host.ready();\r\n\r\n            });\r\n\r\n        }).error(function(e) {\r\n\r\n            throw Error.init('snow / cannot recover from error: $e');\r\n\r\n        });\r\n\r\n    } //on_snow_ready\r\n\r\n    @:allow(snow.App)\r\n    function do_internal_update( dt:Float ) {\r\n\r\n        io.update();\r\n        input.update();\r\n        audio.update();\r\n        host.update( dt );\r\n\r\n    } //do_internal_update\r\n\r\n        /** Called for you by snow, unless configured otherwise. Only call this manually if your render_rate is 0! */\r\n    public function render() {\r\n\r\n        windowing.update();\r\n\r\n    } //render\r\n\r\n    function on_snow_update() {\r\n\r\n        if(freeze) return;\r\n\r\n            //first update timers\r\n        Timer.update();\r\n\r\n            //handle promise executions\r\n        snow.utils.Promise.Promises.step();\r\n\r\n            //fire any next tick callbacks\r\n        handle_next_list();\r\n\r\n            //game updates aren't allowed till we are flagged\r\n        if(!is_ready) return;\r\n\r\n            //handle any internal updates\r\n        host.on_internal_update();\r\n\r\n            //handle any internal render updates\r\n        host.on_internal_render();\r\n\r\n            //let the system have some time\r\n        #if snow_native\r\n            Sys.sleep(0);\r\n        #end\r\n\r\n    } //on_snow_update\r\n\r\n    public function dispatch_system_event( _event:SystemEvent ) {\r\n\r\n        on_event(_event);\r\n\r\n    } //dispatch_system_event\r\n\r\n    function on_event( _event:SystemEvent ) {\r\n\r\n        if( _event.type != SystemEventType.update &&\r\n            _event.type != SystemEventType.unknown &&\r\n            _event.type != SystemEventType.window &&\r\n            _event.type != SystemEventType.input\r\n\r\n        ) {\r\n            _debug( 'event / system event / ${_event.type} / $_event');\r\n        }\r\n\r\n        if( _event.type != SystemEventType.update ) {\r\n            _verboser( 'event / system event / $_event');\r\n        }\r\n\r\n            //all systems should get these basically...\r\n            //cos of app lifecycles etc being here.\r\n        if(is_ready) {\r\n            io.on_event( _event );\r\n            audio.on_event( _event );\r\n            windowing.on_event( _event );\r\n            input.on_event( _event );\r\n            host.onevent( _event );\r\n        }\r\n\r\n        switch(_event.type) {\r\n\r\n            case SystemEventType.init: {\r\n                on_snow_init();\r\n            } //init\r\n\r\n            case SystemEventType.ready: {\r\n                on_snow_ready();\r\n            } //ready\r\n\r\n            case SystemEventType.update: {\r\n                on_snow_update();\r\n            } //update\r\n\r\n            case SystemEventType.quit, SystemEventType.app_terminating: {\r\n                shutdown();\r\n            } //quit\r\n\r\n            case SystemEventType.shutdown: {\r\n                log('Goodbye.');\r\n            } //shutdown\r\n\r\n            default: {\r\n\r\n            } //default\r\n\r\n        } //switch _event.type\r\n\r\n    } //on_event\r\n\r\n    function set_freeze( _freeze:Bool ) {\r\n\r\n        freeze = _freeze;\r\n\r\n        if(_freeze) {\r\n            audio.suspend();\r\n        } else {\r\n            audio.resume();\r\n        }\r\n\r\n        return freeze;\r\n\r\n    } //set_freeze\r\n\r\n    function setup_default_assets() {\r\n\r\n        return new Promise(function(resolve, reject) {\r\n\r\n            if(!snow_config.config_custom_assets) {\r\n\r\n                    //load the correct asset path from the snow config\r\n                assets.manifest_path = snow_config.config_assets_path;\r\n\r\n                    //\r\n                _debug('assets / fetching list \"${assets.manifest_path}\"');\r\n\r\n                    //we fetch the a list from the manifest\r\n                default_asset_list().then(function(list) {\r\n\r\n                        //then we add the list for the asset manager\r\n                    config.assets = list;\r\n                    assets.add( config.assets );\r\n\r\n                    resolve();\r\n\r\n                }).error(function(e:Dynamic) {\r\n\r\n                    //default asset manifest is not critical\r\n                    //and will leave logs so we just continue with\r\n                    //making a note of the state\r\n                    config.assets = [];\r\n                    resolve();\r\n\r\n                });\r\n\r\n            } //custom assets\r\n\r\n        }); //promise\r\n\r\n    } //ready_default_assets\r\n\r\n    function setup_configs() {\r\n\r\n            //sync configs\r\n        config.window = default_window_config();\r\n        config.render = default_render_config();\r\n\r\n        return new Promise(function(resolve, reject){\r\n\r\n            if(!snow_config.config_custom_runtime) {\r\n\r\n                _debug('config / fetching runtime config');\r\n\r\n                default_runtime_config().then(function(_runtime_conf:Dynamic) {\r\n\r\n                    config.runtime = _runtime_conf;\r\n                    setup_host_config();\r\n                    resolve();\r\n\r\n                });\r\n\r\n            } else {\r\n\r\n                    //if default config is disabled\r\n                    //we still need the user config\r\n                setup_host_config();\r\n                resolve();\r\n\r\n            } //disabled\r\n\r\n        }); //promise\r\n\r\n    } //setup_configs\r\n\r\n    function setup_host_config() {\r\n\r\n        _debug('config / fetching user config');\r\n\r\n        config = host.config( config );\r\n\r\n    } //setup_host_config\r\n\r\n\r\n    function setup_default_window() {\r\n\r\n        _debug('windowing / creating default window');\r\n\r\n            //force fullscreen on mobile to get better\r\n            //behavior from the window for now.\r\n            //borderless will control the status bar\r\n        #if mobile\r\n            config.window.fullscreen = true;\r\n        #end //mobile\r\n\r\n            //now if they requested a window, let's open one\r\n        if(config.has_window == true) {\r\n\r\n            window = windowing.create( config.window );\r\n\r\n                //failed to create?\r\n            if(window.handle == null) {\r\n                throw Error.windowing('requested default window cannot be created. cannot continue');\r\n            }\r\n\r\n        } //has_window\r\n\r\n    } //create_default_window\r\n\r\n\r\n        /** handles the default method of parsing a runtime config json,\r\n            To change this behavior override `get_runtime_config`. This is called by default in get_runtime_config. */\r\n    function default_runtime_config() : Promise {\r\n\r\n        return new Promise(function(resolve, reject) {\r\n\r\n            var json:Dynamic = null;\r\n\r\n                //we want to load the runtime config from a json file by default\r\n            var onload = function(asset:snow.assets.AssetText) {\r\n                if(asset.text != null) {\r\n                    try {\r\n\r\n                        json = haxe.Json.parse( asset.text );\r\n                        _debug('config / ok / loaded runtime config');\r\n\r\n                    } catch(e:Dynamic) {\r\n                        log('config / json parse error ');\r\n                        throw Error.init('config / failed / default runtime config failed to parse as JSON. cannot recover. $e');\r\n                    }\r\n\r\n                    resolve(json);\r\n                }\r\n            }\r\n\r\n            var found = assets.text( snow_config.config_runtime_path, { silent:true, onload:onload });\r\n            if(found == null) resolve({});\r\n\r\n        }); //promise\r\n\r\n    } //default_runtime_config\r\n\r\n        /** handles the default method of parsing the file manifest list as json, stored in an array and returned. */\r\n    function default_asset_list() : Promise {\r\n\r\n        return new Promise(function(resolve, reject){\r\n\r\n            var list_path : String = assets.assets_root + assets.manifest_path;\r\n            var load = io.data_load( list_path, { binary:false });\r\n\r\n            load.then(function(_data:Uint8Array) {\r\n\r\n                var _filedata = _data.toBytes().toString();\r\n                if(_filedata != null && _filedata.length != 0) {\r\n\r\n                    var _list:Array<String> = haxe.Json.parse(_filedata.toString());\r\n                    var asset_list : Array<AssetInfo> = [];\r\n\r\n                    for(asset in _list) {\r\n\r\n                        asset_list.push({\r\n                            id : asset,\r\n                            path : haxe.io.Path.join([assets.assets_root, asset]),\r\n                            type : haxe.io.Path.extension(asset),\r\n                            ext : haxe.io.Path.extension(asset)\r\n                        });\r\n\r\n                    } //for each asset\r\n\r\n                    _debug('assets / ok / loaded asset manifest.');\r\n                    _debug('assets / list loaded as $asset_list');\r\n\r\n                    resolve( asset_list );\r\n\r\n                } else { //manifest_data != null\r\n\r\n                    log('assets / info / default asset manifest is empty?');\r\n                    reject('default asset manifest is empty');\r\n\r\n                }\r\n\r\n            }).error(function(e:Dynamic) {\r\n\r\n                log('assets / info / default asset manifest not found at $list_path');\r\n                reject('default asset manifest error: $e');\r\n\r\n            });\r\n\r\n        }); //new promise\r\n\r\n    } //default_asset_list\r\n\r\n\r\n        /** Returns a default configured render config */\r\n    function default_render_config() : RenderConfig {\r\n\r\n        _debug('config / fetching default render config');\r\n\r\n        return {\r\n            depth : false,\r\n            stencil : false,\r\n            antialiasing : 0,\r\n            red_bits : 8,\r\n            green_bits : 8,\r\n            blue_bits : 8,\r\n            alpha_bits : 8,\r\n            depth_bits : 0,\r\n            stencil_bits : 0,\r\n            opengl : {\r\n                minor:0, major:0,\r\n                profile:OpenGLProfile.compatibility\r\n            }\r\n        };\r\n\r\n    } //default_render_config\r\n\r\n        /** Returns a default configured window config */\r\n    function default_window_config() : WindowConfig {\r\n\r\n        _debug('config / fetching default window config');\r\n\r\n        var conf =  {\r\n            fullscreen_desktop  : true,\r\n            fullscreen          : false,\r\n            borderless          : false,\r\n            resizable           : true,\r\n            x                   : 0x1FFF0000,\r\n            y                   : 0x1FFF0000,\r\n            width               : 960,\r\n            height              : 640,\r\n            title               : 'snow app'\r\n        };\r\n\r\n            #if mobile\r\n                conf.fullscreen = true;\r\n                conf.borderless = true;\r\n            #end //mobile\r\n\r\n        return conf;\r\n\r\n    } //default_window_config\r\n\r\n\r\n//Helpers\r\n\r\n    function get_uniqueid() : String {\r\n        return _uniqueid();\r\n    } //get_uniqueid\r\n\r\n    inline function _uniqueid(?val:Int) : String {\r\n\r\n        // http://www.anotherchris.net/csharp/friendly-unique-id-generation-part-2/#base62\r\n\r\n        if(val == null) val = Std.random(0x7fffffff);\r\n\r\n        function to_char(value:Int) : String {\r\n            if (value > 9) {\r\n                var ascii = (65 + (value - 10));\r\n                if (ascii > 90) { ascii += 6; }\r\n                return String.fromCharCode(ascii);\r\n            } else return Std.string(value).charAt(0);\r\n        } //to_char\r\n\r\n        var r = Std.int(val % 62);\r\n        var q = Std.int(val / 62);\r\n        if (q > 0) return _uniqueid(q) + to_char(r);\r\n        else return Std.string(to_char(r));\r\n\r\n    } //_uniqueid\r\n\r\n        /** Loads a function out of a library */\r\n    public static function load( library:String, method:String, args:Int = 0 ) : Dynamic {\r\n\r\n        return snow.utils.Libs.load( library, method, args );\r\n\r\n    } //load\r\n\r\n\r\n    static var next_list : Array<Void->Void>;\r\n        /** Call a function at the start of the next frame,\r\n            useful for async calls in a sync context, allowing the sync function to return safely before the onload is fired. */\r\n    public static function next( func: Void->Void ) {\r\n\r\n        if(func != null) {\r\n            next_list.push(func);\r\n        }\r\n\r\n    } //next\r\n\r\n    function handle_next_list() {\r\n\r\n        if(next_list.length > 0) {\r\n\r\n                //to avoid culling ones adding during a next call\r\n            var _pre_next_length = next_list.length;\r\n                //avoid allocating on the run loop\r\n                //as much as possible so no iterator\r\n            for(i in 0 ... next_list.length) {\r\n                next_list[i]();\r\n            }\r\n\r\n            next_list.splice(0, _pre_next_length);\r\n\r\n        } //next_list.length\r\n\r\n    } //handle_next_list\r\n\r\n} //Snow\r\n\r\n","package snow.assets;\r\n\r\nimport snow.assets.Assets;\r\nimport snow.types.Types;\r\n\r\n\r\n/**  An asset base class. Get assets from the `app.assets` */\r\nclass Asset {\r\n\r\n\r\n        /** The asset manager associated with this asset */\r\n    public var assets : Assets;\r\n        /** The id of this asset like `assets/image.png` */\r\n    public var id : String;\r\n        /** The `AssetInfo` of this asset */\r\n    public var info : AssetInfo;\r\n        /** The concrete type this asset holds (useful when handling as Asset base class) */\r\n    public var type : AssetType;\r\n        /** True if this asset has completely loaded. Only changed through `load` and when load completes */\r\n    public var loaded : Bool = false;\r\n\r\n\r\n        /** Called from subclasses, by `app.assets` */\r\n    public function new( _assets:Assets, _info:AssetInfo ) {\r\n\r\n        assets = _assets;\r\n        info = _info;\r\n        id = info.id;\r\n\r\n    } //new\r\n\r\n\r\n} //Asset","package snow.assets;\r\n\r\nimport snow.io.IO;\r\nimport snow.types.Types;\r\nimport snow.utils.Libs;\r\nimport snow.assets.AssetSystem;\r\n\r\n\r\n/**  An asset that contains audio file `audio` as an `AudioInfo`. Get assets from the `Assets` class, via `app.assets` */\r\nclass AssetAudio extends Asset {\r\n\r\n\r\n        /** The `AudioInfo` this asset contains */\r\n    public var audio : AudioInfo;\r\n        /** The audio format of this asset. */\r\n    public var format : AudioFormatType;\r\n        /** Whether or not this asset is to be loaded in full (or alternatively, streamed). Used from `load` only. */\r\n    public var load_full : Bool = true;\r\n\r\n\r\n        /** Created from `app.assets.audio`.  */\r\n    public function new( _assets:Assets, _info:AssetInfo, _format:AudioFormatType, ?_load:Bool=true ) {\r\n\r\n        super( _assets, _info );\r\n        type = AssetType.audio;\r\n        format = _format;\r\n        load_full = _load;\r\n\r\n    } //new\r\n\r\n\r\n        /** Called from `app.assets.audio`, or manually, if reloading the asset data at a later point.\r\n            Note this function calls the onload handler in the next frame, so sync code can return. */\r\n    public function load( ?onload:AssetAudio->Void ) {\r\n\r\n        loaded = false;\r\n            //clear any old data in case\r\n        audio = null;\r\n\r\n            //load the new data\r\n        assets.platform.audio_load_info( info.path, format, load_full, function( ?_audio:AudioInfo ) {\r\n\r\n            audio = _audio;\r\n\r\n            loaded = true;\r\n\r\n            if(onload != null) {\r\n                Snow.next(function(){\r\n                    onload( this );\r\n                });\r\n            }\r\n\r\n        }); //audio_load_info\r\n\r\n    } //load\r\n\r\n\r\n        /** Called from `app.assets.audio`, or manually, if reloading the asset data at a later point. This is a synchronous call */\r\n    public function load_from_bytes( bytes:snow.io.typedarray.Uint8Array, format:AudioFormatType, ?onload:AssetAudio->Void ) {\r\n\r\n        loaded = false;\r\n\r\n                //clear old reference\r\n            audio = null;\r\n                //load the new data\r\n            audio = assets.platform.audio_info_from_bytes( info.path, bytes, format );\r\n\r\n            if(onload != null) {\r\n                onload( this );\r\n            }\r\n\r\n        loaded = true;\r\n\r\n    } //load\r\n\r\n\r\n} //AssetAudio\r\n","package snow.assets;\r\n\r\nimport snow.io.IO;\r\nimport snow.types.Types;\r\nimport snow.utils.Libs;\r\nimport snow.assets.AssetSystem;\r\nimport snow.io.typedarray.Uint8Array;\r\n\r\n\r\n/**  An asset that contains byte `bytes` as a `Uint8Array`. Get assets from the `Assets` class, via `app.assets` */\r\nclass AssetBytes extends Asset {\r\n\r\n\r\n        /** The `Uint8Array` this asset contains */\r\n    public var bytes : Uint8Array;\r\n        /** Whether or not this bytes data will load syncronously. Used in `load` only. */\r\n    public var async : Bool = false;\r\n\r\n\r\n        /** Called from `app.assets` */\r\n    public function new( _assets:Assets, _info:AssetInfo, ?_async:Bool=false ) {\r\n\r\n        super( _assets, _info );\r\n        type = AssetType.bytes;\r\n        async = _async;\r\n\r\n    } //new\r\n\r\n        /** Called from `app.assets.bytes`, or manually, if reloading the asset data at a later point.\r\n            Note this function calls the onload handler in the next frame, so sync code can return. */\r\n    public function load( ?onload:AssetBytes->Void ) {\r\n\r\n        loaded = false;\r\n            //clear any old data in case\r\n        bytes = null;\r\n\r\n        var p = assets.lib.io.data_load( info.path, { binary:true });\r\n        p.then(function(data:Uint8Array){\r\n\r\n            load_from_bytes(data, onload);\r\n\r\n        });\r\n\r\n    } //load\r\n\r\n        /** This function is a synchronous call. */\r\n    public function load_from_bytes( _bytes:Uint8Array, ?onload:AssetBytes->Void ) {\r\n\r\n        loaded = false;\r\n\r\n            bytes = _bytes;\r\n\r\n        loaded = true;\r\n\r\n        if(onload != null) {\r\n            onload( this );\r\n        }\r\n\r\n    } //load_from_bytes\r\n\r\n\r\n} //AssetBytes\r\n","package snow.assets;\r\n\r\nimport snow.io.IO;\r\nimport snow.io.typedarray.Uint8Array;\r\nimport snow.types.Types;\r\nimport snow.utils.Libs;\r\nimport snow.assets.Asset;\r\nimport snow.assets.AssetSystem;\r\n\r\n\r\n/**  An asset that contains image file `image` as an `ImageInfo`. Get assets from the `Assets` class, via `app.assets` */\r\nclass AssetImage extends Asset {\r\n\r\n\r\n        /** The `ImageInfo` this asset contains */\r\n    public var image : ImageInfo;\r\n        /** The requested components when loading this image. */\r\n    public var components : Int = 4;\r\n\r\n\r\n        /** Called from `app.assets` */\r\n    public function new( _assets:Assets, _info:AssetInfo, ?_components:Int=4 ) {\r\n\r\n        super( _assets, _info );\r\n        type = AssetType.image;\r\n        components = _components;\r\n\r\n    } //new\r\n\r\n        /** Called from `app.assets.image`, or manually, if reloading the asset data at a later point.\r\n            Note this function is async by nature, and calls the onload handler in the next frame. */\r\n    public function load( ?onload:AssetImage->Void ) {\r\n\r\n        loaded = false;\r\n            //clear any old data in case\r\n        image = null;\r\n\r\n            //load the new data\r\n        assets.platform.image_load_info( info.path, components, function( ?_image:ImageInfo ) {\r\n\r\n            if(_image != null) {\r\n                image = _image;\r\n                loaded = true;\r\n            }\r\n\r\n            if(onload != null) {\r\n                Snow.next(function(){\r\n                    onload( this );\r\n                });\r\n            }\r\n\r\n        }); //image_load_info\r\n\r\n    } //load\r\n\r\n        /** Called from `app.assets.image`, or manually, if reloading the asset data at a later point. This is a synchronous call */\r\n    public function load_from_bytes( bytes:Uint8Array, ?onload:AssetImage->Void ) {\r\n\r\n        loaded = false;\r\n\r\n                //clear old reference\r\n            image = null;\r\n                //load the new data\r\n            image = assets.platform.image_info_from_bytes( info.path, bytes, components );\r\n\r\n            if(onload != null) {\r\n                onload( this );\r\n            }\r\n\r\n        loaded = true;\r\n\r\n    } //load_from_bytes\r\n\r\n        /** Create an image asset from a pre-existing decoded image info. This is a synchronous call */\r\n    public function load_from_pixels( _id:String, _width:Int, _height:Int, _pixels: snow.io.typedarray.Uint8Array, ?onload:AssetImage->Void ) {\r\n\r\n        loaded = false;\r\n\r\n                //clear old reference\r\n            image = null;\r\n                //image info\r\n            image = {\r\n                id : _id,\r\n                width : _width,\r\n                width_actual : _width,\r\n                height : _height,\r\n                height_actual : _height,\r\n                bpp : 4, //:todo :\r\n                bpp_source : 4,\r\n                data : _pixels\r\n            };\r\n\r\n            if(onload != null) {\r\n                onload( this );\r\n            }\r\n\r\n        loaded = true;\r\n\r\n    } //load_from_pixels\r\n\r\n\r\n} //AssetImage\r\n","package snow.assets;\r\n\r\nimport snow.io.typedarray.Uint8Array;\r\nimport snow.Snow;\r\nimport snow.assets.Assets;\r\nimport snow.types.Types;\r\n\r\nimport snow.utils.AbstractClass;\r\n\r\n\r\n#if snow_web\r\n    @:noCompletion typedef AssetSystem = snow.platform.web.assets.AssetSystem;\r\n#else\r\n    @:noCompletion typedef AssetSystem = snow.platform.native.assets.AssetSystem;\r\n#end\r\n\r\n\r\n@:noCompletion class AssetSystemBinding implements AbstractClass {\r\n\r\n    public var manager : Assets;\r\n\r\n//common\r\n\r\n        /** Return true if the asset exists or false if not.\r\n            If strict is enabled, it will only check the stored asset list.\r\n            If strict is false, will allow unlisted paths and use platform specific exists checks.\r\n            On web targets, this will return false for unlisted files as http requests for 404's is silly. */\r\n    public function exists( _id:String, ?_strict:Bool=true ) : Bool;\r\n\r\n//image\r\n\r\n        /** Image info load from file path. Use `app.assets` */\r\n    public function image_load_info( _path:String, ?_components:Int = 4, ?_onload:?ImageInfo->Void ) : ImageInfo;\r\n        /** Image info load from `snow.io.typedarray.Uint8Array`. Use `app.assets` */\r\n    public function image_info_from_bytes( _path:String, _bytes:Uint8Array, ?_components:Int = 4 ) : ImageInfo;\r\n\r\n//audio\r\n\r\n        /** Audio info loader, use `app.assets`. */\r\n    public function audio_load_info( _path:String, ?_format:AudioFormatType, ?_load:Bool = true, ?_onload:?AudioInfo->Void ) : AudioInfo;\r\n        /** Audio info load from `Uint8Array`. use `app.assets`. */\r\n    public function audio_info_from_bytes( _path:String, _bytes:Uint8Array, _format:AudioFormatType ) : AudioInfo;\r\n\r\n\r\n\r\n\r\n\r\n//Native only\r\n\r\n\r\n\r\n\r\n\r\n    #if snow_native\r\n\r\n            /** Audio seek the specified audio info to the given position in bytes. `native` only */\r\n        public function audio_seek_source( _info:AudioInfo, _to:Int ) : Bool;\r\n            /** Audio portion loading (used for streaming or splitting source files into multiple blobs). sizes are in bytes. `native` only */\r\n        public function audio_load_portion( _info:AudioInfo, _start:Int, _len:Int ) : AudioDataBlob;\r\n\r\n    #end //snow_native\r\n\r\n\r\n} //AssetSystemBinding\r\n","package snow.assets;\r\n\r\nimport snow.io.IO;\r\nimport snow.types.Types;\r\nimport snow.utils.Libs;\r\nimport snow.assets.AssetSystem;\r\nimport snow.io.typedarray.Uint8Array;\r\n\r\n\r\n/**  An asset that contains `text` as a `String`. Get assets from the `Assets` class, via `app.assets` */\r\nclass AssetText extends Asset {\r\n\r\n\r\n        /** The `String` this asset contains */\r\n    public var text : String;\r\n        /** Whether or not this bytes data will load syncronously. Used in `load` only. */\r\n    public var async : Bool = false;\r\n\r\n\r\n        /** Called from `app.assets.text` */\r\n    public function new( _assets:Assets, _info:AssetInfo, ?_async:Bool=false ) {\r\n\r\n        super( _assets, _info );\r\n        type = AssetType.text;\r\n        async = _async;\r\n\r\n    } //new\r\n\r\n        /** Called from `app.assets.text`, or manually, if reloading the asset data at a later point.\r\n            Note this function calls the onload handler in the next frame, so sync code can return. */\r\n    public function load( ?onload:AssetText->Void ) {\r\n\r\n        loaded = false;\r\n            //clear any old data in case\r\n        text = null;\r\n\r\n        var p = assets.lib.io.data_load( info.path, { binary:false });\r\n        p.then(function(data:Uint8Array){\r\n            load_from_string( data.toBytes().toString(), onload );\r\n        });\r\n\r\n    } //load\r\n\r\n    public function load_from_string( _string:String, ?onload:AssetText->Void ) {\r\n\r\n        loaded = false;\r\n        text = _string;\r\n        loaded = true;\r\n\r\n        if(onload != null) {\r\n            onload( this );\r\n        }\r\n\r\n    } //load_from_string\r\n\r\n\r\n} //AssetText\r\n","package snow.assets;\r\n\r\nimport snow.io.IO;\r\nimport snow.types.Types;\r\nimport snow.utils.Libs;\r\n\r\nimport snow.assets.AssetSystem;\r\nimport snow.assets.AssetImage;\r\nimport snow.assets.AssetText;\r\nimport snow.assets.AssetBytes;\r\nimport snow.assets.AssetAudio;\r\n\r\nimport snow.io.typedarray.Uint8Array;\r\n\r\nimport snow.Log.log;\r\nimport snow.Log._debug;\r\nimport snow.Log._verbose;\r\nimport snow.Log._verboser;\r\n\r\n/** The asset system class gives you access to fetching and manipulating assets,\r\n    handling loading files and data in a consistent cross platform way */\r\nclass Assets {\r\n\r\n\r\n        /** The list of assets in the system, added at startup by the `App` class, in the `get_asset_list` function */\r\n    public var list : Map<String, AssetInfo>;\r\n        /** If the assets are not relative to the runtime root path, this value can adjust all asset paths. This is automatically handled and exists to allow control. */\r\n    public var assets_root : String = '';\r\n        /** The manifest file to parse for the asset list. By default, this is set to `manifest` from the build tools but the `App` class can have a custom `get_asset_list` handler use this value. */\r\n    public var manifest_path : String = 'manifest';\r\n        /** The default approach to finding assets, overridable in each get call, this value will be used if the flag is not specified. */\r\n    public var strict : Bool = true;\r\n\r\n        /** access to platform implementation */\r\n    @:noCompletion public var platform : AssetSystem;\r\n        /** access to snow from subsystems */\r\n    @:noCompletion public var lib : Snow;\r\n\r\n\r\n        /** constructed internally, use `app.assets` */\r\n    @:allow(snow.Snow)\r\n    function new( _lib:Snow ) {\r\n\r\n        #if ios\r\n                //This is because of how the files are put into the xcode project\r\n                //for the iOS builds, it stores them inside of /assets to avoid\r\n                //including the root in the project in the Resources/ folder\r\n            assets_root = 'assets/';\r\n        #end\r\n\r\n        lib = _lib;\r\n        list = new Map();\r\n        platform = new AssetSystem(this);\r\n\r\n    } //new\r\n\r\n        /** Add an asset info list to the system */\r\n    public function add( _list:Array<AssetInfo> ) {\r\n\r\n        for(_asset in _list) {\r\n\r\n                //we transform the types by extension for common files.\r\n                //these are just hints anyway, snow won't enforce them.\r\n            var images = [\"psd\", \"bmp\", \"tga\", \"gif\", \"jpg\", \"png\"];\r\n            var sounds = [\"pcm\", \"ogg\", \"wav\"];\r\n\r\n            if( Lambda.has(images, _asset.ext) ) {\r\n                _asset.type = 'image';\r\n            } else if(Lambda.has(sounds, _asset.ext)) {\r\n                _asset.type = 'sound';\r\n            }\r\n\r\n            // lib._debug('/ snow /    added asset ${_asset.id} at ${_asset.path} (${_asset.type}) ');\r\n\r\n            list.set(_asset.id, _asset);\r\n\r\n        } //for each\r\n\r\n    } //add\r\n\r\n        /** Get an asset info for a given id */\r\n    public function get( _id:String ) : AssetInfo {\r\n\r\n        return list.get(_id);\r\n\r\n    } //get\r\n\r\n        /** Check if an asset info exists in the list for a given id. */\r\n    public function listed( _id:String ) : Bool {\r\n\r\n        return list.exists(_id);\r\n\r\n    } //listed\r\n\r\n        /** Check if an asset exists for a given id.\r\n            On web targets, there is no file exists check so unless it is stored in the asset list\r\n            this function will return false specyifying why. */\r\n    public function exists( _id:String, ?_strict:Bool=true ) : Bool {\r\n\r\n        return platform.exists(_id, _strict);\r\n\r\n    } //exists\r\n\r\n\r\n        /** Get the asset path for an asset, adjusted by platform, root etc.\r\n            If it fails to find the asset the id is returned as is with the asset root prefixed. */\r\n    public function path( _id:String ) : String {\r\n\r\n        if( listed(_id) ) {\r\n            return get(_id).path;\r\n        }\r\n\r\n        return assets_root + _id;\r\n\r\n    } //path\r\n\r\n\r\n        /** Get an asset as a `AssetBytes`, data stored as `Uint8Array` used for binary assets. */\r\n    public function bytes( _id:String, ?options:AssetBytesOptions ) : AssetBytes {\r\n\r\n        var _strict = strict;\r\n        var _silent = false;\r\n\r\n        if(options != null) {\r\n            if(options.strict != null) { _strict = options.strict; }\r\n            if(options.silent != null) { _silent = options.silent; }\r\n        }\r\n\r\n        if(exists(_id, _strict)) {\r\n\r\n            var info : AssetInfo = get(_id);\r\n\r\n            if(info == null) {\r\n                info = info_from_id(_id, 'bytes');\r\n            }\r\n\r\n            var asset = new AssetBytes( this, info, options != null ? options.async : null );\r\n                asset.load( options != null ? options.onload : null );\r\n\r\n            return asset;\r\n\r\n        } else { //exists\r\n            exists_error(_id, _silent);\r\n        }\r\n\r\n        return null;\r\n\r\n    } //bytes\r\n\r\n        /** Get an asset as a `AssetText`, data stored as `String`, used for text based assets */\r\n    public function text( _id:String, ?options:AssetTextOptions ) : AssetText {\r\n\r\n        var _strict = strict;\r\n        var _silent = false;\r\n\r\n        if(options != null) {\r\n            if(options.strict != null) { _strict = options.strict; }\r\n            if(options.silent != null) { _silent = options.silent; }\r\n        }\r\n\r\n        if(exists(_id, _strict)) {\r\n\r\n            var info : AssetInfo = get(_id);\r\n\r\n            if(info == null) {\r\n                info = info_from_id(_id, 'text');\r\n            }\r\n\r\n            var asset = new AssetText( this, info, options != null ? options.async : null );\r\n                asset.load( options != null ? options.onload : null );\r\n\r\n            return asset;\r\n\r\n        } else { //exists\r\n            exists_error(_id, _silent);\r\n        }\r\n\r\n        return null;\r\n\r\n    } //text\r\n\r\n        /** Get an asset as a `AssetImage`, data stored as `ImageInfo`, used for image files */\r\n    public function image( _id:String, ?options:AssetImageOptions ) : AssetImage {\r\n\r\n        var _strict = strict;\r\n        var _silent = false;\r\n        var _from_bytes = false;\r\n\r\n        if(options != null) {\r\n            if(options.strict != null) { _strict = options.strict; }\r\n            if(options.silent != null) { _silent = options.silent; }\r\n\r\n            _from_bytes = options.bytes != null;\r\n        }\r\n\r\n        if(exists(_id, _strict) || _from_bytes) {\r\n\r\n            if(options == null) {\r\n                options = { components : 4 };\r\n            }\r\n\r\n            var info : AssetInfo = get(_id);\r\n\r\n            if(info == null) {\r\n                info = info_from_id(_id, 'image');\r\n            }\r\n\r\n            var comp = (options.components == null) ? 4 : options.components;\r\n\r\n            var asset = new AssetImage( this, info, comp );\r\n\r\n            if(!_from_bytes) {\r\n                asset.load( options.onload );\r\n            } else {\r\n                asset.load_from_bytes( options.bytes, options.onload );\r\n            }\r\n\r\n            return asset;\r\n\r\n        } else { //exists\r\n            exists_error(_id, _silent);\r\n        }\r\n\r\n        return null;\r\n\r\n    } //image\r\n\r\n        /** Get an asset as a `AssetAudio`, used for audio files */\r\n    public function audio( _id:String, ?options:AssetAudioOptions ) : AssetAudio {\r\n\r\n        var _strict = strict;\r\n        var _silent = false;\r\n        var _from_bytes = false;\r\n\r\n        if(options != null) {\r\n            if(options.strict != null) { _strict = options.strict; }\r\n            if(options.silent != null) { _silent = options.silent; }\r\n\r\n            _from_bytes = options.bytes != null;\r\n        }\r\n\r\n        if(exists(_id, _strict) || _from_bytes) {\r\n\r\n            var info : AssetInfo = get(_id);\r\n\r\n            if(info == null) {\r\n                info = info_from_id(_id, 'audio');\r\n            }\r\n\r\n                //handle default options.\r\n                //type defaults to extension and\r\n                //load is true for loading the whole now,\r\n                //streaming sounds request false etc.\r\n            if(options == null) {\r\n                options = { type:info.ext, load:true }\r\n            } else {\r\n                if(options.type == null || options.type == \"\") {\r\n                    options.type = info.ext;\r\n                }\r\n            }\r\n\r\n            var _type : AudioFormatType = AudioFormatType.unknown;\r\n            switch(options.type) {\r\n                case 'wav': {\r\n                    _type = AudioFormatType.wav;\r\n                }\r\n                case 'ogg':{\r\n                    _type = AudioFormatType.ogg;\r\n                }\r\n                case 'pcm':{\r\n                    _type = AudioFormatType.pcm;\r\n                }\r\n                default: {\r\n                    load_error(_id, 'unrecognized audio format');\r\n                    return null;\r\n                }\r\n            } //options.type\r\n\r\n            var asset = new AssetAudio( this, info, _type, options.load );\r\n\r\n            if(!_from_bytes) {\r\n                asset.load( options != null ? options.onload : null );\r\n            } else {\r\n                    //options has to be non-null for bytes, so ignore check on options.onload\r\n                asset.load_from_bytes( options.bytes, _type, options.onload );\r\n            }\r\n\r\n            return asset;\r\n\r\n        } else {\r\n            exists_error(_id, _silent);\r\n        }\r\n\r\n        return null;\r\n\r\n    } //audio\r\n\r\n//Internal API\r\n\r\n    @:noCompletion public function info_from_id(_id:String, _type:String) : AssetInfo {\r\n        return {\r\n            id : _id,\r\n            path : _id,\r\n            ext : haxe.io.Path.extension(_id),\r\n            type : _type\r\n        }\r\n    } //info_from_id\r\n\r\n        //this is separate so we can defer the behavior later\r\n    function exists_error( _id:String, _silent:Bool=false ) {\r\n        if(!_silent) log('not found \"$_id\"' );\r\n    } //exists_error\r\n\r\n    function load_error( _id:String, ?reason:String = \"unknown\", _silent:Bool=false ) {\r\n        if(!_silent) log('found \"$_id\" but it failed to load ($reason)' );\r\n    } //load_error\r\n\r\n\r\n} //Assets\r\n","package snow.audio;\r\n\r\nimport haxe.ds.BalancedTree;\r\nimport snow.types.Types;\r\n\r\nimport snow.audio.Sound;\r\nimport snow.audio.AudioSystem;\r\n\r\nimport snow.assets.Assets;\r\nimport snow.assets.AssetAudio;\r\n\r\nimport snow.Log.log;\r\nimport snow.Log._debug;\r\nimport snow.Log._verbose;\r\nimport snow.Log._verboser;\r\n\r\n\r\nclass Audio {\r\n\r\n        /** access to platform specific implementation */\r\n    public var platform : AudioSystem;\r\n        /** Set to false to stop any and all processing in the audio system */\r\n    public var active : Bool = false;\r\n\r\n        /** for external access to the library by the systems */\r\n    @:noCompletion public var lib : Snow;\r\n        /** for mapping native handles to Sound instances. Use the `app.audio` to manipulate preferably. */\r\n    @:noCompletion public var handles : AudioHandleMap;\r\n        /** for mapping named sounds to Sound instances. Use the `app.audio` to manipulate preferably. */\r\n    @:noCompletion public var sound_list : Map<String, Sound>;\r\n        /** for mapping named streams to SoundStream instances. Use the `app.audio` to manipulate preferably. */\r\n    @:noCompletion public var stream_list : Map<String, SoundStream>;\r\n\r\n        /** constructed internally, use `app.audio` */\r\n    @:allow(snow.Snow)\r\n    function new( _lib:Snow ) {\r\n\r\n        lib = _lib;\r\n\r\n        platform = new AudioSystem(this, lib);\r\n\r\n        platform.init();\r\n\r\n        sound_list = new Map();\r\n        stream_list = new Map();\r\n        handles = new AudioHandleMap();\r\n\r\n        active = true;\r\n\r\n    } //new\r\n\r\n\r\n//Public API\r\n\r\n\r\n        /** Create a sound for playing. If no name is given, a unique id is assigned. Use the sound instance or the public api by name. */\r\n    public function create( _id:String, ?_name:String = '', ?streaming:Bool = false ) : Sound {\r\n\r\n        if(_name == '') {\r\n            _name = lib.uniqueid;\r\n        } //_name\r\n\r\n            //We always return a valid sound object, so code will be reliable\r\n            //even if the sound is unable to play etc\r\n\r\n        var sound : Sound = null;\r\n\r\n            //try loading the sound asset, only reading the entire file if its not streaming,\r\n            //this on load handler is called in the next frame if the load is sync, so that,\r\n            //the return code happens immediately giving back the instance.\r\n        var _asset = lib.assets.audio( _id, { load:!streaming, onload:function(asset:AssetAudio) {\r\n\r\n                    if(asset != null && sound != null) {\r\n                        handles.set(asset.audio.handle, sound);\r\n                        sound.info = asset.audio;\r\n                    }\r\n\r\n                } //onload\r\n            } //options\r\n        ); //audio\r\n\r\n\r\n            if(!streaming) {\r\n\r\n                sound = new Sound(this, _name);\r\n\r\n            } else {\r\n\r\n                var sound_stream = new SoundStream(this, _name);\r\n                    //we store the streams in a separate list\r\n                    //so that they don't get bogged down by\r\n                    //lots of sound effects. This means you have\r\n                    //to remove it if not using the audio wrapper routes to cleanup\r\n                stream_list.set(_name, sound_stream);\r\n                    //set the higher typed one for return\r\n                sound = sound_stream;\r\n\r\n            } //streaming\r\n\r\n                //store for later\r\n            sound_list.set(_name, sound);\r\n\r\n        return sound;\r\n\r\n    } //create\r\n\r\n        /** Create a sound for playing from bytes. If no name is given, a unique id is assigned. Use the sound instance or the public api by name. \r\n            Currently only non-streamed sounds and is a wip implementation fixes. */\r\n    @:noCompletion\r\n    public function create_from_bytes( _id:String, ?_name:String = '', bytes:snow.io.typedarray.Uint8Array ) : Sound {\r\n\r\n        if(_name == '') {\r\n            _name = lib.uniqueid;\r\n        } //_name\r\n\r\n            //We always return a valid sound object, so code will be reliable\r\n            //even if the sound is unable to play etc\r\n\r\n        var sound : Sound = new Sound(this, _name);\r\n            //store for later\r\n        sound_list.set(_name, sound);\r\n\r\n            //try loading the sound asset\r\n        var _asset = lib.assets.audio( _id, { load:true, bytes:bytes, onload:function(asset:AssetAudio) {\r\n\r\n                    if(asset != null && sound != null) {\r\n                        handles.set(asset.audio.handle, sound);\r\n                        sound.info = asset.audio;\r\n                    }\r\n\r\n                } //onload\r\n            } //options\r\n        ); //audio\r\n\r\n        return sound;\r\n\r\n    } //create_from_bytes\r\n\r\n        /** Destroy a sound instance by name. Use sound_instance.destroy() if you have an instance already. */\r\n    public function uncreate( _name:String ) {\r\n\r\n        var _sound = sound_list.get(_name);\r\n\r\n        if(_sound == null) {\r\n            log('can\\'t find sound, unable to uncreate, use create first: ${_name}');\r\n        } //_sound\r\n\r\n            //kill the sound\r\n        _sound.destroy();\r\n\r\n    } //uncreate\r\n\r\n        /** Listen for a event on a named sound. `load` and `end` are valid events. */\r\n    public function on( _name:String, _event:String, _handler:Sound->Void ) {\r\n        var sound = get(_name);\r\n        if(sound != null) {\r\n            sound.on(_event, _handler);\r\n        }\r\n    } //on\r\n\r\n        /** Remove a listener for a event on a named sound. see `on` */\r\n    public function off( _name:String, _event:String, _handler:Sound->Void ) {\r\n        var sound = get(_name);\r\n        if(sound != null) {\r\n            sound.off(_event, _handler);\r\n        }\r\n    } //off\r\n\r\n        /** Get a sound instance by name */\r\n    public function get( _name:String ) : Sound {\r\n\r\n        var _sound = sound_list.get(_name);\r\n\r\n        if(_sound == null) {\r\n            log('sound not found, use create first: ${_name}');\r\n        } //_sound\r\n\r\n        return _sound;\r\n\r\n    } //get\r\n\r\n        /** Get/Set the volume of a sound instance by name.\r\n            Leave the second argument blank to return the current value. */\r\n    public function volume( _name:String, ?_volume:Float ) : Float {\r\n        var sound = get(_name);\r\n        if(sound != null) {\r\n            if(_volume != null) {\r\n                return sound.volume = _volume;\r\n            } else {\r\n                return sound.volume;\r\n            }\r\n        }\r\n        return 0;\r\n    } //volume\r\n\r\n        /** Get/Set the pan of a sound instance by name\r\n            Leave the second argument blank to return the current value.  */\r\n    public function pan( _name:String, ?_pan:Float ) {\r\n        var sound = get(_name);\r\n        if(sound != null) {\r\n            if(_pan != null) {\r\n                return sound.pan = _pan;\r\n            } else {\r\n                return sound.pan;\r\n            }\r\n        }\r\n        return 0;\r\n    } //pan\r\n\r\n        /** Get/Set the pitch of a sound instance by name\r\n            Leave the second argument blank to return the current value.  */\r\n    public function pitch( _name:String, ?_pitch:Float ) {\r\n        var sound = get(_name);\r\n        if(sound != null) {\r\n            if(_pitch != null) {\r\n                return sound.pitch = _pitch;\r\n            } else {\r\n                return sound.pitch;\r\n            }\r\n        }\r\n        return 0;\r\n    } //pitch\r\n\r\n        /** Get/Set the position **in seconds** of a sound instance by name.\r\n            Leave the second argument blank to return the current value.  */\r\n    public function position( _name:String, ?_position:Float ) {\r\n        var sound = get(_name);\r\n        if(sound != null) {\r\n            if(_position != null) {\r\n                return sound.position = _position;\r\n            } else {\r\n                return sound.position;\r\n            }\r\n        }\r\n        return 0;\r\n    } //position\r\n\r\n        /** Get the duration of a sound instance by name.\r\n            Duration is set from the sound instance, so it is read only. */\r\n    public function duration( _name:String ) {\r\n        var sound = get(_name);\r\n        if(sound != null) {\r\n            return sound.duration;\r\n        }\r\n        return 0;\r\n    } //duration\r\n\r\n        /** Play a sound instance by name */\r\n    public function play(_name:String) {\r\n\r\n        if(!active) {\r\n            return;\r\n        }\r\n\r\n        var sound = get(_name);\r\n        if(sound != null) {\r\n            sound.play();\r\n        }\r\n    } //play\r\n\r\n        /** Loop a sound instance by name, indefinitely. Use stop to end it */\r\n    public function loop(_name:String) {\r\n\r\n        if(!active) {\r\n            return;\r\n        }\r\n\r\n        var sound = get(_name);\r\n        if(sound != null) {\r\n            sound.loop();\r\n        }\r\n    } //loop\r\n\r\n        /** Pause a sound instance by name */\r\n    public function pause(_name:String) {\r\n\r\n        if(!active) {\r\n            return;\r\n        }\r\n\r\n        var sound = get(_name);\r\n        if(sound != null) {\r\n            sound.pause();\r\n        }\r\n    } //pause\r\n\r\n        /** Stop a sound instance by name */\r\n    public function stop(_name:String) {\r\n\r\n        if(!active) {\r\n            return;\r\n        }\r\n\r\n        var sound = get(_name);\r\n        if(sound != null) {\r\n            sound.stop();\r\n        }\r\n    } //stop\r\n\r\n        /** Toggle a sound instance by name, pausing the sound */\r\n    public function toggle(_name:String) {\r\n\r\n        if(!active) {\r\n            return;\r\n        }\r\n\r\n        var sound = get(_name);\r\n        if(sound != null) {\r\n            sound.toggle();\r\n        }\r\n    } //toggle\r\n\r\n\r\n//Internal API\r\n\r\n        /** Stop managing a sound instance */\r\n    @:noCompletion public function kill( _sound:Sound ) {\r\n\r\n        if(_sound == null) return;\r\n\r\n        if(_sound.info != null) {\r\n            handles.remove(_sound.info.handle);\r\n        }\r\n\r\n        sound_list.remove(_sound.name);\r\n        stream_list.remove(_sound.name);\r\n\r\n    } //kill\r\n\r\n    @:noCompletion public function suspend() {\r\n\r\n        if(!active) {\r\n            return;\r\n        }\r\n\r\n        log(\"suspending sound context\");\r\n\r\n        active = false;\r\n\r\n        for(sound in stream_list) {\r\n            sound.internal_pause();\r\n        }\r\n\r\n        platform.suspend();\r\n\r\n    } //suspend\r\n\r\n    @:noCompletion public function resume() {\r\n\r\n        if(active) {\r\n            return;\r\n        }\r\n\r\n        log(\"resuming sound context\");\r\n\r\n        active = true;\r\n\r\n        platform.resume();\r\n\r\n        for(sound in stream_list) {\r\n            sound.internal_play();\r\n        }\r\n\r\n    } //resume\r\n\r\n\r\n        /** Called by Snow when a system event is dispatched */\r\n    @:allow(snow.Snow)\r\n    function on_event( _event:SystemEvent ) {\r\n\r\n        if(_event.type == SystemEventType.app_willenterbackground) {\r\n            suspend();\r\n        } else if(_event.type == SystemEventType.app_willenterforeground) {\r\n            resume();\r\n        }\r\n\r\n        #if mobile\r\n\r\n            if(_event.type == SystemEventType.window) {\r\n                switch(_event.window.type) {\r\n                    case WindowEventType.focus_lost:\r\n                        suspend();\r\n                    case WindowEventType.focus_gained:\r\n                        resume();\r\n                    default:\r\n                }\r\n            } //_event.type == window\r\n\r\n        #end //mobile\r\n\r\n    } //on_event\r\n\r\n        /** Called by Snow, cleans up sounds/system */\r\n    @:allow(snow.Snow)\r\n    function destroy() {\r\n\r\n        active = false;\r\n\r\n        for(sound in sound_list) {\r\n            sound.destroy();\r\n        }\r\n\r\n        platform.destroy();\r\n\r\n    } //destroy\r\n\r\n        /** Called by Snow, update any sounds / streams */\r\n    @:allow(snow.Snow)\r\n    function update() {\r\n\r\n        if(!active) {\r\n            return;\r\n        }\r\n\r\n        for(_sound in sound_list) {\r\n            if(_sound.playing) {\r\n                _sound.internal_update();\r\n            }\r\n        }\r\n\r\n        platform.process();\r\n\r\n    } //update\r\n\r\n\r\n} //Audio\r\n\r\n\r\n#if snow_web\r\n\r\n    private typedef AudioHandleMap = Map<AudioHandle, Sound>;\r\n\r\n#else\r\n\r\n    private class AudioHandleMap extends haxe.ds.BalancedTree<AudioHandle,Sound> {\r\n\r\n        override function compare(k1:AudioHandle, k2:AudioHandle) {\r\n            if(k1 == null) return 1;\r\n            if(k2 == null) return 1;\r\n            if(k1 == k2) return 0;\r\n            if(k1 < k2) return -1;\r\n            return 1;\r\n        }\r\n\r\n    } //AudioHandleMap\r\n\r\n#end\r\n","package snow.audio;\r\n\r\nimport snow.audio.Audio;\r\nimport snow.Snow;\r\n\r\nimport snow.utils.AbstractClass;\r\n\r\n#if snow_web\r\n\r\n    #if snow_audio_howlerjs\r\n        @:noCompletion typedef AudioSystem = snow.platform.web.audio.howlerjs.AudioSystem;\r\n    #else\r\n        @:noCompletion typedef AudioSystem = snow.platform.web.audio.AudioSystem;\r\n    #end\r\n\r\n#else\r\n\r\n    #if snow_audio_openal\r\n        @:noCompletion typedef AudioSystem = snow.platform.native.audio.openal.AudioSystem;\r\n    #else\r\n        @:noCompletion typedef AudioSystem = snow.platform.native.audio.AudioSystem;\r\n    #end //snow_audio_openal\r\n\r\n#end\r\n\r\n\r\n/** Internal audio system definition, interact with this system through `snow.Audio`, not directly */\r\n@:noCompletion class AudioSystemBinding implements AbstractClass {\r\n\r\n    public var manager : Audio;\r\n    public var lib : Snow;\r\n\r\n        /** Called by the audio manager when initiating this system*/\r\n    public function init();\r\n        /** Called by the audio manager when updating this system*/\r\n    public function process();\r\n        /** Called by the audio manager when destroying this system*/\r\n    public function destroy();\r\n        /** Called by the audio manager when suspending this system*/\r\n    public function suspend();\r\n        /** Called by the audio manager when resuming this system*/\r\n    public function resume();\r\n\r\n\r\n} //AudioSystem","package snow.audio;\r\n\r\nimport snow.audio.Audio;\r\nimport snow.types.Types;\r\n\r\nimport snow.utils.AbstractClass;\r\n\r\nimport snow.Log.log;\r\nimport snow.Log._debug;\r\nimport snow.Log._verbose;\r\nimport snow.Log._verboser;\r\n\r\n#if snow_web\r\n\r\n    #if snow_audio_howlerjs\r\n        typedef Sound = snow.platform.web.audio.howlerjs.Sound;\r\n        typedef SoundStream = snow.platform.web.audio.howlerjs.SoundStream;\r\n    #else\r\n        typedef Sound = snow.platform.web.audio.Sound;\r\n        typedef SoundStream = snow.platform.web.audio.SoundStream;\r\n    #end\r\n\r\n#else\r\n\r\n    #if snow_audio_openal\r\n        typedef Sound = snow.platform.native.audio.openal.Sound;\r\n        typedef SoundStream = snow.platform.native.audio.openal.SoundStream;\r\n    #else\r\n        typedef Sound = snow.platform.native.audio.Sound;\r\n        typedef SoundStream = snow.platform.native.audio.SoundStream;\r\n    #end\r\n\r\n#end\r\n\r\n\r\n\r\n//The base class for a sound or sound stream instance.\r\n//This can't be abstract like the other bindings due to so much shared code,\r\n//it's cleaner to keep this all in here instead\r\n\r\n@:noCompletion class SoundBinding {\r\n\r\n        /** The `Audio` system handling this sound */\r\n    public var manager : Audio;\r\n        /** The name of this sound */\r\n    public var name : String = '';\r\n\r\n        /** If the sound is playing */\r\n    public var playing : Bool = false;\r\n        /** If the sound is paused */\r\n    public var paused : Bool = false;\r\n        /** If the sound is loaded or ready to use */\r\n    public var loaded : Bool = false;\r\n        /** If the sound is a stream source */\r\n    public var is_stream : Bool = false;\r\n\r\n        /** The `AudioInfo` this sound is created from. When assigning this it will clean up and set itself to this info instead. */\r\n    @:isVar public var info     (get,set) : AudioInfo;\r\n        /** The pitch of this sound */\r\n    @:isVar public var pitch    (get,set) : Float = 1.0;\r\n        /** The volume of this sound */\r\n    @:isVar public var volume   (get,set) : Float = 1.0;\r\n        /** The pan of this sound. Pan only logically works on mono sounds, and is by default 2D sounds  */\r\n    @:isVar public var pan      (get,set) : Float = 0.0;\r\n        /** If the sound is looping or not. Use `loop()` to change this. */\r\n    @:isVar public var looping  (get,set) : Bool = false;\r\n        /** The current playback position of this sound in `seconds` */\r\n    @:isVar public var position  (get,set) : Float = 0.0;\r\n        /** The duration of this sound, in `seconds` */\r\n    @:isVar public var duration (get,never) : Float = 0.0;\r\n\r\n\r\n    @:noCompletion public function emit(_event:String) {\r\n        switch(_event) {\r\n            case 'end':\r\n                do_onend();\r\n            case 'load':\r\n                do_onload();\r\n            default:\r\n                log('no event {$_event}');\r\n        } //_event\r\n    } //emit\r\n\r\n    public function on(_event:String, _handler:Sound->Void) {\r\n        switch(_event) {\r\n            case 'end':\r\n                onend_list.push(_handler);\r\n            case 'load':\r\n                add_onload(_handler);\r\n            default:\r\n                log('no event {$_event}');\r\n        } //_event\r\n    } //emit\r\n\r\n    public function off(_event:String, _handler:Sound->Void) {\r\n        switch(_event) {\r\n            case 'end':\r\n                onend_list.remove(_handler);\r\n            case 'load':\r\n                onload_list.remove(_handler);\r\n            default:\r\n                log('no event {$_event}');\r\n        } //_event\r\n    } //off\r\n\r\n    var onload_list : Array<Sound->Void>;\r\n    var onend_list : Array<Sound->Void>;\r\n\r\n//Construct\r\n\r\n    public function new( _manager:Audio, _name:String ) {\r\n\r\n        name = _name;\r\n        manager = _manager;\r\n        onload_list = [];\r\n        onend_list = [];\r\n\r\n    } //new\r\n\r\n//Abstract functions implemented in concrete platform level\r\n\r\n        /** Play this sound */\r\n    public function play() {}\r\n        /** Loop this sound */\r\n    public function loop() {}\r\n        /** Stop this sound */\r\n    public function stop() {}\r\n        /** Pause this sound */\r\n    public function pause() {}\r\n        /** Destroy this sound and it's data. */\r\n    public function destroy() {}\r\n\r\n// Internal system events\r\n\r\n    @:noCompletion public function internal_update() {}\r\n    @:noCompletion public function internal_play()  {}\r\n    @:noCompletion public function internal_loop() {}\r\n    @:noCompletion public function internal_stop() {}\r\n    @:noCompletion public function internal_pause() {}\r\n\r\n//Shared implementations\r\n\r\n        /** Toggle this sound */\r\n    public function toggle() {\r\n\r\n        playing = !playing;\r\n\r\n        if(playing) {\r\n            if(looping) {\r\n                loop();\r\n            } else {\r\n                play();\r\n            }\r\n        } else {\r\n            pause();\r\n        }\r\n\r\n    } //toggle\r\n\r\n//Getters/setters\r\n\r\n    function get_info() : AudioInfo {\r\n        return info;\r\n    }\r\n\r\n    function set_info( _info:AudioInfo ) : AudioInfo {\r\n        return info = _info;\r\n    }\r\n\r\n    function get_pan() : Float {\r\n        return pan;\r\n    } //get_pan\r\n\r\n    function get_pitch() : Float {\r\n        return pitch;\r\n    } //get_pitch\r\n\r\n    function get_volume() : Float {\r\n        return volume;\r\n    } //get_volume\r\n\r\n    function get_looping() : Bool {\r\n        return looping;\r\n    } //get_looping\r\n\r\n    function get_position() : Float {\r\n        return position;\r\n    } //get_position\r\n\r\n        //overridden in platform concrete\r\n    function get_duration() : Float {\r\n        return 0;\r\n    } //get_duration\r\n\r\n    function set_pan( _pan:Float ) : Float {\r\n        return pan = _pan;\r\n    } //set_pan\r\n\r\n    function set_pitch( _pitch:Float ) : Float {\r\n        return pitch = _pitch;\r\n    } //set_pitch\r\n\r\n    function set_volume( _volume:Float ) : Float {\r\n        return volume = _volume;\r\n    } //set_volume\r\n\r\n    function set_position( _position:Float ) : Float {\r\n        return position = _position;\r\n    } //set_position\r\n\r\n    function set_looping( _looping:Bool ) : Bool {\r\n        return looping = _looping;\r\n    } //set_looping\r\n\r\n//Internal API\r\n\r\n    @:noCompletion public function do_onload() {\r\n\r\n        for(_f in onload_list) {\r\n            _f(cast this);\r\n        }\r\n\r\n        onload_list = null;\r\n        onload_list = [];\r\n\r\n    } //do_onload\r\n\r\n    @:noCompletion public function do_onend() {\r\n\r\n        for(_f in onend_list) {\r\n            _f(cast this);\r\n        }\r\n\r\n    } //onend_list\r\n\r\n    function add_onload( _onload:Sound->Void ) {\r\n\r\n            //too late, just call immediately\r\n        if(loaded) {\r\n            _onload(cast this);\r\n        } else {\r\n            onload_list.push(_onload);\r\n        }\r\n\r\n        return _onload;\r\n\r\n    } //add_onload\r\n} //Sound\r\n","package snow.input;\r\n\r\nimport snow.types.Types;\r\nimport snow.input.InputSystem;\r\nimport snow.window.Window;\r\n\r\n\r\ntypedef MapIntBool = Map<Int, Bool>;\r\ntypedef MapIntFloat = Map<Int, Float>;\r\n\r\n/** Internal input system, accessed via `app.input` */\r\nclass Input {\r\n\r\n        /** access to snow from subsystems */\r\n    @:noCompletion public var lib : Snow;\r\n        /** access to platform implementation */\r\n    @:noCompletion public var platform : InputSystem;\r\n\r\n        //this is the keycode based flags for keypressed/keyreleased/keydown\r\n    var key_code_down : MapIntBool;\r\n    var key_code_pressed : MapIntBool;\r\n    var key_code_released : MapIntBool;\r\n\r\n        //this is the scancode based flags for scanpressed/scanreleased/scandown\r\n    var scan_code_down : MapIntBool;\r\n    var scan_code_pressed : MapIntBool;\r\n    var scan_code_released : MapIntBool;\r\n\r\n        //this is the mouse button based flags for mousepressed/mousereleased/mousedown\r\n    var mouse_button_down : MapIntBool;\r\n    var mouse_button_pressed : MapIntBool;\r\n    var mouse_button_released : MapIntBool;\r\n\r\n        //this is the gamepad button based flags for gamepadpressed/gamepadreleased/gamepaddown\r\n    var gamepad_button_down : Map<Int, MapIntBool >;\r\n    var gamepad_button_pressed : Map<Int, MapIntBool >;\r\n    var gamepad_button_released : Map<Int, MapIntBool >;\r\n    var gamepad_axis_values : Map<Int, MapIntFloat >;\r\n\r\n        //map of the touches currently down,\r\n        //:todo:wip:\r\n    @:noCompletion public var touch_count : Int = 0;\r\n    @:noCompletion public var touches_down : MapIntBool;\r\n\r\n        /** constructed internally, use `app.input` */\r\n    @:allow(snow.Snow)\r\n    function new( _lib:Snow ) {\r\n\r\n        lib = _lib;\r\n\r\n        platform = new InputSystem(this, lib);\r\n\r\n        platform.init();\r\n\r\n        //keys\r\n\r\n            key_code_pressed = new Map();\r\n            key_code_down = new Map();\r\n            key_code_released = new Map();\r\n\r\n            scan_code_pressed = new Map();\r\n            scan_code_down = new Map();\r\n            scan_code_released = new Map();\r\n\r\n        //mouse\r\n\r\n            mouse_button_pressed = new Map();\r\n            mouse_button_down = new Map();\r\n            mouse_button_released = new Map();\r\n\r\n        //gamepad\r\n\r\n            gamepad_button_pressed = new Map();\r\n            gamepad_button_down = new Map();\r\n            gamepad_button_released = new Map();\r\n            gamepad_axis_values = new Map();\r\n\r\n        //touch\r\n\r\n            touches_down = new Map();\r\n\r\n    } //new\r\n\r\n\r\n//Public facing API\r\n\r\n\r\n    //Key immediate style access\r\n\r\n            /** returns true if the `Key` value was pressed in the latest frame */\r\n        public function keypressed( _code:Int ) : Bool {\r\n            return key_code_pressed.exists(_code);\r\n        } //keypressed\r\n\r\n            /** returns true if the `Key` value was released in the latest frame */\r\n        public function keyreleased( _code:Int ) : Bool {\r\n            return key_code_released.exists(_code);\r\n        } //keyreleased\r\n\r\n            /** returns true if the `Key` value is down at the time of calling this */\r\n        public function keydown( _code:Int ) : Bool {\r\n           return key_code_down.exists(_code);\r\n        } //keydown\r\n\r\n            /** returns true if the `Scan` value was pressed in the latest frame */\r\n        public function scanpressed( _code:Int ) : Bool {\r\n            return scan_code_pressed.exists(_code);\r\n        } //scanpressed\r\n\r\n            /** returns true if the `Scan` value was released in the latest frame */\r\n        public function scanreleased( _code:Int ) : Bool {\r\n            return scan_code_released.exists(_code);\r\n        } //scanreleased\r\n\r\n            /** returns true if the `Scan` value is down at the time of calling this */\r\n        public function scandown( _code:Int ) : Bool {\r\n           return scan_code_down.exists(_code);\r\n        } //keydown\r\n\r\n    //Mouse immediate style access\r\n\r\n            /** returns true if the mouse button was pressed in the latest frame */\r\n        public function mousepressed( _button:Int ) : Bool {\r\n            return mouse_button_pressed.exists(_button);\r\n        } //keypressed\r\n\r\n            /** returns true if the mouse button was released in the latest frame */\r\n        public function mousereleased( _button:Int ) : Bool {\r\n            return mouse_button_released.exists(_button);\r\n        } //mousereleased\r\n\r\n            /** returns true if the mouse button value is down at the time of calling this */\r\n        public function mousedown( _button:Int ) : Bool {\r\n           return mouse_button_down.exists(_button);\r\n        } //mousedown\r\n\r\n    //Gamepad immediate style access\r\n\r\n            /** returns true if the mouse button was pressed in the latest frame */\r\n        public function gamepadpressed( _gamepad:Int, _button:Int ) : Bool {\r\n\r\n            var _gamepad_state = gamepad_button_pressed.get(_gamepad);\r\n            return _gamepad_state != null ? _gamepad_state.exists(_button) : false;\r\n\r\n        } //keypressed\r\n\r\n            /** returns true if the gamepad button was released in the latest frame */\r\n        public function gamepadreleased( _gamepad:Int, _button:Int ) : Bool {\r\n\r\n            var _gamepad_state = gamepad_button_released.get(_gamepad);\r\n            return _gamepad_state != null ? _gamepad_state.exists(_button) : false;\r\n\r\n        } //gamepadreleased\r\n\r\n            /** returns true if the gamepad button value is down at the time of calling this */\r\n        public function gamepaddown( _gamepad:Int, _button:Int ) : Bool {\r\n\r\n           var _gamepad_state = gamepad_button_down.get(_gamepad);\r\n            return _gamepad_state != null ? _gamepad_state.exists(_button) : false;\r\n\r\n        } //gamepaddown\r\n\r\n            /** returns true if the gamepad button value is down at the time of calling this */\r\n        public function gamepadaxis( _gamepad:Int, _axis:Int ) : Float {\r\n\r\n            var _gamepad_state = gamepad_axis_values.get(_gamepad);\r\n            if(_gamepad_state != null) {\r\n                if(_gamepad_state.exists(_axis)) {\r\n                    return _gamepad_state.get(_axis);\r\n                }\r\n            }\r\n\r\n            return 0;\r\n\r\n        } //gamepaddown\r\n\r\n        /** manually dispatch a key down event through the system, delivered to the app handlers, internal and external */\r\n    public function dispatch_key_down_event( keycode:Int, scancode:Int, repeat:Bool, mod:ModState, timestamp:Float, window_id:Int ) {\r\n\r\n            //only do the realtime flags if not key repeat\r\n        if(!repeat) {\r\n                //flag the key as pressed, but unprocessed (false)\r\n            key_code_pressed.set(keycode, false);\r\n                //flag it as down, because keyup removes it\r\n            key_code_down.set(keycode, true);\r\n                //flag the scan as pressed, but unprocessed (false)\r\n            scan_code_pressed.set(scancode, false);\r\n                //flag it as down, because keyup removes it\r\n            scan_code_down.set(scancode, true);\r\n        }\r\n\r\n            //forward the event\r\n        lib.host.onkeydown(keycode, scancode, repeat, mod, timestamp, window_id);\r\n\r\n    } //dispatch_key_down_event\r\n\r\n        /** manually dispatch a key up event through the system, delivered to the app handlers, internal and external */\r\n    public function dispatch_key_up_event( keycode:Int, scancode:Int, repeat:Bool, mod:ModState, timestamp:Float, window_id:Int ) {\r\n\r\n            //flag it as released but unprocessed\r\n        key_code_released.set(keycode, false);\r\n            //remove the down flag\r\n        key_code_down.remove(keycode);\r\n\r\n            //flag it as released but unprocessed\r\n        scan_code_released.set(scancode, false);\r\n            //remove the down flag\r\n        scan_code_down.remove(scancode);\r\n\r\n\r\n            //dispatch the event\r\n        lib.host.onkeyup(keycode, scancode, repeat, mod, timestamp, window_id);\r\n\r\n    } //dispatch_key_up_event\r\n\r\n        /** manually dispatch a text event through the system, delivered to the app handlers, internal and external */\r\n    public function dispatch_text_event( text:String, start:Int, length:Int, type:TextEventType, timestamp:Float, window_id:Int ) {\r\n\r\n        lib.host.ontextinput( text, start, length, type, timestamp, window_id );\r\n\r\n    } //dispatch_text_event\r\n\r\n\r\n        /** manually dispatch a mouse move event through the system, delivered to the app handlers, internal and external */\r\n    public function dispatch_mouse_move_event( x:Int, y:Int, xrel:Int, yrel:Int, timestamp:Float, window_id:Int ) {\r\n\r\n        lib.host.onmousemove( x, y, xrel, yrel, timestamp, window_id );\r\n\r\n    } //dispatch_mouse_move_event\r\n\r\n        /** manually dispatch a mouse button down event through the system, delivered to the app handlers, internal and external */\r\n    public function dispatch_mouse_down_event( x:Int, y:Int, button:Int, timestamp:Float, window_id:Int ) {\r\n\r\n            //flag the button as pressed, but unprocessed (false)\r\n        mouse_button_pressed.set(button, false);\r\n            //flag it as down, because mouseup removes it\r\n        mouse_button_down.set(button, true);\r\n\r\n\r\n        lib.host.onmousedown( x, y, button, timestamp, window_id );\r\n\r\n    } //dispatch_mouse_down_event\r\n\r\n        /** manually dispatch a mouse button up event through the system, delivered to the app handlers, internal and external */\r\n    public function dispatch_mouse_up_event( x:Int, y:Int, button:Int, timestamp:Float, window_id:Int ) {\r\n\r\n            //flag it as released but unprocessed\r\n        mouse_button_released.set(button, false);\r\n            //remove the down flag\r\n        mouse_button_down.remove(button);\r\n\r\n\r\n        lib.host.onmouseup( x, y, button, timestamp, window_id );\r\n\r\n    } //dispatch_mouse_up_event\r\n\r\n        /** manually dispatch a mouse wheel event through the system, delivered to the app handlers, internal and external */\r\n    public function dispatch_mouse_wheel_event( x:Int, y:Int, timestamp:Float, window_id:Int ) {\r\n\r\n        lib.host.onmousewheel( x, y, timestamp, window_id );\r\n\r\n    } //dispatch_mouse_wheel_event\r\n\r\n        /** manually dispatch a touch down through the system, delivered to the app handlers, internal and external */\r\n    public function dispatch_touch_down_event( x:Float, y:Float, touch_id:Int, timestamp:Float ) {\r\n\r\n        if(!touches_down.exists(touch_id)) {\r\n            touch_count++;\r\n            touches_down.set(touch_id, true);\r\n        }\r\n\r\n        lib.host.ontouchdown( x, y, touch_id, timestamp );\r\n\r\n    } //dispatch_touch_down_event\r\n\r\n        /** manually dispatch a touch up through the system, delivered to the app handlers, internal and external */\r\n    public function dispatch_touch_up_event( x:Float, y:Float, touch_id:Int, timestamp:Float ) {\r\n\r\n        lib.host.ontouchup( x, y, touch_id, timestamp );\r\n\r\n        if(touches_down.remove(touch_id)) {\r\n            touch_count--;\r\n        }\r\n\r\n    } //dispatch_touch_up_event\r\n\r\n        /** manually dispatch a touch move through the system, delivered to the app handlers, internal and external */\r\n    public function dispatch_touch_move_event( x:Float, y:Float, dx:Float, dy:Float, touch_id:Int, timestamp:Float ) {\r\n\r\n        lib.host.ontouchmove( x, y, dx, dy, touch_id, timestamp );\r\n\r\n    } //dispatch_touch_move_event\r\n\r\n        /** manually dispatch a gamepad axis event through the system, delivered to the app handlers, internal and external */\r\n    public function dispatch_gamepad_axis_event( gamepad:Int, axis:Int, value:Float, timestamp:Float ) {\r\n\r\n            //if not existing, add it's map\r\n        if(!gamepad_axis_values.exists(gamepad)) {\r\n            gamepad_axis_values.set(gamepad, new Map());\r\n        }\r\n\r\n            //update the axis value\r\n        gamepad_axis_values.get(gamepad).set(axis, value);\r\n\r\n        lib.host.ongamepadaxis( gamepad, axis, value, timestamp );\r\n\r\n    } //dispatch_gamepad_axis_event\r\n\r\n        /** manually dispatch a gamepad button down event through the system, delivered to the app handlers, internal and external */\r\n    public function dispatch_gamepad_button_down_event( gamepad:Int, button:Int, value:Float, timestamp:Float ) {\r\n\r\n            //if not existing, add it's map\r\n        if(!gamepad_button_pressed.exists(gamepad)) {\r\n            gamepad_button_pressed.set(gamepad, new Map());\r\n        }\r\n\r\n        if(!gamepad_button_down.exists(gamepad)) {\r\n            gamepad_button_down.set(gamepad, new Map());\r\n        }\r\n\r\n            //flag it as released but unprocessed\r\n        gamepad_button_pressed.get(gamepad).set(button, false);\r\n            //flag it as down, because gamepadup removes it\r\n        gamepad_button_down.get(gamepad).set(button, true);\r\n\r\n\r\n        lib.host.ongamepaddown( gamepad, button, value, timestamp );\r\n\r\n    } //dispatch_gamepad_button_down_event\r\n\r\n        /** manually dispatch a gamepad button up event through the system, delivered to the app handlers, internal and external */\r\n    public function dispatch_gamepad_button_up_event( gamepad:Int, button:Int, value:Float, timestamp:Float ) {\r\n\r\n           //if not existing, add it's map, this should never happen,\r\n           //but rather be safe than crashy. :todo:shipping:\r\n        if(!gamepad_button_released.exists(gamepad)) {\r\n            gamepad_button_released.set(gamepad, new Map());\r\n        }\r\n\r\n        if(!gamepad_button_down.exists(gamepad)) {\r\n            gamepad_button_down.set(gamepad, new Map());\r\n        }\r\n\r\n            //flag it as released but unprocessed\r\n        gamepad_button_released.get(gamepad).set(button, false);\r\n            //flag it as down, because gamepadup removes it\r\n        gamepad_button_down.get(gamepad).remove(button);\r\n\r\n        lib.host.ongamepadup( gamepad, button, value, timestamp );\r\n\r\n    } //dispatch_gamepad_button_up_event\r\n\r\n        /** manually dispatch a gamepad device event through the system, delivered to the app handlers, internal and external */\r\n    public function dispatch_gamepad_device_event( gamepad:Int, type:GamepadDeviceEventType, timestamp:Float ) {\r\n\r\n        lib.host.ongamepaddevice( gamepad, type, timestamp );\r\n\r\n    } //dispatch_gamepad_device_event\r\n\r\n//Interal API\r\n\r\n        /** Attach to a window to listen for input from it */\r\n    @:noCompletion public function listen( _window:Window ) {\r\n\r\n        platform.listen(_window);\r\n\r\n    } //listen\r\n\r\n        /** Detach a listening window, stopping listening of input from it */\r\n    @:noCompletion public function unlisten( _window:Window ) {\r\n\r\n        platform.unlisten(_window);\r\n\r\n    } //unlisten\r\n\r\n        /** Called when a system event is dispatched through the core */\r\n    @:noCompletion public function on_event( _event:SystemEvent ) {\r\n\r\n        if(_event.type == SystemEventType.input) {\r\n            platform.on_event( _event.input );\r\n        } //only input events\r\n\r\n    } //on_event\r\n\r\n        /** Called when a gamepad is added, in order to handle any platform details */\r\n    @:noCompletion public function on_gamepad_added( _event:Dynamic ) {\r\n\r\n        platform.gamepad_add( _event.which );\r\n\r\n    } //on_gamepad_added\r\n\r\n        /** Called when a gamepad is removed, in order to handle any platform details */\r\n    @:noCompletion public function on_gamepad_removed( _event:Dynamic ) {\r\n\r\n        platform.gamepad_remove( _event.which );\r\n\r\n    } //on_gamepad_removed\r\n\r\n        /** Handle any input related processing, called by Snow */\r\n    @:allow(snow.Snow)\r\n    function update() {\r\n\r\n        platform.process();\r\n\r\n        _update_keystate();\r\n        _update_gamepadstate();\r\n        _update_mousestate();\r\n\r\n    } //update\r\n\r\n        /** Destroy and clean up etc. */\r\n    @:allow(snow.Snow)\r\n    function destroy() {\r\n\r\n        platform.destroy();\r\n\r\n    } //destroy\r\n\r\n//internal\r\n\r\n        /** update mouse pressed/released/down states */\r\n    function _update_mousestate() {\r\n\r\n        for(_code in mouse_button_pressed.keys()){\r\n\r\n            if(mouse_button_pressed.get(_code)){\r\n                mouse_button_pressed.remove(_code);\r\n            } else {\r\n                mouse_button_pressed.set(_code, true);\r\n            }\r\n\r\n        } //each mouse_button_pressed\r\n\r\n        for(_code in mouse_button_released.keys()){\r\n\r\n            if(mouse_button_released.get(_code)){\r\n                mouse_button_released.remove(_code);\r\n            } else {\r\n                mouse_button_released.set(_code, true);\r\n            }\r\n\r\n        } //each mouse_button_released\r\n\r\n    } //_update_mousestate\r\n\r\n        /** update gamepad pressed/released/down/axis states */\r\n    function _update_gamepadstate() {\r\n\r\n        for(_gamepad_pressed in gamepad_button_pressed){\r\n            for(_button in _gamepad_pressed.keys()) {\r\n\r\n                if(_gamepad_pressed.get(_button)){\r\n                    _gamepad_pressed.remove(_button);\r\n                } else {\r\n                    _gamepad_pressed.set(_button, true);\r\n                }\r\n\r\n            } //each _gamepad_pressed\r\n        } //each gamepad_button_pressed\r\n\r\n        for(_gamepad_released in gamepad_button_released){\r\n            for(_button in _gamepad_released.keys()) {\r\n\r\n                if(_gamepad_released.get(_button)){\r\n                    _gamepad_released.remove(_button);\r\n                } else {\r\n                    _gamepad_released.set(_button, true);\r\n                }\r\n\r\n            } //each _gamepad_released\r\n        } //each gamepad_button_released\r\n\r\n    } //_update_gamepadstate\r\n\r\n        /** update key pressed/released/down states */\r\n    function _update_keystate() {\r\n\r\n            //remove any stale key pressed value\r\n            //unless it wasn't alive for a full frame yet,\r\n            //then flag it so that it may be\r\n        for(_code in key_code_pressed.keys()){\r\n\r\n            if(key_code_pressed.get(_code)){\r\n                key_code_pressed.remove(_code);\r\n            } else {\r\n                key_code_pressed.set(_code, true);\r\n            }\r\n\r\n        } //each key_code_pressed\r\n\r\n            //remove any stale key released value\r\n            //unless it wasn't alive for a full frame yet,\r\n            //then flag it so that it may be\r\n        for(_code in key_code_released.keys()){\r\n\r\n            if(key_code_released.get(_code)){\r\n                key_code_released.remove(_code);\r\n            } else {\r\n                key_code_released.set(_code, true);\r\n            }\r\n\r\n        } //each key_code_released\r\n\r\n    //scans\r\n\r\n            //remove any stale key pressed value\r\n            //unless it wasn't alive for a full frame yet,\r\n            //then flag it so that it may be\r\n        for(_code in scan_code_pressed.keys()){\r\n\r\n            if(scan_code_pressed.get(_code)){\r\n                scan_code_pressed.remove(_code);\r\n            } else {\r\n                scan_code_pressed.set(_code, true);\r\n            }\r\n\r\n        } //each scan_code_pressed\r\n\r\n            //remove any stale key released value\r\n            //unless it wasn't alive for a full frame yet,\r\n            //then flag it so that it may be\r\n        for(_code in scan_code_released.keys()){\r\n\r\n            if(scan_code_released.get(_code)){\r\n                scan_code_released.remove(_code);\r\n            } else {\r\n                scan_code_released.set(_code, true);\r\n            }\r\n\r\n        } //each scan_code_released\r\n\r\n    } //_update_keystate\r\n\r\n\r\n} //Input\r\n\r\n\r\n","package snow.input;\r\n\r\nimport snow.Snow;\r\nimport snow.types.Types;\r\nimport snow.input.Input;\r\n\r\nimport snow.utils.AbstractClass;\r\nimport snow.window.Window;\r\n\r\n\r\n#if snow_web\r\n\r\n    @:noCompletion typedef InputSystem = snow.platform.web.input.InputSystem;\r\n\r\n#else\r\n\r\n    #if snow_input_sdl\r\n        @:noCompletion typedef InputSystem = snow.platform.native.input.sdl.InputSystem;\r\n    #else\r\n        @:noCompletion typedef InputSystem = snow.platform.native.input.InputSystem;\r\n    #end\r\n\r\n#end\r\n\r\n/** Internal input system, accessed through `snow.Input`, not directly */\r\n@:noCompletion class InputSystemBinding implements AbstractClass {\r\n\r\n    public var manager : Input;\r\n    public var lib : Snow;\r\n\r\n        /** Called when the input manager initiates this system */\r\n    public function init();\r\n        /** Called when the input manager updates this system */\r\n    public function process();\r\n        /** Called when the input manager destroys this system */\r\n    public function destroy();\r\n        /** Called when the input manager forwards an event to this system */\r\n    public function on_event( _event : InputEvent );\r\n\r\n        /** Start a system text input state, this includes soft keyboard on mobile. on some platforms like web this does nothing (yet?) */\r\n    public function text_input_start();\r\n        /** End a system text input state, this includes soft keyboard on mobile. on some platforms like web this does nothing (yet?) */\r\n    public function text_input_stop();\r\n        /** In a system text input state, this determines the area that is accepting input. */\r\n    public function text_input_rect(x:Int, y:Int, w:Int, h:Int);\r\n\r\n        /** Open a gamepad with this id */\r\n    public function gamepad_add(id:Int);\r\n        /** Close a gamepad with this id */\r\n    public function gamepad_remove(id:Int);\r\n        /** Listen for input events on the given window */\r\n    @:noCompletion public function listen( window:Window );\r\n        /** Stop listening for input events on the given window */\r\n    @:noCompletion public function unlisten( window:Window );\r\n\r\n} //InputSystemBinding\r\n","package snow.input;\r\n\r\n\r\n/** The keycode class, with conversion helpers for scancodes. The values below come directly from SDL header include files,\r\nbut they aren't specific to SDL so they are used generically */\r\n@:noCompletion class Keycodes {\r\n\r\n        /** Convert a scancode to a keycode for comparison */\r\n    public static function from_scan( scancode : Int ) : Int {\r\n        return (scancode | Scancodes.MASK);\r\n    } //from_scan\r\n\r\n        /** Convert a keycode to a scancode if possible.\r\n            NOTE - this will only map a large % but not all keys,\r\n            there is a list of unmapped keys commented in the code. */\r\n    public static function to_scan( keycode : Int ) : Int {\r\n\r\n            //quite a lot map directly to a masked scancode\r\n            //if that's the case, return it directly\r\n        if ((keycode & Scancodes.MASK) != 0) {\r\n            return keycode &~ Scancodes.MASK;\r\n        }\r\n\r\n            //now we translate them to the scan where unmapped\r\n\r\n        switch(keycode) {\r\n            case Keycodes.enter:         return Scancodes.enter;\r\n            case Keycodes.escape:        return Scancodes.escape;\r\n            case Keycodes.backspace:     return Scancodes.backspace;\r\n            case Keycodes.tab:           return Scancodes.tab;\r\n            case Keycodes.space:         return Scancodes.space;\r\n            case Keycodes.slash:         return Scancodes.slash;\r\n            case Keycodes.key_0:         return Scancodes.key_0;\r\n            case Keycodes.key_1:         return Scancodes.key_1;\r\n            case Keycodes.key_2:         return Scancodes.key_2;\r\n            case Keycodes.key_3:         return Scancodes.key_3;\r\n            case Keycodes.key_4:         return Scancodes.key_4;\r\n            case Keycodes.key_5:         return Scancodes.key_5;\r\n            case Keycodes.key_6:         return Scancodes.key_6;\r\n            case Keycodes.key_7:         return Scancodes.key_7;\r\n            case Keycodes.key_8:         return Scancodes.key_8;\r\n            case Keycodes.key_9:         return Scancodes.key_9;\r\n            case Keycodes.semicolon:     return Scancodes.semicolon;\r\n            case Keycodes.equals:        return Scancodes.equals;\r\n            case Keycodes.leftbracket:   return Scancodes.leftbracket;\r\n            case Keycodes.backslash:     return Scancodes.backslash;\r\n            case Keycodes.rightbracket:  return Scancodes.rightbracket;\r\n            case Keycodes.backquote:     return Scancodes.grave;\r\n            case Keycodes.key_a:         return Scancodes.key_a;\r\n            case Keycodes.key_b:         return Scancodes.key_b;\r\n            case Keycodes.key_c:         return Scancodes.key_c;\r\n            case Keycodes.key_d:         return Scancodes.key_d;\r\n            case Keycodes.key_e:         return Scancodes.key_e;\r\n            case Keycodes.key_f:         return Scancodes.key_f;\r\n            case Keycodes.key_g:         return Scancodes.key_g;\r\n            case Keycodes.key_h:         return Scancodes.key_h;\r\n            case Keycodes.key_i:         return Scancodes.key_i;\r\n            case Keycodes.key_j:         return Scancodes.key_j;\r\n            case Keycodes.key_k:         return Scancodes.key_k;\r\n            case Keycodes.key_l:         return Scancodes.key_l;\r\n            case Keycodes.key_m:         return Scancodes.key_m;\r\n            case Keycodes.key_n:         return Scancodes.key_n;\r\n            case Keycodes.key_o:         return Scancodes.key_o;\r\n            case Keycodes.key_p:         return Scancodes.key_p;\r\n            case Keycodes.key_q:         return Scancodes.key_q;\r\n            case Keycodes.key_r:         return Scancodes.key_r;\r\n            case Keycodes.key_s:         return Scancodes.key_s;\r\n            case Keycodes.key_t:         return Scancodes.key_t;\r\n            case Keycodes.key_u:         return Scancodes.key_u;\r\n            case Keycodes.key_v:         return Scancodes.key_v;\r\n            case Keycodes.key_w:         return Scancodes.key_w;\r\n            case Keycodes.key_x:         return Scancodes.key_x;\r\n            case Keycodes.key_y:         return Scancodes.key_y;\r\n            case Keycodes.key_z:         return Scancodes.key_z;\r\n\r\n\r\n                //These are unmappable because they are not keys\r\n                //but values on the key (like a shift key combo)\r\n                //and to hardcode them to the key you think it is,\r\n                //would be to map it to a fixed locale probably.\r\n                //They don't have scancodes, so we don't return one\r\n            // case exclaim:      ;\r\n            // case quotedbl:     ;\r\n            // case hash:         ;\r\n            // case percent:      ;\r\n            // case dollar:       ;\r\n            // case ampersand:    ;\r\n            // case quote:        ;\r\n            // case leftparen:    ;\r\n            // case rightparen:   ;\r\n            // case asterisk:     ;\r\n            // case plus:         ;\r\n            // case comma:        ;\r\n            // case minus:        ;\r\n            // case period:       ;\r\n            // case less:         ;\r\n            // case colon:        ;\r\n            // case greater:      ;\r\n            // case question:     ;\r\n            // case at:           ;\r\n            // case caret:        ;\r\n            // case underscore:   ;\r\n\r\n        } //switch(keycode)\r\n\r\n        return Scancodes.unknown;\r\n\r\n    } //to_scan\r\n\r\n        /** Convert a keycode to string */\r\n    public static function name( keycode : Int ) : String {\r\n\r\n        //we don't use to_scan because it would consume\r\n        //the typeable characters and we want those as unicode etc.\r\n\r\n        if ((keycode & Scancodes.MASK) != 0) {\r\n            return Scancodes.name(keycode &~ Scancodes.MASK);\r\n        }\r\n\r\n        switch(keycode) {\r\n\r\n            case Keycodes.enter:     return Scancodes.name(Scancodes.enter);\r\n            case Keycodes.escape:    return Scancodes.name(Scancodes.escape);\r\n            case Keycodes.backspace: return Scancodes.name(Scancodes.backspace);\r\n            case Keycodes.tab:       return Scancodes.name(Scancodes.tab);\r\n            case Keycodes.space:     return Scancodes.name(Scancodes.space);\r\n            case Keycodes.delete:    return Scancodes.name(Scancodes.delete);\r\n\r\n            default: {\r\n\r\n                var decoder = new haxe.Utf8();\r\n                    decoder.addChar(keycode);\r\n\r\n                return decoder.toString();\r\n\r\n            } //default\r\n\r\n        } //switch(keycode)\r\n\r\n    } //name\r\n\r\n    public static var unknown : Int                     = 0;\r\n\r\n    public static var enter : Int                       = 13;\r\n    public static var escape : Int                      = 27;\r\n    public static var backspace : Int                   = 8;\r\n    public static var tab : Int                         = 9;\r\n    public static var space : Int                       = 32;\r\n    public static var exclaim : Int                     = 33;\r\n    public static var quotedbl : Int                    = 34;\r\n    public static var hash : Int                        = 35;\r\n    public static var percent : Int                     = 37;\r\n    public static var dollar : Int                      = 36;\r\n    public static var ampersand : Int                   = 38;\r\n    public static var quote : Int                       = 39;\r\n    public static var leftparen : Int                   = 40;\r\n    public static var rightparen : Int                  = 41;\r\n    public static var asterisk : Int                    = 42;\r\n    public static var plus : Int                        = 43;\r\n    public static var comma : Int                       = 44;\r\n    public static var minus : Int                       = 45;\r\n    public static var period : Int                      = 46;\r\n    public static var slash : Int                       = 47;\r\n    public static var key_0 : Int                       = 48;\r\n    public static var key_1 : Int                       = 49;\r\n    public static var key_2 : Int                       = 50;\r\n    public static var key_3 : Int                       = 51;\r\n    public static var key_4 : Int                       = 52;\r\n    public static var key_5 : Int                       = 53;\r\n    public static var key_6 : Int                       = 54;\r\n    public static var key_7 : Int                       = 55;\r\n    public static var key_8 : Int                       = 56;\r\n    public static var key_9 : Int                       = 57;\r\n    public static var colon : Int                       = 58;\r\n    public static var semicolon : Int                   = 59;\r\n    public static var less : Int                        = 60;\r\n    public static var equals : Int                      = 61;\r\n    public static var greater : Int                     = 62;\r\n    public static var question : Int                    = 63;\r\n    public static var at : Int                          = 64;\r\n    /*\r\n       Skip uppercase letters\r\n     */\r\n    public static var leftbracket : Int                 = 91;\r\n    public static var backslash : Int                   = 92;\r\n    public static var rightbracket : Int                = 93;\r\n    public static var caret : Int                       = 94;\r\n    public static var underscore : Int                  = 95;\r\n    public static var backquote : Int                   = 96;\r\n    public static var key_a : Int                       = 97;\r\n    public static var key_b : Int                       = 98;\r\n    public static var key_c : Int                       = 99;\r\n    public static var key_d : Int                       = 100;\r\n    public static var key_e : Int                       = 101;\r\n    public static var key_f : Int                       = 102;\r\n    public static var key_g : Int                       = 103;\r\n    public static var key_h : Int                       = 104;\r\n    public static var key_i : Int                       = 105;\r\n    public static var key_j : Int                       = 106;\r\n    public static var key_k : Int                       = 107;\r\n    public static var key_l : Int                       = 108;\r\n    public static var key_m : Int                       = 109;\r\n    public static var key_n : Int                       = 110;\r\n    public static var key_o : Int                       = 111;\r\n    public static var key_p : Int                       = 112;\r\n    public static var key_q : Int                       = 113;\r\n    public static var key_r : Int                       = 114;\r\n    public static var key_s : Int                       = 115;\r\n    public static var key_t : Int                       = 116;\r\n    public static var key_u : Int                       = 117;\r\n    public static var key_v : Int                       = 118;\r\n    public static var key_w : Int                       = 119;\r\n    public static var key_x : Int                       = 120;\r\n    public static var key_y : Int                       = 121;\r\n    public static var key_z : Int                       = 122;\r\n\r\n    public static var capslock : Int             = from_scan(Scancodes.capslock);\r\n\r\n    public static var f1 : Int                   = from_scan(Scancodes.f1);\r\n    public static var f2 : Int                   = from_scan(Scancodes.f2);\r\n    public static var f3 : Int                   = from_scan(Scancodes.f3);\r\n    public static var f4 : Int                   = from_scan(Scancodes.f4);\r\n    public static var f5 : Int                   = from_scan(Scancodes.f5);\r\n    public static var f6 : Int                   = from_scan(Scancodes.f6);\r\n    public static var f7 : Int                   = from_scan(Scancodes.f7);\r\n    public static var f8 : Int                   = from_scan(Scancodes.f8);\r\n    public static var f9 : Int                   = from_scan(Scancodes.f9);\r\n    public static var f10 : Int                  = from_scan(Scancodes.f10);\r\n    public static var f11 : Int                  = from_scan(Scancodes.f11);\r\n    public static var f12 : Int                  = from_scan(Scancodes.f12);\r\n\r\n    public static var printscreen : Int          = from_scan(Scancodes.printscreen);\r\n    public static var scrolllock : Int           = from_scan(Scancodes.scrolllock);\r\n    public static var pause : Int                = from_scan(Scancodes.pause);\r\n    public static var insert : Int               = from_scan(Scancodes.insert);\r\n    public static var home : Int                 = from_scan(Scancodes.home);\r\n    public static var pageup : Int               = from_scan(Scancodes.pageup);\r\n    public static var delete : Int               = 127;\r\n    public static var end : Int                  = from_scan(Scancodes.end);\r\n    public static var pagedown : Int             = from_scan(Scancodes.pagedown);\r\n    public static var right : Int                = from_scan(Scancodes.right);\r\n    public static var left : Int                 = from_scan(Scancodes.left);\r\n    public static var down : Int                 = from_scan(Scancodes.down);\r\n    public static var up : Int                   = from_scan(Scancodes.up);\r\n\r\n    public static var numlockclear : Int         = from_scan(Scancodes.numlockclear);\r\n    public static var kp_divide : Int            = from_scan(Scancodes.kp_divide);\r\n    public static var kp_multiply : Int          = from_scan(Scancodes.kp_multiply);\r\n    public static var kp_minus : Int             = from_scan(Scancodes.kp_minus);\r\n    public static var kp_plus : Int              = from_scan(Scancodes.kp_plus);\r\n    public static var kp_enter : Int             = from_scan(Scancodes.kp_enter);\r\n    public static var kp_1 : Int                 = from_scan(Scancodes.kp_1);\r\n    public static var kp_2 : Int                 = from_scan(Scancodes.kp_2);\r\n    public static var kp_3 : Int                 = from_scan(Scancodes.kp_3);\r\n    public static var kp_4 : Int                 = from_scan(Scancodes.kp_4);\r\n    public static var kp_5 : Int                 = from_scan(Scancodes.kp_5);\r\n    public static var kp_6 : Int                 = from_scan(Scancodes.kp_6);\r\n    public static var kp_7 : Int                 = from_scan(Scancodes.kp_7);\r\n    public static var kp_8 : Int                 = from_scan(Scancodes.kp_8);\r\n    public static var kp_9 : Int                 = from_scan(Scancodes.kp_9);\r\n    public static var kp_0 : Int                 = from_scan(Scancodes.kp_0);\r\n    public static var kp_period : Int            = from_scan(Scancodes.kp_period);\r\n\r\n    public static var application : Int          = from_scan(Scancodes.application);\r\n    public static var power : Int                = from_scan(Scancodes.power);\r\n    public static var kp_equals : Int            = from_scan(Scancodes.kp_equals);\r\n    public static var f13 : Int                  = from_scan(Scancodes.f13);\r\n    public static var f14 : Int                  = from_scan(Scancodes.f14);\r\n    public static var f15 : Int                  = from_scan(Scancodes.f15);\r\n    public static var f16 : Int                  = from_scan(Scancodes.f16);\r\n    public static var f17 : Int                  = from_scan(Scancodes.f17);\r\n    public static var f18 : Int                  = from_scan(Scancodes.f18);\r\n    public static var f19 : Int                  = from_scan(Scancodes.f19);\r\n    public static var f20 : Int                  = from_scan(Scancodes.f20);\r\n    public static var f21 : Int                  = from_scan(Scancodes.f21);\r\n    public static var f22 : Int                  = from_scan(Scancodes.f22);\r\n    public static var f23 : Int                  = from_scan(Scancodes.f23);\r\n    public static var f24 : Int                  = from_scan(Scancodes.f24);\r\n    public static var execute : Int              = from_scan(Scancodes.execute);\r\n    public static var help : Int                 = from_scan(Scancodes.help);\r\n    public static var menu : Int                 = from_scan(Scancodes.menu);\r\n    public static var select : Int               = from_scan(Scancodes.select);\r\n    public static var stop : Int                 = from_scan(Scancodes.stop);\r\n    public static var again : Int                = from_scan(Scancodes.again);\r\n    public static var undo : Int                 = from_scan(Scancodes.undo);\r\n    public static var cut : Int                  = from_scan(Scancodes.cut);\r\n    public static var copy : Int                 = from_scan(Scancodes.copy);\r\n    public static var paste : Int                = from_scan(Scancodes.paste);\r\n    public static var find : Int                 = from_scan(Scancodes.find);\r\n    public static var mute : Int                 = from_scan(Scancodes.mute);\r\n    public static var volumeup : Int             = from_scan(Scancodes.volumeup);\r\n    public static var volumedown : Int           = from_scan(Scancodes.volumedown);\r\n    public static var kp_comma : Int             = from_scan(Scancodes.kp_comma);\r\n    public static var kp_equalsas400 : Int       = from_scan(Scancodes.kp_equalsas400);\r\n\r\n    public static var alterase : Int             = from_scan(Scancodes.alterase);\r\n    public static var sysreq : Int               = from_scan(Scancodes.sysreq);\r\n    public static var cancel : Int               = from_scan(Scancodes.cancel);\r\n    public static var clear : Int                = from_scan(Scancodes.clear);\r\n    public static var prior : Int                = from_scan(Scancodes.prior);\r\n    public static var return2 : Int              = from_scan(Scancodes.return2);\r\n    public static var separator : Int            = from_scan(Scancodes.separator);\r\n    public static var out : Int                  = from_scan(Scancodes.out);\r\n    public static var oper : Int                 = from_scan(Scancodes.oper);\r\n    public static var clearagain : Int           = from_scan(Scancodes.clearagain);\r\n    public static var crsel : Int                = from_scan(Scancodes.crsel);\r\n    public static var exsel : Int                = from_scan(Scancodes.exsel);\r\n\r\n    public static var kp_00 : Int                = from_scan(Scancodes.kp_00);\r\n    public static var kp_000 : Int               = from_scan(Scancodes.kp_000);\r\n    public static var thousandsseparator : Int   = from_scan(Scancodes.thousandsseparator);\r\n    public static var decimalseparator : Int     = from_scan(Scancodes.decimalseparator);\r\n    public static var currencyunit : Int         = from_scan(Scancodes.currencyunit);\r\n    public static var currencysubunit : Int      = from_scan(Scancodes.currencysubunit);\r\n    public static var kp_leftparen : Int         = from_scan(Scancodes.kp_leftparen);\r\n    public static var kp_rightparen : Int        = from_scan(Scancodes.kp_rightparen);\r\n    public static var kp_leftbrace : Int         = from_scan(Scancodes.kp_leftbrace);\r\n    public static var kp_rightbrace : Int        = from_scan(Scancodes.kp_rightbrace);\r\n    public static var kp_tab : Int               = from_scan(Scancodes.kp_tab);\r\n    public static var kp_backspace : Int         = from_scan(Scancodes.kp_backspace);\r\n    public static var kp_a : Int                 = from_scan(Scancodes.kp_a);\r\n    public static var kp_b : Int                 = from_scan(Scancodes.kp_b);\r\n    public static var kp_c : Int                 = from_scan(Scancodes.kp_c);\r\n    public static var kp_d : Int                 = from_scan(Scancodes.kp_d);\r\n    public static var kp_e : Int                 = from_scan(Scancodes.kp_e);\r\n    public static var kp_f : Int                 = from_scan(Scancodes.kp_f);\r\n    public static var kp_xor : Int               = from_scan(Scancodes.kp_xor);\r\n    public static var kp_power : Int             = from_scan(Scancodes.kp_power);\r\n    public static var kp_percent : Int           = from_scan(Scancodes.kp_percent);\r\n    public static var kp_less : Int              = from_scan(Scancodes.kp_less);\r\n    public static var kp_greater : Int           = from_scan(Scancodes.kp_greater);\r\n    public static var kp_ampersand : Int         = from_scan(Scancodes.kp_ampersand);\r\n    public static var kp_dblampersand : Int      = from_scan(Scancodes.kp_dblampersand);\r\n    public static var kp_verticalbar : Int       = from_scan(Scancodes.kp_verticalbar);\r\n    public static var kp_dblverticalbar : Int    = from_scan(Scancodes.kp_dblverticalbar);\r\n    public static var kp_colon : Int             = from_scan(Scancodes.kp_colon);\r\n    public static var kp_hash : Int              = from_scan(Scancodes.kp_hash);\r\n    public static var kp_space : Int             = from_scan(Scancodes.kp_space);\r\n    public static var kp_at : Int                = from_scan(Scancodes.kp_at);\r\n    public static var kp_exclam : Int            = from_scan(Scancodes.kp_exclam);\r\n    public static var kp_memstore : Int          = from_scan(Scancodes.kp_memstore);\r\n    public static var kp_memrecall : Int         = from_scan(Scancodes.kp_memrecall);\r\n    public static var kp_memclear : Int          = from_scan(Scancodes.kp_memclear);\r\n    public static var kp_memadd : Int            = from_scan(Scancodes.kp_memadd);\r\n    public static var kp_memsubtract : Int       = from_scan(Scancodes.kp_memsubtract);\r\n    public static var kp_memmultiply : Int       = from_scan(Scancodes.kp_memmultiply);\r\n    public static var kp_memdivide : Int         = from_scan(Scancodes.kp_memdivide);\r\n    public static var kp_plusminus : Int         = from_scan(Scancodes.kp_plusminus);\r\n    public static var kp_clear : Int             = from_scan(Scancodes.kp_clear);\r\n    public static var kp_clearentry : Int        = from_scan(Scancodes.kp_clearentry);\r\n    public static var kp_binary : Int            = from_scan(Scancodes.kp_binary);\r\n    public static var kp_octal : Int             = from_scan(Scancodes.kp_octal);\r\n    public static var kp_decimal : Int           = from_scan(Scancodes.kp_decimal);\r\n    public static var kp_hexadecimal : Int       = from_scan(Scancodes.kp_hexadecimal);\r\n\r\n    public static var lctrl : Int                = from_scan(Scancodes.lctrl);\r\n    public static var lshift : Int               = from_scan(Scancodes.lshift);\r\n    public static var lalt : Int                 = from_scan(Scancodes.lalt);\r\n    public static var lmeta : Int                = from_scan(Scancodes.lmeta);\r\n    public static var rctrl : Int                = from_scan(Scancodes.rctrl);\r\n    public static var rshift : Int               = from_scan(Scancodes.rshift);\r\n    public static var ralt : Int                 = from_scan(Scancodes.ralt);\r\n    public static var rmeta : Int                = from_scan(Scancodes.rmeta);\r\n\r\n    public static var mode : Int                 = from_scan(Scancodes.mode);\r\n\r\n    public static var audionext : Int            = from_scan(Scancodes.audionext);\r\n    public static var audioprev : Int            = from_scan(Scancodes.audioprev);\r\n    public static var audiostop : Int            = from_scan(Scancodes.audiostop);\r\n    public static var audioplay : Int            = from_scan(Scancodes.audioplay);\r\n    public static var audiomute : Int            = from_scan(Scancodes.audiomute);\r\n    public static var mediaselect : Int          = from_scan(Scancodes.mediaselect);\r\n    public static var www : Int                  = from_scan(Scancodes.www);\r\n    public static var mail : Int                 = from_scan(Scancodes.mail);\r\n    public static var calculator : Int           = from_scan(Scancodes.calculator);\r\n    public static var computer : Int             = from_scan(Scancodes.computer);\r\n    public static var ac_search : Int            = from_scan(Scancodes.ac_search);\r\n    public static var ac_home : Int              = from_scan(Scancodes.ac_home);\r\n    public static var ac_back : Int              = from_scan(Scancodes.ac_back);\r\n    public static var ac_forward : Int           = from_scan(Scancodes.ac_forward);\r\n    public static var ac_stop : Int              = from_scan(Scancodes.ac_stop);\r\n    public static var ac_refresh : Int           = from_scan(Scancodes.ac_refresh);\r\n    public static var ac_bookmarks : Int         = from_scan(Scancodes.ac_bookmarks);\r\n\r\n    public static var brightnessdown : Int       = from_scan(Scancodes.brightnessdown);\r\n    public static var brightnessup : Int         = from_scan(Scancodes.brightnessup);\r\n    public static var displayswitch : Int        = from_scan(Scancodes.displayswitch);\r\n    public static var kbdillumtoggle : Int       = from_scan(Scancodes.kbdillumtoggle);\r\n    public static var kbdillumdown : Int         = from_scan(Scancodes.kbdillumdown);\r\n    public static var kbdillumup : Int           = from_scan(Scancodes.kbdillumup);\r\n    public static var eject : Int                = from_scan(Scancodes.eject);\r\n    public static var sleep : Int                = from_scan(Scancodes.sleep);\r\n\r\n} //Keycodes\r\n\r\n\r\n/** The scancode class. The values below come directly from SDL header include files,\r\nbut they aren't specific to SDL so they are used generically */\r\n@:noCompletion class Scancodes {\r\n\r\n        /** Convert a scancode to a name */\r\n    public static function name( scancode : Int ) : String {\r\n\r\n        var res = null;\r\n\r\n        if (scancode >= 0 && scancode < scancode_names.length) {\r\n            res = scancode_names[scancode];\r\n        }\r\n\r\n        return res != null ? res : \"\";\r\n\r\n    } //name\r\n\r\n        //special value remains caps\r\n    public static var MASK:Int                      = (1<<30);\r\n\r\n    public static var unknown : Int                 = 0;\r\n\r\n       // Usage page 0x07\r\n       // These values are from usage page 0x07 (USB keyboard page).\r\n\r\n    public static var key_a : Int                   = 4;\r\n    public static var key_b : Int                   = 5;\r\n    public static var key_c : Int                   = 6;\r\n    public static var key_d : Int                   = 7;\r\n    public static var key_e : Int                   = 8;\r\n    public static var key_f : Int                   = 9;\r\n    public static var key_g : Int                   = 10;\r\n    public static var key_h : Int                   = 11;\r\n    public static var key_i : Int                   = 12;\r\n    public static var key_j : Int                   = 13;\r\n    public static var key_k : Int                   = 14;\r\n    public static var key_l : Int                   = 15;\r\n    public static var key_m : Int                   = 16;\r\n    public static var key_n : Int                   = 17;\r\n    public static var key_o : Int                   = 18;\r\n    public static var key_p : Int                   = 19;\r\n    public static var key_q : Int                   = 20;\r\n    public static var key_r : Int                   = 21;\r\n    public static var key_s : Int                   = 22;\r\n    public static var key_t : Int                   = 23;\r\n    public static var key_u : Int                   = 24;\r\n    public static var key_v : Int                   = 25;\r\n    public static var key_w : Int                   = 26;\r\n    public static var key_x : Int                   = 27;\r\n    public static var key_y : Int                   = 28;\r\n    public static var key_z : Int                   = 29;\r\n\r\n    public static var key_1 : Int                   = 30;\r\n    public static var key_2 : Int                   = 31;\r\n    public static var key_3 : Int                   = 32;\r\n    public static var key_4 : Int                   = 33;\r\n    public static var key_5 : Int                   = 34;\r\n    public static var key_6 : Int                   = 35;\r\n    public static var key_7 : Int                   = 36;\r\n    public static var key_8 : Int                   = 37;\r\n    public static var key_9 : Int                   = 38;\r\n    public static var key_0 : Int                   = 39;\r\n\r\n    public static var enter : Int                   = 40;\r\n    public static var escape : Int                  = 41;\r\n    public static var backspace : Int               = 42;\r\n    public static var tab : Int                     = 43;\r\n    public static var space : Int                   = 44;\r\n\r\n    public static var minus : Int                   = 45;\r\n    public static var equals : Int                  = 46;\r\n    public static var leftbracket : Int             = 47;\r\n    public static var rightbracket : Int            = 48;\r\n\r\n/** Located at the lower left of the return\r\n    key on ISO keyboards and at the right end\r\n    of the QWERTY row on ANSI keyboards.\r\n    Produces REVERSE SOLIDUS (backslash) and\r\n    VERTICAL LINE in a US layout, REVERSE\r\n    SOLIDUS and VERTICAL LINE in a UK Mac\r\n    layout, NUMBER SIGN and TILDE in a UK\r\n    Windows layout, DOLLAR SIGN and POUND SIGN\r\n    in a Swiss German layout, NUMBER SIGN and\r\n    APOSTROPHE in a German layout, GRAVE\r\n    ACCENT and POUND SIGN in a French Mac\r\n    layout, and ASTERISK and MICRO SIGN in a\r\n    French Windows layout.\r\n*/\r\n    public static var backslash : Int               = 49;\r\n\r\n/** ISO USB keyboards actually use this code\r\n    instead of 49 for the same key, but all\r\n    OSes I've seen treat the two codes\r\n    identically. So, as an implementor, unless\r\n    your keyboard generates both of those\r\n    codes and your OS treats them differently,\r\n    you should generate public static var BACKSLASH\r\n    instead of this code. As a user, you\r\n    should not rely on this code because SDL\r\n    will never generate it with most (all?)\r\n    keyboards.\r\n*/\r\n    public static var nonushash : Int          = 50;\r\n    public static var semicolon : Int          = 51;\r\n    public static var apostrophe : Int         = 52;\r\n\r\n/** Located in the top left corner (on both ANSI\r\n    and ISO keyboards). Produces GRAVE ACCENT and\r\n    TILDE in a US Windows layout and in US and UK\r\n    Mac layouts on ANSI keyboards, GRAVE ACCENT\r\n    and NOT SIGN in a UK Windows layout, SECTION\r\n    SIGN and PLUS-MINUS SIGN in US and UK Mac\r\n    layouts on ISO keyboards, SECTION SIGN and\r\n    DEGREE SIGN in a Swiss German layout (Mac:\r\n    only on ISO keyboards); CIRCUMFLEX ACCENT and\r\n    DEGREE SIGN in a German layout (Mac: only on\r\n    ISO keyboards), SUPERSCRIPT TWO and TILDE in a\r\n    French Windows layout, COMMERCIAL AT and\r\n    NUMBER SIGN in a French Mac layout on ISO\r\n    keyboards, and LESS-THAN SIGN and GREATER-THAN\r\n    SIGN in a Swiss German, German, or French Mac\r\n    layout on ANSI keyboards.\r\n*/\r\n    public static var grave : Int              = 53;\r\n    public static var comma : Int              = 54;\r\n    public static var period : Int             = 55;\r\n    public static var slash : Int              = 56;\r\n\r\n    public static var capslock : Int           = 57;\r\n\r\n    public static var f1 : Int                 = 58;\r\n    public static var f2 : Int                 = 59;\r\n    public static var f3 : Int                 = 60;\r\n    public static var f4 : Int                 = 61;\r\n    public static var f5 : Int                 = 62;\r\n    public static var f6 : Int                 = 63;\r\n    public static var f7 : Int                 = 64;\r\n    public static var f8 : Int                 = 65;\r\n    public static var f9 : Int                 = 66;\r\n    public static var f10 : Int                = 67;\r\n    public static var f11 : Int                = 68;\r\n    public static var f12 : Int                = 69;\r\n\r\n    public static var printscreen : Int        = 70;\r\n    public static var scrolllock : Int         = 71;\r\n    public static var pause : Int              = 72;\r\n\r\n/** insert on PC, help on some Mac keyboards (but does send code 73, not 117) */\r\n    public static var insert : Int             = 73;\r\n    public static var home : Int               = 74;\r\n    public static var pageup : Int             = 75;\r\n    public static var delete : Int             = 76;\r\n    public static var end : Int                = 77;\r\n    public static var pagedown : Int           = 78;\r\n    public static var right : Int              = 79;\r\n    public static var left : Int               = 80;\r\n    public static var down : Int               = 81;\r\n    public static var up : Int                 = 82;\r\n\r\n/** num lock on PC, clear on Mac keyboards */\r\n    public static var numlockclear : Int       = 83;\r\n    public static var kp_divide : Int          = 84;\r\n    public static var kp_multiply : Int        = 85;\r\n    public static var kp_minus : Int           = 86;\r\n    public static var kp_plus : Int            = 87;\r\n    public static var kp_enter : Int           = 88;\r\n    public static var kp_1 : Int               = 89;\r\n    public static var kp_2 : Int               = 90;\r\n    public static var kp_3 : Int               = 91;\r\n    public static var kp_4 : Int               = 92;\r\n    public static var kp_5 : Int               = 93;\r\n    public static var kp_6 : Int               = 94;\r\n    public static var kp_7 : Int               = 95;\r\n    public static var kp_8 : Int               = 96;\r\n    public static var kp_9 : Int               = 97;\r\n    public static var kp_0 : Int               = 98;\r\n    public static var kp_period : Int          = 99;\r\n\r\n\r\n/** This is the additional key that ISO\r\n    keyboards have over ANSI ones,\r\n    located between left shift and Y.\r\n    Produces GRAVE ACCENT and TILDE in a\r\n    US or UK Mac layout, REVERSE SOLIDUS\r\n    (backslash) and VERTICAL LINE in a\r\n    US or UK Windows layout, and\r\n    LESS-THAN SIGN and GREATER-THAN SIGN\r\n    in a Swiss German, German, or French\r\n    layout. */\r\n    public static var nonusbackslash : Int     = 100;\r\n\r\n/** windows contextual menu, compose */\r\n    public static var application : Int        = 101;\r\n\r\n/** The USB document says this is a status flag,\r\n    not a physical key - but some Mac keyboards\r\n    do have a power key. */\r\n    public static var power : Int              = 102;\r\n    public static var kp_equals : Int          = 103;\r\n    public static var f13 : Int                = 104;\r\n    public static var f14 : Int                = 105;\r\n    public static var f15 : Int                = 106;\r\n    public static var f16 : Int                = 107;\r\n    public static var f17 : Int                = 108;\r\n    public static var f18 : Int                = 109;\r\n    public static var f19 : Int                = 110;\r\n    public static var f20 : Int                = 111;\r\n    public static var f21 : Int                = 112;\r\n    public static var f22 : Int                = 113;\r\n    public static var f23 : Int                = 114;\r\n    public static var f24 : Int                = 115;\r\n    public static var execute : Int            = 116;\r\n    public static var help : Int               = 117;\r\n    public static var menu : Int               = 118;\r\n    public static var select : Int             = 119;\r\n    public static var stop : Int               = 120;\r\n\r\n/** redo */\r\n    public static var again : Int              = 121;\r\n    public static var undo : Int               = 122;\r\n    public static var cut : Int                = 123;\r\n    public static var copy : Int               = 124;\r\n    public static var paste : Int              = 125;\r\n    public static var find : Int               = 126;\r\n    public static var mute : Int               = 127;\r\n    public static var volumeup : Int           = 128;\r\n    public static var volumedown : Int         = 129;\r\n\r\n// not sure whether there's a reason to enable these\r\n//     public static var lockingcapslock = 130,\r\n//     public static var lockingnumlock = 131,\r\n//     public static var lockingscrolllock = 132,\r\n\r\n    public static var kp_comma : Int           = 133;\r\n    public static var kp_equalsas400 : Int     = 134;\r\n\r\n/** used on Asian keyboards; see footnotes in USB doc */\r\n    public static var international1 : Int     = 135;\r\n    public static var international2 : Int     = 136;\r\n\r\n/** Yen */\r\n    public static var international3 : Int     = 137;\r\n    public static var international4 : Int     = 138;\r\n    public static var international5 : Int     = 139;\r\n    public static var international6 : Int     = 140;\r\n    public static var international7 : Int     = 141;\r\n    public static var international8 : Int     = 142;\r\n    public static var international9 : Int     = 143;\r\n/** Hangul/English toggle */\r\n    public static var lang1 : Int              = 144;\r\n/** Hanja conversion */\r\n    public static var lang2 : Int              = 145;\r\n/** Katakana */\r\n    public static var lang3 : Int              = 146;\r\n/** Hiragana */\r\n    public static var lang4 : Int              = 147;\r\n/** Zenkaku/Hankaku */\r\n    public static var lang5 : Int              = 148;\r\n/** reserved */\r\n    public static var lang6 : Int              = 149;\r\n/** reserved */\r\n    public static var lang7 : Int              = 150;\r\n/** reserved */\r\n    public static var lang8 : Int              = 151;\r\n/** reserved */\r\n    public static var lang9 : Int              = 152;\r\n/** Erase-Eaze */\r\n    public static var alterase : Int           = 153;\r\n    public static var sysreq : Int             = 154;\r\n    public static var cancel : Int             = 155;\r\n    public static var clear : Int              = 156;\r\n    public static var prior : Int              = 157;\r\n    public static var return2 : Int            = 158;\r\n    public static var separator : Int          = 159;\r\n    public static var out : Int                = 160;\r\n    public static var oper : Int               = 161;\r\n    public static var clearagain : Int         = 162;\r\n    public static var crsel : Int              = 163;\r\n    public static var exsel : Int              = 164;\r\n\r\n    public static var kp_00 : Int              = 176;\r\n    public static var kp_000 : Int             = 177;\r\n    public static var thousandsseparator : Int = 178;\r\n    public static var decimalseparator : Int   = 179;\r\n    public static var currencyunit : Int       = 180;\r\n    public static var currencysubunit : Int    = 181;\r\n    public static var kp_leftparen : Int       = 182;\r\n    public static var kp_rightparen : Int      = 183;\r\n    public static var kp_leftbrace : Int       = 184;\r\n    public static var kp_rightbrace : Int      = 185;\r\n    public static var kp_tab : Int             = 186;\r\n    public static var kp_backspace : Int       = 187;\r\n    public static var kp_a : Int               = 188;\r\n    public static var kp_b : Int               = 189;\r\n    public static var kp_c : Int               = 190;\r\n    public static var kp_d : Int               = 191;\r\n    public static var kp_e : Int               = 192;\r\n    public static var kp_f : Int               = 193;\r\n    public static var kp_xor : Int             = 194;\r\n    public static var kp_power : Int           = 195;\r\n    public static var kp_percent : Int         = 196;\r\n    public static var kp_less : Int            = 197;\r\n    public static var kp_greater : Int         = 198;\r\n    public static var kp_ampersand : Int       = 199;\r\n    public static var kp_dblampersand : Int    = 200;\r\n    public static var kp_verticalbar : Int     = 201;\r\n    public static var kp_dblverticalbar : Int  = 202;\r\n    public static var kp_colon : Int           = 203;\r\n    public static var kp_hash : Int            = 204;\r\n    public static var kp_space : Int           = 205;\r\n    public static var kp_at : Int              = 206;\r\n    public static var kp_exclam : Int          = 207;\r\n    public static var kp_memstore : Int        = 208;\r\n    public static var kp_memrecall : Int       = 209;\r\n    public static var kp_memclear : Int        = 210;\r\n    public static var kp_memadd : Int          = 211;\r\n    public static var kp_memsubtract : Int     = 212;\r\n    public static var kp_memmultiply : Int     = 213;\r\n    public static var kp_memdivide : Int       = 214;\r\n    public static var kp_plusminus : Int       = 215;\r\n    public static var kp_clear : Int           = 216;\r\n    public static var kp_clearentry : Int      = 217;\r\n    public static var kp_binary : Int          = 218;\r\n    public static var kp_octal : Int           = 219;\r\n    public static var kp_decimal : Int         = 220;\r\n    public static var kp_hexadecimal : Int     = 221;\r\n\r\n    public static var lctrl : Int              = 224;\r\n    public static var lshift : Int             = 225;\r\n/** alt, option */\r\n    public static var lalt : Int               = 226;\r\n/** windows, command (apple), meta */\r\n    public static var lmeta : Int              = 227;\r\n    public static var rctrl : Int              = 228;\r\n    public static var rshift : Int             = 229;\r\n/** alt gr, option */\r\n    public static var ralt : Int               = 230;\r\n/** windows, command (apple), meta */\r\n    public static var rmeta : Int              = 231;\r\n\r\n/** Not sure if this is really not covered\r\n    by any of the above, but since there's a\r\n    special KMOD_MODE for it I'm adding it here */\r\n    public static var mode : Int               = 257;\r\n\r\n\r\n    //\r\n    //    Usage page 0x0C\r\n    //    These values are mapped from usage page 0x0C (USB consumer page).\r\n\r\n    public static var audionext : Int          = 258;\r\n    public static var audioprev : Int          = 259;\r\n    public static var audiostop : Int          = 260;\r\n    public static var audioplay : Int          = 261;\r\n    public static var audiomute : Int          = 262;\r\n    public static var mediaselect : Int        = 263;\r\n    public static var www : Int                = 264;\r\n    public static var mail : Int               = 265;\r\n    public static var calculator : Int         = 266;\r\n    public static var computer : Int           = 267;\r\n    public static var ac_search : Int          = 268;\r\n    public static var ac_home : Int            = 269;\r\n    public static var ac_back : Int            = 270;\r\n    public static var ac_forward : Int         = 271;\r\n    public static var ac_stop : Int            = 272;\r\n    public static var ac_refresh : Int         = 273;\r\n    public static var ac_bookmarks : Int       = 274;\r\n\r\n      // Walther keys\r\n      // These are values that Christian Walther added (for mac keyboard?).\r\n\r\n    public static var brightnessdown : Int     = 275;\r\n    public static var brightnessup : Int       = 276;\r\n\r\n/** display mirroring/dual display switch, video mode switch */\r\n    public static var displayswitch : Int      = 277;\r\n\r\n    public static var kbdillumtoggle : Int     = 278;\r\n    public static var kbdillumdown : Int       = 279;\r\n    public static var kbdillumup : Int         = 280;\r\n    public static var eject : Int              = 281;\r\n    public static var sleep : Int              = 282;\r\n\r\n    public static var app1 : Int               = 283;\r\n    public static var app2 : Int               = 284;\r\n\r\n    static var scancode_names:Array<String> = [\r\n        null, null, null, null,\r\n        \"A\",\r\n        \"B\",\r\n        \"C\",\r\n        \"D\",\r\n        \"E\",\r\n        \"F\",\r\n        \"G\",\r\n        \"H\",\r\n        \"I\",\r\n        \"J\",\r\n        \"K\",\r\n        \"L\",\r\n        \"M\",\r\n        \"N\",\r\n        \"O\",\r\n        \"P\",\r\n        \"Q\",\r\n        \"R\",\r\n        \"S\",\r\n        \"T\",\r\n        \"U\",\r\n        \"V\",\r\n        \"W\",\r\n        \"X\",\r\n        \"Y\",\r\n        \"Z\",\r\n        \"1\",\r\n        \"2\",\r\n        \"3\",\r\n        \"4\",\r\n        \"5\",\r\n        \"6\",\r\n        \"7\",\r\n        \"8\",\r\n        \"9\",\r\n        \"0\",\r\n        \"Enter\",\r\n        \"Escape\",\r\n        \"Backspace\",\r\n        \"Tab\",\r\n        \"Space\",\r\n        \"-\",\r\n        \"=\",\r\n        \"[\",\r\n        \"]\",\r\n        \"\\\\\",\r\n        \"#\",\r\n        \";\",\r\n        \"'\",\r\n        \"`\",\r\n        \",\",\r\n        \".\",\r\n        \"/\",\r\n        \"CapsLock\",\r\n        \"F1\",\r\n        \"F2\",\r\n        \"F3\",\r\n        \"F4\",\r\n        \"F5\",\r\n        \"F6\",\r\n        \"F7\",\r\n        \"F8\",\r\n        \"F9\",\r\n        \"F10\",\r\n        \"F11\",\r\n        \"F12\",\r\n        \"PrintScreen\",\r\n        \"ScrollLock\",\r\n        \"Pause\",\r\n        \"Insert\",\r\n        \"Home\",\r\n        \"PageUp\",\r\n        \"Delete\",\r\n        \"End\",\r\n        \"PageDown\",\r\n        \"Right\",\r\n        \"Left\",\r\n        \"Down\",\r\n        \"Up\",\r\n        \"Numlock\",\r\n        \"Keypad /\",\r\n        \"Keypad *\",\r\n        \"Keypad -\",\r\n        \"Keypad +\",\r\n        \"Keypad Enter\",\r\n        \"Keypad 1\",\r\n        \"Keypad 2\",\r\n        \"Keypad 3\",\r\n        \"Keypad 4\",\r\n        \"Keypad 5\",\r\n        \"Keypad 6\",\r\n        \"Keypad 7\",\r\n        \"Keypad 8\",\r\n        \"Keypad 9\",\r\n        \"Keypad 0\",\r\n        \"Keypad .\",\r\n        null,\r\n        \"Application\",\r\n        \"Power\",\r\n        \"Keypad =\",\r\n        \"F13\",\r\n        \"F14\",\r\n        \"F15\",\r\n        \"F16\",\r\n        \"F17\",\r\n        \"F18\",\r\n        \"F19\",\r\n        \"F20\",\r\n        \"F21\",\r\n        \"F22\",\r\n        \"F23\",\r\n        \"F24\",\r\n        \"Execute\",\r\n        \"Help\",\r\n        \"Menu\",\r\n        \"Select\",\r\n        \"Stop\",\r\n        \"Again\",\r\n        \"Undo\",\r\n        \"Cut\",\r\n        \"Copy\",\r\n        \"Paste\",\r\n        \"Find\",\r\n        \"Mute\",\r\n        \"VolumeUp\",\r\n        \"VolumeDown\",\r\n        null, null, null,\r\n        \"Keypad ,\",\r\n        \"Keypad = (AS400)\",\r\n        null, null, null, null, null, null, null, null, null, null, null, null,\r\n        null, null, null, null, null, null,\r\n        \"AltErase\",\r\n        \"SysReq\",\r\n        \"Cancel\",\r\n        \"Clear\",\r\n        \"Prior\",\r\n        \"Enter\",\r\n        \"Separator\",\r\n        \"Out\",\r\n        \"Oper\",\r\n        \"Clear / Again\",\r\n        \"CrSel\",\r\n        \"ExSel\",\r\n        null, null, null, null, null, null, null, null, null, null, null,\r\n        \"Keypad 00\",\r\n        \"Keypad 000\",\r\n        \"ThousandsSeparator\",\r\n        \"DecimalSeparator\",\r\n        \"CurrencyUnit\",\r\n        \"CurrencySubUnit\",\r\n        \"Keypad (\",\r\n        \"Keypad )\",\r\n        \"Keypad {\",\r\n        \"Keypad }\",\r\n        \"Keypad Tab\",\r\n        \"Keypad Backspace\",\r\n        \"Keypad A\",\r\n        \"Keypad B\",\r\n        \"Keypad C\",\r\n        \"Keypad D\",\r\n        \"Keypad E\",\r\n        \"Keypad F\",\r\n        \"Keypad XOR\",\r\n        \"Keypad ^\",\r\n        \"Keypad %\",\r\n        \"Keypad <\",\r\n        \"Keypad >\",\r\n        \"Keypad &\",\r\n        \"Keypad &&\",\r\n        \"Keypad |\",\r\n        \"Keypad ||\",\r\n        \"Keypad :\",\r\n        \"Keypad #\",\r\n        \"Keypad Space\",\r\n        \"Keypad @\",\r\n        \"Keypad !\",\r\n        \"Keypad MemStore\",\r\n        \"Keypad MemRecall\",\r\n        \"Keypad MemClear\",\r\n        \"Keypad MemAdd\",\r\n        \"Keypad MemSubtract\",\r\n        \"Keypad MemMultiply\",\r\n        \"Keypad MemDivide\",\r\n        \"Keypad +/-\",\r\n        \"Keypad Clear\",\r\n        \"Keypad ClearEntry\",\r\n        \"Keypad Binary\",\r\n        \"Keypad Octal\",\r\n        \"Keypad Decimal\",\r\n        \"Keypad Hexadecimal\",\r\n        null, null,\r\n        \"Left Ctrl\",\r\n        \"Left Shift\",\r\n        \"Left Alt\",\r\n        \"Left Meta\",\r\n        \"Right Ctrl\",\r\n        \"Right Shift\",\r\n        \"Right Alt\",\r\n        \"Right Meta\",\r\n        null, null, null, null, null, null, null, null, null, null, null, null,\r\n        null, null, null, null, null, null, null, null, null, null, null, null,\r\n        null,\r\n        \"ModeSwitch\",\r\n        \"AudioNext\",\r\n        \"AudioPrev\",\r\n        \"AudioStop\",\r\n        \"AudioPlay\",\r\n        \"AudioMute\",\r\n        \"MediaSelect\",\r\n        \"WWW\",\r\n        \"Mail\",\r\n        \"Calculator\",\r\n        \"Computer\",\r\n        \"AC Search\",\r\n        \"AC Home\",\r\n        \"AC Back\",\r\n        \"AC Forward\",\r\n        \"AC Stop\",\r\n        \"AC Refresh\",\r\n        \"AC Bookmarks\",\r\n        \"BrightnessDown\",\r\n        \"BrightnessUp\",\r\n        \"DisplaySwitch\",\r\n        \"KBDIllumToggle\",\r\n        \"KBDIllumDown\",\r\n        \"KBDIllumUp\",\r\n        \"Eject\",\r\n        \"Sleep\",\r\n    ]; //scancode names\r\n\r\n\r\n} //Scancodes\r\n\r\n","package snow.io;\r\n\r\nimport snow.io.IOSystem;\r\nimport snow.types.Types;\r\nimport snow.io.typedarray.Uint8Array;\r\nimport snow.utils.Promise;\r\n\r\nclass IO {\r\n\r\n\r\n    @:noCompletion public var lib : Snow;\r\n    @:noCompletion public var platform : IOSystem;\r\n\r\n        /** constructed internally, use `app.io` */\r\n    @:allow(snow.Snow)\r\n    function new( _lib:Snow ) {\r\n\r\n        lib = _lib;\r\n\r\n        platform = new IOSystem(this, lib);\r\n\r\n        platform.init();\r\n\r\n    } //new\r\n\r\n        /** Call this to open a url in the default browser */\r\n    public function url_open( _url:String ) {\r\n\r\n        platform.url_open(_url);\r\n\r\n    } //url_open\r\n\r\n        /** Load bytes from the file path/url given.\r\n            On web a request is sent for the data */\r\n    public function data_load( _path:String, ?_options:IODataOptions ) : Promise {\r\n\r\n        return platform.data_load( _path, _options );\r\n\r\n    } //data_load\r\n\r\n\r\n        /** Save bytes to the file path/url given.\r\n            On platforms where this doesn't make sense (web) this will do nothing atm */\r\n    public function data_save( _path:String, _data:Uint8Array, ?_options:IODataOptions ) : Bool {\r\n\r\n        return platform.data_save( _path, _data, _options );\r\n\r\n    } //data_save\r\n\r\n\r\n        /** Return the full path that the application is located */\r\n    public function app_path() : String {\r\n\r\n        return Snow.core.app_path();\r\n\r\n    } //app_path\r\n\r\n        /** On platforms where this makes sense, get the application specific writeable data path.\r\n            Uses the package from `SnowConfig`, passed through from flow projects or boot config. */\r\n    public function app_path_prefs() : String {\r\n\r\n        return Snow.core.app_path_prefs();\r\n\r\n    } //app_path_prefs\r\n\r\n\r\n//Internal\r\n\r\n        /** Called by Snow when a system event happens. */\r\n    @:allow(snow.Snow)\r\n    function on_event( _event:SystemEvent ) {\r\n\r\n        platform.on_event( _event );\r\n\r\n    } //on_event\r\n\r\n        /** Called by Snow, update any IO related processing */\r\n    @:allow(snow.Snow)\r\n    function update() {\r\n\r\n        platform.process();\r\n\r\n    } //update\r\n\r\n        /** Called by Snow, cleans up IO */\r\n    @:allow(snow.Snow)\r\n    function destroy() {\r\n\r\n        platform.destroy();\r\n\r\n    } //destroy\r\n\r\n\r\n} //IO\r\n","package snow.io;\r\n\r\nimport snow.utils.AbstractClass;\r\nimport snow.io.typedarray.Uint8Array;\r\nimport snow.utils.Promise;\r\n\r\nimport snow.types.Types;\r\n\r\n#if snow_web\r\n\r\n    @:noCompletion typedef IOSystem = snow.platform.web.io.IOSystem;\r\n\r\n#else\r\n\r\n    @:noCompletion typedef IOSystem = snow.platform.native.io.IOSystem;\r\n\r\n#end\r\n\r\n\r\nclass IOSystemBinding implements AbstractClass {\r\n\r\n    public var manager : IO;\r\n    public var lib : Snow;\r\n\r\n        /** Called when the IO manager initiates this system */\r\n    public function init();\r\n        /** Called when the IO manager updates this system */\r\n    public function process();\r\n        /** Called when the IO manager destroys this system */\r\n    public function destroy();\r\n        /** Called when the IO manager forwards an event to this system */\r\n    public function on_event( _event : SystemEvent );\r\n        /** Call this to open a url in the default browser */\r\n    public function url_open( _url:String );\r\n\r\n        /** Load bytes from the file path/url given.\r\n            On web a request is sent for the data */\r\n    public function data_load( _path:String, ?_options:IODataOptions ) : Promise;\r\n        /** Save bytes to the file path/url given.\r\n            On platforms where this doesn't make sense (web) this will do nothing atm */\r\n    public function data_save( _path:String, _data:Uint8Array, ?_options:IODataOptions ) : Bool;\r\n\r\n    #if desktop\r\n\r\n            /** Call this to add a directory to watch for file change notifications.\r\n                This is for directories only. Children files + sub folders children files will notify of change.\r\n                supports:`windows` `mac` `linux` only */\r\n        public function watch_add( _path:String ) : Void;\r\n            /** Call this to remove a watched directory.\r\n                supports:`windows` `mac` `linux` only */\r\n        public function watch_remove( _path:String ) : Void;\r\n            /** Call this to open a native platform file open dialog.\r\n                Returns a blank string if they cancel or any error occurs.\r\n                supports: `windows` `mac` `linux` */\r\n        public function dialog_open( ?_title:String = \"Select file\", ?_filters:Array<FileFilter> ) : String;\r\n            /** Call this to open a native platform file save dialog.\r\n                Returns a blank string if they cancel or any error occurs.\r\n                supports:`windows` `mac` `linux` */\r\n        public function dialog_save( ?_title:String = \"Save file\", ?_filter:FileFilter ) : String;\r\n            /** Call this to open a native platform folder select dialog.\r\n                Returns a blank string if they cancel or any error occurs.\r\n                supports:`windows` `mac` `linux` */\r\n        public function dialog_folder( ?_title:String = \"Select folder\" ) : String;\r\n\r\n    #end //desktop\r\n\r\n} //IOSystem\r\n","package snow.io.typedarray;\r\n\r\n#if js\r\n\r\n    @:forward\r\n    @:arrayAccess\r\n    abstract Int32Array(js.html.Int32Array)\r\n        from js.html.Int32Array\r\n        to js.html.Int32Array {\r\n\r\n        @:generic\r\n        public inline function new<T>(\r\n            ?elements:Int,\r\n            ?array:Array<T>,\r\n            ?view:ArrayBufferView,\r\n            ?buffer:ArrayBuffer, ?byteoffset:Int = 0, ?len:Null<Int>\r\n        ) {\r\n            if(elements != null) {\r\n                this = new js.html.Int32Array( elements );\r\n            } else if(array != null) {\r\n                this = new js.html.Int32Array( untyped array );\r\n            } else if(view != null) {\r\n                this = new js.html.Int32Array( untyped view );\r\n            } else if(buffer != null) {\r\n                len = (len == null) ? untyped __js__('undefined') : len;\r\n                this = new js.html.Int32Array( buffer, byteoffset, len );\r\n            } else {\r\n                this = null;\r\n            }\r\n        }\r\n\r\n        @:arrayAccess inline function __set(idx:Int, val:Int) return this[idx] = val;\r\n        @:arrayAccess inline function __get(idx:Int) : Int return this[idx];\r\n\r\n\r\n            //non spec haxe conversions\r\n        public static function fromBytes( bytes:haxe.io.Bytes, ?byteOffset:Int=0, ?len:Int ) : Int32Array {\r\n            return new js.html.Int32Array(cast bytes.getData(), byteOffset, len);\r\n        }\r\n\r\n        public function toBytes() : haxe.io.Bytes {\r\n            #if (haxe_ver < 3.2)\r\n                return @:privateAccess new haxe.io.Bytes( this.byteLength, cast new js.html.Uint8Array(this.buffer) );\r\n            #else\r\n                return @:privateAccess new haxe.io.Bytes( cast new js.html.Uint8Array(this.buffer) );\r\n            #end\r\n        }\r\n\r\n    }\r\n\r\n#else\r\n\r\n    import snow.io.typedarray.ArrayBufferView;\r\n    import snow.io.typedarray.TypedArrayType;\r\n\r\n    @:forward()\r\n    @:arrayAccess\r\n    abstract Int32Array(ArrayBufferView) from ArrayBufferView to ArrayBufferView {\r\n\r\n        public inline static var BYTES_PER_ELEMENT : Int = 4;\r\n\r\n        public var length (get, never):Int;\r\n\r\n        @:generic\r\n        public inline function new<T>(\r\n            ?elements:Int,\r\n            ?array:Array<T>,\r\n            ?view:ArrayBufferView,\r\n            ?buffer:ArrayBuffer, ?byteoffset:Int = 0, ?len:Null<Int>\r\n        ) {\r\n\r\n            if(elements != null) {\r\n                this = new ArrayBufferView( elements, Int32 );\r\n            } else if(array != null) {\r\n                this = new ArrayBufferView(0, Int32).initArray(array);\r\n            } else if(view != null) {\r\n                this = new ArrayBufferView(0, Int32).initTypedArray(view);\r\n            } else if(buffer != null) {\r\n                this = new ArrayBufferView(0, Int32).initBuffer(buffer, byteoffset, len);\r\n            } else {\r\n                throw \"Invalid constructor arguments for Int32Array\";\r\n            }\r\n        }\r\n\r\n    //Public API\r\n\r\n        public inline function subarray( begin:Int, end:Null<Int> = null) : Int32Array return this.subarray(begin, end);\r\n\r\n\r\n            //non spec haxe conversions\r\n        public static function fromBytes( bytes:haxe.io.Bytes, ?byteOffset:Int=0, ?len:Int ) : Int32Array {\r\n            return new Int32Array(bytes, byteOffset, len);\r\n        }\r\n\r\n        public function toBytes() : haxe.io.Bytes {\r\n            return this.buffer;\r\n        }\r\n\r\n    //Internal\r\n\r\n        inline function get_length() return this.length;\r\n\r\n\r\n        @:noCompletion\r\n        @:arrayAccess\r\n        public inline function __get(idx:Int) {\r\n            return ArrayBufferIO.getInt32(this.buffer, this.byteOffset+(idx*BYTES_PER_ELEMENT));\r\n        }\r\n\r\n        @:noCompletion\r\n        @:arrayAccess\r\n        public inline function __set(idx:Int, val:Int) {\r\n            return ArrayBufferIO.setInt32(this.buffer, this.byteOffset+(idx*BYTES_PER_ELEMENT), val);\r\n        }\r\n\r\n    }\r\n\r\n#end //!js\r\n","package snow.io.typedarray;\r\n\r\n#if js\r\n\r\n    @:forward\r\n    @:arrayAccess\r\n    abstract Uint8Array(js.html.Uint8Array)\r\n        from js.html.Uint8Array\r\n        to js.html.Uint8Array {\r\n\r\n        @:generic\r\n        public inline function new<T>(\r\n            ?elements:Int,\r\n            ?array:Array<T>,\r\n            ?view:ArrayBufferView,\r\n            ?buffer:ArrayBuffer, ?byteoffset:Int = 0, ?len:Null<Int>\r\n        ) {\r\n            if(elements != null) {\r\n                this = new js.html.Uint8Array( elements );\r\n            } else if(array != null) {\r\n                this = new js.html.Uint8Array( untyped array );\r\n            } else if(view != null) {\r\n                this = new js.html.Uint8Array( untyped view );\r\n            } else if(buffer != null) {\r\n                len = (len == null) ? untyped __js__('undefined') : len;\r\n                this = new js.html.Uint8Array( buffer, byteoffset, len );\r\n            } else {\r\n                this = null;\r\n            }\r\n        }\r\n\r\n        @:arrayAccess inline function __set(idx:Int, val:UInt) return this[idx] = val;\r\n        @:arrayAccess inline function __get(idx:Int) : UInt return this[idx];\r\n\r\n\r\n            //non spec haxe conversions\r\n        public static function fromBytes( bytes:haxe.io.Bytes, ?byteOffset:Int=0, ?len:Int ) : Uint8Array {\r\n            return new js.html.Uint8Array(cast bytes.getData(), byteOffset, len);\r\n        }\r\n\r\n        public function toBytes() : haxe.io.Bytes {\r\n            #if (haxe_ver < 3.2)\r\n                return @:privateAccess new haxe.io.Bytes( this.byteLength, cast new js.html.Uint8Array(this.buffer) );\r\n            #else\r\n                return @:privateAccess new haxe.io.Bytes( cast new js.html.Uint8Array(this.buffer) );\r\n            #end\r\n        }\r\n\r\n    }\r\n\r\n#else\r\n\r\n    import snow.io.typedarray.ArrayBufferView;\r\n    import snow.io.typedarray.TypedArrayType;\r\n\r\n    @:forward()\r\n    @:arrayAccess\r\n    abstract Uint8Array(ArrayBufferView) from ArrayBufferView to ArrayBufferView {\r\n\r\n        public inline static var BYTES_PER_ELEMENT : Int = 1;\r\n\r\n        public var length (get, never):Int;\r\n\r\n        @:generic\r\n        public inline function new<T>(\r\n            ?elements:Int,\r\n            ?array:Array<T>,\r\n            ?view:ArrayBufferView,\r\n            ?buffer:ArrayBuffer, ?byteoffset:Int = 0, ?len:Null<Int>\r\n        ) {\r\n\r\n            if(elements != null) {\r\n                this = new ArrayBufferView( elements, Uint8 );\r\n            } else if(array != null) {\r\n                this = new ArrayBufferView(0, Uint8).initArray(array);\r\n            } else if(view != null) {\r\n                this = new ArrayBufferView(0, Uint8).initTypedArray(view);\r\n            } else if(buffer != null) {\r\n                this = new ArrayBufferView(0, Uint8).initBuffer(buffer, byteoffset, len);\r\n            } else {\r\n                throw \"Invalid constructor arguments for Uint8Array\";\r\n            }\r\n        }\r\n\r\n    //Public API\r\n\r\n        public inline function subarray( begin:Int, end:Null<Int> = null) : Uint8Array return this.subarray(begin, end);\r\n\r\n\r\n            //non spec haxe conversions\r\n        public static function fromBytes( bytes:haxe.io.Bytes, ?byteOffset:Int=0, ?len:Int ) : Uint8Array {\r\n            return new Uint8Array(bytes, byteOffset, len);\r\n        }\r\n\r\n        public function toBytes() : haxe.io.Bytes {\r\n            return this.buffer;\r\n        }\r\n\r\n    //Internal\r\n\r\n        inline function get_length() return this.length;\r\n\r\n\r\n        @:noCompletion\r\n        @:arrayAccess\r\n        public inline function __get(idx:Int) {\r\n            return ArrayBufferIO.getUint8(this.buffer, this.byteOffset+idx);\r\n        }\r\n\r\n        @:noCompletion\r\n        @:arrayAccess\r\n        public inline function __set(idx:Int, val:UInt) {\r\n            return ArrayBufferIO.setUint8(this.buffer, this.byteOffset+idx, val);\r\n        }\r\n\r\n    }\r\n\r\n#end //!js\r\n","package snow.platform.web;\r\n\r\nimport snow.types.Types;\r\n\r\nimport snow.Log.log;\r\nimport snow.Log._debug;\r\nimport snow.Log._verbose;\r\nimport snow.Log._verboser;\r\n\r\n\r\n#if snow_web\r\n\r\n    /** Implemented in the platform specific concrete versions of this class */\r\n    @:noCompletion class Core extends snow.Core.CoreBinding {\r\n\r\n        var start_timestamp : Float = 0.0;\r\n\r\n        public function new( _app:Snow ) {\r\n\r\n            app = _app;\r\n            start_timestamp = timestamp();\r\n\r\n        } //new\r\n\r\n            /** Called by the snow internals to intiialize the core and subsystems of the framework, with the event handler passed in for where to deliver system events */\r\n        override public function init( _event_handler : SystemEvent->Void ) : Void {\r\n\r\n                //When we are done in here, start the main init procedure\r\n            app.dispatch_system_event({ type:SystemEventType.init });\r\n\r\n                //After it's had time to init, we fire the ready state\r\n            app.dispatch_system_event({ type:SystemEventType.ready });\r\n\r\n\r\n                //Then if requested, start the main loop\r\n            if(app.snow_config.has_loop) {\r\n                request_update();\r\n            }\r\n\r\n        } //init\r\n\r\n            /** Called to explicitly shutdown the framework cleanly. Called by `quit` and `app_terminated` type events by the core, for example. */\r\n        override public function shutdown() : Void {\r\n\r\n        } //shutdown\r\n\r\n            /** Get the most precise timestamp available on the platform, in seconds (time is always in seconds in snow). */\r\n        override public function timestamp() : Float {\r\n\r\n            var now : Float;\r\n\r\n            if(js.Browser.window.performance != null) {\r\n                now = js.Browser.window.performance.now()/1000.0;\r\n            } else {\r\n                now = haxe.Timer.stamp();\r\n            }\r\n\r\n            return now - start_timestamp;\r\n\r\n        } //timestamp\r\n\r\n    //Path utilities\r\n\r\n            /** Return the full path that the application is located */\r\n        override public function app_path() : String {\r\n\r\n            return haxe.io.Path.directory(js.Browser.location.href) + '/';\r\n\r\n        } //app_path\r\n\r\n        /** On platforms where this makes sense, get the application specific writeable data path.\r\n            Uses the package from `SnowConfig`, passed through from flow projects or boot config. */\r\n        override public function app_path_prefs() : String {\r\n\r\n            return './';\r\n\r\n        } //app_path_prefs\r\n\r\n\r\n    //Internal\r\n\r\n\r\n            //Internal value only, for use ONLY when request animation frame is unavailable.\r\n            //Don't use this value for anything... use the other time constructs in snow.App\r\n        @:noCompletion var _lf_timestamp : Float = 0.016;\r\n        @:noCompletion var _time_now : Float = 0.0;\r\n\r\n        function request_update() {\r\n\r\n                //If they support RAF use it, else fallback\r\n            if(js.Browser.window.requestAnimationFrame != null) {\r\n\r\n                js.Browser.window.requestAnimationFrame(snow_core_loop);\r\n\r\n            } else {\r\n\r\n                log('warning : requestAnimationFrame not found, falling back to render_rate! render_rate:' + app.host.render_rate );\r\n\r\n                    //schedule the callback again\r\n                js.Browser.window.setTimeout(function(){\r\n\r\n                        //cache the current time\r\n                    var _now = timestamp();\r\n                        //increase the time value by the time since last frame\r\n                    _time_now += (_now - _lf_timestamp);\r\n                        //call the callback, to match RAF stuff\r\n                    snow_core_loop( _time_now * 1000.0 );\r\n                        //update the last frame stamp\r\n                    _lf_timestamp = _now;\r\n\r\n                }, Std.int(app.host.render_rate*1000.0) );\r\n\r\n            } //no request anim frame\r\n\r\n        } //request_update\r\n\r\n            //This is the actual main loop code, called by RAF or setTimeout etc.\r\n        function snow_core_loop( ?_t:Float = 0.016 ) : Bool {\r\n\r\n                //internal update\r\n            update();\r\n                //dispatch the event to the framework + host\r\n            app.dispatch_system_event({ type:SystemEventType.update });\r\n                //ask for another update\r\n            request_update();\r\n                //\r\n            return true;\r\n\r\n        } //snow_core_loop\r\n\r\n        function update() {\r\n\r\n        }\r\n\r\n    } //Core\r\n\r\n#end //snow_web","package snow.platform.web.assets;\r\n\r\nimport snow.assets.Assets;\r\nimport snow.assets.AssetSystem;\r\nimport snow.types.Types;\r\n\r\nimport snow.io.typedarray.*;\r\n\r\nimport snow.platform.web.assets.tga.TGA;\r\nimport snow.platform.web.assets.psd.PSD;\r\n\r\nimport snow.Log.log;\r\nimport snow.Log._debug;\r\nimport snow.Log._verbose;\r\nimport snow.Log._verboser;\r\n\r\n#if snow_web\r\n\r\n\r\n    #if snow_audio_howlerjs\r\n        import snow.platform.web.audio.howlerjs.Howl;\r\n    #end //snow_audio_howlerjs\r\n\r\n    @:noCompletion\r\n    @:log_as('assets')\r\n    class AssetSystem extends AssetSystemBinding {\r\n\r\n        public function new( _manager:Assets ) {\r\n            manager = _manager;\r\n        }\r\n\r\n        override public function exists( _id:String, ?_strict:Bool=true ) : Bool {\r\n\r\n            if(_strict) {\r\n                return manager.listed(_id);\r\n            }\r\n\r\n            return true;\r\n\r\n        } //exists\r\n\r\n        //images\r\n\r\n            function nearest_power_of_two(_value:Int) {\r\n\r\n                _value--;\r\n\r\n                _value |= _value >> 1;\r\n                _value |= _value >> 2;\r\n                _value |= _value >> 4;\r\n                _value |= _value >> 8;\r\n                _value |= _value >> 16;\r\n\r\n                _value++;\r\n\r\n                return _value;\r\n\r\n            } //nearest_power_of_two\r\n\r\n            override public function image_load_info( _path:String, ?_components:Int = 4, ?_onload:?ImageInfo->Void ) : ImageInfo {\r\n\r\n                var ext : String = haxe.io.Path.extension(_path);\r\n\r\n                switch(ext) {\r\n                    default:\r\n                        return image_load_info_generic(_path, _components, _onload);\r\n                    case \"tga\":\r\n                        return image_load_info_tga(_path, _components, _onload);\r\n                    case \"psd\":\r\n                        return image_load_info_psd(_path, _components, _onload);\r\n                }\r\n\r\n                return null;\r\n\r\n            } //image_load_info\r\n\r\n                /** Let the browser handle this detail */\r\n            function image_load_info_generic( _path:String, ?_components:Int=4, ?_onload:?ImageInfo->Void ) : ImageInfo {\r\n\r\n                //Create an image element to load the image source\r\n                var image : js.html.ImageElement = js.Browser.document.createImageElement();\r\n                var info : ImageInfo = null;\r\n\r\n                image.onload = function(a) {\r\n\r\n                    var width_pot = nearest_power_of_two(image.width);\r\n                    var height_pot = nearest_power_of_two(image.height);\r\n                    var image_bytes = POT_Uint8Array_from_image(image.width, image.height, width_pot, height_pot, image);\r\n\r\n                    info = {\r\n                        id : _path,\r\n                        bpp : 4,\r\n                        width : image.width,\r\n                        height : image.height,\r\n                        width_actual : width_pot,\r\n                        height_actual : height_pot,\r\n                        bpp_source : 4,\r\n                        data : image_bytes\r\n                    };\r\n\r\n                        //cleanup\r\n                    image_bytes = null;\r\n\r\n                        //append the listener\r\n                    if(_onload != null) {\r\n                        _onload( info );\r\n                    }\r\n\r\n                } //image.onload\r\n\r\n                    //source comes after the onload being set, for race conditions\r\n                image.src = _path;\r\n\r\n                return info;\r\n\r\n            } //image_load_info_generic\r\n\r\n            function image_load_info_tga( _path:String, ?_components:Int=4, ?_onload:?ImageInfo->Void ) : ImageInfo {\r\n\r\n                var info : ImageInfo = null;\r\n\r\n                    var load = manager.lib.io.data_load( _path, { binary:false });\r\n                    load.then(function(uint:Uint8Array) {\r\n\r\n                        var image = new TGA();\r\n                            image.load( uint );\r\n\r\n                        var width_pot = nearest_power_of_two(image.header.width);\r\n                        var height_pot = nearest_power_of_two(image.header.height);\r\n                        var image_bytes = POT_Uint8Array_from_image(image.header.width, image.header.height, width_pot, height_pot, image.getCanvas());\r\n\r\n                            //todo: bpp?\r\n\r\n                        info = {\r\n                            id : _path,\r\n                            bpp : 4,\r\n                            width : image.header.width,\r\n                            height : image.header.height,\r\n                            width_actual : width_pot,\r\n                            height_actual : height_pot,\r\n                            bpp_source : 4,\r\n                            data : image_bytes\r\n                        };\r\n\r\n                            //cleanup\r\n                        image_bytes = null;\r\n\r\n                        if(_onload != null) {\r\n                            _onload( info );\r\n                        }\r\n\r\n                    }).error(function(e){\r\n\r\n                        if(_onload != null) {\r\n                            _onload( info );\r\n                        }\r\n\r\n                    });\r\n\r\n\r\n                return info;\r\n\r\n            } //image_load_info_tga\r\n\r\n            function POT_Uint8Array_from_image(_width:Int, _height:Int, _width_pot:Int, _height_pot:Int, _source:js.html.Element) : Uint8Array {\r\n\r\n                var tmp_canvas = js.Browser.document.createCanvasElement();\r\n\r\n                    tmp_canvas.width = _width_pot;\r\n                    tmp_canvas.height = _height_pot;\r\n\r\n                var tmp_context = tmp_canvas.getContext2d();\r\n\r\n                    tmp_context.clearRect( 0,0, tmp_canvas.width, tmp_canvas.height );\r\n                    tmp_context.drawImage( cast _source, 0, 0, _width, _height );\r\n\r\n                var image_bytes = null;\r\n\r\n                try {\r\n\r\n                    image_bytes = tmp_context.getImageData( 0, 0, tmp_canvas.width, tmp_canvas.height );\r\n\r\n                } catch(e:Dynamic) {\r\n\r\n                    var tips = '- textures served from file:/// throw security errors\\n';\r\n                        tips += '- textures served over http:// work for cross origin byte requests';\r\n\r\n                    log(tips);\r\n                    throw e;\r\n\r\n                } //catch\r\n\r\n                    //cleanup\r\n                tmp_canvas = null; tmp_context = null;\r\n\r\n                return new Uint8Array(image_bytes.data);\r\n\r\n            } //POT_Uint8Array_from_image\r\n\r\n            function image_load_info_psd(_path:String, ?_components:Int=4, ?_onload:?ImageInfo->Void ) : ImageInfo {\r\n\r\n                var info : ImageInfo = null;\r\n\r\n                    var image = new PSD();\r\n\r\n                    image.open(_path, function(psdimage){\r\n\r\n                        var png_then = function(png_image) {\r\n\r\n                            var width_pot = nearest_power_of_two(psdimage.header.width);\r\n                            var height_pot = nearest_power_of_two(psdimage.header.height);\r\n                            var image_bytes = POT_Uint8Array_from_image(psdimage.header.width, psdimage.header.height, width_pot, height_pot, png_image);\r\n\r\n                            info = {\r\n                                id : _path,\r\n                                bpp : 4,\r\n                                width : psdimage.header.width,\r\n                                height : psdimage.header.height,\r\n                                width_actual : width_pot,\r\n                                height_actual : height_pot,\r\n                                bpp_source : 4,\r\n                                data : image_bytes\r\n                            };\r\n\r\n                                //cleanup\r\n                            image_bytes = null;\r\n\r\n                                //append the listener\r\n                            if(_onload != null) {\r\n                                _onload( info );\r\n                            }\r\n\r\n                        }\r\n\r\n                        untyped psdimage.image.toPng().then(png_then);\r\n\r\n                    });\r\n\r\n                return info;\r\n\r\n            } //image_load_info_psd\r\n\r\n        override public function image_info_from_bytes( _path:String, _bytes:Uint8Array, ?_components:Int = 4 ) : ImageInfo {\r\n\r\n            #if !snow_no_format_png\r\n\r\n                if(_bytes == null) {\r\n                    log(\"invalid bytes passed to image_info_from_bytes \" + _path);\r\n                    return null;\r\n                }\r\n\r\n                    //Then we need it to be a BytesInput haxe.io.Input\r\n                var _raw_bytes = _bytes.toBytes();\r\n                    //now a byte input for format.png\r\n                var byte_input = new haxe.io.BytesInput(_raw_bytes, 0, _raw_bytes.length);\r\n                    //get the raw data\r\n                var png_reader = new snow.utils.format.png.Reader(byte_input);\r\n                    png_reader.checkCRC = false;\r\n                var png_data = png_reader.read();\r\n                    //Extract the bytes from the png reader\r\n                var png_bytes = snow.utils.format.png.Tools.extract32(png_data);\r\n                    //And the header information for infomation\r\n                var png_header = snow.utils.format.png.Tools.getHeader(png_data);\r\n\r\n                return {\r\n                    id : _path,\r\n                    bpp : _components,\r\n                    width : png_header.width,\r\n                    height : png_header.height,\r\n                    width_actual : png_header.width,\r\n                    height_actual : png_header.height,\r\n                    bpp_source : png_header.colbits,\r\n                    data : new Uint8Array(cast png_bytes.getData())\r\n                }\r\n            #else\r\n\r\n                return null;\r\n\r\n            #end\r\n\r\n        } //image_info_from_bytes\r\n\r\n        override public function audio_load_info( _path:String, ?_format:AudioFormatType, ?_load:Bool = true, ?_onload:?AudioInfo->Void ) : AudioInfo {\r\n\r\n            var info : AudioInfo = {\r\n                format:_format,\r\n                id:_path, handle:null, data:null\r\n            };\r\n\r\n            info.handle = new Howl({\r\n                urls: [_path],\r\n                    //this seems to not work as intended\r\n                    //when skipping sounds. :todo : test on server\r\n                // buffer : !_load,\r\n                onend : function() {\r\n                    manager.lib.audio.platform._on_end(info.handle);\r\n                },\r\n                onload : function(){\r\n                    if(_onload != null) {\r\n                        _onload(info);\r\n                    }\r\n                }\r\n            });\r\n\r\n            return info;\r\n\r\n        } //audio_load_info\r\n\r\n        override public function audio_info_from_bytes( _path:String, _bytes:Uint8Array, _format:AudioFormatType ) : AudioInfo {\r\n            //:todo: not implemented as this is changing in the underlying core\r\n            throw \"unimplemented\";\r\n        }\r\n\r\n    } //AssetSystem\r\n\r\n#end //snow_web\r\n","package snow.platform.web.assets.psd;\r\n\r\n/*\r\nBindings for https://github.com/meltingice/psd.js\r\nCopyright Sven Bergström\r\nCreated for http://snowkit.org/snow\r\nMIT License\r\n*/\r\n\r\nclass PSD {\r\n\r\n    var _PSD : Dynamic;\r\n\r\n    public function new() {\r\n        _PSD = untyped window.require('psd');\r\n    }\r\n\r\n    public function open( _url:String, _psd_onload:Dynamic->Void ) {\r\n\r\n        untyped _PSD.fromURL(_url).then(function(psd){ if(_psd_onload) _psd_onload(psd); });\r\n\r\n    } //open\r\n\r\n} //PSD","package snow.platform.web.audio;\r\n\r\nimport snow.audio.Audio;\r\nimport snow.audio.AudioSystem;\r\nimport snow.types.Types;\r\n\r\n\r\n@:noCompletion class AudioSystem extends AudioSystemBinding {\r\n\r\n    public function new( _manager:Audio, _lib:Snow ) {\r\n\r\n        manager = _manager;\r\n        lib = _lib;\r\n\r\n    } //new\r\n\r\n    override public function init() {\r\n\r\n    } //init\r\n\r\n    override public function process() {\r\n\r\n    } //process\r\n\r\n    override public function destroy() {\r\n\r\n    } //destroy\r\n\r\n    override public function suspend() {\r\n\r\n    } //suspend\r\n\r\n    override public function resume() {\r\n\r\n    } //resume\r\n\r\n\r\n} //AudioSystem\r\n","package snow.platform.web.audio;\r\n\r\nimport snow.audio.Audio;\r\nimport snow.types.Types;\r\n\r\n    //This is not needlessly empty, it binds an empty platform binding where no implementation exists\r\n\r\nclass Sound extends snow.audio.Sound.SoundBinding {\r\n\r\n} //Sound","package snow.platform.web.audio.howlerjs;\r\n\r\nimport snow.audio.Audio;\r\nimport snow.types.Types;\r\n\r\nimport snow.Log.log;\r\nimport snow.Log._debug;\r\nimport snow.Log._verbose;\r\nimport snow.Log._verboser;\r\n\r\n#if snow_web\r\n\r\nclass Sound extends snow.platform.web.audio.Sound {\r\n\r\n    public function new( _manager:Audio, _name:String ) {\r\n\r\n        super(_manager, _name);\r\n\r\n    } //new\r\n\r\n    override function set_info( _info:AudioInfo ) {\r\n\r\n            //if preexisting,\r\n        if(info != null) {\r\n            destroy();\r\n        }\r\n\r\n            //flag as done for gc\r\n        info = null;\r\n\r\n                //now\r\n            if(_info == null) {\r\n                log(\"not creating sound, info was null\");\r\n                return info;\r\n            }\r\n\r\n            //store the new sound\r\n        info = _info;\r\n        loaded = true;\r\n\r\n            //handle listeners\r\n        emit('load');\r\n\r\n            _debug('creating sound / ${name} / ${info.id} / ${info.format}');\r\n\r\n        return info;\r\n\r\n    } //set_info\r\n\r\n\r\n    var pan_dirty : Bool = false;\r\n    var volume_dirty : Bool = false;\r\n\r\n    override function set_pan(_pan:Float) : Float {\r\n\r\n            pan_dirty = true;\r\n\r\n        return pan = _pan;\r\n\r\n    } //set_pan\r\n\r\n    override function set_volume(_volume:Float) : Float {\r\n\r\n            volume_dirty = true;\r\n\r\n        return volume = _volume;\r\n\r\n    } //set_volume\r\n\r\n\r\n    override function set_pitch( _pitch:Float ) : Float {\r\n\r\n        untyped this.info.handle._rate = _pitch;\r\n\r\n        return pitch = _pitch;\r\n\r\n    } //set_pitch\r\n\r\n    override function set_position( _position:Float ) : Float {\r\n\r\n        if(info != null && info.handle != null) {\r\n            info.handle.pos(_position);\r\n        }\r\n\r\n        return position = _position;\r\n\r\n    } //set_position\r\n\r\n    override function get_position() : Float {\r\n\r\n        if(info != null && info.handle != null) {\r\n            return info.handle.pos();\r\n        } //has info\r\n\r\n        return position;\r\n    } //get_position\r\n\r\n        //will return 0 if the info is not set yet i.e loading\r\n    override function get_duration() : Float {\r\n\r\n        if(info != null && info.handle != null) {\r\n            return untyped this.info.handle._duration;\r\n        } //has info\r\n\r\n        return 0;\r\n\r\n    } //get_duration\r\n\r\n        /** Play this sound */\r\n    override public function play() {\r\n\r\n\r\n        if(info != null && info.handle != null) {\r\n\r\n            playing = true;\r\n            looping = false;\r\n\r\n            info.handle.loop(false);\r\n            info.handle.play();\r\n                //weird thing, howler won't set\r\n                //the pan because it can't find an active sound,\r\n                //so we simply set it immediate after playing if it changed\r\n            if(pan_dirty) {\r\n                info.handle.pos3d(pan);\r\n            }\r\n\r\n            if(volume_dirty) {\r\n                info.handle.volume(volume);\r\n            }\r\n\r\n        }  //has info\r\n\r\n    } //play\r\n\r\n        /** Loop this sound */\r\n    override public function loop() {\r\n\r\n        if(info != null && info.handle != null) {\r\n\r\n            playing = true;\r\n            looping = true;\r\n\r\n            info.handle.loop(true);\r\n            info.handle.play();\r\n\r\n                //see note in play()\r\n            if(pan_dirty) {\r\n                info.handle.pos3d(pan);\r\n            }\r\n            if(volume_dirty) {\r\n                info.handle.volume(volume);\r\n            }\r\n\r\n        } //has info\r\n\r\n    } //loop\r\n\r\n        /** Stop this sound */\r\n    override public function stop() {\r\n\r\n        playing = false;\r\n\r\n        if(info != null && info.handle != null) {\r\n            info.handle.stop();\r\n        } //\r\n\r\n    } //stop\r\n\r\n        /** Pause this sound */\r\n    override public function pause() {\r\n\r\n        if(info != null && info.handle != null) {\r\n            info.handle.pause();\r\n        } //\r\n\r\n    } //pause\r\n\r\n        /** Destroy this sound and it's data */\r\n    override public function destroy() {\r\n\r\n        if(info != null && info.handle != null) {\r\n            info.handle.unload();\r\n        } //\r\n\r\n        manager.kill(this);\r\n\r\n    } //destroy\r\n\r\n} //Sound\r\n\r\n#end //snow_web","package snow.platform.web.audio;\r\n\r\nimport snow.audio.Audio;\r\nimport snow.types.Types;\r\n\r\n\t//This is not needlessly empty, it binds an empty platform binding where no implementation exists\r\n\r\nclass SoundStream extends snow.audio.Sound {\r\n\r\n} //SoundStream\r\n","package snow.platform.web.audio.howlerjs;\r\n\r\nimport snow.audio.Audio;\r\nimport snow.types.Types;\r\n\r\n@:noCompletion class AudioSystem extends snow.platform.web.audio.AudioSystem {\r\n\r\n    var suspended_sounds : Array<Sound>;\r\n\r\n    override public function init() {\r\n\r\n        suspended_sounds = [];\r\n\r\n    } //init\r\n\r\n    override public function process() {\r\n\r\n    } //process\r\n\r\n    override public function destroy() {\r\n\r\n    } //destroy\r\n\r\n\r\n    override public function suspend() {\r\n\r\n        for(sound in manager.handles) {\r\n            if(sound.playing) {\r\n                sound.toggle();\r\n                suspended_sounds.push(sound);\r\n            }\r\n        }\r\n\r\n    } //suspend\r\n\r\n    override public function resume() {\r\n\r\n        while(suspended_sounds.length > 0) {\r\n            var sound = suspended_sounds.pop();\r\n            sound.toggle();\r\n        }\r\n\r\n    } //resume\r\n\r\n        //called by howler js as it forces specifying the on end handler\r\n        //when loading the sound... not at any point later,\r\n        //so we use this and the internal map to get a Sound and handle\r\n    public function _on_end(handle:AudioHandle) {\r\n        var sound = manager.handles.get(handle);\r\n        if(sound != null) {\r\n            sound.emit('end');\r\n        }\r\n    }\r\n\r\n} //AudioSystem\r\n","package snow.platform.web.audio.howlerjs;\r\n\r\nimport snow.audio.Audio;\r\nimport snow.types.Types;\r\n\r\nclass SoundStream extends snow.platform.web.audio.SoundStream {\r\n\r\n} //SoundStream\r\n","package snow.platform.web.input;\r\n\r\nimport snow.types.Types;\r\n\r\n@:noCompletion\r\nclass DOMKeys {\r\n\r\n        /** This function takes the DOM keycode and translates it into the\r\n            corresponding snow Keycodes value - but only if needed for special cases */\r\n    public static function dom_key_to_keycode(_keycode:Int) {\r\n\r\n        switch(_keycode) {\r\n\r\n        //\r\n            case dom_shift:         return Key.lshift;     //:todo : this is both left/right but returns left\r\n            case dom_ctrl:          return Key.lctrl;      //:todo : ^\r\n            case dom_alt:           return Key.lalt;       //:todo : ^\r\n            case dom_capslock:      return Key.capslock;\r\n        //\r\n            case dom_pageup:        return Key.pageup;\r\n            case dom_pagedown:      return Key.pagedown;\r\n            case dom_end:           return Key.end;\r\n            case dom_home:          return Key.home;\r\n            case dom_left:          return Key.left;\r\n            case dom_up:            return Key.up;\r\n            case dom_right:         return Key.right;\r\n            case dom_down:          return Key.down;\r\n            case dom_printscr:      return Key.printscreen;\r\n            case dom_insert:        return Key.insert;\r\n            case dom_delete:        return Key.delete;\r\n        //\r\n            case dom_lmeta:         return Key.lmeta;\r\n            case dom_rmeta:         return Key.rmeta;\r\n            case dom_meta:          return Key.lmeta;\r\n        //\r\n            case dom_kp_0:          return Key.kp_0;\r\n            case dom_kp_1:          return Key.kp_1;\r\n            case dom_kp_2:          return Key.kp_2;\r\n            case dom_kp_3:          return Key.kp_3;\r\n            case dom_kp_4:          return Key.kp_4;\r\n            case dom_kp_5:          return Key.kp_5;\r\n            case dom_kp_6:          return Key.kp_6;\r\n            case dom_kp_7:          return Key.kp_7;\r\n            case dom_kp_8:          return Key.kp_8;\r\n            case dom_kp_9:          return Key.kp_9;\r\n            case dom_kp_multiply:   return Key.kp_multiply;\r\n            case dom_kp_plus:       return Key.kp_plus;\r\n            case dom_kp_minus:      return Key.kp_minus;\r\n            case dom_kp_decimal:    return Key.kp_decimal;\r\n            case dom_kp_divide:     return Key.kp_divide;\r\n            case dom_kp_numlock:    return Key.numlockclear;\r\n        //\r\n            case dom_f1:            return Key.f1;\r\n            case dom_f2:            return Key.f2;\r\n            case dom_f3:            return Key.f3;\r\n            case dom_f4:            return Key.f4;\r\n            case dom_f5:            return Key.f5;\r\n            case dom_f6:            return Key.f6;\r\n            case dom_f7:            return Key.f7;\r\n            case dom_f8:            return Key.f8;\r\n            case dom_f9:            return Key.f9;\r\n            case dom_f10:           return Key.f10;\r\n            case dom_f11:           return Key.f11;\r\n            case dom_f12:           return Key.f12;\r\n            case dom_f13:           return Key.f13;\r\n            case dom_f14:           return Key.f14;\r\n            case dom_f15:           return Key.f15;\r\n            case dom_f16:           return Key.f16;\r\n            case dom_f17:           return Key.f17;\r\n            case dom_f18:           return Key.f18;\r\n            case dom_f19:           return Key.f19;\r\n            case dom_f20:           return Key.f20;\r\n            case dom_f21:           return Key.f21;\r\n            case dom_f22:           return Key.f22;\r\n            case dom_f23:           return Key.f23;\r\n            case dom_f24:           return Key.f24;\r\n        //\r\n            case dom_caret:         return Key.caret;\r\n            case dom_exclaim:       return Key.exclaim;\r\n            case dom_quotedbl:      return Key.quotedbl;\r\n            case dom_hash:          return Key.hash;\r\n            case dom_dollar:        return Key.dollar;\r\n            case dom_percent:       return Key.percent;\r\n            case dom_ampersand:     return Key.ampersand;\r\n            case dom_underscore:    return Key.underscore;\r\n            case dom_leftparen:     return Key.leftparen;\r\n            case dom_rightparen:    return Key.rightparen;\r\n            case dom_asterisk:      return Key.asterisk;\r\n            case dom_plus:          return Key.plus;\r\n            case dom_pipe:          return Key.backslash; // pipe\r\n            case dom_minus:         return Key.minus;\r\n            case dom_leftbrace:     return Key.leftbracket; // {, same code as [ on native...\r\n            case dom_rightbrace:    return Key.rightbracket; // }, same code as ] on native...\r\n            case dom_tilde:         return Key.backquote; // tilde\r\n        //\r\n            case dom_audiomute:     return Key.audiomute;\r\n            case dom_volumedown:    return Key.volumedown;\r\n            case dom_volumeup:      return Key.volumeup;\r\n        //\r\n            case dom_comma:         return Key.comma;\r\n            case dom_period:        return Key.period;\r\n            case dom_slash:         return Key.slash;\r\n            case dom_backquote:     return Key.backquote;\r\n            case dom_leftbracket:   return Key.leftbracket;\r\n            case dom_rightbracket:  return Key.rightbracket;\r\n            case dom_backslash:     return Key.backslash;\r\n            case dom_quote:         return Key.quote;\r\n\r\n        } //switch(_keycode)\r\n\r\n        return _keycode;\r\n\r\n    } //dom_key_to_keycode\r\n\r\n// the keycodes below are dom specific keycodes mapped to snow input names\r\n// these values *come from the browser* dom spec codes only, some info here\r\n// http://www.w3.org/TR/DOM-Level-3-Events/#determine-keydown-keyup-keyCode\r\n\r\n//\r\n    static inline var dom_shift          = 16;\r\n    static inline var dom_ctrl           = 17;\r\n    static inline var dom_alt            = 18;\r\n    static inline var dom_capslock       = 20;\r\n//\r\n    static inline var dom_pageup         = 33;\r\n    static inline var dom_pagedown       = 34;\r\n    static inline var dom_end            = 35;\r\n    static inline var dom_home           = 36;\r\n    static inline var dom_left           = 37;\r\n    static inline var dom_up             = 38;\r\n    static inline var dom_right          = 39;\r\n    static inline var dom_down           = 40;\r\n    static inline var dom_printscr       = 44;\r\n    static inline var dom_insert         = 45;\r\n    static inline var dom_delete         = 46;\r\n//\r\n    static inline var dom_lmeta          = 91;\r\n    static inline var dom_rmeta          = 93;\r\n//\r\n    static inline var dom_kp_0           = 96;\r\n    static inline var dom_kp_1           = 97;\r\n    static inline var dom_kp_2           = 98;\r\n    static inline var dom_kp_3           = 99;\r\n    static inline var dom_kp_4           = 100;\r\n    static inline var dom_kp_5           = 101;\r\n    static inline var dom_kp_6           = 102;\r\n    static inline var dom_kp_7           = 103;\r\n    static inline var dom_kp_8           = 104;\r\n    static inline var dom_kp_9           = 105;\r\n    static inline var dom_kp_multiply    = 106;\r\n    static inline var dom_kp_plus        = 107;\r\n    static inline var dom_kp_minus       = 109;\r\n    static inline var dom_kp_decimal     = 110;\r\n    static inline var dom_kp_divide      = 111;\r\n    static inline var dom_kp_numlock     = 144;\r\n//\r\n    static inline var dom_f1             = 112;\r\n    static inline var dom_f2             = 113;\r\n    static inline var dom_f3             = 114;\r\n    static inline var dom_f4             = 115;\r\n    static inline var dom_f5             = 116;\r\n    static inline var dom_f6             = 117;\r\n    static inline var dom_f7             = 118;\r\n    static inline var dom_f8             = 119;\r\n    static inline var dom_f9             = 120;\r\n    static inline var dom_f10            = 121;\r\n    static inline var dom_f11            = 122;\r\n    static inline var dom_f12            = 123;\r\n    static inline var dom_f13            = 124;\r\n    static inline var dom_f14            = 125;\r\n    static inline var dom_f15            = 126;\r\n    static inline var dom_f16            = 127;\r\n    static inline var dom_f17            = 128;\r\n    static inline var dom_f18            = 129;\r\n    static inline var dom_f19            = 130;\r\n    static inline var dom_f20            = 131;\r\n    static inline var dom_f21            = 132;\r\n    static inline var dom_f22            = 133;\r\n    static inline var dom_f23            = 134;\r\n    static inline var dom_f24            = 135;\r\n//\r\n    static inline var dom_caret          = 160;\r\n    static inline var dom_exclaim        = 161;\r\n    static inline var dom_quotedbl       = 162;\r\n    static inline var dom_hash           = 163;\r\n    static inline var dom_dollar         = 164;\r\n    static inline var dom_percent        = 165;\r\n    static inline var dom_ampersand      = 166;\r\n    static inline var dom_underscore     = 167;\r\n    static inline var dom_leftparen      = 168;\r\n    static inline var dom_rightparen     = 169;\r\n    static inline var dom_asterisk       = 170;\r\n    static inline var dom_plus           = 171;\r\n    static inline var dom_pipe           = 172; //backslash\r\n    static inline var dom_minus          = 173;\r\n    static inline var dom_leftbrace      = 174;\r\n    static inline var dom_rightbrace     = 175;\r\n    static inline var dom_tilde          = 176;\r\n//\r\n    static inline var dom_audiomute      = 181;\r\n    static inline var dom_volumedown     = 182;\r\n    static inline var dom_volumeup       = 183;\r\n//\r\n    static inline var dom_comma          = 188;\r\n    static inline var dom_period         = 190;\r\n    static inline var dom_slash          = 191;\r\n    static inline var dom_backquote      = 192;\r\n    static inline var dom_leftbracket    = 219;\r\n    static inline var dom_rightbracket   = 221;\r\n    static inline var dom_backslash      = 220;\r\n    static inline var dom_quote          = 222;\r\n    static inline var dom_meta           = 224;\r\n\r\n} //DOM_SDL_keys","package snow.platform.web.input;\r\n\r\nimport snow.input.Input;\r\nimport snow.input.InputSystem;\r\nimport snow.types.Types;\r\nimport snow.window.Window;\r\n\r\nimport snow.platform.web.input.DOMKeys;\r\n\r\nimport snow.Log.log;\r\nimport snow.Log._debug;\r\nimport snow.Log._verbose;\r\nimport snow.Log._verboser;\r\n\r\n\r\n#if snow_web\r\n\r\ntypedef WebGamepadButton = {\r\n    value : Float,\r\n    pressed : Bool\r\n}\r\n\r\ntypedef WebGamepad = {\r\n    axes : Array<Float>,\r\n    index : Int,\r\n    buttons : Array<WebGamepadButton>,\r\n    id : String,\r\n    timestamp : Float\r\n}\r\n\r\n\r\n@:noCompletion\r\n@:log_as('input')\r\nclass InputSystem extends InputSystemBinding {\r\n\r\n    var active_gamepads : Map<Int, WebGamepad>;\r\n    var gamepads_supported : Bool = false;\r\n\r\n \t@:noCompletion public function new( _manager:Input, _lib:Snow ) {\r\n\r\n        manager = _manager;\r\n        lib = _lib;\r\n\r\n    } //new\r\n\r\n    override public function init() {\r\n\r\n            //key input is page wide, not just per canvas\r\n        js.Browser.document.addEventListener('keypress', on_keypress);\r\n        js.Browser.document.addEventListener('keydown',  on_keydown);\r\n        js.Browser.document.addEventListener('keyup',    on_keyup);\r\n\r\n            //initialize gamepads if they exist\r\n        active_gamepads = new Map();\r\n        gamepads_supported = (get_gamepad_list() != null);\r\n\r\n        log('Gamepads supported: $gamepads_supported');\r\n\r\n    } //init\r\n\r\n    override public function process() {\r\n\r\n        if(gamepads_supported) {\r\n            poll_gamepads();\r\n        }\r\n\r\n    } //process\r\n\r\n    override public function destroy() {\r\n    } //destroy\r\n\r\n    @:noCompletion override public function listen( window:Window ) {\r\n\r\n        window.handle.addEventListener('contextmenu', on_contextmenu );\r\n\r\n        window.handle.addEventListener('mousedown',  on_mousedown);\r\n        window.handle.addEventListener('mouseup',    on_mouseup);\r\n        window.handle.addEventListener('mousemove',  on_mousemove);\r\n\r\n        window.handle.addEventListener('mousewheel', on_mousewheel);\r\n        window.handle.addEventListener('wheel',      on_mousewheel);\r\n\r\n        window.handle.addEventListener('touchstart', on_touchdown);\r\n        window.handle.addEventListener('touchend',   on_touchup);\r\n        window.handle.addEventListener('touchmove',  on_touchmove);\r\n\r\n    } //listen\r\n\r\n    @:noCompletion override public function unlisten( window:Window ) {\r\n\r\n    } //unlisten\r\n\r\n    override public function on_event( _event : InputEvent ) {\r\n    } //on_event\r\n\r\n\r\n    override public function text_input_start() {\r\n        // :unsupported: :todo:\r\n    } //text_input_start\r\n\r\n    override public function text_input_stop() {\r\n        // :unsupported: :todo:\r\n    } //text_input_stop\r\n\r\n    override public function text_input_rect(x:Int, y:Int, w:Int, h:Int) {\r\n        // :unsupported: :todo:\r\n    } //text_input_rect\r\n\r\n\r\n//Gamepad\r\n    override public function gamepad_add( id:Int ) {\r\n\r\n    } //gamepad_add\r\n\r\n    override public function gamepad_remove( id:Int ) {\r\n\r\n    } //gamepad_remove\r\n\r\n    function poll_gamepads() {\r\n\r\n        //just in case\r\n        if(!gamepads_supported) return;\r\n\r\n        var list = get_gamepad_list();\r\n        if(list != null) {\r\n            for(i in 0 ... list.length) {\r\n                if( untyped list[i] != null ) {\r\n                    handle_gamepad( untyped list[i] );\r\n                } else {\r\n                    //if an entry in the list was null,\r\n                    //check if it was here already before\r\n                    var _gamepad = active_gamepads.get(i);\r\n                    if(_gamepad != null) {\r\n\r\n                        manager.dispatch_gamepad_device_event(\r\n                            _gamepad.index,\r\n                            GamepadDeviceEventType.device_removed,\r\n                            lib.time //:todo:gamepadtimestamp:\r\n                        );\r\n\r\n                    } //_gamepad != null\r\n\r\n                        //and remove it so it only fires once\r\n                    active_gamepads.remove(i);\r\n\r\n                } //list[i] != null\r\n            } //for each in the list\r\n        } //if there is a list\r\n\r\n    } //poll_gamepads\r\n\r\n    function handle_gamepad( _gamepad : Dynamic ) {\r\n\r\n        //disconnected gamepads we don't need\r\n        if(_gamepad == null) return;\r\n\r\n            //check if this gamepad exists already\r\n        if( !active_gamepads.exists( _gamepad.index ) ) {\r\n\r\n                //if not we add it to the list\r\n            var _new_gamepad : WebGamepad = {\r\n                id : _gamepad.id,\r\n                index : _gamepad.index,\r\n                axes : [],\r\n                buttons : [],\r\n                timestamp : lib.time //:todo:gamepadtimestamp:\r\n            };\r\n\r\n            var axes : Array<Float> = cast _gamepad.axes;\r\n            for(value in axes) {\r\n                _new_gamepad.axes.push(value);\r\n            }\r\n\r\n            var _button_list : Array<WebGamepadButton> = cast _gamepad.buttons;\r\n            for(_button in _button_list) {\r\n                _new_gamepad.buttons.push({ pressed:false, value:0 });\r\n            }\r\n\r\n            active_gamepads.set( _new_gamepad.index, _new_gamepad );\r\n\r\n            manager.dispatch_gamepad_device_event(\r\n                _new_gamepad.index,\r\n                GamepadDeviceEventType.device_added,\r\n                _new_gamepad.timestamp\r\n            );\r\n\r\n        } else {\r\n\r\n                //found in the list so we can update it if anything changed\r\n            var gamepad = active_gamepads.get(_gamepad.index);\r\n\r\n                //but only if the timestamp differs :todo:gamepadtimestamp:\r\n                //failfox at least doesn't store timestamp changes -_-\r\n            // if(gamepad.timestamp != _gamepad.timestamp) {\r\n\r\n                    //update the id if it changed\r\n                if(gamepad.id != _gamepad.id) { gamepad.id = _gamepad.id; }\r\n\r\n                    //:todo: see :gamepadtimestamp:\r\n                // gamepad.timestamp = _gamepad.timestamp;\r\n\r\n                    //we store the list of changed indices\r\n                    //so we can call the handler functions with each\r\n                var axes_changed : Array<Int> = [];\r\n                var buttons_changed : Array<Int> = [];\r\n                    //the last known values\r\n                var last_axes : Array<Float> = gamepad.axes;\r\n                var last_buttons : Array<WebGamepadButton> = gamepad.buttons;\r\n\r\n                    //the new known values\r\n                var new_axes : Array<Float> = cast _gamepad.axes;\r\n                var new_buttons : Array<WebGamepadButton> = cast _gamepad.buttons;\r\n\r\n                    //check for axes changes\r\n                var axis_index : Int = 0;\r\n                for(axis in new_axes) {\r\n\r\n                    if(axis != last_axes[axis_index]) {\r\n                        axes_changed.push(axis_index);\r\n                        gamepad.axes[axis_index] = axis;\r\n                    }\r\n\r\n                    axis_index++;\r\n\r\n                } //axis in new_axes\r\n\r\n                    //check for button changes\r\n                var button_index : Int = 0;\r\n                for(button in new_buttons) {\r\n\r\n                    if( button.value != last_buttons[button_index].value ) {\r\n                        buttons_changed.push(button_index);\r\n                        gamepad.buttons[button_index].pressed = button.pressed;\r\n                        gamepad.buttons[button_index].value = button.value;\r\n                    }\r\n\r\n                    button_index++;\r\n\r\n                } //button in new_buttons\r\n\r\n                    //now forward any axis changes to the wrapper\r\n                for(index in axes_changed) {\r\n\r\n                    manager.dispatch_gamepad_axis_event(\r\n                        gamepad.index,\r\n                        index,\r\n                        new_axes[index],\r\n                        gamepad.timestamp\r\n                    );\r\n\r\n                } //for each axis changed\r\n\r\n                    //then forward any button changes to the wrapper\r\n                for(index in buttons_changed) {\r\n\r\n                    if(new_buttons[index].pressed == true) {\r\n\r\n                        manager.dispatch_gamepad_button_down_event(\r\n                            gamepad.index,\r\n                            index,\r\n                            new_buttons[index].value,\r\n                            gamepad.timestamp\r\n                        );\r\n\r\n                    } else {\r\n\r\n                        manager.dispatch_gamepad_button_up_event(\r\n                            gamepad.index,\r\n                            index,\r\n                            new_buttons[index].value,\r\n                            gamepad.timestamp\r\n                        );\r\n\r\n                    } //new_buttons[index].pressed\r\n\r\n                } //for each button change\r\n\r\n                //:todo: see :gamepadtimestamp:\r\n            // } //timestamp changed\r\n\r\n        } //exists\r\n\r\n    } //handle_gamepad\r\n\r\n    function fail_gamepads() {\r\n\r\n        gamepads_supported = false;\r\n        log(\"Gamepads are not supported in this browser :(\");\r\n\r\n    } //fail_gamepads\r\n\r\n        //It's really early for gamepads in browser\r\n    function get_gamepad_list() : Dynamic {\r\n\r\n        //Modernizr is used to detect gamepad support\r\n        var modernizr = untyped js.Browser.window.Modernizr;\r\n        if(modernizr != null) {\r\n\r\n            if(modernizr.gamepads == true) {\r\n\r\n                    //try official api first\r\n                if( untyped js.Browser.navigator.getGamepads != null ) {\r\n                    return untyped js.Browser.navigator.getGamepads();\r\n                }\r\n\r\n                    //try newer webkit GetGamepads() function\r\n                if( untyped js.Browser.navigator.webkitGetGamepads != null ) {\r\n                    return untyped js.Browser.navigator.webkitGetGamepads();\r\n                }\r\n\r\n                    //if we make it here we failed support so fail out\r\n                fail_gamepads();\r\n\r\n            } else {\r\n                fail_gamepads();\r\n            }\r\n\r\n        } //modernizr != null\r\n\r\n        return null;\r\n\r\n    } //get_gamepad_list\r\n\r\n//Mouse\r\n    function on_mousedown( _mouse_event:js.html.MouseEvent ) {\r\n\r\n        var _window : Window = lib.windowing.window_from_handle(cast _mouse_event.target);\r\n\r\n            //buttons are 1 index, on native, so we increase button\r\n        manager.dispatch_mouse_down_event(\r\n            (_mouse_event.pageX - js.Browser.window.pageXOffset) - _window.x,\r\n            (_mouse_event.pageY - js.Browser.window.pageYOffset) - _window.y,\r\n            _mouse_event.button+1,\r\n            _mouse_event.timeStamp,\r\n            _window.id\r\n        );\r\n\r\n    } //on_mousedown\r\n\r\n    function on_mouseup( _mouse_event:js.html.MouseEvent ) {\r\n\r\n        var _window : Window = lib.windowing.window_from_handle(cast _mouse_event.target);\r\n\r\n        manager.dispatch_mouse_up_event(\r\n            (_mouse_event.pageX - js.Browser.window.pageXOffset) - _window.x,\r\n            (_mouse_event.pageY - js.Browser.window.pageYOffset) - _window.y,\r\n            _mouse_event.button+1,\r\n            _mouse_event.timeStamp,\r\n            _window.id\r\n        );\r\n\r\n    } //on_mouseup\r\n\r\n    function on_mousemove( _mouse_event:js.html.MouseEvent ) {\r\n\r\n        var _window : Window = lib.windowing.window_from_handle(cast _mouse_event.target);\r\n\r\n        var _movement_x : Int = untyped _mouse_event.movementX;\r\n        var _movement_y : Int = untyped _mouse_event.movementY;\r\n\r\n        if(untyped _mouse_event.webkitMovementX != null) {\r\n            _movement_x = untyped _mouse_event.webkitMovementX;\r\n            _movement_y = untyped _mouse_event.webkitMovementY;\r\n        } else if(untyped _mouse_event.mozMovementX != null) {\r\n            _movement_x = untyped _mouse_event.mozMovementX;\r\n            _movement_y = untyped _mouse_event.mozMovementY;\r\n        }\r\n\r\n        manager.dispatch_mouse_move_event(\r\n            (_mouse_event.pageX - js.Browser.window.pageXOffset) - _window.x,\r\n            (_mouse_event.pageY - js.Browser.window.pageYOffset) - _window.y,\r\n            _movement_x,\r\n            _movement_y,\r\n            _mouse_event.timeStamp,\r\n            _window.id\r\n        );\r\n\r\n    } //on_mousemove\r\n\r\n\r\n    function on_mousewheel( _wheel_event:js.html.WheelEvent ) {\r\n\r\n        if(lib.config.web.prevent_default_mouse_wheel) {\r\n            _wheel_event.preventDefault();\r\n        }\r\n\r\n        var _window : Window = lib.windowing.window_from_handle(cast _wheel_event.target);\r\n\r\n        var _x : Int = 0;\r\n        var _y : Int = 0;\r\n\r\n            //:todo:haxe:3.2: deltaX/deltaY added in haxe 3.2.0\r\n        if(untyped _wheel_event.deltaY != null) {\r\n            _y  = untyped _wheel_event.deltaY;\r\n        } else if((untyped _wheel_event.wheelDeltaY) != null) {\r\n            _y = Std.int(-(untyped _wheel_event.wheelDeltaY)/3);\r\n        }\r\n\r\n        if(untyped _wheel_event.deltaX != null) {\r\n            _x  = untyped _wheel_event.deltaX;\r\n        } else if((untyped _wheel_event.wheelDeltaX) != null) {\r\n            _x = Std.int(-(untyped _wheel_event.wheelDeltaX)/3);\r\n        }\r\n\r\n            //the /16 here is the default em size of a web page\r\n            //because native scrolls in lines, and web scrolls in pixels,\r\n            //sometimes, fuuu\r\n        manager.dispatch_mouse_wheel_event(\r\n            Math.round(_x/16),\r\n            Math.round(_y/16),\r\n            _wheel_event.timeStamp,\r\n            _window.id\r\n        );\r\n\r\n    } //on_mousewheel\r\n\r\n    function on_contextmenu( _event:js.html.MouseEvent ) {\r\n\r\n        if(lib.config.web.no_context_menu) {\r\n            _event.preventDefault();\r\n        }\r\n\r\n    } //on_contextmenu\r\n\r\n//Keys\r\n\r\n    //window id is 1 for keys as they come from the page, so always the main window\r\n\r\n        //a list of keycodes that should not generate text\r\n        //based events because... browsers.\r\n    static var _keypress_blacklist = [Key.backspace, Key.enter];\r\n        //keypress gives us typable keys\r\n    function on_keypress( _key_event:js.html.KeyboardEvent ) {\r\n\r\n        if(_key_event.which != 0 &&\r\n           _keypress_blacklist.indexOf(_key_event.keyCode) == -1) {\r\n\r\n            var _text = String.fromCharCode(_key_event.charCode);\r\n\r\n            manager.dispatch_text_event(\r\n                _text, 0, _text.length,     //text, start, length\r\n                TextEventType.input,        //TextEventType\r\n                _key_event.timeStamp,       //timestamp\r\n                1                           //window\r\n            );\r\n\r\n        } //not special\r\n\r\n    } //on_keypress\r\n\r\n    function on_keydown( _key_event:js.html.KeyboardEvent ) {\r\n\r\n        var _keycode : Int = convert_keycode(_key_event.keyCode);\r\n        var _scancode : Int = Key.to_scan(_keycode);\r\n        var _mod_state : ModState = mod_state_from_event(_key_event);\r\n\r\n        if(lib.config.web.prevent_default_keys.indexOf(_keycode) != -1) {\r\n            _key_event.preventDefault();\r\n        }\r\n\r\n        manager.dispatch_key_down_event(\r\n            _keycode,\r\n            _scancode,\r\n            untyped _key_event.repeat,\r\n            _mod_state,\r\n            _key_event.timeStamp,\r\n            1\r\n        );\r\n\r\n    } //on_keydown\r\n\r\n    function on_keyup( _key_event:js.html.KeyboardEvent ) {\r\n\r\n\r\n        var _keycode : Int = convert_keycode(_key_event.keyCode);\r\n        var _scancode : Int = Key.to_scan(_keycode);\r\n        var _mod_state : ModState = mod_state_from_event(_key_event);\r\n\r\n        if(lib.config.web.prevent_default_keys.indexOf(_keycode) != -1) {\r\n            _key_event.preventDefault();\r\n        }\r\n\r\n        manager.dispatch_key_up_event(\r\n            _keycode,\r\n            _scancode,\r\n            untyped _key_event.repeat,\r\n            _mod_state,\r\n            _key_event.timeStamp,\r\n            1\r\n        );\r\n\r\n    } //on_keyup\r\n\r\n\tfunction mod_state_from_event( _key_event : js.html.KeyboardEvent ) : ModState {\r\n\r\n        var _none : Bool =\r\n            !_key_event.altKey &&\r\n            !_key_event.ctrlKey &&\r\n            !_key_event.metaKey &&\r\n            !_key_event.shiftKey;\r\n\r\n        return {\r\n            none    : _none,\r\n            lshift  : _key_event.shiftKey,\r\n            rshift  : _key_event.shiftKey,\r\n            lctrl   : _key_event.ctrlKey,\r\n            rctrl   : _key_event.ctrlKey,\r\n            lalt    : _key_event.altKey,\r\n            ralt    : _key_event.altKey,\r\n            lmeta   : _key_event.metaKey,\r\n            rmeta   : _key_event.metaKey,\r\n            num     : false, //:unsupported:\r\n            caps    : false, //:unsupported:\r\n            mode    : false, //:unsupported:\r\n            ctrl    : _key_event.ctrlKey,\r\n            shift   : _key_event.shiftKey,\r\n            alt     : _key_event.altKey,\r\n            meta    : _key_event.metaKey\r\n        };\r\n\r\n    } //mod_state_from_event\r\n\r\n        //This takes a *DOM* keycode and returns a snow Keycodes value\r\n    function convert_keycode(dom_keycode:Int) : Int {\r\n\r\n            //this converts the uppercase into lower case,\r\n            //since those are fixed values it doesn't need to be checked\r\n        if (dom_keycode >= 65 && dom_keycode <= 90) {\r\n            return dom_keycode + 32;\r\n        }\r\n\r\n            //this will pass back the same value if unmapped\r\n        return DOMKeys.dom_key_to_keycode(dom_keycode);\r\n\r\n    } //convert_keycode\r\n\r\n//Touch\r\n\r\n    function on_touchdown( _touch_event:js.html.TouchEvent ) {\r\n\r\n        var _window : Window = lib.windowing.window_from_handle(cast _touch_event.target);\r\n\r\n        for(touch in _touch_event.changedTouches) {\r\n\r\n            var _x:Float = (touch.pageX - js.Browser.window.pageXOffset) - _window.x;\r\n            var _y:Float = (touch.pageY - js.Browser.window.pageYOffset) - _window.y;\r\n                _x = (_x / _window.width);\r\n                _y = (_y / _window.height);\r\n\r\n            manager.dispatch_touch_down_event(\r\n                _x,\r\n                _y,\r\n                touch.identifier,\r\n                manager.lib.time\r\n            );\r\n        }\r\n    } //on_touchdown\r\n\r\n    function on_touchup( _touch_event:js.html.TouchEvent ){\r\n\r\n        var _window : Window = lib.windowing.window_from_handle(cast _touch_event.target);\r\n\r\n        for(touch in _touch_event.changedTouches) {\r\n\r\n            var _x:Float = (touch.pageX - js.Browser.window.pageXOffset) - _window.x;\r\n            var _y:Float = (touch.pageY - js.Browser.window.pageYOffset) - _window.y;\r\n                _x = (_x / _window.width);\r\n                _y = (_y / _window.height);\r\n\r\n            manager.dispatch_touch_up_event(\r\n                _x,\r\n                _y,\r\n                touch.identifier,\r\n                manager.lib.time\r\n            );\r\n        }\r\n\r\n    } //on_touchup\r\n\r\n    function on_touchmove( _touch_event:js.html.TouchEvent ){\r\n\r\n        var _window : Window = lib.windowing.window_from_handle(cast _touch_event.target);\r\n\r\n        for(touch in _touch_event.changedTouches) {\r\n\r\n            var _x:Float = (touch.pageX - js.Browser.window.pageXOffset) - _window.x;\r\n            var _y:Float = (touch.pageY - js.Browser.window.pageYOffset) - _window.y;\r\n                _x = (_x / _window.width);\r\n                _y = (_y / _window.height);\r\n\r\n            manager.dispatch_touch_move_event(\r\n                _x,\r\n                _y,\r\n                0,\r\n                0,\r\n                touch.identifier,\r\n                manager.lib.time\r\n            );\r\n        }\r\n\r\n    } //on_touchmove\r\n\r\n\r\n} //InputSystem\r\n\r\n\r\n#end //snow_web\r\n","package snow.platform.web.io;\r\n\r\nimport snow.types.Types;\r\nimport snow.io.IOSystem;\r\nimport snow.io.IO;\r\n\r\nimport snow.io.typedarray.Uint8Array;\r\nimport snow.utils.Promise;\r\n\r\n#if snow_web\r\n\r\n\r\n    class IOSystem extends IOSystemBinding {\r\n\r\n        @:noCompletion public function new( _manager:IO, _lib:Snow ) {\r\n\r\n            manager = _manager;\r\n            lib = _lib;\r\n\r\n        } //new\r\n\r\n    //Public API\r\n\r\n        override public function url_open( _url:String ) {\r\n\r\n            if(_url != null && _url.length > 0) {\r\n                js.Browser.window.open(_url, '_blank');\r\n            }\r\n\r\n        } //url_open\r\n\r\n            /** Load bytes from the file path/url given.\r\n                On web a request is sent for the data */\r\n        override public function data_load( _path:String, ?_options:IODataOptions ) : Promise {\r\n\r\n            return new Promise(function(resolve,reject) {\r\n\r\n                    //defaults\r\n                var _async = true;\r\n                var _binary = true;\r\n\r\n                if(_options != null) {\r\n                    if(_options.binary != null) _binary = _options.binary;\r\n                }\r\n\r\n                var request = new js.html.XMLHttpRequest();\r\n                    request.open(\"GET\", _path, _async);\r\n\r\n                if(_binary) {\r\n                    request.overrideMimeType('text/plain; charset=x-user-defined');\r\n                } else {\r\n                    request.overrideMimeType('text/plain; charset=UTF-8');\r\n                }\r\n\r\n                    //only _async can set the type it seems\r\n                if(_async) {\r\n                    #if (haxe_ver < 3.2)\r\n                        request.responseType = 'arraybuffer';\r\n                    #else\r\n                        request.responseType = js.html.XMLHttpRequestResponseType.ARRAYBUFFER;\r\n                    #end\r\n                }\r\n\r\n                request.onload = function(data) {\r\n\r\n                    if(request.status == 200) {\r\n                        resolve( new Uint8Array(request.response) );\r\n                    } else {\r\n                        reject('request status was ${request.status} / ${request.statusText}');\r\n                    }\r\n\r\n                } //onload\r\n\r\n                request.send();\r\n\r\n            });\r\n\r\n        } //data_load\r\n\r\n        override public function data_save( _path:String, _data:Uint8Array, ?_options:IODataOptions ) : Bool {\r\n\r\n            return false;\r\n\r\n        } //data_save\r\n\r\n    //Internal API\r\n\r\n        @:noCompletion override public function init() {\r\n        } //init\r\n        @:noCompletion override public function process() {\r\n        } //process\r\n        @:noCompletion override public function destroy() {\r\n        } //destroy\r\n        @:noCompletion override public function on_event( _event:SystemEvent ) {\r\n        } //destroy\r\n\r\n\r\n    } //IOSystem\r\n\r\n\r\n#end //snow_web","package snow.platform.web.render.opengl;\r\n\r\n#if snow_web\r\n\r\nimport js.html.webgl.RenderingContext;\r\n\r\nimport snow.io.typedarray.ArrayBuffer;\r\nimport snow.io.typedarray.ArrayBufferView;\r\nimport snow.io.typedarray.Int32Array;\r\nimport snow.io.typedarray.Float32Array;\r\n\r\n\r\ntypedef GLActiveInfo                = js.html.webgl.ActiveInfo;\r\ntypedef GLBuffer                    = js.html.webgl.Buffer;\r\ntypedef GLContextAttributes         = js.html.webgl.ContextAttributes;\r\ntypedef GLFramebuffer               = js.html.webgl.Framebuffer;\r\ntypedef GLProgram                   = js.html.webgl.Program;\r\ntypedef GLRenderbuffer              = js.html.webgl.Renderbuffer;\r\ntypedef GLShader                    = js.html.webgl.Shader;\r\ntypedef GLTexture                   = js.html.webgl.Texture;\r\ntypedef GLUniformLocation           = js.html.webgl.UniformLocation;\r\ntypedef GLShaderPrecisionFormat     = js.html.webgl.ShaderPrecisionFormat;\r\n\r\nclass GL {\r\n\r\n\r\n\r\n    public static var version(get_version, null):Int;\r\n    public static var current_context:RenderingContext;\r\n\r\n//non-spec\r\n\r\n    public static function versionString():String {\r\n\r\n        var ver = current_context.getParameter(VERSION);\r\n        var slver = current_context.getParameter(SHADING_LANGUAGE_VERSION);\r\n        var ren = current_context.getParameter(RENDERER);\r\n        var ven = current_context.getParameter(VENDOR);\r\n\r\n        return \"/ \" + ver + \" / \" + slver + \" / \" + ren + \" / \" + ven + \" /\";\r\n    }\r\n\r\n//spec\r\n\r\n    public static function activeTexture(texture:Int):Void\r\n        current_context.activeTexture(texture);\r\n\r\n    public static function attachShader(program:GLProgram, shader:GLShader):Void\r\n        current_context.attachShader(program, shader);\r\n\r\n    public static function bindAttribLocation(program:GLProgram, index:Int, name:String):Void\r\n        current_context.bindAttribLocation(program, index, name);\r\n\r\n    public static function bindBuffer(target:Int, buffer:GLBuffer):Void\r\n        current_context.bindBuffer(target, buffer);\r\n\r\n    public static function bindFramebuffer(target:Int, framebuffer:GLFramebuffer):Void\r\n        current_context.bindFramebuffer(target, framebuffer);\r\n\r\n    public static function bindRenderbuffer(target:Int, renderbuffer:GLRenderbuffer):Void\r\n        current_context.bindRenderbuffer(target, renderbuffer);\r\n\r\n    public static function bindTexture(target:Int, texture:GLTexture):Void\r\n        current_context.bindTexture(target, texture);\r\n\r\n    public static function blendColor(red:Float, green:Float, blue:Float, alpha:Float):Void\r\n        current_context.blendColor(red, green, blue, alpha);\r\n\r\n    public static function blendEquation(mode:Int):Void\r\n        current_context.blendEquation(mode);\r\n\r\n    public static function blendEquationSeparate(modeRGB:Int, modeAlpha:Int):Void\r\n        current_context.blendEquationSeparate(modeRGB, modeAlpha);\r\n\r\n    public static function blendFunc(sfactor:Int, dfactor:Int):Void\r\n        current_context.blendFunc(sfactor, dfactor);\r\n\r\n    public static function blendFuncSeparate(srcRGB:Int, dstRGB:Int, srcAlpha:Int, dstAlpha:Int):Void\r\n        current_context.blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);\r\n\r\n    public static function bufferData(target:Int, data:ArrayBufferView, usage:Int):Void\r\n        current_context.bufferData( target, data, usage );\r\n\r\n    public static function bufferSubData(target:Int, offset:Int, data:ArrayBufferView):Void\r\n        current_context.bufferSubData(target, offset, data);\r\n\r\n    public static function checkFramebufferStatus(target:Int):Int\r\n        return current_context.checkFramebufferStatus(target);\r\n\r\n    public static function clear(mask:Int):Void\r\n        current_context.clear(mask);\r\n\r\n    public static function clearColor(red:Float, green:Float, blue:Float, alpha:Float):Void\r\n        current_context.clearColor(red, green, blue, alpha);\r\n\r\n    public static function clearDepth(depth:Float):Void\r\n        current_context.clearDepth(depth);\r\n\r\n    public static function clearStencil(s:Int):Void\r\n        current_context.clearStencil(s);\r\n\r\n    public static function colorMask(red:Bool, green:Bool, blue:Bool, alpha:Bool):Void\r\n        current_context.colorMask(red, green, blue, alpha);\r\n\r\n    public static function compileShader(shader:GLShader):Void\r\n        current_context.compileShader(shader);\r\n\r\n    public static function compressedTexImage2D(target:Int, level:Int, internalformat:Int, width:Int, height:Int, border:Int, data:ArrayBufferView):Void\r\n        current_context.compressedTexImage2D(target, level, internalformat, width, height, border, data);\r\n\r\n    public static function compressedTexSubImage2D(target:Int, level:Int, xoffset:Int, yoffset:Int, width:Int, height:Int, format:Int, data:ArrayBufferView):Void\r\n        current_context.compressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, data);\r\n\r\n    public static function copyTexImage2D(target:Int, level:Int, internalformat:Int, x:Int, y:Int, width:Int, height:Int, border:Int):Void\r\n        current_context.copyTexImage2D(target, level, internalformat, x, y, width, height, border);\r\n\r\n    public static function copyTexSubImage2D(target:Int, level:Int, xoffset:Int, yoffset:Int, x:Int, y:Int, width:Int, height:Int):Void\r\n        current_context.copyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);\r\n\r\n    public static function createBuffer():GLBuffer\r\n        return current_context.createBuffer();\r\n\r\n    public static function createFramebuffer():GLFramebuffer\r\n        return current_context.createFramebuffer();\r\n\r\n    public static function createProgram():GLProgram\r\n        return current_context.createProgram();\r\n\r\n    public static function createRenderbuffer():GLRenderbuffer\r\n        return current_context.createRenderbuffer();\r\n\r\n    public static function createShader(type:Int):GLShader\r\n        return current_context.createShader(type);\r\n\r\n    public static function createTexture():GLTexture\r\n        return current_context.createTexture();\r\n\r\n    public static function cullFace(mode:Int):Void\r\n        current_context.cullFace(mode);\r\n\r\n    public static function deleteBuffer(buffer:GLBuffer):Void\r\n        current_context.deleteBuffer(buffer);\r\n\r\n    public static function deleteFramebuffer(framebuffer:GLFramebuffer):Void\r\n        current_context.deleteFramebuffer(framebuffer);\r\n\r\n    public static function deleteProgram(program:GLProgram):Void\r\n        current_context.deleteProgram(program);\r\n\r\n    public static function deleteRenderbuffer(renderbuffer:GLRenderbuffer):Void\r\n        current_context.deleteRenderbuffer(renderbuffer);\r\n\r\n    public static function deleteShader(shader:GLShader):Void\r\n        current_context.deleteShader(shader);\r\n\r\n    public static function deleteTexture(texture:GLTexture):Void\r\n        current_context.deleteTexture(texture);\r\n\r\n    public static function depthFunc(func:Int):Void\r\n        current_context.depthFunc(func);\r\n\r\n    public static function depthMask(flag:Bool):Void\r\n        current_context.depthMask(flag);\r\n\r\n    public static function depthRange(zNear:Float, zFar:Float):Void\r\n        current_context.depthRange(zNear, zFar);\r\n\r\n    public static function detachShader(program:GLProgram, shader:GLShader):Void\r\n        current_context.detachShader(program, shader);\r\n\r\n    public static function disable(cap:Int):Void\r\n        current_context.disable(cap);\r\n\r\n    public static function disableVertexAttribArray(index:Int):Void\r\n        current_context.disableVertexAttribArray(index);\r\n\r\n    public static function drawArrays(mode:Int, first:Int, count:Int):Void\r\n        current_context.drawArrays(mode, first, count);\r\n\r\n    public static function drawElements(mode:Int, count:Int, type:Int, offset:Int):Void\r\n        current_context.drawElements(mode, count, type, offset);\r\n\r\n    public static function enable(cap:Int):Void\r\n        current_context.enable(cap);\r\n\r\n    public static function enableVertexAttribArray(index:Int):Void\r\n        current_context.enableVertexAttribArray(index);\r\n\r\n    public static function finish():Void\r\n        current_context.finish();\r\n\r\n    public static function flush():Void\r\n        current_context.flush();\r\n\r\n    public static function framebufferRenderbuffer(target:Int, attachment:Int, renderbuffertarget:Int, renderbuffer:GLRenderbuffer):Void\r\n        current_context.framebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer);\r\n\r\n    public static function framebufferTexture2D(target:Int, attachment:Int, textarget:Int, texture:GLTexture, level:Int):Void\r\n        current_context.framebufferTexture2D(target, attachment, textarget, texture, level);\r\n\r\n    public static function frontFace(mode:Int):Void\r\n        current_context.frontFace(mode);\r\n\r\n    public static function generateMipmap(target:Int):Void\r\n        current_context.generateMipmap(target);\r\n\r\n    public static function getActiveAttrib(program:GLProgram, index:Int):GLActiveInfo\r\n        return current_context.getActiveAttrib(program, index);\r\n\r\n    public static function getActiveUniform(program:GLProgram, index:Int):GLActiveInfo\r\n        return current_context.getActiveUniform(program, index);\r\n\r\n    public static function getAttachedShaders(program:GLProgram):Array<GLShader>\r\n        return current_context.getAttachedShaders(program);\r\n\r\n    public static function getAttribLocation(program:GLProgram, name:String):Int\r\n        return current_context.getAttribLocation(program, name);\r\n\r\n    public static function getBufferParameter(target:Int, pname:Int):Dynamic\r\n        return current_context.getBufferParameter(target, pname);\r\n\r\n    public static function getContextAttributes():GLContextAttributes\r\n        return current_context.getContextAttributes();\r\n\r\n    public static function getError():Int\r\n        return current_context.getError();\r\n\r\n    public static function getExtension(name:String):Dynamic\r\n        return current_context.getExtension(name);\r\n\r\n    public static function getFramebufferAttachmentParameter(target:Int, attachment:Int, pname:Int):Dynamic\r\n        return current_context.getFramebufferAttachmentParameter(target, attachment, pname);\r\n\r\n    public static function getParameter(pname:Int):Dynamic\r\n        return current_context.getParameter(pname);\r\n\r\n    public static function getProgramInfoLog(program:GLProgram):String\r\n        return current_context.getProgramInfoLog(program);\r\n\r\n    public static function getProgramParameter(program:GLProgram, pname:Int):Int\r\n        return current_context.getProgramParameter(program, pname);\r\n\r\n    public static function getRenderbufferParameter(target:Int, pname:Int):Dynamic\r\n        return current_context.getRenderbufferParameter(target, pname);\r\n\r\n    public static function getShaderInfoLog(shader:GLShader):String\r\n        return current_context.getShaderInfoLog(shader);\r\n\r\n    public static function getShaderParameter(shader:GLShader, pname:Int):Int\r\n        return current_context.getShaderParameter(shader, pname);\r\n\r\n    public static function getShaderPrecisionFormat(shadertype:Int, precisiontype:Int) : GLShaderPrecisionFormat\r\n        return current_context.getShaderPrecisionFormat(shadertype, precisiontype);\r\n\r\n    public static function getShaderSource(shader:GLShader):String\r\n        return current_context.getShaderSource(shader);\r\n\r\n    public static function getSupportedExtensions() : Array<String>\r\n        return current_context.getSupportedExtensions();\r\n\r\n    public static function getTexParameter(target:Int, pname:Int):Dynamic\r\n        return current_context.getTexParameter(target, pname);\r\n\r\n    public static function getUniform(program:GLProgram, location:GLUniformLocation):Dynamic\r\n        return current_context.getUniform(program, location);\r\n\r\n    public static function getUniformLocation(program:GLProgram, name:String):GLUniformLocation\r\n        return current_context.getUniformLocation(program, name);\r\n\r\n    public static function getVertexAttrib(index:Int, pname:Int):Dynamic\r\n        return current_context.getVertexAttrib(index, pname);\r\n\r\n    public static function getVertexAttribOffset(index:Int, pname:Int):Int\r\n        return current_context.getVertexAttribOffset(index, pname);\r\n\r\n    public static function hint(target:Int, mode:Int):Void\r\n        current_context.hint(target, mode);\r\n\r\n    public static function isBuffer(buffer:GLBuffer):Bool\r\n        return current_context.isBuffer(buffer);\r\n\r\n    // This is non-static\r\n    // public function isContextLost():Bool { return false; }\r\n\r\n    public static function isEnabled(cap:Int):Bool\r\n        return current_context.isEnabled(cap);\r\n\r\n    public static function isFramebuffer(framebuffer:GLFramebuffer):Bool\r\n        return current_context.isFramebuffer(framebuffer);\r\n\r\n    public static function isProgram(program:GLProgram):Bool\r\n        return current_context.isProgram(program);\r\n\r\n    public static function isRenderbuffer(renderbuffer:GLRenderbuffer):Bool\r\n        return current_context.isRenderbuffer(renderbuffer);\r\n\r\n    public static function isShader(shader:GLShader):Bool\r\n        return current_context.isShader(shader);\r\n\r\n    public static function isTexture(texture:GLTexture):Bool\r\n        return current_context.isTexture(texture);\r\n\r\n    public static function lineWidth(width:Float):Void\r\n        current_context.lineWidth(width);\r\n\r\n    public static function linkProgram(program:GLProgram):Void\r\n        current_context.linkProgram(program);\r\n\r\n    public static function pixelStorei(pname:Int, param:Int):Void\r\n        current_context.pixelStorei(pname, param);\r\n\r\n    public static function polygonOffset(factor:Float, units:Float):Void\r\n        current_context.polygonOffset(factor, units);\r\n\r\n        // TODO: pixels? May need setting to work (canvas.getContext(\"experimental-webgl\", {preserveDrawingBuffer: true});)\r\n    public static function readPixels(x:Int, y:Int, width:Int, height:Int, format:Int, type:Int, data:ArrayBufferView):Void\r\n        current_context.readPixels(x, y, width, height, format, type, data);\r\n\r\n    public static function renderbufferStorage(target:Int, internalformat:Int, width:Int, height:Int):Void\r\n        current_context.renderbufferStorage(target, internalformat, width, height);\r\n\r\n    public static function sampleCoverage(value:Float, invert:Bool):Void\r\n        current_context.sampleCoverage(value, invert);\r\n\r\n    public static function scissor(x:Int, y:Int, width:Int, height:Int):Void\r\n        current_context.scissor(x, y, width, height);\r\n\r\n    public static function shaderSource(shader:GLShader, source:String):Void\r\n        current_context.shaderSource(shader, source);\r\n\r\n    public static function stencilFunc(func:Int, ref:Int, mask:Int):Void\r\n        current_context.stencilFunc(func, ref, mask);\r\n\r\n    public static function stencilFuncSeparate(face:Int, func:Int, ref:Int, mask:Int):Void\r\n        current_context.stencilFuncSeparate(face, func, ref, mask);\r\n\r\n    public static function stencilMask(mask:Int):Void\r\n        current_context.stencilMask(mask);\r\n\r\n    public static function stencilMaskSeparate(face:Int, mask:Int):Void\r\n        current_context.stencilMaskSeparate(face, mask);\r\n\r\n    public static function stencilOp(fail:Int, zfail:Int, zpass:Int):Void\r\n        current_context.stencilOp(fail, zfail, zpass);\r\n\r\n    public static function stencilOpSeparate(face:Int, fail:Int, zfail:Int, zpass:Int):Void\r\n        current_context.stencilOpSeparate(face, fail, zfail, zpass);\r\n\r\n    public static function texImage2D(target:Int, level:Int, internalformat:Int, width:Int, height:Int, border:Int, format:Int, type:Int, data:ArrayBufferView):Void\r\n        current_context.texImage2D(target, level, internalformat, width, height, border, format, type, data);\r\n\r\n    public static function texParameterf(target:Int, pname:Int, param:Float):Void\r\n        current_context.texParameterf(target, pname, param);\r\n\r\n    public static function texParameteri(target:Int, pname:Int, param:Int):Void\r\n        current_context.texParameteri(target, pname, param);\r\n\r\n    public static function texSubImage2D(target:Int, level:Int, xoffset:Int, yoffset:Int, width:Int, height:Int, format:Int, type:Int, data:ArrayBufferView):Void\r\n        current_context.texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, data);\r\n\r\n    public static function uniform1f(location:GLUniformLocation, x:Float):Void\r\n        current_context.uniform1f(location, x);\r\n\r\n    public static function uniform1fv(location:GLUniformLocation, data:Float32Array):Void\r\n        current_context.uniform1fv(location, data);\r\n\r\n    public static function uniform1i(location:GLUniformLocation, x:Int):Void\r\n        current_context.uniform1i(location, x);\r\n\r\n    public static function uniform1iv(location:GLUniformLocation, data:Int32Array):Void\r\n        current_context.uniform1iv(location, data);\r\n\r\n    public static function uniform2f(location:GLUniformLocation, x:Float, y:Float):Void\r\n        current_context.uniform2f(location, x, y);\r\n\r\n    public static function uniform2fv(location:GLUniformLocation, data:Float32Array):Void\r\n        current_context.uniform2fv(location, data);\r\n\r\n    public static function uniform2i(location:GLUniformLocation, x:Int, y:Int):Void\r\n        current_context.uniform2i(location, x, y);\r\n\r\n    public static function uniform2iv(location:GLUniformLocation, data:Int32Array):Void\r\n        current_context.uniform2iv(location, data);\r\n\r\n    public static function uniform3f(location:GLUniformLocation, x:Float, y:Float, z:Float):Void\r\n        current_context.uniform3f(location, x, y, z);\r\n\r\n    public static function uniform3fv(location:GLUniformLocation, data:Float32Array):Void\r\n        current_context.uniform3fv(location, data);\r\n\r\n    public static function uniform3i(location:GLUniformLocation, x:Int, y:Int, z:Int):Void\r\n        current_context.uniform3i(location, x, y, z);\r\n\r\n    public static function uniform3iv(location:GLUniformLocation, data:Int32Array):Void\r\n        current_context.uniform3iv(location, data);\r\n\r\n    public static function uniform4f(location:GLUniformLocation, x:Float, y:Float, z:Float, w:Float):Void\r\n        current_context.uniform4f(location, x, y, z, w);\r\n\r\n    public static function uniform4fv(location:GLUniformLocation, data:Float32Array):Void\r\n        current_context.uniform4fv(location, data);\r\n\r\n    public static function uniform4i(location:GLUniformLocation, x:Int, y:Int, z:Int, w:Int):Void\r\n        current_context.uniform4i(location, x, y, z, w);\r\n\r\n    public static function uniform4iv(location:GLUniformLocation, data:Int32Array):Void\r\n        current_context.uniform4iv(location, data);\r\n\r\n    public static function uniformMatrix2fv(location:GLUniformLocation, transpose:Bool, data:Float32Array):Void\r\n        current_context.uniformMatrix2fv(location, transpose, data);\r\n\r\n    public static function uniformMatrix3fv(location:GLUniformLocation, transpose:Bool, data:Float32Array):Void\r\n        current_context.uniformMatrix3fv(location, transpose, data);\r\n\r\n    public static function uniformMatrix4fv(location:GLUniformLocation, transpose:Bool, data:Float32Array):Void\r\n        current_context.uniformMatrix4fv(location, transpose, data);\r\n\r\n    public static function useProgram(program:GLProgram):Void\r\n        current_context.useProgram(program);\r\n\r\n    public static function validateProgram(program:GLProgram):Void\r\n        current_context.validateProgram(program);\r\n\r\n    public static function vertexAttrib1f(indx:Int, x:Float):Void\r\n        current_context.vertexAttrib1f(indx, x);\r\n\r\n    public static function vertexAttrib1fv(indx:Int, data:Float32Array):Void\r\n        current_context.vertexAttrib1fv(indx, data);\r\n\r\n    public static function vertexAttrib2f(indx:Int, x:Float, y:Float):Void\r\n        current_context.vertexAttrib2f(indx, x, y);\r\n\r\n    public static function vertexAttrib2fv(indx:Int, data:Float32Array):Void\r\n        current_context.vertexAttrib2fv(indx, data);\r\n\r\n    public static function vertexAttrib3f(indx:Int, x:Float, y:Float, z:Float):Void\r\n        current_context.vertexAttrib3f(indx, x, y, z);\r\n\r\n    public static function vertexAttrib3fv(indx:Int, data:Float32Array):Void\r\n        current_context.vertexAttrib3fv(indx, data);\r\n\r\n    public static function vertexAttrib4f(indx:Int, x:Float, y:Float, z:Float, w:Float):Void\r\n        current_context.vertexAttrib4f(indx, x, y, z, w);\r\n\r\n    public static function vertexAttrib4fv(indx:Int, data:Float32Array):Void\r\n        current_context.vertexAttrib4fv(indx, data);\r\n\r\n    public static function vertexAttribPointer(indx:Int, size:Int, type:Int, normalized:Bool, stride:Int, offset:Int):Void\r\n        current_context.vertexAttribPointer(indx, size, type, normalized, stride, offset);\r\n\r\n    public static function viewport(x:Int, y:Int, width:Int, height:Int):Void\r\n        current_context.viewport(x, y, width, height);\r\n\r\n\r\n// getters/setters\r\n\r\n    static function get_version():Int { return RenderingContext.VERSION; }\r\n\r\n//defines\r\n\r\n    /* ClearBufferMask */\r\n    public static inline var DEPTH_BUFFER_BIT               = 0x00000100;\r\n    public static inline var STENCIL_BUFFER_BIT             = 0x00000400;\r\n    public static inline var COLOR_BUFFER_BIT               = 0x00004000;\r\n\r\n    /* BeginMode */\r\n    public static inline var POINTS                         = 0x0000;\r\n    public static inline var LINES                          = 0x0001;\r\n    public static inline var LINE_LOOP                      = 0x0002;\r\n    public static inline var LINE_STRIP                     = 0x0003;\r\n    public static inline var TRIANGLES                      = 0x0004;\r\n    public static inline var TRIANGLE_STRIP                 = 0x0005;\r\n    public static inline var TRIANGLE_FAN                   = 0x0006;\r\n\r\n    /* AlphaFunction(not supported in ES20) */\r\n    /*      NEVER */\r\n    /*      LESS */\r\n    /*      EQUAL */\r\n    /*      LEQUAL */\r\n    /*      GREATER */\r\n    /*      NOTEQUAL */\r\n    /*      GEQUAL */\r\n    /*      ALWAYS */\r\n\r\n    /* BlendingFactorDest */\r\n    public static inline var ZERO                           = 0;\r\n    public static inline var ONE                            = 1;\r\n    public static inline var SRC_COLOR                      = 0x0300;\r\n    public static inline var ONE_MINUS_SRC_COLOR            = 0x0301;\r\n    public static inline var SRC_ALPHA                      = 0x0302;\r\n    public static inline var ONE_MINUS_SRC_ALPHA            = 0x0303;\r\n    public static inline var DST_ALPHA                      = 0x0304;\r\n    public static inline var ONE_MINUS_DST_ALPHA            = 0x0305;\r\n\r\n    /* BlendingFactorSrc */\r\n    /*      ZERO */\r\n    /*      ONE */\r\n    public static inline var DST_COLOR                      = 0x0306;\r\n    public static inline var ONE_MINUS_DST_COLOR            = 0x0307;\r\n    public static inline var SRC_ALPHA_SATURATE             = 0x0308;\r\n    /*      SRC_ALPHA */\r\n    /*      ONE_MINUS_SRC_ALPHA */\r\n    /*      DST_ALPHA */\r\n    /*      ONE_MINUS_DST_ALPHA */\r\n\r\n    /* BlendEquationSeparate */\r\n    public static inline var FUNC_ADD                       = 0x8006;\r\n    public static inline var BLEND_EQUATION                 = 0x8009;\r\n    public static inline var BLEND_EQUATION_RGB             = 0x8009;   /* same as BLEND_EQUATION */\r\n    public static inline var BLEND_EQUATION_ALPHA           = 0x883D;\r\n\r\n    /* BlendSubtract */\r\n    public static inline var FUNC_SUBTRACT                  = 0x800A;\r\n    public static inline var FUNC_REVERSE_SUBTRACT          = 0x800B;\r\n\r\n    /* Separate Blend Functions */\r\n    public static inline var BLEND_DST_RGB                  = 0x80C8;\r\n    public static inline var BLEND_SRC_RGB                  = 0x80C9;\r\n    public static inline var BLEND_DST_ALPHA                = 0x80CA;\r\n    public static inline var BLEND_SRC_ALPHA                = 0x80CB;\r\n    public static inline var CONSTANT_COLOR                 = 0x8001;\r\n    public static inline var ONE_MINUS_CONSTANT_COLOR       = 0x8002;\r\n    public static inline var CONSTANT_ALPHA                 = 0x8003;\r\n    public static inline var ONE_MINUS_CONSTANT_ALPHA       = 0x8004;\r\n    public static inline var BLEND_COLOR                    = 0x8005;\r\n\r\n    /* GLBuffer Objects */\r\n    public static inline var ARRAY_BUFFER                   = 0x8892;\r\n    public static inline var ELEMENT_ARRAY_BUFFER           = 0x8893;\r\n    public static inline var ARRAY_BUFFER_BINDING           = 0x8894;\r\n    public static inline var ELEMENT_ARRAY_BUFFER_BINDING   = 0x8895;\r\n\r\n    public static inline var STREAM_DRAW                    = 0x88E0;\r\n    public static inline var STATIC_DRAW                    = 0x88E4;\r\n    public static inline var DYNAMIC_DRAW                   = 0x88E8;\r\n\r\n    public static inline var BUFFER_SIZE                    = 0x8764;\r\n    public static inline var BUFFER_USAGE                   = 0x8765;\r\n\r\n    public static inline var CURRENT_VERTEX_ATTRIB          = 0x8626;\r\n\r\n    /* CullFaceMode */\r\n    public static inline var FRONT                          = 0x0404;\r\n    public static inline var BACK                           = 0x0405;\r\n    public static inline var FRONT_AND_BACK                 = 0x0408;\r\n\r\n    /* DepthFunction */\r\n    /*      NEVER */\r\n    /*      LESS */\r\n    /*      EQUAL */\r\n    /*      LEQUAL */\r\n    /*      GREATER */\r\n    /*      NOTEQUAL */\r\n    /*      GEQUAL */\r\n    /*      ALWAYS */\r\n\r\n    /* EnableCap */\r\n    /* TEXTURE_2D */\r\n    public static inline var CULL_FACE                      = 0x0B44;\r\n    public static inline var BLEND                          = 0x0BE2;\r\n    public static inline var DITHER                         = 0x0BD0;\r\n    public static inline var STENCIL_TEST                   = 0x0B90;\r\n    public static inline var DEPTH_TEST                     = 0x0B71;\r\n    public static inline var SCISSOR_TEST                   = 0x0C11;\r\n    public static inline var POLYGON_OFFSET_FILL            = 0x8037;\r\n    public static inline var SAMPLE_ALPHA_TO_COVERAGE       = 0x809E;\r\n    public static inline var SAMPLE_COVERAGE                = 0x80A0;\r\n\r\n    /* ErrorCode */\r\n    public static inline var NO_ERROR                       = 0;\r\n    public static inline var INVALID_ENUM                   = 0x0500;\r\n    public static inline var INVALID_VALUE                  = 0x0501;\r\n    public static inline var INVALID_OPERATION              = 0x0502;\r\n    public static inline var OUT_OF_MEMORY                  = 0x0505;\r\n\r\n    /* FrontFaceDirection */\r\n    public static inline var CW                             = 0x0900;\r\n    public static inline var CCW                            = 0x0901;\r\n\r\n    /* GetPName */\r\n    public static inline var LINE_WIDTH                     = 0x0B21;\r\n    public static inline var ALIASED_POINT_SIZE_RANGE       = 0x846D;\r\n    public static inline var ALIASED_LINE_WIDTH_RANGE       = 0x846E;\r\n    public static inline var CULL_FACE_MODE                 = 0x0B45;\r\n    public static inline var FRONT_FACE                     = 0x0B46;\r\n    public static inline var DEPTH_RANGE                    = 0x0B70;\r\n    public static inline var DEPTH_WRITEMASK                = 0x0B72;\r\n    public static inline var DEPTH_CLEAR_VALUE              = 0x0B73;\r\n    public static inline var DEPTH_FUNC                     = 0x0B74;\r\n    public static inline var STENCIL_CLEAR_VALUE            = 0x0B91;\r\n    public static inline var STENCIL_FUNC                   = 0x0B92;\r\n    public static inline var STENCIL_FAIL                   = 0x0B94;\r\n    public static inline var STENCIL_PASS_DEPTH_FAIL        = 0x0B95;\r\n    public static inline var STENCIL_PASS_DEPTH_PASS        = 0x0B96;\r\n    public static inline var STENCIL_REF                    = 0x0B97;\r\n    public static inline var STENCIL_VALUE_MASK             = 0x0B93;\r\n    public static inline var STENCIL_WRITEMASK              = 0x0B98;\r\n    public static inline var STENCIL_BACK_FUNC              = 0x8800;\r\n    public static inline var STENCIL_BACK_FAIL              = 0x8801;\r\n    public static inline var STENCIL_BACK_PASS_DEPTH_FAIL   = 0x8802;\r\n    public static inline var STENCIL_BACK_PASS_DEPTH_PASS   = 0x8803;\r\n    public static inline var STENCIL_BACK_REF               = 0x8CA3;\r\n    public static inline var STENCIL_BACK_VALUE_MASK        = 0x8CA4;\r\n    public static inline var STENCIL_BACK_WRITEMASK         = 0x8CA5;\r\n    public static inline var VIEWPORT                       = 0x0BA2;\r\n    public static inline var SCISSOR_BOX                    = 0x0C10;\r\n    /*      SCISSOR_TEST */\r\n    public static inline var COLOR_CLEAR_VALUE              = 0x0C22;\r\n    public static inline var COLOR_WRITEMASK                = 0x0C23;\r\n    public static inline var UNPACK_ALIGNMENT               = 0x0CF5;\r\n    public static inline var PACK_ALIGNMENT                 = 0x0D05;\r\n    public static inline var MAX_TEXTURE_SIZE               = 0x0D33;\r\n    public static inline var MAX_VIEWPORT_DIMS              = 0x0D3A;\r\n    public static inline var SUBPIXEL_BITS                  = 0x0D50;\r\n    public static inline var RED_BITS                       = 0x0D52;\r\n    public static inline var GREEN_BITS                     = 0x0D53;\r\n    public static inline var BLUE_BITS                      = 0x0D54;\r\n    public static inline var ALPHA_BITS                     = 0x0D55;\r\n    public static inline var DEPTH_BITS                     = 0x0D56;\r\n    public static inline var STENCIL_BITS                   = 0x0D57;\r\n    public static inline var POLYGON_OFFSET_UNITS           = 0x2A00;\r\n    /*      POLYGON_OFFSET_FILL */\r\n    public static inline var POLYGON_OFFSET_FACTOR          = 0x8038;\r\n    public static inline var TEXTURE_BINDING_2D             = 0x8069;\r\n    public static inline var SAMPLE_BUFFERS                 = 0x80A8;\r\n    public static inline var SAMPLES                        = 0x80A9;\r\n    public static inline var SAMPLE_COVERAGE_VALUE          = 0x80AA;\r\n    public static inline var SAMPLE_COVERAGE_INVERT         = 0x80AB;\r\n\r\n    /* GetTextureParameter */\r\n    /*      TEXTURE_MAG_FILTER */\r\n    /*      TEXTURE_MIN_FILTER */\r\n    /*      TEXTURE_WRAP_S */\r\n    /*      TEXTURE_WRAP_T */\r\n\r\n    public static inline var COMPRESSED_TEXTURE_FORMATS     = 0x86A3;\r\n\r\n    /* HintMode */\r\n    public static inline var DONT_CARE                      = 0x1100;\r\n    public static inline var FASTEST                        = 0x1101;\r\n    public static inline var NICEST                         = 0x1102;\r\n\r\n    /* HintTarget */\r\n    public static inline var GENERATE_MIPMAP_HINT            = 0x8192;\r\n\r\n    /* DataType */\r\n    public static inline var BYTE                           = 0x1400;\r\n    public static inline var UNSIGNED_BYTE                  = 0x1401;\r\n    public static inline var SHORT                          = 0x1402;\r\n    public static inline var UNSIGNED_SHORT                 = 0x1403;\r\n    public static inline var INT                            = 0x1404;\r\n    public static inline var UNSIGNED_INT                   = 0x1405;\r\n    public static inline var FLOAT                          = 0x1406;\r\n\r\n    /* PixelFormat */\r\n    public static inline var DEPTH_COMPONENT                = 0x1902;\r\n    public static inline var ALPHA                          = 0x1906;\r\n    public static inline var RGB                            = 0x1907;\r\n    public static inline var RGBA                           = 0x1908;\r\n    public static inline var LUMINANCE                      = 0x1909;\r\n    public static inline var LUMINANCE_ALPHA                = 0x190A;\r\n\r\n    /* PixelType */\r\n    /*      UNSIGNED_BYTE */\r\n    public static inline var UNSIGNED_SHORT_4_4_4_4         = 0x8033;\r\n    public static inline var UNSIGNED_SHORT_5_5_5_1         = 0x8034;\r\n    public static inline var UNSIGNED_SHORT_5_6_5           = 0x8363;\r\n\r\n    /* Shaders */\r\n    public static inline var FRAGMENT_SHADER                  = 0x8B30;\r\n    public static inline var VERTEX_SHADER                    = 0x8B31;\r\n    public static inline var MAX_VERTEX_ATTRIBS               = 0x8869;\r\n    public static inline var MAX_VERTEX_UNIFORM_VECTORS       = 0x8DFB;\r\n    public static inline var MAX_VARYING_VECTORS              = 0x8DFC;\r\n    public static inline var MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D;\r\n    public static inline var MAX_VERTEX_TEXTURE_IMAGE_UNITS   = 0x8B4C;\r\n    public static inline var MAX_TEXTURE_IMAGE_UNITS          = 0x8872;\r\n    public static inline var MAX_FRAGMENT_UNIFORM_VECTORS     = 0x8DFD;\r\n    public static inline var SHADER_TYPE                      = 0x8B4F;\r\n    public static inline var DELETE_STATUS                    = 0x8B80;\r\n    public static inline var LINK_STATUS                      = 0x8B82;\r\n    public static inline var VALIDATE_STATUS                  = 0x8B83;\r\n    public static inline var ATTACHED_SHADERS                 = 0x8B85;\r\n    public static inline var ACTIVE_UNIFORMS                  = 0x8B86;\r\n    public static inline var ACTIVE_ATTRIBUTES                = 0x8B89;\r\n    public static inline var SHADING_LANGUAGE_VERSION         = 0x8B8C;\r\n    public static inline var CURRENT_PROGRAM                  = 0x8B8D;\r\n\r\n    /* StencilFunction */\r\n    public static inline var NEVER                          = 0x0200;\r\n    public static inline var LESS                           = 0x0201;\r\n    public static inline var EQUAL                          = 0x0202;\r\n    public static inline var LEQUAL                         = 0x0203;\r\n    public static inline var GREATER                        = 0x0204;\r\n    public static inline var NOTEQUAL                       = 0x0205;\r\n    public static inline var GEQUAL                         = 0x0206;\r\n    public static inline var ALWAYS                         = 0x0207;\r\n\r\n    /* StencilOp */\r\n    /*      ZERO */\r\n    public static inline var KEEP                           = 0x1E00;\r\n    public static inline var REPLACE                        = 0x1E01;\r\n    public static inline var INCR                           = 0x1E02;\r\n    public static inline var DECR                           = 0x1E03;\r\n    public static inline var INVERT                         = 0x150A;\r\n    public static inline var INCR_WRAP                      = 0x8507;\r\n    public static inline var DECR_WRAP                      = 0x8508;\r\n\r\n    /* StringName */\r\n    public static inline var VENDOR                         = 0x1F00;\r\n    public static inline var RENDERER                       = 0x1F01;\r\n    public static inline var VERSION                        = 0x1F02;\r\n\r\n    /* TextureMagFilter */\r\n    public static inline var NEAREST                        = 0x2600;\r\n    public static inline var LINEAR                         = 0x2601;\r\n\r\n    /* TextureMinFilter */\r\n    /*      NEAREST */\r\n    /*      LINEAR */\r\n    public static inline var NEAREST_MIPMAP_NEAREST         = 0x2700;\r\n    public static inline var LINEAR_MIPMAP_NEAREST          = 0x2701;\r\n    public static inline var NEAREST_MIPMAP_LINEAR          = 0x2702;\r\n    public static inline var LINEAR_MIPMAP_LINEAR           = 0x2703;\r\n\r\n    /* TextureParameterName */\r\n    public static inline var TEXTURE_MAG_FILTER             = 0x2800;\r\n    public static inline var TEXTURE_MIN_FILTER             = 0x2801;\r\n    public static inline var TEXTURE_WRAP_S                 = 0x2802;\r\n    public static inline var TEXTURE_WRAP_T                 = 0x2803;\r\n\r\n    /* TextureTarget */\r\n    public static inline var TEXTURE_2D                     = 0x0DE1;\r\n    public static inline var TEXTURE                        = 0x1702;\r\n\r\n    public static inline var TEXTURE_CUBE_MAP               = 0x8513;\r\n    public static inline var TEXTURE_BINDING_CUBE_MAP       = 0x8514;\r\n    public static inline var TEXTURE_CUBE_MAP_POSITIVE_X    = 0x8515;\r\n    public static inline var TEXTURE_CUBE_MAP_NEGATIVE_X    = 0x8516;\r\n    public static inline var TEXTURE_CUBE_MAP_POSITIVE_Y    = 0x8517;\r\n    public static inline var TEXTURE_CUBE_MAP_NEGATIVE_Y    = 0x8518;\r\n    public static inline var TEXTURE_CUBE_MAP_POSITIVE_Z    = 0x8519;\r\n    public static inline var TEXTURE_CUBE_MAP_NEGATIVE_Z    = 0x851A;\r\n    public static inline var MAX_CUBE_MAP_TEXTURE_SIZE      = 0x851C;\r\n\r\n    /* TextureUnit */\r\n    public static inline var TEXTURE0                       = 0x84C0;\r\n    public static inline var TEXTURE1                       = 0x84C1;\r\n    public static inline var TEXTURE2                       = 0x84C2;\r\n    public static inline var TEXTURE3                       = 0x84C3;\r\n    public static inline var TEXTURE4                       = 0x84C4;\r\n    public static inline var TEXTURE5                       = 0x84C5;\r\n    public static inline var TEXTURE6                       = 0x84C6;\r\n    public static inline var TEXTURE7                       = 0x84C7;\r\n    public static inline var TEXTURE8                       = 0x84C8;\r\n    public static inline var TEXTURE9                       = 0x84C9;\r\n    public static inline var TEXTURE10                      = 0x84CA;\r\n    public static inline var TEXTURE11                      = 0x84CB;\r\n    public static inline var TEXTURE12                      = 0x84CC;\r\n    public static inline var TEXTURE13                      = 0x84CD;\r\n    public static inline var TEXTURE14                      = 0x84CE;\r\n    public static inline var TEXTURE15                      = 0x84CF;\r\n    public static inline var TEXTURE16                      = 0x84D0;\r\n    public static inline var TEXTURE17                      = 0x84D1;\r\n    public static inline var TEXTURE18                      = 0x84D2;\r\n    public static inline var TEXTURE19                      = 0x84D3;\r\n    public static inline var TEXTURE20                      = 0x84D4;\r\n    public static inline var TEXTURE21                      = 0x84D5;\r\n    public static inline var TEXTURE22                      = 0x84D6;\r\n    public static inline var TEXTURE23                      = 0x84D7;\r\n    public static inline var TEXTURE24                      = 0x84D8;\r\n    public static inline var TEXTURE25                      = 0x84D9;\r\n    public static inline var TEXTURE26                      = 0x84DA;\r\n    public static inline var TEXTURE27                      = 0x84DB;\r\n    public static inline var TEXTURE28                      = 0x84DC;\r\n    public static inline var TEXTURE29                      = 0x84DD;\r\n    public static inline var TEXTURE30                      = 0x84DE;\r\n    public static inline var TEXTURE31                      = 0x84DF;\r\n    public static inline var ACTIVE_TEXTURE                 = 0x84E0;\r\n\r\n    /* TextureWrapMode */\r\n    public static inline var REPEAT                         = 0x2901;\r\n    public static inline var CLAMP_TO_EDGE                  = 0x812F;\r\n    public static inline var MIRRORED_REPEAT                = 0x8370;\r\n\r\n    /* Uniform Types */\r\n    public static inline var FLOAT_VEC2                     = 0x8B50;\r\n    public static inline var FLOAT_VEC3                     = 0x8B51;\r\n    public static inline var FLOAT_VEC4                     = 0x8B52;\r\n    public static inline var INT_VEC2                       = 0x8B53;\r\n    public static inline var INT_VEC3                       = 0x8B54;\r\n    public static inline var INT_VEC4                       = 0x8B55;\r\n    public static inline var BOOL                           = 0x8B56;\r\n    public static inline var BOOL_VEC2                      = 0x8B57;\r\n    public static inline var BOOL_VEC3                      = 0x8B58;\r\n    public static inline var BOOL_VEC4                      = 0x8B59;\r\n    public static inline var FLOAT_MAT2                     = 0x8B5A;\r\n    public static inline var FLOAT_MAT3                     = 0x8B5B;\r\n    public static inline var FLOAT_MAT4                     = 0x8B5C;\r\n    public static inline var SAMPLER_2D                     = 0x8B5E;\r\n    public static inline var SAMPLER_CUBE                   = 0x8B60;\r\n\r\n    /* Vertex Arrays */\r\n    public static inline var VERTEX_ATTRIB_ARRAY_ENABLED        = 0x8622;\r\n    public static inline var VERTEX_ATTRIB_ARRAY_SIZE           = 0x8623;\r\n    public static inline var VERTEX_ATTRIB_ARRAY_STRIDE         = 0x8624;\r\n    public static inline var VERTEX_ATTRIB_ARRAY_TYPE           = 0x8625;\r\n    public static inline var VERTEX_ATTRIB_ARRAY_NORMALIZED     = 0x886A;\r\n    public static inline var VERTEX_ATTRIB_ARRAY_POINTER        = 0x8645;\r\n    public static inline var VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 0x889F;\r\n\r\n    /* Point Size */\r\n    public static inline var VERTEX_PROGRAM_POINT_SIZE       = 0x8642;\r\n    public static inline var POINT_SPRITE                    = 0x8861;\r\n\r\n    /* GLShader Source */\r\n    public static inline var COMPILE_STATUS                 = 0x8B81;\r\n\r\n    /* GLShader Precision-Specified Types */\r\n    public static inline var LOW_FLOAT                      = 0x8DF0;\r\n    public static inline var MEDIUM_FLOAT                   = 0x8DF1;\r\n    public static inline var HIGH_FLOAT                     = 0x8DF2;\r\n    public static inline var LOW_INT                        = 0x8DF3;\r\n    public static inline var MEDIUM_INT                     = 0x8DF4;\r\n    public static inline var HIGH_INT                       = 0x8DF5;\r\n\r\n    /* GLFramebuffer Object. */\r\n    public static inline var FRAMEBUFFER                    = 0x8D40;\r\n    public static inline var RENDERBUFFER                   = 0x8D41;\r\n\r\n    public static inline var RGBA4                          = 0x8056;\r\n    public static inline var RGB5_A1                        = 0x8057;\r\n    public static inline var RGB565                         = 0x8D62;\r\n    public static inline var DEPTH_COMPONENT16              = 0x81A5;\r\n    public static inline var STENCIL_INDEX                  = 0x1901;\r\n    public static inline var STENCIL_INDEX8                 = 0x8D48;\r\n    public static inline var DEPTH_STENCIL                  = 0x84F9;\r\n\r\n    public static inline var RENDERBUFFER_WIDTH             = 0x8D42;\r\n    public static inline var RENDERBUFFER_HEIGHT            = 0x8D43;\r\n    public static inline var RENDERBUFFER_INTERNAL_FORMAT   = 0x8D44;\r\n    public static inline var RENDERBUFFER_RED_SIZE          = 0x8D50;\r\n    public static inline var RENDERBUFFER_GREEN_SIZE        = 0x8D51;\r\n    public static inline var RENDERBUFFER_BLUE_SIZE         = 0x8D52;\r\n    public static inline var RENDERBUFFER_ALPHA_SIZE        = 0x8D53;\r\n    public static inline var RENDERBUFFER_DEPTH_SIZE        = 0x8D54;\r\n    public static inline var RENDERBUFFER_STENCIL_SIZE      = 0x8D55;\r\n\r\n    public static inline var FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE           = 0x8CD0;\r\n    public static inline var FRAMEBUFFER_ATTACHMENT_OBJECT_NAME           = 0x8CD1;\r\n    public static inline var FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL         = 0x8CD2;\r\n    public static inline var FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 0x8CD3;\r\n\r\n    public static inline var COLOR_ATTACHMENT0              = 0x8CE0;\r\n    public static inline var DEPTH_ATTACHMENT               = 0x8D00;\r\n    public static inline var STENCIL_ATTACHMENT             = 0x8D20;\r\n    public static inline var DEPTH_STENCIL_ATTACHMENT       = 0x821A;\r\n\r\n    public static inline var NONE                           = 0;\r\n\r\n    public static inline var FRAMEBUFFER_COMPLETE                      = 0x8CD5;\r\n    public static inline var FRAMEBUFFER_INCOMPLETE_ATTACHMENT         = 0x8CD6;\r\n    public static inline var FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7;\r\n    public static inline var FRAMEBUFFER_INCOMPLETE_DIMENSIONS         = 0x8CD9;\r\n    public static inline var FRAMEBUFFER_UNSUPPORTED                   = 0x8CDD;\r\n\r\n    public static inline var FRAMEBUFFER_BINDING            = 0x8CA6;\r\n    public static inline var RENDERBUFFER_BINDING           = 0x8CA7;\r\n    public static inline var MAX_RENDERBUFFER_SIZE          = 0x84E8;\r\n\r\n    public static inline var INVALID_FRAMEBUFFER_OPERATION  = 0x0506;\r\n\r\n    /* WebGL-specific enums */\r\n    public static inline var UNPACK_FLIP_Y_WEBGL            = 0x9240;\r\n    public static inline var UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241;\r\n    public static inline var CONTEXT_LOST_WEBGL             = 0x9242;\r\n    public static inline var UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243;\r\n    public static inline var BROWSER_DEFAULT_WEBGL          = 0x9244;\r\n\r\n\r\n\r\n}\r\n\r\n#end //snow_web","package snow.window;\r\n\r\nimport snow.Snow;\r\nimport snow.types.Types;\r\nimport snow.window.Window;\r\nimport snow.window.Windowing;\r\n\r\nimport snow.utils.AbstractClass;\r\n\r\n#if snow_web\r\n\r\n    @:noCompletion typedef WindowSystem = snow.platform.web.window.WindowSystem;\r\n\r\n#else\r\n\r\n    #if snow_window_sdl\r\n        @:noCompletion typedef WindowSystem = snow.platform.native.window.sdl.WindowSystem;\r\n    #else\r\n        @:noCompletion typedef WindowSystem = snow.platform.native.window.WindowSystem;\r\n    #end\r\n\r\n#end\r\n\r\n\r\n/**\r\n    Internal class handled by `Windowing`, a less concrete implementation of the platform window bindings.\r\n    WindowBinding is bound to snow.platform.native.WindowSystem, snow.platform.native.WindowSystem etc\r\n*/\r\n@:noCompletion class WindowSystemBinding implements AbstractClass {\r\n\r\n    public var manager : Windowing;\r\n    public var lib : Snow;\r\n\r\n        /** Called when the window manager initializes this system */\r\n    public function init();\r\n        /** Called when the window manager updates this system */\r\n    public function process();\r\n        /** Called when the window manager destroys this system */\r\n    public function destroy();\r\n        /** Called to set up any listeners on the given window  */\r\n    public function listen( window:Window );\r\n        /** Called to remove any listeners on the given window  */\r\n    public function unlisten( window:Window );\r\n\r\n        /** Create a window with config, calls on_created when complete passing the handle, the ID,\r\n            and the actual config that was used since the requested config could fail */\r\n    public function create( render_config:RenderConfig, config:WindowConfig, on_created: WindowHandle->Int->WindowingConfig->Void );\r\n        /** Close a given window */\r\n    public function close( window:Window );\r\n        /** reopen this window once closed. Destroyed windows cannot be reopened, it must use create again */\r\n    public function show( window:Window );\r\n        /** Close a given window */\r\n    public function destroy_window( window:Window );\r\n        /** Update a given window */\r\n    public function update( window:Window );\r\n        /** Render a given window */\r\n    public function render( window:Window );\r\n        /** Swap a given window */\r\n    public function swap( window:Window );\r\n        /** Display a message on a window */\r\n    public function simple_message( window:Window, message:String, ?title:String=\"\" );\r\n        /** Set the size of a window */\r\n    public function set_size( window:Window, w:Int, h:Int );\r\n        /** Set the position of a window */\r\n    public function set_position( window:Window, x:Int, y:Int );\r\n        /** Set the title of a window */\r\n    public function set_title( window:Window, title:String );\r\n        /** Set the max size of a window */\r\n    public function set_max_size( window:Window, w:Int, h:Int );\r\n        /** Set the min size of a window */\r\n    public function set_min_size( window:Window, w:Int, h:Int );\r\n        /** Set the fullscreen state of a window */\r\n    public function fullscreen( window:Window, fullscreen:Bool );\r\n        /** Set the bordered state of a window */\r\n    public function bordered( window:Window, bordered:Bool );\r\n\r\n//cursor\r\n        /** Set the grab state of a window */\r\n    public function grab( window:Window, grabbed:Bool );\r\n        /** Set the cursor position inside of a given window */\r\n    public function set_cursor_position( window:Window, x:Int, y:Int );\r\n\r\n//General\r\n\r\n        /** Toggle the OS cursor. This is not window specific but system wide */\r\n    public function system_enable_cursor( enable:Bool );\r\n        /** Lock the OS cursor to the foreground window. This hides the cursor and prevents it from leaving, reporting relative coordinates. */\r\n    public function system_lock_cursor( enable:Bool );\r\n        /** Toggle vertical refresh. This is not window specific but context wide, returns 0 on success or -1 if not supported */\r\n    public function system_enable_vsync( enable:Bool ) : Int;\r\n\r\n//Desktop\r\n\r\n        /** Get the number of displays present */\r\n    public function display_count() : Int;\r\n        /** Get the number of display modes present */\r\n    public function display_mode_count( display:Int ) : Int;\r\n        /** Get the native mode information of the display by index */\r\n    public function display_native_mode( display:Int ) : DisplayMode;\r\n        /** Get the current mode information of the display by index */\r\n    public function display_current_mode( display:Int ) : DisplayMode;\r\n        /** Get the information from a specific mode index, the index obtrained from iterating with `display_mode_count` value */\r\n    public function display_mode( display:Int, mode_index:Int ) : DisplayMode;\r\n        /** Get the bounds of the display by index */\r\n    public function display_bounds( display:Int ) : { x:Int, y:Int, width:Int, height:Int };\r\n        /** Get the name of the display by index, where available */\r\n    public function display_name( display:Int ) : String;\r\n\r\n\r\n} //WindowSystemBinding\r\n","package snow.platform.web.window;\r\n\r\nimport snow.Snow;\r\nimport snow.types.Types;\r\nimport snow.window.Window;\r\nimport snow.window.Windowing;\r\nimport snow.window.WindowSystem;\r\n\r\n#if snow_web\r\n\r\n        //Internal class handled by Windowing, a less concrete implementation of the window system\r\n    @:noCompletion class WindowSystem extends WindowSystemBinding {\r\n\r\n        public var gl_contexts : Map<Int, js.html.webgl.RenderingContext>;\r\n\r\n        var seq_window : Int = 1;\r\n        var fs_windows : Array<Window>;\r\n\r\n        public function new( _manager:Windowing, _lib:Snow ) {\r\n\r\n            manager = _manager;\r\n            lib = _lib;\r\n            fs_windows = [];\r\n            gl_contexts = new Map();\r\n\r\n        } //new\r\n\r\n        override public function init() {\r\n\r\n            listen_for_visibility();\r\n            listen_for_resize();\r\n\r\n        } //init\r\n\r\n        override public function process() {\r\n        } //process\r\n\r\n        override public function destroy() {\r\n        } //destroy\r\n\r\n        function _copy_config( _config:WindowConfig ) {\r\n            return {\r\n                borderless:_config.borderless,\r\n                fullscreen:_config.fullscreen,\r\n                fullscreen_desktop:_config.fullscreen_desktop,\r\n                height:_config.height,\r\n                no_input:_config.no_input,\r\n                resizable:_config.resizable,\r\n                title:_config.title,\r\n                width:_config.width,\r\n                x:_config.x,\r\n                y:_config.y\r\n            }\r\n        }\r\n\r\n        override public function create( render_config:RenderConfig, _config:WindowConfig, on_created: WindowHandle->Int->WindowingConfig->Void ) {\r\n\r\n            var _window_id = seq_window;\r\n            var _handle : js.html.CanvasElement = js.Browser.document.createCanvasElement();\r\n            var config = _copy_config(_config);\r\n\r\n                    //assign the initial sizes\r\n                _handle.width = config.width;\r\n                _handle.height = config.height;\r\n\r\n                if(config.fullscreen) {\r\n                    internal_fullscreen( _handle, config.fullscreen );\r\n                    config.width = _handle.width;\r\n                    config.height = _handle.height;\r\n                }\r\n\r\n                    //make sure it displays nicely\r\n                _handle.style.display = 'block';\r\n                _handle.style.position = 'relative';\r\n                _handle.style.background = '#000';\r\n\r\n                    //add it to the document\r\n                js.Browser.document.body.appendChild(_handle);\r\n\r\n                //:todo: These options need to be exposed and documented\r\n            var _gl_context = _handle.getContextWebGL({ alpha:false, premultipliedAlpha:false, antialias: render_config.antialiasing > 0 });\r\n                //early out on no possible context\r\n            if(_gl_context == null) {\r\n                var msg =  'WebGL is required to run this!<br/><br/>';\r\n                    msg += 'visit http://get.webgl.org/ for help <br/>';\r\n                    msg += 'and contact the developer of the application';\r\n                internal_fallback(msg);\r\n                throw msg;\r\n            }\r\n\r\n                //make sure there is a set up context early\r\n            if(snow.render.opengl.GL.current_context == null) {\r\n                snow.render.opengl.GL.current_context = _gl_context;\r\n            }\r\n\r\n                //store it for activating later\r\n            gl_contexts.set(_window_id, _gl_context);\r\n\r\n                //get the real canvas position and give it to the config\r\n            var _window_pos = get_real_window_position( _handle );\r\n\r\n                config.x = _window_pos.x;\r\n                config.y = _window_pos.y;\r\n\r\n                //set the window title to the config title if there is one\r\n            if(config.title != null && config.title != '') {\r\n                js.Browser.document.title = config.title;\r\n            }\r\n\r\n                //tell them and give the handle for later.\r\n            on_created(_handle, _window_id, { config:config, render_config:render_config });\r\n            _handle.setAttribute('id', 'window${_window_id}');\r\n\r\n            seq_window++;\r\n\r\n        } //window_create\r\n\r\n        override public function destroy_window( _window:Window ) {\r\n\r\n            js.Browser.document.body.removeChild( _window.handle );\r\n\r\n        } //destroy_window\r\n\r\n        override public function close( _window:Window ) {\r\n\r\n            _window.handle.style.display = 'none';\r\n\r\n        } //close\r\n\r\n        override public function show( _window:Window ) {\r\n\r\n            _window.handle.style.display = null;\r\n\r\n        } //show\r\n\r\n        function internal_resize( _window:Window, _w:Float, _h:Float ) {\r\n\r\n            lib.dispatch_system_event({\r\n                type : SystemEventType.window,\r\n                window : {\r\n                    type : WindowEventType.size_changed,\r\n                    timestamp : lib.time,\r\n                    window_id : _window.id,\r\n                    event : { x:_w, y:_h }\r\n                }\r\n            });\r\n\r\n            lib.dispatch_system_event({\r\n                type : SystemEventType.window,\r\n                window : {\r\n                    type : WindowEventType.resized,\r\n                    timestamp : lib.time,\r\n                    window_id : _window.id,\r\n                    event : { x:_w, y:_h }\r\n                }\r\n            });\r\n\r\n        } //internal_resize\r\n\r\n        override public function update( _window:Window ) {\r\n\r\n            var _rect = _window.handle.getBoundingClientRect();\r\n\r\n                if(_rect.left != _window.x || _rect.top != _window.y) {\r\n\r\n                    lib.dispatch_system_event({\r\n                        type : SystemEventType.window,\r\n                        window : {\r\n                            type : WindowEventType.moved,\r\n                            timestamp : lib.time,\r\n                            window_id : _window.id,\r\n                            event : { x:_rect.left, y:_rect.top }\r\n                        }\r\n                    });\r\n\r\n                }\r\n\r\n                if(_rect.width != _window.width || _rect.height != _window.height) {\r\n\r\n                    internal_resize(_window, _rect.width, _rect.height);\r\n\r\n                }\r\n\r\n            _rect = null;\r\n\r\n        } //window_update\r\n\r\n        override public function render( _window:Window ) {\r\n\r\n            var _window_gl_context = gl_contexts.get(_window.id);\r\n            if(snow.render.opengl.GL.current_context != _window_gl_context) {\r\n                snow.render.opengl.GL.current_context = _window_gl_context;\r\n            }\r\n\r\n        } //window_render\r\n\r\n        override public function swap( _window:Window ) {\r\n\r\n            //:unsupported:\r\n            //this concept is not possible in browser\r\n\r\n        } //window_swap\r\n\r\n        override public function simple_message( _window:Window, message:String, ?title:String=\"\" ) {\r\n\r\n            js.Browser.window.alert( message );\r\n\r\n        } //window_simple_message\r\n\r\n        override public function set_size( _window:Window, w:Int, h:Int ) {\r\n\r\n            _window.handle.width = w;\r\n            _window.handle.height = h;\r\n            _window.handle.style.width = '${w}px';\r\n            _window.handle.style.height = '${h}px';\r\n\r\n            internal_resize(_window, w, h);\r\n\r\n        } //window_set_size\r\n\r\n        override public function set_position( _window:Window, x:Int, y:Int ) {\r\n\r\n            _window.handle.style.left = '${x}px';\r\n            _window.handle.style.top = '${y}px';\r\n\r\n        } //window_set_position\r\n\r\n        public function get_real_window_position( handle:WindowHandle ) : { x:Int, y:Int } {\r\n\r\n            // see the following link for this implementation\r\n            // http://www.quirksmode.org/js/findpos.html\r\n\r\n            var curleft = 0;\r\n            var curtop = 0;\r\n\r\n                //start at the canvas\r\n            var _obj : js.html.Element = cast handle;\r\n\r\n            var _has_parent : Bool = true;\r\n            var _max_count = 0;\r\n\r\n            while(_has_parent == true) {\r\n\r\n                _max_count++;\r\n\r\n                if(_max_count > 100) {\r\n                    _has_parent = false;\r\n                    break;\r\n                } //prevent rogue endless loops\r\n\r\n                if(_obj.offsetParent != null) {\r\n\r\n                        //it still has an offset parent, add it up\r\n                    curleft += _obj.offsetLeft;\r\n                    curtop += _obj.offsetTop;\r\n\r\n                        //then move onto the parent\r\n                    _obj = cast _obj.offsetParent;\r\n\r\n                } else {\r\n                        //we are done\r\n                    _has_parent = false;\r\n\r\n                }\r\n            } //while\r\n\r\n            return { x:curleft, y:curtop };\r\n\r\n        } //get_real_window_position\r\n\r\n        override public function set_title( _window:Window, title:String ) {\r\n\r\n            js.Browser.document.title = title;\r\n\r\n        } //window_set_title\r\n\r\n        override public function set_max_size( _window:Window, w:Int, h:Int ) {\r\n\r\n            _window.handle.style.maxWidth = '${w}px';\r\n            _window.handle.style.maxHeight = '${h}px';\r\n\r\n        } //window_set_max_size\r\n\r\n        override public function set_min_size( _window:Window, w:Int, h:Int ) {\r\n\r\n            _window.handle.style.minWidth = '${w}px';\r\n            _window.handle.style.minHeight = '${h}px';\r\n\r\n        } //window_set_min_size\r\n\r\n\r\n\r\n        var _pre_fs_padding : String = '0';\r\n        var _pre_fs_margin : String = '0';\r\n        var _pre_fs_s_width : String = '';\r\n        var _pre_fs_s_height : String = '';\r\n        var _pre_fs_width : Int = 0;\r\n        var _pre_fs_height : Int = 0;\r\n        var _pre_fs_body_overflow : String = '0';\r\n        var _pre_fs_body_margin : String = '0';\r\n\r\n        function internal_fullscreen( _handle:WindowHandle, fullscreen:Bool ) {\r\n\r\n                //find out if the config requested true fullscreen or not\r\n            var true_fullscreen = lib.config.web.true_fullscreen;\r\n\r\n                //as always browser support for newer features will be\r\n                //sporadic. Tested fullscreen against firefox/chrome/opera/safari latest\r\n                //all appear to work as expected, but have no cancel (user must press escape)\r\n            if(fullscreen) {\r\n\r\n                if(true_fullscreen) {\r\n\r\n\r\n                        //official api's first\r\n                    if(untyped _handle.requestFullscreen == null) {\r\n                        if(untyped _handle.requestFullScreen == null) {\r\n                            if(untyped _handle.webkitRequestFullscreen == null) {\r\n                                if(untyped _handle.mozRequestFullScreen == null) {\r\n\r\n                                } else { untyped _handle.mozRequestFullScreen(); }\r\n                            } else { untyped _handle.webkitRequestFullscreen(); }\r\n                        } else { untyped _handle.requestFullScreen(null); }\r\n                    } else { untyped _handle.requestFullscreen(); }\r\n\r\n                } else {\r\n\r\n                    _pre_fs_padding = _handle.style.padding;\r\n                    _pre_fs_margin = _handle.style.margin;\r\n                    _pre_fs_s_width = _handle.style.width;\r\n                    _pre_fs_s_height = _handle.style.height;\r\n                    _pre_fs_width = _handle.width;\r\n                    _pre_fs_height = _handle.height;\r\n                    _pre_fs_body_margin = js.Browser.document.body.style.margin;\r\n                    _pre_fs_body_overflow = js.Browser.document.body.style.overflow;\r\n\r\n                    _handle.style.margin = '0';\r\n                    _handle.style.padding = '0';\r\n                    _handle.style.width = js.Browser.window.innerWidth + 'px';\r\n                    _handle.style.height = js.Browser.window.innerHeight + 'px';\r\n                    _handle.width = js.Browser.window.innerWidth;\r\n                    _handle.height = js.Browser.window.innerHeight;\r\n\r\n                        //stop the browser page from having scrollbars etc\r\n                    js.Browser.document.body.style.margin = '0';\r\n                    js.Browser.document.body.style.overflow = 'hidden';\r\n\r\n                }\r\n\r\n            } else {\r\n\r\n                if(true_fullscreen) {\r\n\r\n                    //:unsupported:\r\n                    //currently no cancel full screen in fullscreen mode\r\n\r\n                } else {\r\n\r\n                    _handle.style.padding = _pre_fs_padding;\r\n                    _handle.style.margin = _pre_fs_margin;\r\n                    _handle.style.width = _pre_fs_s_width;\r\n                    _handle.style.height = _pre_fs_s_height;\r\n                    _handle.width = _pre_fs_width;\r\n                    _handle.height = _pre_fs_height;\r\n                    js.Browser.document.body.style.margin = _pre_fs_body_margin;\r\n                    js.Browser.document.body.style.overflow = _pre_fs_body_overflow;\r\n\r\n                }\r\n\r\n            }\r\n\r\n        } //set_handle_fullscreen\r\n\r\n        override public function fullscreen( _window:Window, fullscreen:Bool ) {\r\n\r\n            if(fullscreen) {\r\n                if(fs_windows.indexOf(_window) == -1) {\r\n                    fs_windows.push(_window);\r\n                }\r\n            } else {\r\n                fs_windows.remove(_window);\r\n            }\r\n\r\n            internal_fullscreen( _window.handle, fullscreen );\r\n\r\n        } //window_fullscreen\r\n\r\n        override public function bordered( _window:Window, bordered:Bool ) {\r\n\r\n            //:unsupported:\r\n            //no such concept on browser\r\n\r\n        } //window_bordered\r\n\r\n\r\n        override public function grab( _window:Window, grabbed:Bool ) {\r\n\r\n            if(grabbed) {\r\n                    //official api's first\r\n                if(_window.handle.requestPointerLock == null) {\r\n                        if(untyped _window.handle.webkitRequestPointerLock == null) {\r\n                            if(untyped _window.handle.mozRequestPointerLock == null) {\r\n\r\n                            } else { untyped _window.handle.mozRequestPointerLock(); }\r\n                        } else { untyped _window.handle.webkitRequestPointerLock(); }\r\n                } else { _window.handle.requestPointerLock(); }\r\n\r\n            } else {\r\n\r\n                //:unsupported:\r\n                //pointer lock cancel api not yet in browsers,\r\n                //user must press escape\r\n\r\n            }\r\n\r\n        } //window_grab\r\n\r\n        override public function set_cursor_position( _window:Window, x:Int, y:Int ) {\r\n\r\n            // :unsupported:\r\n            // for good reason.\r\n\r\n        } //set_cursor_position\r\n\r\n            /** Toggle the OS cursor. This is not window specific but system wide */\r\n        var cursor_style : js.html.Element;\r\n        var _cursor_visible : Bool = true;\r\n        override function system_enable_cursor( enable:Bool ) {\r\n\r\n            if(cursor_style == null) {\r\n                cursor_style = js.Browser.document.createStyleElement();\r\n                cursor_style.innerHTML = '* { cursor:none; }';\r\n            }\r\n\r\n            if(enable && !_cursor_visible) {\r\n                _cursor_visible = true;\r\n                js.Browser.document.body.removeChild(cursor_style);\r\n            } else if(!enable && _cursor_visible) {\r\n                _cursor_visible = false;\r\n                js.Browser.document.body.appendChild(cursor_style);\r\n            }\r\n\r\n        } //system_enable_cursor\r\n\r\n            /** Lock the OS cursor to the foreground window. This hides the cursor and prevents it from leaving, reporting relative coordinates. */\r\n        override function system_lock_cursor( enable:Bool ) {\r\n\r\n            if(lib.window != null) {\r\n                grab(lib.window, enable);\r\n            }\r\n\r\n        } //system_lock_cursor\r\n\r\n            /** Toggle vertical refresh. This is not window specific but context wide */\r\n        override function system_enable_vsync( enable:Bool ) : Int {\r\n\r\n            // :unsupported:\r\n            //technically RAF is vsync but it's not a toggle,\r\n            //and without it is terrible so, not doing that\r\n\r\n            return -1;\r\n\r\n        } //system_enable_vsync\r\n\r\n\r\n        override public function display_count() : Int {\r\n\r\n            //:unsupported:\r\n            return 1;\r\n\r\n        } //display_count\r\n\r\n        override public function display_mode_count( display:Int ) : Int {\r\n\r\n            //:unsupported:\r\n            return 1;\r\n\r\n        } //display_mode_count\r\n\r\n        override public function display_native_mode( display:Int ) : DisplayMode {\r\n\r\n            //:unsupported:\r\n\r\n            return {\r\n                format : 0,\r\n                refresh_rate : 0,\r\n                width : js.Browser.window.screen.width,\r\n                height : js.Browser.window.screen.height\r\n            };\r\n\r\n        } //display_native_mode\r\n\r\n        override public function display_current_mode( display:Int ) : DisplayMode {\r\n\r\n            //:unsupported:\r\n            //will always return the default display mode\r\n\r\n            return display_native_mode(display);\r\n\r\n        } //display_current_mode\r\n\r\n        override public function display_mode( display:Int, mode_index:Int ) : DisplayMode {\r\n\r\n            //:unsupported:\r\n            //will always return the default display mode\r\n\r\n            return display_native_mode(display);\r\n\r\n        } //display_mode\r\n\r\n            //returns the size of the main window\r\n        override public function display_bounds( display:Int ) : { x:Int, y:Int, width:Int, height:Int } {\r\n\r\n            return {\r\n                x : 0,\r\n                y : 0,\r\n                width : js.Browser.window.innerWidth,\r\n                height : js.Browser.window.innerHeight\r\n            };\r\n\r\n        } //display_bounds\r\n\r\n        override public function display_name( display:Int ) : String {\r\n\r\n            return js.Browser.navigator.vendor;\r\n\r\n        } //display_name\r\n\r\n            /** Called to set up any listeners on the given window  */\r\n        override public function listen( _window:Window ) {\r\n\r\n            _window.handle.addEventListener('mouseleave', on_internal_leave);\r\n            _window.handle.addEventListener('mouseenter', on_internal_enter);\r\n\r\n        } //listen\r\n\r\n            /** Called to remove any listeners on the given window  */\r\n        override public function unlisten( _window:Window ) {\r\n\r\n            _window.handle.removeEventListener('mouseleave', on_internal_leave);\r\n            _window.handle.removeEventListener('mouseenter', on_internal_enter);\r\n\r\n        } //unlisten\r\n\r\n\r\n        function on_internal_leave( _mouse_event:js.html.MouseEvent ) {\r\n\r\n            var _window : Window = lib.windowing.window_from_handle(cast _mouse_event.target);\r\n\r\n                //tell the system\r\n            lib.dispatch_system_event({\r\n                type : SystemEventType.window,\r\n                window : {\r\n                    type : WindowEventType.leave,\r\n                    timestamp : _mouse_event.timeStamp,\r\n                    window_id : _window.id,\r\n                    event : _mouse_event\r\n                }\r\n            });\r\n\r\n        } //on_internal_leave\r\n\r\n        function on_internal_enter( _mouse_event:js.html.MouseEvent ) {\r\n\r\n            var _window : Window = lib.windowing.window_from_handle(cast _mouse_event.target);\r\n\r\n                //tell the system\r\n            lib.dispatch_system_event({\r\n                type : SystemEventType.window,\r\n                window : {\r\n                    type : WindowEventType.enter,\r\n                    timestamp : _mouse_event.timeStamp,\r\n                    window_id : _window.id,\r\n                    event : _mouse_event\r\n                }\r\n            });\r\n\r\n        } //on_internal_enter\r\n\r\n        function listen_for_resize() {\r\n\r\n            js.Browser.window.onresize = function(e){\r\n                if(!lib.config.web.true_fullscreen) {\r\n\r\n                    for(window in fs_windows) {\r\n                        window.set_size( js.Browser.window.innerWidth, js.Browser.window.innerHeight);\r\n                        internal_resize( window, window.width, window.height );\r\n                    }\r\n\r\n                } //if true_fullscreen\r\n            } //onresize\r\n\r\n        } //listen_for_resize\r\n\r\n        var _hidden_name = '';\r\n        var _hidden_event_name = '';\r\n        function listen_for_visibility() {\r\n\r\n            if( untyped __js__('typeof document.hidden !== undefined') ) {\r\n                _hidden_name = 'hidden';\r\n                _hidden_event_name = 'visibilitychange';\r\n            } else if( untyped __js__('typeof document.mozHidden !== undefined ')) {\r\n                _hidden_name = 'mozHidden';\r\n                _hidden_name = 'mozvisibilitychange';\r\n            } else if( untyped __js__('typeof document.msHidden !== \"undefined\"')) {\r\n                _hidden_name = \"msHidden\";\r\n                _hidden_event_name = \"msvisibilitychange\";\r\n            } else if( untyped __js__('typeof document.webkitHidden !== \"undefined\"')) {\r\n                _hidden_name = \"webkitHidden\";\r\n                _hidden_event_name = \"webkitvisibilitychange\";\r\n            }\r\n\r\n            if(_hidden_name != '' && _hidden_event_name != '') {\r\n                js.Browser.document.addEventListener(_hidden_event_name, on_visibility_change );\r\n            }\r\n\r\n        }\r\n\r\n        function on_visibility_change(jsevent) {\r\n\r\n            var _event = {\r\n                type : SystemEventType.window,\r\n                window : {\r\n                    type : WindowEventType.shown,\r\n                    timestamp : lib.time,\r\n                    window_id : 1, //page window id is 1\r\n                    event : jsevent\r\n                }\r\n            };\r\n\r\n                //dispatch one for minimize/restore, one for focus lost/gain\r\n                //and one for hidden/exposed\r\n            if( untyped document[_hidden_name] ) {\r\n                _event.window.type = WindowEventType.hidden;\r\n                    lib.dispatch_system_event(_event);\r\n                _event.window.type = WindowEventType.minimized;\r\n                    lib.dispatch_system_event(_event);\r\n                _event.window.type = WindowEventType.focus_lost;\r\n                    lib.dispatch_system_event(_event);\r\n            } else {\r\n                _event.window.type = WindowEventType.shown;\r\n                    lib.dispatch_system_event(_event);\r\n                _event.window.type = WindowEventType.restored;\r\n                    lib.dispatch_system_event(_event);\r\n                _event.window.type = WindowEventType.focus_gained;\r\n                    lib.dispatch_system_event(_event);\r\n            }\r\n\r\n        } //on_visibility_change\r\n\r\n        function internal_fallback( message:String ) {\r\n\r\n            var text_el : js.html.Element;\r\n            var overlay_el : js.html.Element;\r\n\r\n            text_el = js.Browser.document.createDivElement();\r\n            overlay_el = js.Browser.document.createDivElement();\r\n\r\n            text_el.style.marginLeft = 'auto';\r\n            text_el.style.marginRight = 'auto';\r\n            text_el.style.color = '#d3d3d3';\r\n            text_el.style.marginTop = '5em';\r\n            text_el.style.fontSize = '1.4em';\r\n            text_el.style.fontFamily = 'helvetica,sans-serif';\r\n            text_el.innerHTML = message;\r\n\r\n            overlay_el.style.top = '0';\r\n            overlay_el.style.left = '0';\r\n            overlay_el.style.width = '100%';\r\n            overlay_el.style.height = '100%';\r\n            overlay_el.style.display = 'block';\r\n            overlay_el.style.minWidth = '100%';\r\n            overlay_el.style.minHeight = '100%';\r\n            overlay_el.style.textAlign = 'center';\r\n            overlay_el.style.position = 'absolute';\r\n            overlay_el.style.background = 'rgba(1,1,1,0.90)';\r\n\r\n            overlay_el.appendChild(text_el);\r\n            js.Browser.document.body.appendChild(overlay_el);\r\n\r\n\r\n        }\r\n\r\n    } //WindowSystem\r\n\r\n#end //snow_web\r\n","package snow.utils;\r\n\r\nclass Libs {\r\n\r\n        //for Load function\r\n    @:noCompletion static var __moduleNames:Map<String, String> = null;\r\n\r\n    static function tryLoad( name:String, library:String, func:String, args:Int ) : Dynamic {\r\n\r\n        #if snow_native\r\n\r\n            try {\r\n\r\n                #if cpp\r\n                    var result = cpp.Lib.load( name, func, args );\r\n                #elseif (neko)\r\n                    var result = neko.Lib.load( name, func, args );\r\n                #else\r\n                    return null;\r\n                #end\r\n\r\n                if (result != null) {\r\n\r\n                    loaderTrace (\"Got result \" + name);\r\n                    __moduleNames.set (library, name);\r\n\r\n                    return result;\r\n\r\n                } //result != null\r\n\r\n            } catch (e:Dynamic) {\r\n\r\n                loaderTrace (\"Failed to load : \" + name);\r\n\r\n            } //catch\r\n\r\n        #end //snow_native\r\n\r\n        return null;\r\n\r\n    } //tryLoad\r\n\r\n    #if neko\r\n\r\n        static function loadNekoAPI ():Void {\r\n\r\n            var init = load (\"snow\", \"neko_init\", 5);\r\n\r\n            if (init != null) {\r\n\r\n                loaderTrace (\"Found nekoapi @ \" + __moduleNames.get (\"snow\"));\r\n                init (function(s) return new String (s), function (len:Int) { var r = []; if (len > 0) r[len - 1] = null; return r; }, null, true, false);\r\n\r\n            } else {\r\n\r\n                throw (\"Could not find NekoAPI interface.\");\r\n\r\n            }\r\n\r\n        }\r\n\r\n    #end //neko\r\n\r\n    static function findHaxeLib( library:String ) : String {\r\n\r\n        try {\r\n\r\n            #if snow_native\r\n\r\n                var proc = new sys.io.Process (\"haxelib\", [ \"path\", library ]);\r\n\r\n                if (proc != null) {\r\n\r\n                    var stream = proc.stdout;\r\n\r\n                    try {\r\n\r\n                        while (true) {\r\n\r\n                            var s = stream.readLine ();\r\n\r\n                            if (s.substr (0, 1) != \"-\") {\r\n\r\n                                stream.close ();\r\n                                proc.close ();\r\n                                loaderTrace (\"Found haxelib \" + s);\r\n                                return s;\r\n\r\n                            }\r\n\r\n                        }\r\n\r\n                    } catch(e:Dynamic) { }\r\n\r\n                    stream.close ();\r\n                    proc.close ();\r\n\r\n                }\r\n\r\n            #end //snow_native\r\n\r\n        } catch (e:Dynamic) { }\r\n\r\n        return \"\";\r\n\r\n    } //findHaxeLib\r\n\r\n    static function get_system_name() : String {\r\n\r\n        #if snow_native\r\n            #if cpp\r\n                var sys_string = cpp.Lib.load (\"std\", \"sys_string\", 0);\r\n                return sys_string();\r\n            #else\r\n                return Sys.systemName();\r\n            #end\r\n        #end\r\n\r\n        #if snow_web\r\n            return js.Browser.navigator.userAgent;\r\n        #end\r\n\r\n        return \"unknown\";\r\n\r\n    } //get_system_name\r\n\r\n#if snow_web\r\n\r\n    public static var _web_libs:Map<String,Dynamic>;\r\n\r\n    public static function web_add_lib( library:String, root:Dynamic ) {\r\n\r\n        if(_web_libs == null) {\r\n            _web_libs = new Map<String,Dynamic>();\r\n        }\r\n\r\n        _web_libs.set( library, root );\r\n\r\n        return true;\r\n\r\n    } //web_add_lib\r\n\r\n    public static function web_lib_load(library:String, method:String) {\r\n\r\n        if(_web_libs == null) {\r\n             _web_libs = new Map<String,Dynamic>();\r\n        }\r\n\r\n        var _root = _web_libs.get(library);\r\n        if(_root != null) {\r\n            return Reflect.field(_root, method);\r\n        }\r\n\r\n        return null;\r\n\r\n    } //web_lib_load\r\n\r\n#end //snow_web\r\n\r\n    public static function load (library:String, method:String, args:Int = 0):Dynamic {\r\n\r\n        #if (iphone || emscripten || android)\r\n            return cpp.Lib.load( library, method, args );\r\n        #end\r\n\r\n        #if snow_web\r\n            var found_in_web_libs = web_lib_load( library, method );\r\n            if(found_in_web_libs) {\r\n                return found_in_web_libs;\r\n            }\r\n        #end //snow_web\r\n\r\n        if (__moduleNames == null) __moduleNames = new Map<String, String> ();\r\n        if (__moduleNames.exists (library)) {\r\n\r\n            #if cpp\r\n                return cpp.Lib.load (__moduleNames.get (library), method, args);\r\n            #elseif neko\r\n                return neko.Lib.load (__moduleNames.get (library), method, args);\r\n            #end\r\n\r\n        }\r\n\r\n        __moduleNames.set (library, library);\r\n\r\n        var result:Dynamic = tryLoad (\"./\" + library, library, method, args);\r\n\r\n        if (result == null) {\r\n            result = tryLoad (\".\\\\\" + library, library, method, args);\r\n        }\r\n\r\n        if (result == null) {\r\n            result = tryLoad (library, library, method, args);\r\n        }\r\n\r\n        if (result == null) {\r\n\r\n            var slash = (get_system_name ().substr (7).toLowerCase () == \"windows\") ? \"\\\\\" : \"/\";\r\n            var haxelib = findHaxeLib (\"snow\");\r\n\r\n            if (haxelib != \"\") {\r\n                result = tryLoad (haxelib + slash + \"ndll\" + slash + get_system_name () + slash + library, library, method, args);\r\n                if (result == null) {\r\n                    result = tryLoad (haxelib + slash + \"ndll\" + slash + get_system_name() + \"64\" + slash + library, library, method, args);\r\n                }\r\n            }\r\n\r\n        } //result == null\r\n\r\n        loaderTrace (\"Result : \" + result);\r\n\r\n        #if neko\r\n            if (library == \"snow\") {\r\n                loadNekoAPI();\r\n            }\r\n        #end\r\n\r\n        return result;\r\n\r\n    } //load\r\n\r\n    static function loaderTrace( message:String ) {\r\n\r\n        #if snow_native\r\n\r\n            #if cpp\r\n\r\n                var get_env = cpp.Lib.load (\"std\", \"get_env\", 1);\r\n                var debug = (get_env (\"SNOW_LOAD_DEBUG\") != null);\r\n\r\n            #else //# not cpp\r\n\r\n                var debug = (Sys.getEnv (\"SNOW_LOAD_DEBUG\") !=null);\r\n\r\n            #end //# if cpp\r\n\r\n            if (debug) {\r\n                Sys.println (message);\r\n            } //if debug\r\n\r\n        #end //snow_native\r\n\r\n\r\n        #if snow_web\r\n            //:todo : leverage console.log somehow?\r\n        #end //snow_web\r\n\r\n    } //loaderTrace\r\n\r\n} //Libs\r\n","package snow.utils;\r\n\r\n/**\r\nThe Promise interface represents a proxy for a value not necessarily\r\nknown when the promise is created. It allows you to associate handlers\r\nto an asynchronous action's eventual success or failure. This lets asynchronous\r\nmethods return values like synchronous methods: instead of the final value,\r\nthe asynchronous method returns a promise of having a value at some point in the future.\r\n\r\nA pending promise can become either fulfilled with a value, or\r\nrejected with a reason. When either of these happens, the associated\r\nhandlers queued up by a promise's then method are called. (If the promise\r\nhas already been fulfilled or rejected when a corresponding handler is attached,\r\nthe handler will be called, so there is no race condition between an asynchronous\r\noperation completing and its handlers being attached.)\r\n\r\nAs the Promise.prototype.then and Promise.prototype.error methods return promises,\r\nthey can be chained—an operation called composition.\r\n\r\nDocumentation provided mostly by MDN\r\nlicensed under CC-BY-SA 2.5. by Mozilla Contributors.\r\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\r\n*/\r\n@:allow(snow.utils.Promises)\r\nclass Promise {\r\n\r\n        /** The state this promise is in. */\r\n    var state : PromiseState;\r\n        /** internal: The result of this promise */\r\n    var result : Dynamic;\r\n        /** internal: The reactions lists */\r\n    var reject_reactions: Array<Dynamic>;\r\n    var fulfill_reactions: Array<Dynamic>;\r\n    var settle_reactions: Array<Dynamic>;\r\n\r\n        /** internal: If the promise was handled by a reject reaction */\r\n    var was_caught: Bool = false;\r\n\r\n        /** Creates a new promise by providing a function with two callback arguments.\r\n            Inside this function, invoking these callbacks controls the promise state.\r\n\r\n            For example, if fetching a value async, and the operation fails, you would\r\n            invoke the second callback with the reason/error. If the operation succeeded,\r\n            you would invoke the first.\r\n\r\n            `new Promise(function(resolve, reject) {\r\n                var success = ... get value ...\r\n                if(success) {\r\n                    resolve(value);\r\n                } else {\r\n                    reject(Error(...));\r\n                }\r\n            });` */\r\n    public function new<T>( func:T ) {\r\n\r\n        state = pending;\r\n\r\n        reject_reactions = [];\r\n        fulfill_reactions = [];\r\n        settle_reactions = [];\r\n\r\n        Promises.queue(function() {\r\n\r\n            #if hxpromise_catch_and_reject_on_promise_body\r\n                try {\r\n                    untyped func(onfulfill, onreject);\r\n                } catch(err:Dynamic) {\r\n                    onexception(err);\r\n                }\r\n            #else\r\n                untyped func(onfulfill, onreject);\r\n            #end //hxpromise_catch_and_reject_on_promise_body\r\n\r\n            Promises.defer(Promises.next);\r\n        });\r\n\r\n    } //new\r\n\r\n        /** The then function returns a Promise. It takes two arguments,\r\n            both are callback functions for the success and failure cases of the Promise. */\r\n    public function then<T,T1>( on_fulfilled:T, ?on_rejected:T ) : Promise {\r\n\r\n        switch(state) {\r\n\r\n            case pending: {\r\n                add_fulfill(on_fulfilled);\r\n                add_reject(on_rejected);\r\n                return new_linked_promise();\r\n            }\r\n\r\n            case fulfilled: {\r\n                Promises.defer(on_fulfilled, result);\r\n                return Promise.resolve(result);\r\n            }\r\n\r\n            case rejected: {\r\n                Promises.defer(on_rejected, result);\r\n                return Promise.reject(result);\r\n            }\r\n\r\n        } //switch\r\n\r\n    } //then\r\n\r\n        /** The error function returns a Promise and deals with rejected cases only.\r\n            It behaves the same as calling then(null, on_rejected).*/\r\n    public function error<T>( on_rejected:T ) : Promise {\r\n\r\n        switch(state) {\r\n\r\n            case pending: {\r\n                add_reject(on_rejected);\r\n                return new_linked_resolve_empty();\r\n            }\r\n\r\n            case fulfilled: {\r\n                return Promise.resolve(result);\r\n            }\r\n\r\n            case rejected: {\r\n                Promises.defer(on_rejected, result);\r\n                return Promise.reject(result);\r\n            }\r\n\r\n        } //switch\r\n\r\n    } //error\r\n\r\n        /** The Promise.all(iterable) function returns a promise that\r\n            resolves when all of the promises in the iterable argument\r\n            have resolved. The result is passed as an array of values\r\n            from all the promises.\r\n            If any of the passed in promises rejects, the all Promise\r\n            immediately rejects with the value of the promise that rejected,\r\n            discarding all the other promises whether or not they have resolved. */\r\n    public static function all( _tag='all', list:Array<Promise> ) {\r\n\r\n        return new Promise(function(ok, no) {\r\n\r\n            var current = 0;\r\n            var total = list.length;\r\n            var fulfill_result = [];\r\n            var reject_result = null;\r\n            var all_state:PromiseState = pending;\r\n\r\n            var single_ok = function(val) {\r\n\r\n                if(all_state != pending) return;\r\n\r\n                current++;\r\n                fulfill_result.push(val);\r\n\r\n                if(total == current) {\r\n                    all_state = fulfilled;\r\n                    ok(fulfill_result);\r\n                }\r\n\r\n            } //single_ok\r\n\r\n            var single_err = function(val) {\r\n\r\n                if(all_state != pending) return;\r\n\r\n                all_state = rejected;\r\n                reject_result = val;\r\n                no(reject_result);\r\n\r\n            } //single_err\r\n\r\n            for(promise in list) {\r\n                promise.then(single_ok).error(single_err);\r\n            }\r\n\r\n        }); //promise\r\n\r\n    } //all\r\n\r\n        /** The Promise.race function returns a promise that\r\n            resolves or rejects as soon as one of the promises in the\r\n            list resolves or rejects, with the value or reason from that promise. */\r\n    public static function race( list:Array<Promise> ) {\r\n\r\n        return new Promise(function(ok,no) {\r\n\r\n            var settled = false;\r\n            var single_ok = function(val) {\r\n                if(settled) return;\r\n                settled = true;\r\n                ok(val);\r\n            }\r\n\r\n            var single_err = function(val) {\r\n                if(settled) return;\r\n                settled = true;\r\n                no(val);\r\n            }\r\n\r\n            for(promise in list) {\r\n                promise.then(single_ok).error(single_err);\r\n            }\r\n        });\r\n\r\n    } //race\r\n\r\n        /** The Promise.reject function returns a Promise object\r\n            that is rejected with the optional reason. */\r\n    public static function reject<T>( ?reason:T ) {\r\n\r\n        return new Promise(function(ok, no){\r\n            no(reason);\r\n        });\r\n\r\n    } //reject\r\n\r\n        /** The static Promise.resolve function returns a Promise object\r\n            that is resolved with the given value. */\r\n    public static function resolve<T>( ?val:T ) {\r\n\r\n        return new Promise(function(ok, no){\r\n            ok(val);\r\n        });\r\n\r\n    } //resolve\r\n\r\n//Debug\r\n\r\n    function toString() {\r\n        return 'Promise { state:${state_string()}, result:$result }';\r\n    }\r\n\r\n//Internal\r\n\r\n        /** internal: Add a settle reaction unless\r\n            this promise is already settled,\r\n            if it is the call is deferred but happens \"immediately\" */\r\n    function add_settle(f) {\r\n\r\n        if(state == pending) {\r\n            settle_reactions.push(f);\r\n        } else {\r\n            Promises.defer(f,result);\r\n        }\r\n\r\n    } //add_settle\r\n\r\n        /** internal: Return a new linked promise that\r\n            will wait on this, and settle it with this result */\r\n    function new_linked_promise() {\r\n\r\n        return new Promise(function(f, r) {\r\n            add_settle(function(_){\r\n                if(state == fulfilled){\r\n                    f(result);\r\n                } else {\r\n                    r(result);\r\n                }\r\n            });\r\n        }); //promise\r\n\r\n    } //\r\n\r\n\r\n        /** internal: Return a resolved promise that\r\n            will wait on this, and fulfill with this result */\r\n    function new_linked_resolve() {\r\n        return new Promise(function (f,r) {\r\n            add_settle(function(val) {\r\n                f(val);\r\n            });\r\n        });\r\n    } //\r\n\r\n        /** internal: Return a rejected promise that\r\n            will wait on this, and reject with this result */\r\n    function new_linked_reject() {\r\n        return new Promise(function (f,r) {\r\n            add_settle(function(val){\r\n                r(val);\r\n            });\r\n        });\r\n    } //\r\n\r\n        /** internal: Return an already resolved\r\n            promise that will wait on this one\r\n            but have no value fulfilled */\r\n    function new_linked_resolve_empty() {\r\n        return new Promise(function(f,r) {\r\n            add_settle(function(_){\r\n                f();\r\n            });\r\n        });\r\n    } //\r\n\r\n        /** internal: Return an already rejected\r\n            promise that will wait on this one\r\n            but have no value rejected */\r\n    function new_linked_reject_empty() {\r\n        return new Promise(function(f,r) {\r\n            add_settle(function(_){\r\n                r();\r\n            });\r\n        });\r\n    } //\r\n\r\n\r\n        /** internal: Add a fulfill reaction callback */\r\n    function add_fulfill<T>(f:T) {\r\n        if(f != null) {\r\n            fulfill_reactions.push(f);\r\n        }\r\n    } //\r\n\r\n        /** internal: Add a reject reaction callback */\r\n    function add_reject<T>(f:T) {\r\n        if(f != null) {\r\n            was_caught = true;\r\n            reject_reactions.push(f);\r\n        }\r\n    } //\r\n\r\n//State shifts\r\n\r\n        /** internal: Called if the promise is fulfilled. */\r\n    function onfulfill<T>( val:T ) {\r\n\r\n        // trace('resolve: to $val, with ${fulfill_reactions.length} reactions');\r\n\r\n        state = fulfilled;\r\n        result = val;\r\n\r\n        while(fulfill_reactions.length > 0) {\r\n            var fn = fulfill_reactions.shift();\r\n            fn(result);\r\n        }\r\n\r\n        onsettle();\r\n\r\n    } //onfulfill\r\n\r\n        /** internal: Called if the promise is rejected. */\r\n    function onreject<T>( reason:T ) {\r\n\r\n        // trace('reject: to $reason, with ${reject_reactions.length} reactions');\r\n\r\n        state = rejected;\r\n        result = reason;\r\n\r\n        while(reject_reactions.length > 0) {\r\n            var fn = reject_reactions.shift();\r\n            fn(result);\r\n        }\r\n\r\n        onsettle();\r\n\r\n    } //onreject\r\n\r\n        /** internal: Called when the promise is settled. */\r\n    function onsettle() {\r\n\r\n        while(settle_reactions.length > 0) {\r\n            var fn = settle_reactions.shift();\r\n            fn(result);\r\n        }\r\n\r\n    } //onsettle\r\n\r\n        /** internal: Handle exceptions in the promise callback.\r\n            This causes a rejection, and if no handlers are found will throw */\r\n    function onexception<T>( err:T ) {\r\n\r\n        #if !hxpromise_dont_throw_unhandled_rejection\r\n\r\n        add_settle(function(_){\r\n            if(!was_caught) {\r\n                if(state == rejected) {\r\n                    throw PromiseError.UnhandledPromiseRejection(this.toString());\r\n                    return;\r\n                }\r\n            }\r\n        });\r\n\r\n        #end //hxpromise_throw_unhandled_rejection\r\n\r\n            //state can't transition\r\n            //and we shouldn't reject twice\r\n            //so we only reject if pending\r\n        if(state == pending) {\r\n            onreject(err);\r\n        }\r\n\r\n    } //onexception\r\n\r\n        /** internal: return a string for our state */\r\n    function state_string() {\r\n        return switch(state){\r\n            case pending:'pending';\r\n            case fulfilled:'fulfilled';\r\n            case rejected:'rejected';\r\n        }\r\n    }\r\n\r\n} //Promise\r\n\r\n\r\n/**\r\nPromises implementation. Use this to integrate the promises\r\ninto your code base. Call step at the end of a frame/microtask.\r\n*/\r\n@:allow(snow.utils.Promise)\r\nclass Promises {\r\n\r\n    static var calls: Array<Dynamic> = [];\r\n    static var defers: Array<{f:Dynamic,a:Dynamic}> = [];\r\n\r\n        /** Call this once when you want to propagate promises */\r\n    public static function step() {\r\n\r\n        next();\r\n\r\n        while(defers.length > 0) {\r\n            var defer = defers.shift();\r\n                defer.f(defer.a);\r\n        }\r\n\r\n    } //\r\n\r\n        /** Handle the next job in the queue if any */\r\n    static function next() {\r\n        if(calls.length > 0) (calls.shift())();\r\n    } //\r\n\r\n        /** Defer a call with an argument to the next step */\r\n    static function defer<T,T1>(f:T, ?a:T1) {\r\n        if(f == null) return;\r\n        defers.push({f:f, a:a});\r\n    } //\r\n\r\n        /** Queue a job to be executed in order */\r\n    static function queue<T>(f:T) {\r\n        if(f == null) return;\r\n        calls.push(f);\r\n    } //\r\n\r\n} //Promises\r\n\r\n//Promise types\r\n\r\nenum PromiseError {\r\n    UnhandledPromiseRejection(err:Dynamic);\r\n}\r\n\r\n@:enum\r\nabstract PromiseState(Int) from Int to Int {\r\n        //initial state, not fulfilled or rejected\r\n    var pending = 0;\r\n        //successful operation\r\n    var fulfilled = 1;\r\n        //failed operation\r\n    var rejected = 2;\r\n\r\n} //\r\n","package snow.utils;\r\n\r\nimport haxe.PosInfos;\r\nimport haxe.Log;\r\n\r\n    class Timer {\r\n\r\n        static var running_timers:Array<Timer> = [];\r\n\r\n        @:noCompletion public var time:Float;\r\n        @:noCompletion public var fire_at:Float;\r\n        @:noCompletion public var running:Bool;\r\n\r\n        public function new(_time:Float) {\r\n\r\n            time = _time;\r\n            running_timers.push( this );\r\n            fire_at = stamp() + time;\r\n            running = true;\r\n\r\n        } //new\r\n\r\n        public static function measure<T>( f : Void -> T, ?pos : PosInfos ) : T {\r\n            var t0 = stamp();\r\n            var r = f();\r\n            Log.trace((stamp() - t0) + \"s\", pos);\r\n            return r;\r\n        }\r\n\r\n        // Set this with \"run=...\"\r\n        dynamic public function run () { }\r\n\r\n        public function stop ():Void {\r\n\r\n            if (running) {\r\n                running = false;\r\n                running_timers.remove (this);\r\n            }\r\n\r\n        } //stop\r\n\r\n\r\n        /**\r\n         * @private\r\n         */\r\n        @:noCompletion public static function update() {\r\n\r\n            var now = stamp();\r\n\r\n            for (timer in running_timers) {\r\n                if(timer.running) {\r\n                    if(timer.fire_at < now) {\r\n                        timer.fire_at += timer.time;\r\n                        timer.run();\r\n                    } //now\r\n                }\r\n            } //all timers\r\n\r\n        } //update\r\n\r\n            //From std/haxe/Timer.hx\r\n        public static function delay( _time:Float, _f:Void -> Void ) {\r\n\r\n            var t = new Timer( _time );\r\n            t.run = function() {\r\n                t.stop();\r\n                _f();\r\n            };\r\n\r\n            return t;\r\n\r\n        } //delay\r\n\r\n\r\n        static public function stamp():Float {\r\n            return Snow.core.timestamp();\r\n        } //stamp()\r\n\r\n    } //Timer\r\n\r\n","/*\r\n * format - haXe File Formats\r\n *\r\n * Copyright (c) 2008-2009, The haXe Project Contributors\r\n * All rights reserved.\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n *   - Redistributions of source code must retain the above copyright\r\n *     notice, this list of conditions and the following disclaimer.\r\n *   - Redistributions in binary form must reproduce the above copyright\r\n *     notice, this list of conditions and the following disclaimer in the\r\n *     documentation and/or other materials provided with the distribution.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE HAXE PROJECT CONTRIBUTORS \"AS IS\" AND ANY\r\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL THE HAXE PROJECT CONTRIBUTORS BE LIABLE FOR\r\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\r\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\r\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\r\n * DAMAGE.\r\n */\r\npackage snow.utils.format.png;\r\nimport snow.utils.format.png.Data;\r\n\r\nclass Reader {\r\n\r\n\tvar i : haxe.io.Input;\r\n\tpublic var checkCRC : Bool;\r\n\r\n\tpublic function new(i) {\r\n\t\tthis.i = i;\r\n\t\ti.bigEndian = true;\r\n\t\tcheckCRC = true;\r\n\t}\r\n\r\n\tpublic function read() : Data {\r\n\t\tfor( b in [137,80,78,71,13,10,26,10] )\r\n\t\t\tif( i.readByte() != b )\r\n\t\t\t\tthrow \"Invalid header\";\r\n\r\n\t\tvar l = new List();\r\n\t\twhile( true ) {\r\n\t\t\tvar c = readChunk();\r\n\t\t\tl.add(c);\r\n\t\t\tif( c == CEnd )\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\treturn l;\r\n\t}\r\n\r\n\tfunction readHeader( i : haxe.io.Input ) : Header {\r\n\t\ti.bigEndian = true;\r\n\t\t#if haxe3\r\n\t\tvar width = i.readInt32();\r\n\t\tvar height = i.readInt32();\r\n\t\t#else\r\n\t\tvar width = i.readUInt30();\r\n\t\tvar height = i.readUInt30();\r\n\t\t#end\r\n\t\tvar colbits = i.readByte();\r\n\t\tvar color = i.readByte();\r\n\t\tvar color = switch( color ) {\r\n\t\tcase 0: ColGrey(false);\r\n\t\tcase 2: ColTrue(false);\r\n\t\tcase 3: ColIndexed;\r\n\t\tcase 4: ColGrey(true);\r\n\t\tcase 6: ColTrue(true);\r\n\t\tdefault: throw \"Unknown color model \"+color+\":\"+colbits;\r\n\t\t};\r\n\t\tvar compress = i.readByte();\r\n\t\tvar filter = i.readByte();\r\n\t\tif( compress != 0 || filter != 0 )\r\n\t\t\tthrow \"Invalid header\";\r\n\t\tvar interlace = i.readByte();\r\n\t\tif( interlace != 0 && interlace != 1 )\r\n\t\t\tthrow \"Invalid header\";\r\n\t\treturn {\r\n\t\t\twidth : width,\r\n\t\t\theight : height,\r\n\t\t\tcolbits : colbits,\r\n\t\t\tcolor : color,\r\n\t\t\tinterlaced : interlace == 1,\r\n\t\t};\r\n\t}\r\n\r\n\tfunction readChunk() {\r\n\t\tvar dataLen = #if haxe3 i.readInt32() #else i.readUInt30() #end;\r\n\t\tvar id = i.readString(4);\r\n\t\tvar data = i.read(dataLen);\r\n\t\tvar crc = i.readInt32();\r\n\t\tif( checkCRC ) {\r\n\t\t\t#if haxe3\r\n\t\t\tvar c = new haxe.crypto.Crc32();\r\n\t\t\tfor( i in 0...4 )\r\n\t\t\t\tc.byte(id.charCodeAt(i));\r\n\t\t\tc.update(data, 0, data.length);\r\n\t\t\tif( c.get() != crc )\r\n\t\t\t\tthrow \"CRC check failure\";\r\n\t\t\t#else\r\n\t\t\tvar c = new format.tools.CRC32();\r\n\t\t\tfor( i in 0...4 )\r\n\t\t\t\tc.byte(id.charCodeAt(i));\r\n\t\t\tc.run(data);\r\n\t\t\tif( haxe.Int32.compare(c.get(),crc) != 0 )\r\n\t\t\t\tthrow \"CRC check failure\";\r\n\t\t\t#end\r\n\t\t}\r\n\t\treturn switch( id ) {\r\n\t\tcase \"IEND\": CEnd;\r\n\t\tcase \"IHDR\": CHeader(readHeader(new haxe.io.BytesInput(data)));\r\n\t\tcase \"IDAT\": CData(data);\r\n\t\tcase \"PLTE\": CPalette(data);\r\n\t\tdefault: CUnknown(id,data);\r\n\t\t}\r\n\t}\r\n\r\n}","/*\r\n * format - haXe File Formats\r\n *\r\n * Copyright (c) 2008-2009, The haXe Project Contributors\r\n * All rights reserved.\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n *   - Redistributions of source code must retain the above copyright\r\n *     notice, this list of conditions and the following disclaimer.\r\n *   - Redistributions in binary form must reproduce the above copyright\r\n *     notice, this list of conditions and the following disclaimer in the\r\n *     documentation and/or other materials provided with the distribution.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE HAXE PROJECT CONTRIBUTORS \"AS IS\" AND ANY\r\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL THE HAXE PROJECT CONTRIBUTORS BE LIABLE FOR\r\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\r\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\r\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\r\n * DAMAGE.\r\n */\r\npackage snow.utils.format.png;\r\nimport snow.utils.format.png.Data;\r\n\r\nclass Tools {\r\n\r\n\t/**\r\n\t\tReturns the PNG header informations. Throws an exception if no header found.\r\n\t**/\r\n\tpublic static function getHeader( d : Data ) : Header {\r\n\t\tfor( c in d )\r\n\t\t\tswitch( c ) {\r\n\t\t\tcase CHeader(h): return h;\r\n\t\t\tdefault:\r\n\t\t\t}\r\n\t\tthrow \"Header not found\";\r\n\t}\r\n\r\n\t/**\r\n\t\tReturn the PNG palette colors, or null if no palette chunk was found\r\n\t**/\r\n\tpublic static function getPalette( d : Data ) : haxe.io.Bytes {\r\n\t\tfor( c in d )\r\n\t\t\tswitch( c )  {\r\n\t\t\tcase CPalette(b): return b;\r\n\t\t\tdefault:\r\n\t\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\tstatic inline function filter( data : #if flash10 format.tools.MemoryBytes #else haxe.io.Bytes #end, x, y, stride, prev, p, numChannels=4 ) {\r\n\t\tvar b = y == 0 ? 0 : data.get(p - stride);\r\n\t\tvar c = x == 0 || y == 0  ? 0 : data.get(p - stride - numChannels);\r\n\t\tvar k = prev + b - c;\r\n\t\tvar pa = k - prev; if( pa < 0 ) pa = -pa;\r\n\t\tvar pb = k - b; if( pb < 0 ) pb = -pb;\r\n\t\tvar pc = k - c; if( pc < 0 ) pc = -pc;\r\n\t\treturn (pa <= pb && pa <= pc) ? prev : (pb <= pc ? b : c);\r\n\t}\r\n\r\n\t/**\r\n\t\tConverts from BGRA to ARGB and the other way by reversing bytes.\r\n\t**/\r\n\tpublic static function reverseBytes( b : haxe.io.Bytes ) {\r\n\t\t#if flash10\r\n\t\tvar bytes = b.getData();\r\n\t\tif( bytes.length < 1024 ) bytes.length = 1024;\r\n\t\tflash.Memory.select(bytes);\r\n\t\t#end\r\n\t\tinline function bget(p) {\r\n\t\t\t#if flash10\r\n\t\t\treturn flash.Memory.getByte(p);\r\n\t\t\t#else\r\n\t\t\treturn b.get(p);\r\n\t\t\t#end\r\n\t\t}\r\n\t\tinline function bset(p,v) {\r\n\t\t\t#if flash10\r\n\t\t\tflash.Memory.setByte(p,v);\r\n\t\t\t#else\r\n\t\t\treturn b.set(p,v);\r\n\t\t\t#end\r\n\t\t}\r\n\t\tvar p = 0;\r\n\t\tfor( i in 0...b.length >> 2 ) {\r\n\t\t\tvar b = bget(p);\r\n\t\t\tvar g = bget(p + 1);\r\n\t\t\tvar r = bget(p + 2);\r\n\t\t\tvar a = bget(p + 3);\r\n\t\t\tbset(p++, a);\r\n\t\t\tbset(p++, r);\r\n\t\t\tbset(p++, g);\r\n\t\t\tbset(p++, b);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t\tDecode the greyscale PNG data and apply filters, extracting only the grey channel if alpha is present.\r\n\t**/\r\n\t@:noDebug\r\n\tpublic static function extractGrey( d : Data ) : haxe.io.Bytes {\r\n\t\tvar h = getHeader(d);\r\n\t\tvar grey = haxe.io.Bytes.alloc(h.width * h.height);\r\n\t\tvar data = null;\r\n\t\tvar fullData : haxe.io.BytesBuffer = null;\r\n\t\tfor( c in d )\r\n\t\t\tswitch( c ) {\r\n\t\t\tcase CData(b):\r\n\t\t\t\tif( fullData != null )\r\n\t\t\t\t\tfullData.add(b);\r\n\t\t\t\telse if( data == null )\r\n\t\t\t\t\tdata = b;\r\n\t\t\t\telse {\r\n\t\t\t\t\tfullData = new haxe.io.BytesBuffer();\r\n\t\t\t\t\tfullData.add(data);\r\n\t\t\t\t\tfullData.add(b);\r\n\t\t\t\t\tdata = null;\r\n\t\t\t\t}\r\n\t\t\tdefault:\r\n\t\t\t}\r\n\t\tif( fullData != null )\r\n\t\t\tdata = fullData.getBytes();\r\n\t\tif( data == null )\r\n\t\t\tthrow \"Data not found\";\r\n\t\tdata = snow.utils.format.tools.Inflate.run(data);\r\n\t\tvar r = 0, w = 0;\r\n\t\tswitch( h.color ) {\r\n\t\tdefault:\r\n\t\t\tthrow \"Unsupported color mode\";\r\n\t\tcase ColGrey(alpha):\r\n\t\t\tif( h.colbits != 8 )\r\n\t\t\t\tthrow \"Unsupported color mode\";\r\n\t\t\tvar width = h.width;\r\n\t\t\tvar stride = (alpha ? 2 : 1) * width + 1;\r\n\t\t\tif( data.length < h.height * stride ) throw \"Not enough data\";\r\n\r\n\t\t\t#if flash10\r\n\t\t\tvar bytes = data.getData();\r\n\t\t\tvar start = h.height * stride;\r\n\t\t\tbytes.length = start + h.width * h.height;\r\n\t\t\tif( bytes.length < 1024 ) bytes.length = 1024;\r\n\t\t\tflash.Memory.select(bytes);\r\n\t\t\tvar realData = data, realGrey = grey;\r\n\t\t\tvar data = format.tools.MemoryBytes.make(0);\r\n\t\t\tvar grey = format.tools.MemoryBytes.make(start);\r\n\t\t\t#end\r\n\r\n\t\t\tvar rinc = (alpha ? 2 : 1);\r\n\t\t\tfor( y in 0...h.height ) {\r\n\t\t\t\tvar f = data.get(r++);\r\n\t\t\t\tswitch( f ) {\r\n\t\t\t\tcase 0:\r\n\t\t\t\t\tfor( x in 0...width ) {\r\n\t\t\t\t\t\tvar v = data.get(r); r += rinc;\r\n\t\t\t\t\t\tgrey.set(w++,v);\r\n\t\t\t\t\t}\r\n\t\t\t\tcase 1:\r\n\t\t\t\t\tvar cv = 0;\r\n\t\t\t\t\tfor( x in 0...width ) {\r\n\t\t\t\t\t\tcv += data.get(r); r += rinc;\r\n\t\t\t\t\t\tgrey.set(w++,cv);\r\n\t\t\t\t\t}\r\n\t\t\t\tcase 2:\r\n\t\t\t\t\tvar stride = y == 0 ? 0 : width;\r\n\t\t\t\t\tfor( x in 0...width ) {\r\n\t\t\t\t\t\tvar v = data.get(r) + grey.get(w - stride); r += rinc;\r\n\t\t\t\t\t\tgrey.set(w++, v);\r\n\t\t\t\t\t}\r\n\t\t\t\tcase 3:\r\n\t\t\t\t\tvar cv = 0;\r\n\t\t\t\t\tvar stride = y == 0 ? 0 : width;\r\n\t\t\t\t\tfor( x in 0...width ) {\r\n\t\t\t\t\t\tcv = (data.get(r) + ((cv + grey.get(w - stride)) >> 1)) & 0xFF; r += rinc;\r\n\t\t\t\t\t\tgrey.set(w++,cv);\r\n\t\t\t\t\t}\r\n\t\t\t\tcase 4:\r\n\t\t\t\t\tvar stride = width;\r\n\t\t\t\t\tvar cv = 0;\r\n\t\t\t\t\tfor( x in 0...width ) {\r\n\t\t\t\t\t\tcv = (filter(grey, x, y, stride, cv, w, 1) + data.get(r)) & 0xFF; r += rinc;\r\n\t\t\t\t\t\tgrey.set(w++, cv);\r\n\t\t\t\t\t}\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow \"Invalid filter \"+f;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t#if flash10\r\n\t\t\tvar b = realGrey.getData();\r\n\t\t\tb.position = 0;\r\n\t\t\tb.writeBytes(realData.getData(), start, h.width * h.height);\r\n\t\t\t#end\r\n\t\t}\r\n\t\treturn grey;\r\n\t}\r\n\t/**\r\n\t\tDecode the PNG data and apply filters. By default this will output BGRA low-endian format. You can use the [reverseBytes] function to inverse the bytes to ARGB big-endian format.\r\n\t**/\r\n\t@:noDebug\r\n\tpublic static function extract32( d : Data, ?bytes ) : haxe.io.Bytes {\r\n\t\tvar h = getHeader(d);\r\n\t\tvar bgra = bytes == null ? haxe.io.Bytes.alloc(h.width * h.height * 4) : bytes;\r\n\t\tvar data = null;\r\n\t\tvar fullData : haxe.io.BytesBuffer = null;\r\n\t\tfor( c in d )\r\n\t\t\tswitch( c ) {\r\n\t\t\tcase CData(b):\r\n\t\t\t\tif( fullData != null )\r\n\t\t\t\t\tfullData.add(b);\r\n\t\t\t\telse if( data == null )\r\n\t\t\t\t\tdata = b;\r\n\t\t\t\telse {\r\n\t\t\t\t\tfullData = new haxe.io.BytesBuffer();\r\n\t\t\t\t\tfullData.add(data);\r\n\t\t\t\t\tfullData.add(b);\r\n\t\t\t\t\tdata = null;\r\n\t\t\t\t}\r\n\t\t\tdefault:\r\n\t\t\t}\r\n\t\tif( fullData != null )\r\n\t\t\tdata = fullData.getBytes();\r\n\t\tif( data == null )\r\n\t\t\tthrow \"Data not found\";\r\n\t\tdata = snow.utils.format.tools.Inflate.run(data);\r\n\t\tvar r = 0, w = 0;\r\n\t\tswitch( h.color ) {\r\n\t\tcase ColIndexed:\r\n\t\t\tvar pal = getPalette(d);\r\n\t\t\tif( pal == null ) throw \"PNG Palette is missing\";\r\n\t\t\t\r\n\t\t\t// transparent palette extension\r\n\t\t\tvar alpha = null;\r\n\t\t\tfor( t in d )\r\n\t\t\t\tswitch( t ) {\r\n\t\t\t\tcase CUnknown(\"tRNS\", data): alpha = data; break;\r\n\t\t\t\tdefault:\r\n\t\t\t\t}\r\n\t\t\t\r\n\t\t\tvar width = h.width;\r\n\t\t\tvar stride = width + 1;\r\n\t\t\tif( data.length < h.height * stride ) throw \"Not enough data\";\r\n\r\n\t\t\t#if flash10\r\n\t\t\tvar bytes = data.getData();\r\n\t\t\tvar start = h.height * stride;\r\n\t\t\tbytes.length = start + h.width * h.height * 4;\r\n\t\t\tif( bytes.length < 1024 ) bytes.length = 1024;\r\n\t\t\tflash.Memory.select(bytes);\r\n\t\t\tvar realData = data, realRgba = bgra;\r\n\t\t\tvar data = format.tools.MemoryBytes.make(0);\r\n\t\t\tvar bgra = format.tools.MemoryBytes.make(start);\r\n\t\t\t#end\r\n\r\n\t\t\tvar vr, vg, vb, va = 0xFF;\r\n\t\t\tinline function decode() {\r\n\t\t\t\tvar c = data.get(r++);\r\n\t\t\t\tvr = pal.get(c * 3);\r\n\t\t\t\tvg = pal.get(c * 3 + 1);\r\n\t\t\t\tvb = pal.get(c * 3 + 2);\r\n\t\t\t\tif( alpha != null ) va = alpha.get(c);\r\n\t\t\t}\r\n\t\t\tfor( y in 0...h.height ) {\r\n\t\t\t\tvar f = data.get(r++);\r\n\t\t\t\tswitch( f ) {\r\n\t\t\t\tcase 0:\r\n\t\t\t\t\tfor( x in 0...width ) {\r\n\t\t\t\t\t\tdecode();\r\n\t\t\t\t\t\tbgra.set(w++,vb);\r\n\t\t\t\t\t\tbgra.set(w++,vg);\r\n\t\t\t\t\t\tbgra.set(w++,vr);\r\n\t\t\t\t\t\tbgra.set(w++,va);\r\n\t\t\t\t\t}\r\n\t\t\t\tcase 1:\r\n\t\t\t\t\tvar cr = 0, cg = 0, cb = 0, ca = 0;\r\n\t\t\t\t\tfor( x in 0...width ) {\r\n\t\t\t\t\t\tdecode();\r\n\t\t\t\t\t\tcb += vb;\tbgra.set(w++,cb);\r\n\t\t\t\t\t\tcg += vg;\tbgra.set(w++,cg);\r\n\t\t\t\t\t\tcr += vr;\tbgra.set(w++,cr);\r\n\t\t\t\t\t\tca += va;\tbgra.set(w++,ca);\r\n\t\t\t\t\t\tbgra.set(w++, va);\r\n\t\t\t\t\t}\r\n\t\t\t\tcase 2:\r\n\t\t\t\t\tvar stride = y == 0 ? 0 : width * 4;\r\n\t\t\t\t\tfor( x in 0...width ) {\r\n\t\t\t\t\t\tdecode();\r\n\t\t\t\t\t\tbgra.set(w, vb + bgra.get(w - stride));\tw++;\r\n\t\t\t\t\t\tbgra.set(w, vg + bgra.get(w - stride));\tw++;\r\n\t\t\t\t\t\tbgra.set(w, vr + bgra.get(w - stride));\tw++;\r\n\t\t\t\t\t\tbgra.set(w, va + bgra.get(w - stride));\tw++;\r\n\t\t\t\t\t}\r\n\t\t\t\tcase 3:\r\n\t\t\t\t\tvar cr = 0, cg = 0, cb = 0, ca = 0;\r\n\t\t\t\t\tvar stride = y == 0 ? 0 : width * 4;\r\n\t\t\t\t\tfor( x in 0...width ) {\r\n\t\t\t\t\t\tdecode();\r\n\t\t\t\t\t\tcb = (vb + ((cb + bgra.get(w - stride)) >> 1)) & 0xFF;\tbgra.set(w++, cb);\r\n\t\t\t\t\t\tcg = (vg + ((cg + bgra.get(w - stride)) >> 1)) & 0xFF;\tbgra.set(w++, cg);\r\n\t\t\t\t\t\tcr = (vr + ((cr + bgra.get(w - stride)) >> 1)) & 0xFF;\tbgra.set(w++, cr);\r\n\t\t\t\t\t\tcr = (va + ((ca + bgra.get(w - stride)) >> 1)) & 0xFF;\tbgra.set(w++, ca);\r\n\t\t\t\t\t}\r\n\t\t\t\tcase 4:\r\n\t\t\t\t\tvar stride = width * 4;\r\n\t\t\t\t\tvar cr = 0, cg = 0, cb = 0, ca = 0;\r\n\t\t\t\t\tfor( x in 0...width ) {\r\n\t\t\t\t\t\tdecode();\r\n\t\t\t\t\t\tcb = (filter(bgra, x, y, stride, cb, w) + vb) & 0xFF; bgra.set(w++, cb);\r\n\t\t\t\t\t\tcg = (filter(bgra, x, y, stride, cg, w) + vg) & 0xFF; bgra.set(w++, cg);\r\n\t\t\t\t\t\tcr = (filter(bgra, x, y, stride, cr, w) + vr) & 0xFF; bgra.set(w++, cr);\r\n\t\t\t\t\t\tca = (filter(bgra, x, y, stride, ca, w) + va) & 0xFF; bgra.set(w++, ca);\r\n\t\t\t\t\t}\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow \"Invalid filter \"+f;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t#if flash10\r\n\t\t\tvar b = realRgba.getData();\r\n\t\t\tb.position = 0;\r\n\t\t\tb.writeBytes(realData.getData(), start, h.width * h.height * 4);\r\n\t\t\t#end\r\n\r\n\t\tcase ColGrey(alpha):\r\n\t\t\tif( h.colbits != 8 )\r\n\t\t\t\tthrow \"Unsupported color mode\";\r\n\t\t\tvar width = h.width;\r\n\t\t\tvar stride = (alpha ? 2 : 1) * width + 1;\r\n\t\t\tif( data.length < h.height * stride ) throw \"Not enough data\";\r\n\r\n\t\t\t#if flash10\r\n\t\t\tvar bytes = data.getData();\r\n\t\t\tvar start = h.height * stride;\r\n\t\t\tbytes.length = start + h.width * h.height * 4;\r\n\t\t\tif( bytes.length < 1024 ) bytes.length = 1024;\r\n\t\t\tflash.Memory.select(bytes);\r\n\t\t\tvar realData = data, realRgba = bgra;\r\n\t\t\tvar data = format.tools.MemoryBytes.make(0);\r\n\t\t\tvar bgra = format.tools.MemoryBytes.make(start);\r\n\t\t\t#end\r\n\r\n\t\t\tfor( y in 0...h.height ) {\r\n\t\t\t\tvar f = data.get(r++);\r\n\t\t\t\tswitch( f ) {\r\n\t\t\t\tcase 0:\r\n\t\t\t\t\tif( alpha )\r\n\t\t\t\t\t\tfor( x in 0...width ) {\r\n\t\t\t\t\t\t\tvar v = data.get(r++);\r\n\t\t\t\t\t\t\tbgra.set(w++,v);\r\n\t\t\t\t\t\t\tbgra.set(w++,v);\r\n\t\t\t\t\t\t\tbgra.set(w++,v);\r\n\t\t\t\t\t\t\tbgra.set(w++,data.get(r++));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tfor( x in 0...width ) {\r\n\t\t\t\t\t\t\tvar v = data.get(r++);\r\n\t\t\t\t\t\t\tbgra.set(w++,v);\r\n\t\t\t\t\t\t\tbgra.set(w++,v);\r\n\t\t\t\t\t\t\tbgra.set(w++,v);\r\n\t\t\t\t\t\t\tbgra.set(w++,0xFF);\r\n\t\t\t\t\t\t}\r\n\t\t\t\tcase 1:\r\n\t\t\t\t\tvar cv = 0, ca = 0;\r\n\t\t\t\t\tif( alpha )\r\n\t\t\t\t\t\tfor( x in 0...width ) {\r\n\t\t\t\t\t\t\tcv += data.get(r++);\r\n\t\t\t\t\t\t\tbgra.set(w++,cv);\r\n\t\t\t\t\t\t\tbgra.set(w++,cv);\r\n\t\t\t\t\t\t\tbgra.set(w++,cv);\r\n\t\t\t\t\t\t\tca += data.get(r++);\r\n\t\t\t\t\t\t\tbgra.set(w++,ca);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tfor( x in 0...width ) {\r\n\t\t\t\t\t\t\tcv += data.get(r++);\r\n\t\t\t\t\t\t\tbgra.set(w++,cv);\r\n\t\t\t\t\t\t\tbgra.set(w++,cv);\r\n\t\t\t\t\t\t\tbgra.set(w++,cv);\r\n\t\t\t\t\t\t\tbgra.set(w++,0xFF);\r\n\t\t\t\t\t\t}\r\n\t\t\t\tcase 2:\r\n\t\t\t\t\tvar stride = y == 0 ? 0 : width * 4;\r\n\t\t\t\t\tif( alpha )\r\n\t\t\t\t\t\tfor( x in 0...width ) {\r\n\t\t\t\t\t\t\tvar v = data.get(r++) + bgra.get(w - stride);\r\n\t\t\t\t\t\t\tbgra.set(w++, v);\r\n\t\t\t\t\t\t\tbgra.set(w++, v);\r\n\t\t\t\t\t\t\tbgra.set(w++, v);\r\n\t\t\t\t\t\t\tbgra.set(w++, data.get(r++) + bgra.get(w - stride));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tfor( x in 0...width ) {\r\n\t\t\t\t\t\t\tvar v = data.get(r++) + bgra.get(w - stride);\r\n\t\t\t\t\t\t\tbgra.set(w++, v);\r\n\t\t\t\t\t\t\tbgra.set(w++, v);\r\n\t\t\t\t\t\t\tbgra.set(w++, v);\r\n\t\t\t\t\t\t\tbgra.set(w++,0xFF);\r\n\t\t\t\t\t\t}\r\n\t\t\t\tcase 3:\r\n\t\t\t\t\tvar cv = 0, ca = 0;\r\n\t\t\t\t\tvar stride = y == 0 ? 0 : width * 4;\r\n\t\t\t\t\tif( alpha )\r\n\t\t\t\t\t\tfor( x in 0...width ) {\r\n\t\t\t\t\t\t\tcv = (data.get(r++) + ((cv + bgra.get(w - stride)) >> 1)) & 0xFF;\r\n\t\t\t\t\t\t\tbgra.set(w++,cv);\r\n\t\t\t\t\t\t\tbgra.set(w++,cv);\r\n\t\t\t\t\t\t\tbgra.set(w++,cv);\r\n\t\t\t\t\t\t\tca = (data.get(r++) + ((ca + bgra.get(w - stride)) >> 1)) & 0xFF;\r\n\t\t\t\t\t\t\tbgra.set(w++,ca);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tfor( x in 0...width ) {\r\n\t\t\t\t\t\t\tcv = (data.get(r++) + ((cv + bgra.get(w - stride)) >> 1)) & 0xFF;\r\n\t\t\t\t\t\t\tbgra.set(w++,cv);\r\n\t\t\t\t\t\t\tbgra.set(w++,cv);\r\n\t\t\t\t\t\t\tbgra.set(w++,cv);\r\n\t\t\t\t\t\t\tbgra.set(w++,0xFF);\r\n\t\t\t\t\t\t}\r\n\t\t\t\tcase 4:\r\n\t\t\t\t\tvar stride = width * 4;\r\n\t\t\t\t\tvar cv = 0, ca = 0;\r\n\t\t\t\t\tif( alpha )\r\n\t\t\t\t\t\tfor( x in 0...width ) {\r\n\t\t\t\t\t\t\tcv = (filter(bgra, x, y, stride, cv, w) + data.get(r++)) & 0xFF;\r\n\t\t\t\t\t\t\tbgra.set(w++, cv);\r\n\t\t\t\t\t\t\tbgra.set(w++, cv);\r\n\t\t\t\t\t\t\tbgra.set(w++, cv);\r\n\t\t\t\t\t\t\tca = (filter(bgra, x, y, stride, ca, w) + data.get(r++)) & 0xFF;\r\n\t\t\t\t\t\t\tbgra.set(w++, ca);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tfor( x in 0...width ) {\r\n\t\t\t\t\t\t\tcv = (filter(bgra, x, y, stride, cv, w) + data.get(r++)) & 0xFF;\r\n\t\t\t\t\t\t\tbgra.set(w++, cv);\r\n\t\t\t\t\t\t\tbgra.set(w++, cv);\r\n\t\t\t\t\t\t\tbgra.set(w++, cv);\r\n\t\t\t\t\t\t\tbgra.set(w++, 0xFF);\r\n\t\t\t\t\t\t}\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow \"Invalid filter \"+f;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t#if flash10\r\n\t\t\tvar b = realRgba.getData();\r\n\t\t\tb.position = 0;\r\n\t\t\tb.writeBytes(realData.getData(), start, h.width * h.height * 4);\r\n\t\t\t#end\r\n\r\n\t\tcase ColTrue(alpha):\r\n\t\t\tif( h.colbits != 8 )\r\n\t\t\t\tthrow \"Unsupported color mode\";\r\n\t\t\tvar width = h.width;\r\n\t\t\tvar stride = (alpha ? 4 : 3) * width + 1;\r\n\t\t\tif( data.length < h.height * stride ) throw \"Not enough data\";\r\n\r\n\t\t\t#if flash10\r\n\t\t\tvar bytes = data.getData();\r\n\t\t\tvar start = h.height * stride;\r\n\t\t\tbytes.length = start + h.width * h.height * 4;\r\n\t\t\tif( bytes.length < 1024 ) bytes.length = 1024;\r\n\t\t\tflash.Memory.select(bytes);\r\n\t\t\tvar realData = data, realRgba = bgra;\r\n\t\t\tvar data = format.tools.MemoryBytes.make(0);\r\n\t\t\tvar bgra = format.tools.MemoryBytes.make(start);\r\n\t\t\t#end\r\n\r\n\t\t\t// PNG data is encoded as RGB[A]\r\n\t\t\tfor( y in 0...h.height ) {\r\n\t\t\t\tvar f = data.get(r++);\r\n\t\t\t\tswitch( f ) {\r\n\t\t\t\tcase 0:\r\n\t\t\t\t\tif( alpha )\r\n\t\t\t\t\t\tfor( x in 0...width ) {\r\n\t\t\t\t\t\t\tbgra.set(w++,data.get(r+2));\r\n\t\t\t\t\t\t\tbgra.set(w++,data.get(r+1));\r\n\t\t\t\t\t\t\tbgra.set(w++,data.get(r));\r\n\t\t\t\t\t\t\tbgra.set(w++,data.get(r+3));\r\n\t\t\t\t\t\t\tr += 4;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tfor( x in 0...width ) {\r\n\t\t\t\t\t\t\tbgra.set(w++,data.get(r+2));\r\n\t\t\t\t\t\t\tbgra.set(w++,data.get(r+1));\r\n\t\t\t\t\t\t\tbgra.set(w++,data.get(r));\r\n\t\t\t\t\t\t\tbgra.set(w++,0xFF);\r\n\t\t\t\t\t\t\tr += 3;\r\n\t\t\t\t\t\t}\r\n\t\t\t\tcase 1:\r\n\t\t\t\t\tvar cr = 0, cg = 0, cb = 0, ca = 0;\r\n\t\t\t\t\tif( alpha )\r\n\t\t\t\t\t\tfor( x in 0...width ) {\r\n\t\t\t\t\t\t\tcb += data.get(r + 2);\tbgra.set(w++,cb);\r\n\t\t\t\t\t\t\tcg += data.get(r + 1);\tbgra.set(w++,cg);\r\n\t\t\t\t\t\t\tcr += data.get(r);\t\tbgra.set(w++,cr);\r\n\t\t\t\t\t\t\tca += data.get(r + 3);\tbgra.set(w++,ca);\r\n\t\t\t\t\t\t\tr += 4;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tfor( x in 0...width ) {\r\n\t\t\t\t\t\t\tcb += data.get(r + 2);\tbgra.set(w++,cb);\r\n\t\t\t\t\t\t\tcg += data.get(r + 1);\tbgra.set(w++,cg);\r\n\t\t\t\t\t\t\tcr += data.get(r);\t\tbgra.set(w++,cr);\r\n\t\t\t\t\t\t\tbgra.set(w++, 0xFF);\r\n\t\t\t\t\t\t\tr += 3;\r\n\t\t\t\t\t\t}\r\n\t\t\t\tcase 2:\r\n\t\t\t\t\tvar stride = y == 0 ? 0 : width * 4;\r\n\t\t\t\t\tif( alpha )\r\n\t\t\t\t\t\tfor( x in 0...width ) {\r\n\t\t\t\t\t\t\tbgra.set(w, data.get(r + 2) + bgra.get(w - stride));\tw++;\r\n\t\t\t\t\t\t\tbgra.set(w, data.get(r + 1) + bgra.get(w - stride));\tw++;\r\n\t\t\t\t\t\t\tbgra.set(w, data.get(r) + bgra.get(w - stride));\t\tw++;\r\n\t\t\t\t\t\t\tbgra.set(w, data.get(r + 3) + bgra.get(w - stride));\tw++;\r\n\t\t\t\t\t\t\tr += 4;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tfor( x in 0...width ) {\r\n\t\t\t\t\t\t\tbgra.set(w, data.get(r + 2) + bgra.get(w - stride));\tw++;\r\n\t\t\t\t\t\t\tbgra.set(w, data.get(r + 1) + bgra.get(w - stride));\tw++;\r\n\t\t\t\t\t\t\tbgra.set(w, data.get(r) + bgra.get(w - stride));\t\tw++;\r\n\t\t\t\t\t\t\tbgra.set(w++,0xFF);\r\n\t\t\t\t\t\t\tr += 3;\r\n\t\t\t\t\t\t}\r\n\t\t\t\tcase 3:\r\n\t\t\t\t\tvar cr = 0, cg = 0, cb = 0, ca = 0;\r\n\t\t\t\t\tvar stride = y == 0 ? 0 : width * 4;\r\n\t\t\t\t\tif( alpha )\r\n\t\t\t\t\t\tfor( x in 0...width ) {\r\n\t\t\t\t\t\t\tcb = (data.get(r + 2) + ((cb + bgra.get(w - stride)) >> 1)) & 0xFF;\tbgra.set(w++, cb);\r\n\t\t\t\t\t\t\tcg = (data.get(r + 1) + ((cg + bgra.get(w - stride)) >> 1)) & 0xFF;\tbgra.set(w++, cg);\r\n\t\t\t\t\t\t\tcr = (data.get(r + 0) + ((cr + bgra.get(w - stride)) >> 1)) & 0xFF;\tbgra.set(w++, cr);\r\n\t\t\t\t\t\t\tca = (data.get(r + 3) + ((ca + bgra.get(w - stride)) >> 1)) & 0xFF;\tbgra.set(w++, ca);\r\n\t\t\t\t\t\t\tr += 4;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tfor( x in 0...width ) {\r\n\t\t\t\t\t\t\tcb = (data.get(r + 2) + ((cb + bgra.get(w - stride)) >> 1)) & 0xFF;\tbgra.set(w++, cb);\r\n\t\t\t\t\t\t\tcg = (data.get(r + 1) + ((cg + bgra.get(w - stride)) >> 1)) & 0xFF;\tbgra.set(w++, cg);\r\n\t\t\t\t\t\t\tcr = (data.get(r + 0) + ((cr + bgra.get(w - stride)) >> 1)) & 0xFF;\tbgra.set(w++, cr);\r\n\t\t\t\t\t\t\tbgra.set(w++, 0xFF);\r\n\t\t\t\t\t\t\tr += 3;\r\n\t\t\t\t\t\t}\r\n\t\t\t\tcase 4:\r\n\t\t\t\t\tvar stride = width * 4;\r\n\t\t\t\t\tvar cr = 0, cg = 0, cb = 0, ca = 0;\r\n\t\t\t\t\tif( alpha )\r\n\t\t\t\t\t\tfor( x in 0...width ) {\r\n\t\t\t\t\t\t\tcb = (filter(bgra, x, y, stride, cb, w) + data.get(r + 2)) & 0xFF; bgra.set(w++, cb);\r\n\t\t\t\t\t\t\tcg = (filter(bgra, x, y, stride, cg, w) + data.get(r + 1)) & 0xFF; bgra.set(w++, cg);\r\n\t\t\t\t\t\t\tcr = (filter(bgra, x, y, stride, cr, w) + data.get(r + 0)) & 0xFF; bgra.set(w++, cr);\r\n\t\t\t\t\t\t\tca = (filter(bgra, x, y, stride, ca, w) + data.get(r + 3)) & 0xFF; bgra.set(w++, ca);\r\n\t\t\t\t\t\t\tr += 4;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tfor( x in 0...width ) {\r\n\t\t\t\t\t\t\tcb = (filter(bgra, x, y, stride, cb, w) + data.get(r + 2)) & 0xFF; bgra.set(w++, cb);\r\n\t\t\t\t\t\t\tcg = (filter(bgra, x, y, stride, cg, w) + data.get(r + 1)) & 0xFF; bgra.set(w++, cg);\r\n\t\t\t\t\t\t\tcr = (filter(bgra, x, y, stride, cr, w) + data.get(r + 0)) & 0xFF; bgra.set(w++, cr);\r\n\t\t\t\t\t\t\tbgra.set(w++, 0xFF);\r\n\t\t\t\t\t\t\tr += 3;\r\n\t\t\t\t\t\t}\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow \"Invalid filter \"+f;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t#if flash10\r\n\t\t\tvar b = realRgba.getData();\r\n\t\t\tb.position = 0;\r\n\t\t\tb.writeBytes(realData.getData(), start, h.width * h.height * 4);\r\n\t\t\t#end\r\n\t\t}\r\n\t\treturn bgra;\r\n\t}\r\n\r\n\t/**\r\n\t\tCreates PNG data from bytes that contains one bytes (grey values) for each pixel.\r\n\t**/\r\n\tpublic static function buildGrey( width : Int, height : Int, data : haxe.io.Bytes ) : Data {\r\n\t\tvar rgb = haxe.io.Bytes.alloc(width * height + height);\r\n\t\t// translate RGB to BGR and add filter byte\r\n\t\tvar w = 0, r = 0;\r\n\t\tfor( y in 0...height ) {\r\n\t\t\trgb.set(w++,0); // no filter for this scanline\r\n\t\t\tfor( x in 0...width )\r\n\t\t\t\trgb.set(w++,data.get(r++));\r\n\t\t}\r\n\t\tvar l = new List();\r\n\t\tl.add(CHeader({ width : width, height : height, colbits : 8, color : ColGrey(false), interlaced : false }));\r\n\t\tl.add(CData(snow.utils.format.tools.Deflate.run(rgb)));\r\n\t\tl.add(CEnd);\r\n\t\treturn l;\r\n\t}\r\n\r\n\t/**\r\n\t\tCreates PNG data from bytes that contains three bytes (R,G and B values) for each pixel.\r\n\t**/\r\n\tpublic static function buildRGB( width : Int, height : Int, data : haxe.io.Bytes ) : Data {\r\n\t\tvar rgb = haxe.io.Bytes.alloc(width * height * 3 + height);\r\n\t\t// translate RGB to BGR and add filter byte\r\n\t\tvar w = 0, r = 0;\r\n\t\tfor( y in 0...height ) {\r\n\t\t\trgb.set(w++,0); // no filter for this scanline\r\n\t\t\tfor( x in 0...width ) {\r\n\t\t\t\trgb.set(w++,data.get(r+2));\r\n\t\t\t\trgb.set(w++,data.get(r+1));\r\n\t\t\t\trgb.set(w++,data.get(r));\r\n\t\t\t\tr += 3;\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar l = new List();\r\n\t\tl.add(CHeader({ width : width, height : height, colbits : 8, color : ColTrue(false), interlaced : false }));\r\n\t\tl.add(CData(snow.utils.format.tools.Deflate.run(rgb)));\r\n\t\tl.add(CEnd);\r\n\t\treturn l;\r\n\t}\r\n\r\n\t/**\r\n\t\tCreates PNG data from bytes that contains four bytes in ARGB format for each pixel.\r\n\t**/\r\n\tpublic static function build32ARGB( width : Int, height : Int, data : haxe.io.Bytes ) : Data {\r\n\t\tvar rgba = haxe.io.Bytes.alloc(width * height * 4 + height);\r\n\t\t// translate ARGB to RGBA and add filter byte\r\n\t\tvar w = 0, r = 0;\r\n\t\tfor( y in 0...height ) {\r\n\t\t\trgba.set(w++,0); // no filter for this scanline\r\n\t\t\tfor( x in 0...width ) {\r\n\t\t\t\trgba.set(w++,data.get(r+1)); // r\r\n\t\t\t\trgba.set(w++,data.get(r+2)); // g\r\n\t\t\t\trgba.set(w++,data.get(r+3)); // b\r\n\t\t\t\trgba.set(w++,data.get(r)); // a\r\n\t\t\t\tr += 4;\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar l = new List();\r\n\t\tl.add(CHeader({ width : width, height : height, colbits : 8, color : ColTrue(true), interlaced : false }));\r\n\t\tl.add(CData(snow.utils.format.tools.Deflate.run(rgba)));\r\n\t\tl.add(CEnd);\r\n\t\treturn l;\r\n\t}\r\n\r\n\t/**\r\n\t\tCreates PNG data from bytes that contains four bytes in BGRA format for each pixel.\r\n\t**/\r\n\tpublic static function build32BGRA( width : Int, height : Int, data : haxe.io.Bytes ) : Data {\r\n\t\tvar rgba = haxe.io.Bytes.alloc(width * height * 4 + height);\r\n\t\t// translate ARGB to RGBA and add filter byte\r\n\t\tvar w = 0, r = 0;\r\n\t\tfor( y in 0...height ) {\r\n\t\t\trgba.set(w++,0); // no filter for this scanline\r\n\t\t\tfor( x in 0...width ) {\r\n\t\t\t\trgba.set(w++,data.get(r+2)); // r\r\n\t\t\t\trgba.set(w++,data.get(r+1)); // g\r\n\t\t\t\trgba.set(w++,data.get(r)); // b\r\n\t\t\t\trgba.set(w++,data.get(r+3)); // a\r\n\t\t\t\tr += 4;\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar l = new List();\r\n\t\tl.add(CHeader({ width : width, height : height, colbits : 8, color : ColTrue(true), interlaced : false }));\r\n\t\tl.add(CData(snow.utils.format.tools.Deflate.run(rgba)));\r\n\t\tl.add(CEnd);\r\n\t\treturn l;\r\n\t}\r\n\r\n}\r\n","/*\r\n * format - haXe File Formats\r\n *\r\n * Copyright (c) 2008, The haXe Project Contributors\r\n * All rights reserved.\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n *   - Redistributions of source code must retain the above copyright\r\n *     notice, this list of conditions and the following disclaimer.\r\n *   - Redistributions in binary form must reproduce the above copyright\r\n *     notice, this list of conditions and the following disclaimer in the\r\n *     documentation and/or other materials provided with the distribution.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE HAXE PROJECT CONTRIBUTORS \"AS IS\" AND ANY\r\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL THE HAXE PROJECT CONTRIBUTORS BE LIABLE FOR\r\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\r\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\r\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\r\n * DAMAGE.\r\n */\r\npackage snow.utils.format.tools;\r\n\r\nclass Adler32 {\r\n\r\n\tvar a1 : Int;\r\n\tvar a2 : Int;\r\n\r\n\tpublic function new() {\r\n\t\ta1 = 1;\r\n\t\ta2 = 0;\r\n\t}\r\n\r\n\tpublic function update( b : haxe.io.Bytes, pos, len ) {\r\n\t\tvar a1 = a1, a2 = a2;\r\n\t\tfor( p in pos...pos + len ) {\r\n\t\t\tvar c = b.get(p);\r\n\t\t\ta1 = (a1 + c) % 65521;\r\n\t\t\ta2 = (a2 + a1) % 65521;\r\n\t\t}\r\n\t\tthis.a1 = a1;\r\n\t\tthis.a2 = a2;\r\n\t}\r\n\r\n\tpublic function equals( a : Adler32 ) {\r\n\t\treturn a.a1 == a1 && a.a2 == a2;\r\n\t}\r\n\r\n\tpublic static function read( i : haxe.io.Input ) {\r\n\t\tvar a = new Adler32();\r\n\t\tvar a2a = i.readByte();\r\n\t\tvar a2b = i.readByte();\r\n\t\tvar a1a = i.readByte();\r\n\t\tvar a1b = i.readByte();\r\n\t\ta.a1 = (a1a << 8) | a1b;\r\n\t\ta.a2 = (a2a << 8) | a2b;\r\n\t\treturn a;\r\n\t}\r\n\r\n}\r\n","/*\r\n * format - haXe File Formats\r\n *\r\n * Copyright (c) 2008, The haXe Project Contributors\r\n * All rights reserved.\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n *   - Redistributions of source code must retain the above copyright\r\n *     notice, this list of conditions and the following disclaimer.\r\n *   - Redistributions in binary form must reproduce the above copyright\r\n *     notice, this list of conditions and the following disclaimer in the\r\n *     documentation and/or other materials provided with the distribution.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE HAXE PROJECT CONTRIBUTORS \"AS IS\" AND ANY\r\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL THE HAXE PROJECT CONTRIBUTORS BE LIABLE FOR\r\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\r\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\r\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\r\n * DAMAGE.\r\n */\r\npackage snow.utils.format.tools;\r\n\r\nclass Deflate {\r\n\r\n\tpublic static function run( b : haxe.io.Bytes ) : haxe.io.Bytes {\r\n\t\t#if neko\r\n\t\treturn neko.zip.Compress.run(b,9);\r\n\t\t#elseif flash9\r\n\t\tvar bytes = b.sub(0,b.length);\r\n\t\tvar data = bytes.getData();\r\n\t\tdata.compress();\r\n\t\treturn haxe.io.Bytes.ofData(data);\r\n\t\t#elseif cpp\r\n\t\treturn cpp.zip.Compress.run(b,9);\r\n\t\t#else\r\n\t\tthrow \"Deflate is not supported on this platform\";\r\n\t\treturn null;\r\n\t\t#end\r\n\t}\r\n\r\n}","/*\r\n * format - haXe File Formats\r\n *\r\n *  inflate format decompression algorithm\r\n *  Copyright (C) 2004-2008 Nicolas Cannasse\r\n *  Compliant with RFC 1950 and 1951\r\n *\r\n * Copyright (c) 2008, The haXe Project Contributors\r\n * All rights reserved.\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n *   - Redistributions of source code must retain the above copyright\r\n *     notice, this list of conditions and the following disclaimer.\r\n *   - Redistributions in binary form must reproduce the above copyright\r\n *     notice, this list of conditions and the following disclaimer in the\r\n *     documentation and/or other materials provided with the distribution.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE HAXE PROJECT CONTRIBUTORS \"AS IS\" AND ANY\r\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL THE HAXE PROJECT CONTRIBUTORS BE LIABLE FOR\r\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\r\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\r\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\r\n * DAMAGE.\r\n */\r\npackage snow.utils.format.tools;\r\n\r\nenum Huffman {\r\n\tFound( i : Int );\r\n\tNeedBit( left : Huffman, right : Huffman );\r\n\tNeedBits( n : Int, table : Array<Huffman> );\r\n}\r\n\r\nclass HuffTools {\r\n\r\n\tpublic function new() {\r\n\t}\r\n\r\n\tfunction treeDepth(t) {\r\n\t\treturn switch(t) {\r\n\t\tcase Found(_): 0;\r\n\t\tcase NeedBits(_,_): throw \"assert\";\r\n\t\tcase NeedBit(a,b):\r\n\t\t\tvar da = treeDepth(a);\r\n\t\t\tvar db = treeDepth(b);\r\n\t\t\t1 + ((da < db) ? da : db);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction treeCompress(t) {\r\n\t\tvar d = treeDepth(t);\r\n\t\tif( d == 0 )\r\n\t\t\treturn t;\r\n\t\tif( d == 1 )\r\n\t\t\treturn switch( t ) {\r\n\t\t\tcase NeedBit(a,b): NeedBit(treeCompress(a),treeCompress(b));\r\n\t\t\tdefault: throw \"assert\";\r\n\t\t\t}\r\n\t\tvar size = 1 << d;\r\n\t\tvar table = new Array();\r\n\t\tfor( i in 0...size )\r\n\t\t\ttable.push(Found(-1));\r\n\t\ttreeWalk(table,0,0,d,t);\r\n\t\treturn NeedBits(d,table);\r\n\t}\r\n\r\n\tfunction treeWalk(table,p,cd,d,t) {\r\n\t\tswitch( t ) {\r\n\t\tcase NeedBit(a,b):\r\n\t\t\tif( d > 0 ) {\r\n\t\t\t\ttreeWalk(table,p,cd+1,d-1,a);\r\n\t\t\t\ttreeWalk(table,p|(1<<cd),cd+1,d-1,b);\r\n\t\t\t} else\r\n\t\t\t\ttable[p] = treeCompress(t);\r\n\t\tdefault:\r\n\t\t\ttable[p] = treeCompress(t);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction treeMake( bits : Map<Int,Int>, maxbits : Int, v : Int, len : Int ) {\r\n\t\tif( len > maxbits ) throw \"Invalid huffman\";\r\n\t\tvar idx = (v << 5) | len;\r\n\t\tif( bits.exists(idx) )\r\n\t\t\treturn Found(bits.get(idx));\r\n\t\tv <<= 1;\r\n\t\tlen += 1;\r\n\t\treturn NeedBit(treeMake(bits,maxbits,v,len),treeMake(bits,maxbits,v|1,len));\r\n\t}\r\n\r\n\tpublic function make(lengths,pos,nlengths,maxbits) {\r\n\t\tvar counts = new Array();\r\n\t\tvar tmp = new Array();\r\n\t\tif( maxbits > 32 ) throw \"Invalid huffman\";\r\n\t\tfor( i in 0...maxbits ) {\r\n\t\t\tcounts.push(0);\r\n\t\t\ttmp.push(0);\r\n\t\t}\r\n\t\tfor( i in 0...nlengths ) {\r\n\t\t\tvar p = lengths[i+pos];\r\n\t\t\tif( p >= maxbits ) throw \"Invalid huffman\";\r\n\t\t\tcounts[p]++;\r\n\t\t}\r\n\t\tvar code = 0;\r\n\t\tfor( i in 1...maxbits-1 ) {\r\n\t\t\tcode = (code + counts[i]) << 1;\r\n\t\t\ttmp[i] = code;\r\n\t\t}\r\n\t\tvar bits = new Map();\r\n\t\tfor( i in 0...nlengths ) {\r\n\t\t\tvar l = lengths[i + pos];\r\n\t\t\tif( l != 0 ) {\r\n\t\t\t\tvar n = tmp[l-1];\r\n\t\t\t\ttmp[l-1] = n + 1;\r\n\t\t\t\tbits.set((n << 5) | l,i);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn treeCompress(NeedBit(treeMake(bits,maxbits,0,1),treeMake(bits,maxbits,1,1)));\r\n\t}\r\n}\r\n","/*\r\n * format - haXe File Formats\r\n *\r\n * Copyright (c) 2008, The haXe Project Contributors\r\n * All rights reserved.\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n *   - Redistributions of source code must retain the above copyright\r\n *     notice, this list of conditions and the following disclaimer.\r\n *   - Redistributions in binary form must reproduce the above copyright\r\n *     notice, this list of conditions and the following disclaimer in the\r\n *     documentation and/or other materials provided with the distribution.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE HAXE PROJECT CONTRIBUTORS \"AS IS\" AND ANY\r\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL THE HAXE PROJECT CONTRIBUTORS BE LIABLE FOR\r\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\r\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\r\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\r\n * DAMAGE.\r\n */\r\npackage snow.utils.format.tools;\r\n\r\nclass Inflate {\r\n\r\n\tpublic static function run( bytes : haxe.io.Bytes ) {\r\n\t\t#if neko\r\n\t\treturn neko.zip.Uncompress.run(bytes);\r\n\t\t#elseif cpp\r\n\t\treturn cpp.zip.Uncompress.run(bytes);\r\n\t\t#elseif flash9\r\n\t\tvar b = new flash.utils.ByteArray();\r\n\t\tb.writeBytes(bytes.getData(),0,bytes.length);\r\n\t\tb.uncompress();\r\n\t\treturn haxe.io.Bytes.ofData(b);\r\n\t\t#else\r\n\t\treturn InflateImpl.run(new haxe.io.BytesInput(bytes));\r\n\t\t#end\r\n\t}\r\n\r\n}\r\n","/*\r\n * format - haXe File Formats\r\n *\r\n *  inflate format decompression algorithm\r\n *  Copyright (C) 2004-2008 Nicolas Cannasse\r\n *  Compliant with RFC 1950 and 1951\r\n *\r\n * Copyright (c) 2008, The haXe Project Contributors\r\n * All rights reserved.\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n *   - Redistributions of source code must retain the above copyright\r\n *     notice, this list of conditions and the following disclaimer.\r\n *   - Redistributions in binary form must reproduce the above copyright\r\n *     notice, this list of conditions and the following disclaimer in the\r\n *     documentation and/or other materials provided with the distribution.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE HAXE PROJECT CONTRIBUTORS \"AS IS\" AND ANY\r\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL THE HAXE PROJECT CONTRIBUTORS BE LIABLE FOR\r\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\r\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\r\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\r\n * DAMAGE.\r\n */\r\npackage snow.utils.format.tools;\r\nimport snow.utils.format.tools.Huffman;\r\n\r\nprivate class Window {\r\n\r\n\tpublic static inline var SIZE = 1 << 15;\r\n\tpublic static inline var BUFSIZE = 1 << 16;\r\n\r\n\tpublic var buffer : haxe.io.Bytes;\r\n\tpublic var pos : Int;\r\n\tvar crc : Adler32;\r\n\r\n\tpublic function new(hasCrc) {\r\n\t\tbuffer = haxe.io.Bytes.alloc(BUFSIZE);\r\n\t\tpos = 0;\r\n\t\tif( hasCrc ) crc = new Adler32();\r\n\t}\r\n\r\n\tpublic function slide() {\r\n\t\tif( crc != null ) crc.update(buffer,0,SIZE);\r\n\t\tvar b = haxe.io.Bytes.alloc(BUFSIZE);\r\n\t\tpos -= SIZE;\r\n\t\tb.blit(0,buffer,SIZE,pos);\r\n\t\tbuffer = b;\r\n\t}\r\n\r\n\tpublic function addBytes(b,p,len) {\r\n\t\tif( pos + len > BUFSIZE ) slide();\r\n\t\tbuffer.blit(pos,b,p,len);\r\n\t\tpos += len;\r\n\t}\r\n\r\n\tpublic function addByte(c) {\r\n\t\tif( pos == BUFSIZE ) slide();\r\n\t\tbuffer.set(pos,c);\r\n\t\tpos++;\r\n\t}\r\n\r\n\tpublic function getLastChar() {\r\n\t\treturn buffer.get(pos - 1);\r\n\t}\r\n\r\n\tpublic function available() {\r\n\t\treturn pos;\r\n\t}\r\n\r\n\tpublic function checksum() {\r\n\t\tif( crc != null ) crc.update(buffer,0,pos);\r\n\t\treturn crc;\r\n\t}\r\n\r\n}\r\n\r\nprivate enum State {\r\n\tHead;\r\n\tBlock;\r\n\tCData;\r\n\tFlat;\r\n\tCrc;\r\n\tDist;\r\n\tDistOne;\r\n\tDone;\r\n}\r\n\r\nclass InflateImpl {\r\n\r\n\tstatic var LEN_EXTRA_BITS_TBL = [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,-1,-1];\r\n\tstatic var LEN_BASE_VAL_TBL = [3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258];\r\n\tstatic var DIST_EXTRA_BITS_TBL = [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,-1,-1];\r\n\tstatic var DIST_BASE_VAL_TBL = [1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577];\r\n\tstatic var CODE_LENGTHS_POS = [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];\r\n\r\n\tvar nbits : Int;\r\n\tvar bits : Int;\r\n\tvar state : State;\r\n\tvar final : Bool;\r\n\tvar huffman : Huffman;\r\n\tvar huffdist : Null<Huffman>;\r\n\tvar htools : HuffTools;\r\n\tvar len : Int;\r\n\tvar dist : Int;\r\n\tvar needed : Int;\r\n\tvar output : haxe.io.Bytes;\r\n\tvar outpos : Int;\r\n\tvar input : haxe.io.Input;\r\n\tvar lengths : Array<Int>;\r\n\tvar window : Window;\r\n\r\n\tstatic var FIXED_HUFFMAN = null;\r\n\r\n\tpublic function new( i, ?header = true, ?crc = true ) {\r\n\t\tfinal = false;\r\n\t\thtools = new HuffTools();\r\n\t\thuffman = buildFixedHuffman();\r\n\t\thuffdist = null;\r\n\t\tlen = 0;\r\n\t\tdist = 0;\r\n\t\tstate = header ? Head : Block;\r\n\t\tinput = i;\r\n\t\tbits = 0;\r\n\t\tnbits = 0;\r\n\t\tneeded = 0;\r\n\t\toutput = null;\r\n\t\toutpos = 0;\r\n\t\tlengths = new Array();\r\n\t\tfor( i in 0...19 )\r\n\t\t\tlengths.push(-1);\r\n\t\twindow = new Window(crc);\r\n\t}\r\n\r\n\tfunction buildFixedHuffman() {\r\n\t\tif( FIXED_HUFFMAN != null )\r\n\t\t\treturn FIXED_HUFFMAN;\r\n\t\tvar a = new Array();\r\n\t\tfor( n in 0...288 )\r\n\t\t\ta.push(if( n <= 143 ) 8 else if( n <= 255 ) 9 else if( n <= 279 ) 7 else 8);\r\n\t\tFIXED_HUFFMAN = htools.make(a,0,288,10);\r\n\t\treturn FIXED_HUFFMAN;\r\n\t}\r\n\r\n\tpublic function readBytes(b,pos,len) {\r\n\t\tneeded = len;\r\n\t\toutpos = pos;\r\n\t\toutput = b;\r\n\t\tif( len > 0 )\r\n\t\t\twhile( inflateLoop() ) {\r\n\t\t\t}\r\n\t\treturn len - needed;\r\n\t}\r\n\r\n\tfunction getBits(n) {\r\n\t\twhile( nbits < n ) {\r\n\t\t\tbits |= input.readByte() << nbits;\r\n\t\t\tnbits += 8;\r\n\t\t}\r\n\t\tvar b = bits & ((1 << n) - 1);\r\n\t\tnbits -= n;\r\n\t\tbits >>= n;\r\n\t\treturn b;\r\n\t}\r\n\r\n\tfunction getBit() {\r\n\t\tif( nbits == 0 ) {\r\n\t\t\tnbits = 8;\r\n\t\t\tbits = input.readByte();\r\n\t\t}\r\n\t\tvar b = bits & 1 == 1;\r\n\t\tnbits--;\r\n\t\tbits >>= 1;\r\n\t\treturn b;\r\n\t}\r\n\r\n\tfunction getRevBits(n) {\r\n\t\treturn if( n == 0 )\r\n\t\t\t0\r\n\t\telse if( getBit() )\r\n\t\t\t(1 << (n - 1)) | getRevBits(n-1)\r\n\t\telse\r\n\t\t\tgetRevBits(n-1);\r\n\t}\r\n\r\n\tfunction resetBits() {\r\n\t\tbits = 0;\r\n\t\tnbits = 0;\r\n\t}\r\n\r\n\tfunction addBytes(b,p,len) {\r\n\t\twindow.addBytes(b,p,len);\r\n\t\toutput.blit(outpos,b,p,len);\r\n\t\tneeded -= len;\r\n\t\toutpos += len;\r\n\t}\r\n\r\n\tfunction addByte(b) {\r\n\t\twindow.addByte(b);\r\n\t\toutput.set(outpos,b);\r\n\t\tneeded--;\r\n\t\toutpos++;\r\n\t}\r\n\r\n\tfunction addDistOne(n) {\r\n\t\tvar c = window.getLastChar();\r\n\t\tfor( i in 0...n )\r\n\t\t\taddByte(c);\r\n\t}\r\n\r\n\tfunction addDist(d,len) {\r\n\t\taddBytes(window.buffer,window.pos - d,len);\r\n\t}\r\n\r\n\tfunction applyHuffman(h) {\r\n\t\treturn switch(h) {\r\n\t\tcase Found(n): n;\r\n\t\tcase NeedBit(a,b): applyHuffman(getBit()?b:a);\r\n\t\tcase NeedBits(n,tbl): applyHuffman(tbl[getBits(n)]);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction inflateLengths(a,max) {\r\n\t\tvar i = 0;\r\n\t\tvar prev = 0;\r\n\t\twhile( i < max ) {\r\n\t\t\tvar n = applyHuffman(huffman);\r\n\t\t\tswitch( n ) {\r\n\t\t\tcase 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15:\r\n\t\t\t\tprev = n;\r\n\t\t\t\ta[i] = n;\r\n\t\t\t\ti++;\r\n\t\t\tcase 16:\r\n\t\t\t\tvar end = i + 3 + getBits(2);\r\n\t\t\t\tif( end > max ) throw \"Invalid data\";\r\n\t\t\t\twhile( i < end ) {\r\n\t\t\t\t\ta[i] = prev;\r\n\t\t\t\t\ti++;\r\n\t\t\t\t}\r\n\t\t\tcase 17:\r\n\t\t\t\ti += 3 + getBits(3);\r\n\t\t\t\tif( i > max ) throw \"Invalid data\";\r\n\t\t\tcase 18:\r\n\t\t\t\ti += 11 + getBits(7);\r\n\t\t\t\tif( i > max ) throw \"Invalid data\";\r\n\t\t\tdefault:\r\n\t\t\t\tthrow \"Invalid data\";\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction inflateLoop() {\r\n\t\tswitch( state ) {\r\n\t\tcase Head:\r\n\t\t\tvar cmf = input.readByte();\r\n\t\t\tvar cm = cmf & 15;\r\n\t\t\tvar cinfo = cmf >> 4;\r\n\t\t\tif( cm != 8 || cinfo != 7 ) throw \"Invalid data\";\r\n\t\t\tvar flg = input.readByte();\r\n\t\t\t//var fcheck = flg & 31;\r\n\t\t\tvar fdict = flg & 32 != 0;\r\n\t\t\t//var flevel = flg >> 6;\r\n\t\t\tif( ((cmf << 8) + flg) % 31 != 0 ) throw \"Invalid data\";\r\n\t\t\tif( fdict ) throw \"Unsupported dictionary\";\r\n\t\t\tstate = Block;\r\n\t\t\treturn true;\r\n\t\tcase Crc:\r\n\t\t\tvar calc = window.checksum();\r\n\t\t\tif( calc == null ) {\r\n\t\t\t\tstate = Done;\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\tvar crc = Adler32.read(input);\r\n\t\t\tif( !calc.equals(crc) ) throw \"Invalid CRC\";\r\n\t\t\tstate = Done;\r\n\t\t\treturn true;\r\n\t\tcase Done:\r\n\t\t\t// nothing\r\n\t\t\treturn false;\r\n\t\tcase Block:\r\n\t\t\tfinal = getBit();\r\n\t\t\tswitch( getBits(2) ) {\r\n\t\t\tcase 0: // no compression\r\n\t\t\t\tlen = input.readUInt16();\r\n\t\t\t\tvar nlen = input.readUInt16();\r\n\t\t\t\tif( nlen != 0xFFFF - len ) throw \"Invalid data\";\r\n\t\t\t\tstate = Flat;\r\n\t\t\t\tvar r = inflateLoop();\r\n\t\t\t\tresetBits();\r\n\t\t\t\treturn r;\r\n\t\t\tcase 1: // fixed Huffman\r\n\t\t\t\thuffman = buildFixedHuffman();\r\n\t\t\t\thuffdist = null;\r\n\t\t\t\tstate = CData;\r\n\t\t\t\treturn true;\r\n\t\t\tcase 2: // dynamic Huffman\r\n\t\t\t\tvar hlit = getBits(5) + 257;\r\n\t\t\t\tvar hdist = getBits(5) + 1;\r\n\t\t\t\tvar hclen = getBits(4) + 4;\r\n\t\t\t\tfor( i in 0...hclen )\r\n\t\t\t\t\tlengths[CODE_LENGTHS_POS[i]] = getBits(3);\r\n\t\t\t\tfor( i in hclen...19 )\r\n\t\t\t\t\tlengths[CODE_LENGTHS_POS[i]] = 0;\r\n\t\t\t\thuffman = htools.make(lengths,0,19,8);\r\n\t\t\t\tvar lengths = new Array();\r\n\t\t\t\tfor( i in 0...hlit + hdist )\r\n\t\t\t\t\tlengths.push(0);\r\n\t\t\t\tinflateLengths(lengths,hlit + hdist);\r\n\t\t\t\thuffdist = htools.make(lengths,hlit,hdist,16);\r\n\t\t\t\thuffman = htools.make(lengths,0,hlit,16);\r\n\t\t\t\tstate = CData;\r\n\t\t\t\treturn true;\r\n\t\t\tdefault:\r\n\t\t\t\tthrow \"Invalid data\";\r\n\t\t\t}\r\n\t\tcase Flat:\r\n\t\t\tvar rlen = (len < needed) ? len : needed;\r\n\t\t\tvar bytes = input.read(rlen);\r\n\t\t\tlen -= rlen;\r\n\t\t\taddBytes(bytes,0,rlen);\r\n\t\t\tif( len == 0 ) state = final ? Crc : Block;\r\n\t\t\treturn needed > 0;\r\n\t\tcase DistOne:\r\n\t\t\tvar rlen = (len < needed) ? len : needed;\r\n\t\t\taddDistOne(rlen);\r\n\t\t\tlen -= rlen;\r\n\t\t\tif( len == 0 ) state = CData;\r\n\t\t\treturn needed > 0;\r\n\t\tcase Dist:\r\n\t\t\twhile( len > 0 && needed > 0 ) {\r\n\t\t\t\tvar rdist = (len < dist) ? len : dist;\r\n\t\t\t\tvar rlen = (needed < rdist) ? needed : rdist;\r\n\t\t\t\taddDist(dist,rlen);\r\n\t\t\t\tlen -= rlen;\r\n\t\t\t}\r\n\t\t\tif( len == 0 ) state = CData;\r\n\t\t\treturn needed > 0;\r\n\t\tcase CData:\r\n\t\t\tvar n = applyHuffman(huffman);\r\n\t\t\tif( n < 256 ) {\r\n\t\t\t\taddByte(n);\r\n\t\t\t\treturn needed > 0;\r\n\t\t\t} else if( n == 256 ) {\r\n\t\t\t\tstate = final ? Crc : Block;\r\n\t\t\t\treturn true;\r\n\t\t\t} else {\r\n\t\t\t\tn -= 257;\r\n\t\t\t\tvar extra_bits = LEN_EXTRA_BITS_TBL[n];\r\n\t\t\t\tif( extra_bits == -1 ) throw \"Invalid data\";\r\n\t\t\t\tlen = LEN_BASE_VAL_TBL[n] + getBits(extra_bits);\r\n\t\t\t\tvar dist_code = if( huffdist == null ) getRevBits(5) else applyHuffman(huffdist);\r\n\t\t\t\textra_bits = DIST_EXTRA_BITS_TBL[dist_code];\r\n\t\t\t\tif( extra_bits == -1 ) throw \"Invalid data\";\r\n\t\t\t\tdist = DIST_BASE_VAL_TBL[dist_code] + getBits(extra_bits);\r\n\t\t\t\tif( dist > window.available() ) throw \"Invalid data\";\r\n\t\t\t\tstate = (dist == 1) ? DistOne : Dist;\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static function run( i : haxe.io.Input, ?bufsize = 65536 ) {\r\n\t\tvar buf = haxe.io.Bytes.alloc(bufsize);\r\n\t\tvar output = new haxe.io.BytesBuffer();\r\n\t\tvar inflate = new InflateImpl(i);\r\n\t\twhile( true ) {\r\n\t\t\tvar len = inflate.readBytes(buf,0,bufsize);\r\n\t\t\toutput.addBytes(buf,0,len);\r\n\t\t\tif( len < bufsize )\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\treturn output.getBytes();\r\n\t}\r\n\r\n}\r\n","package snow.window;\r\n\r\nimport snow.types.Types;\r\nimport snow.window.Windowing;\r\n\r\nimport snow.render.opengl.GL;\r\n\r\nimport snow.Log.log;\r\nimport snow.Log._debug;\r\nimport snow.Log._verbose;\r\nimport snow.Log._verboser;\r\n\r\n    //A window has it's own event loop\r\n    //and allows opening and closing windows\r\nclass Window {\r\n\r\n        /** the window id, for tracking events to each window */\r\n    public var id : Int;\r\n        /** the manager this window belongs to */\r\n    public var manager : Windowing;\r\n        /** the requested window config */\r\n    public var asked_config : WindowConfig;\r\n        /** the actual returned window config */\r\n    public var config : WindowConfig;\r\n        /** the native window handle */\r\n    public var handle : WindowHandle;\r\n\r\n        /** the window event handler callback */\r\n    public var onevent : WindowEvent->Void;\r\n        /** the window render handler callback */\r\n    public var onrender : Window->Void;\r\n\r\n        /** The window title `(read/write)` */\r\n    @:isVar public var title (get,set) : String = 'snow window';\r\n        /** The window bordered state `(read/write)` */\r\n    @:isVar public var bordered (get,set) : Bool = true;\r\n        /** The window grab state `(read/write)` */\r\n    @:isVar public var grab (get,set) : Bool = false;\r\n        /** The window fullscreen state `(read/write)` */\r\n    @:isVar public var fullscreen (get,set) : Bool = false;\r\n\r\n        /** The window position `(read/write)` */\r\n    @:isVar public var x (default,set) : Int = 0;\r\n    @:isVar public var y (default,set) : Int = 0;\r\n    @:isVar public var width (default,set) : Int = 0;\r\n    @:isVar public var height (default,set) : Int = 0;\r\n\r\n        /** The window maximum size `(read/write)` */\r\n    @:isVar public var max_size (get,set) : { x:Int, y:Int };\r\n        /** The window minimum size `(read/write)` */\r\n    @:isVar public var min_size (get,set) : { x:Int, y:Int };\r\n\r\n        /** set this if you want to control when a window calls swap() */\r\n    public var auto_swap : Bool = true;\r\n        /** set this if you want to control when a window calls render() */\r\n    public var auto_render : Bool = true;\r\n        /** A flag for whether this window is open or closed */\r\n    public var closed : Bool = true;\r\n\r\n        //internal minimized flag to avoid rendering when minimized.\r\n        //use on_event for this yourself\r\n    var minimized : Bool = false;\r\n    var internal_position : Bool = false;\r\n    var internal_resize : Bool = false;\r\n\r\n    public function new( _manager:Windowing, _config:WindowConfig ) {\r\n\r\n        max_size    = { x:0, y:0 };\r\n        min_size    = { x:0, y:0 };\r\n\r\n        manager = _manager;\r\n        asked_config = _config;\r\n        config = _config;\r\n\r\n            //default to OS defined window position\r\n        if(config.x == null) {\r\n            config.x = 0x1FFF0000;\r\n        }\r\n\r\n        if(config.y == null) {\r\n            config.y = 0x1FFF0000;\r\n        }\r\n\r\n        manager.platform.create( _manager.lib.config.render, _config, on_window_created );\r\n\r\n    } //new\r\n\r\n    function on_window_created( _handle:WindowHandle, _id:Int, _configs:{ config:WindowConfig, render_config:RenderConfig } ) : Void {\r\n\r\n        id = _id;\r\n        handle = _handle;\r\n\r\n        if(handle == null) {\r\n            log(\"failed to create window\");\r\n            return;\r\n        }\r\n\r\n        closed = false;\r\n            //store the real config\r\n        config = _configs.config;\r\n            //update the render config in the core\r\n        manager.lib.config.render = _configs.render_config;\r\n\r\n            //update the position and size\r\n            //because it updates in the config\r\n            internal_position = true;\r\n        x = config.x;\r\n        y = config.y;\r\n            internal_position = false;\r\n\r\n            internal_resize = true;\r\n        width = config.width;\r\n        height = config.height;\r\n            internal_resize = false;\r\n\r\n        #if mobile\r\n        set_fullscreen(fullscreen);\r\n        #end\r\n\r\n        on_event({\r\n            type:WindowEventType.created,\r\n            window_id : _id,\r\n            timestamp : manager.lib.time,\r\n            event : {}\r\n        });\r\n\r\n        _debug(\"created window with id: \" + id);\r\n        _debug('updating real window config for $id is ' + _configs);\r\n\r\n    } //on_window_created\r\n\r\n    @:noCompletion public function on_event( _event:WindowEvent ) {\r\n\r\n        _verbose(\"window event \" + id + \" / \" + _event.type + \" / \" + _event.event );\r\n\r\n        switch(_event.type) {\r\n\r\n            case WindowEventType.moved : {\r\n\r\n                    internal_position = true;\r\n                set_position(_event.event.x, _event.event.y);\r\n                    internal_position = false;\r\n\r\n            } //moved\r\n\r\n            case WindowEventType.resized : {\r\n\r\n                    internal_resize = true;\r\n                set_size(_event.event.x, _event.event.y);\r\n                    internal_resize = false;\r\n\r\n            } //resized\r\n\r\n            case WindowEventType.size_changed : {\r\n\r\n                    internal_resize = true;\r\n                set_size(_event.event.x, _event.event.y);\r\n                    internal_resize = false;\r\n\r\n            } //size_changed\r\n\r\n            case WindowEventType.minimized : {\r\n\r\n                minimized = true;\r\n\r\n            } //minimized\r\n\r\n            case WindowEventType.restored : {\r\n\r\n                minimized = false;\r\n\r\n            } //restored\r\n\r\n            default: {}\r\n\r\n        } //switch\r\n\r\n        if(onevent != null) {\r\n            onevent( _event );\r\n        }\r\n\r\n    } //on_event\r\n\r\n    @:noCompletion public function update() {\r\n\r\n        if(handle != null && !closed) {\r\n            manager.platform.update( this );\r\n        }\r\n\r\n    } //update\r\n\r\n\r\n        /** Called for you automatically, unless auto_render is disabled. */\r\n    public function render() {\r\n\r\n        if(minimized || closed) {\r\n            return;\r\n        }\r\n\r\n        if(handle == null) {\r\n            return;\r\n        }\r\n\r\n        manager.platform.render( this );\r\n\r\n        if(onrender != null) {\r\n\r\n            onrender( this );\r\n\r\n            if(auto_swap) {\r\n                swap();\r\n            }\r\n\r\n            return;\r\n\r\n        } //has render handler\r\n\r\n            //If it doesn't have a render handler\r\n            //Render a red color so the user can tell\r\n\r\n        GL.clearColor( 0.8, 0.12, 0.12, 1.0 );\r\n        GL.clear(GL.COLOR_BUFFER_BIT);\r\n\r\n        if(auto_swap) {\r\n            swap();\r\n        }\r\n\r\n    } //render\r\n\r\n        /** Swap the back buffer of the window, call after rendering to update the window view */\r\n    public function swap() {\r\n\r\n        if(handle == null || closed || minimized) {\r\n            return;\r\n        }\r\n\r\n        manager.platform.swap( this );\r\n\r\n    } //swap\r\n\r\n        /** Destroy the window. To recreate it create must be used, show will not work. */\r\n    public function destroy() {\r\n\r\n        closed = true;\r\n\r\n        if(handle == null) {\r\n            return;\r\n        }\r\n            //remove from the internal list\r\n        manager.remove(this);\r\n            //destroy system window\r\n        manager.platform.destroy_window( this );\r\n            //clear handle as it's invalid\r\n        handle = null;\r\n\r\n    } //destroy\r\n\r\n        /** Close the window, hiding it (not destroying it). Calling show() will unhide it. */\r\n    public function close() {\r\n\r\n        closed = true;\r\n\r\n        if(handle == null) {\r\n            return;\r\n        }\r\n\r\n        manager.platform.close( this );\r\n\r\n    } //close\r\n\r\n        /** Show the window, unhiding it. If destroyed, nothing happens. */\r\n    public function show() {\r\n\r\n        if(handle == null) {\r\n            return;\r\n        }\r\n\r\n        closed = false;\r\n\r\n        manager.platform.show( this );\r\n\r\n    } //show\r\n\r\n        /** Display a cross platform message on this window */\r\n    public function simple_message( message:String, title:String=\"\" ) {\r\n\r\n        if(handle == null) {\r\n            return;\r\n        }\r\n\r\n        manager.platform.simple_message( this, message, title );\r\n\r\n    } //simple_message\r\n\r\n    function get_fullscreen() : Bool {\r\n\r\n        return fullscreen;\r\n\r\n    } //get_fullscreen\r\n\r\n\r\n    function set_fullscreen( _enable:Bool ) {\r\n\r\n        if(handle != null) {\r\n            manager.platform.fullscreen( this, _enable );\r\n        }\r\n\r\n        return fullscreen = _enable;\r\n\r\n    } //set_fullscreen\r\n\r\n    function get_bordered() : Bool {\r\n\r\n        return bordered;\r\n\r\n    } //get_bordered\r\n\r\n    function get_grab() : Bool {\r\n\r\n        return grab;\r\n\r\n    } //get_grab\r\n\r\n    function get_max_size() : { x:Int, y:Int } {\r\n\r\n        return max_size;\r\n\r\n    } //get_max_size\r\n\r\n    function get_min_size() : { x:Int, y:Int } {\r\n\r\n        return min_size;\r\n\r\n    } //get_min_size\r\n\r\n    function get_title() : String {\r\n\r\n        return title;\r\n\r\n    } //get_title\r\n\r\n    function set_title( _title:String ) {\r\n\r\n        if(handle != null) {\r\n            manager.platform.set_title( this, _title );\r\n        }\r\n\r\n        return title = _title;\r\n\r\n    } //set_title\r\n\r\n    function set_x( _x:Int ) : Int {\r\n\r\n        x = _x;\r\n\r\n        if(handle != null && !internal_position) {\r\n            manager.platform.set_position( this, x, y );\r\n        }\r\n\r\n        return x;\r\n\r\n    } //set_x\r\n\r\n    function set_y( _y:Int ) : Int {\r\n\r\n        y = _y;\r\n\r\n        if(handle != null && !internal_position) {\r\n            manager.platform.set_position( this, x, y );\r\n        }\r\n\r\n        return y;\r\n\r\n    } //set_y\r\n\r\n    function set_width( _width:Int ) : Int {\r\n\r\n        width = _width;\r\n\r\n        if(handle != null && !internal_resize) {\r\n            manager.platform.set_size( this, width, height );\r\n        }\r\n\r\n        return width;\r\n\r\n    } //set_width\r\n\r\n    function set_height( _height:Int ) : Int {\r\n\r\n        height = _height;\r\n\r\n        if(handle != null && !internal_resize) {\r\n            manager.platform.set_size( this, width, height );\r\n        }\r\n\r\n        return height;\r\n\r\n    } //set_height\r\n\r\n    public function set_cursor_position( _x:Int, _y:Int ) {\r\n\r\n        if(handle != null && !closed) {\r\n            manager.platform.set_cursor_position( this, _x, _y );\r\n        }\r\n\r\n    } //set_cursor_position\r\n\r\n    public function set_position( _x:Int, _y:Int ) {\r\n\r\n            //keep the flag\r\n        var last_internal_position_flag = internal_position;\r\n\r\n            //force true\r\n        internal_position = true;\r\n            x = _x;\r\n            y = _y;\r\n        internal_position = last_internal_position_flag;\r\n\r\n            //this is never called\r\n        if(handle != null && !internal_position) {\r\n            manager.platform.set_position( this, x, y );\r\n        }\r\n\r\n    } //set_position\r\n\r\n    public function set_size( _width:Int, _height:Int ) {\r\n\r\n            //keep the flag\r\n        var last_internal_resize_flag = internal_resize;\r\n\r\n            //force true\r\n        internal_resize = true;\r\n            width = _width;\r\n            height = _height;\r\n        internal_resize = last_internal_resize_flag;\r\n\r\n        if(handle != null && !internal_resize) {\r\n            manager.platform.set_size( this, _width, _height );\r\n        }\r\n\r\n    } //set_size\r\n\r\n    function set_max_size( _size:{ x:Int, y:Int } ) : { x:Int, y:Int } {\r\n\r\n        if(max_size != null && handle != null) {\r\n            manager.platform.set_max_size( this, _size.x, _size.y );\r\n        }\r\n\r\n        return max_size = _size;\r\n\r\n    } //set_max_size\r\n\r\n    function set_min_size( _size: { x:Int, y:Int } ) : { x:Int, y:Int } {\r\n\r\n        if(min_size != null && handle != null) {\r\n            manager.platform.set_min_size( this, _size.x, _size.y );\r\n        }\r\n\r\n        return min_size = _size;\r\n\r\n    } //set_min_size\r\n\r\n    function set_bordered( _bordered:Bool ) : Bool {\r\n\r\n        if(handle != null) {\r\n            manager.platform.bordered( this, _bordered );\r\n        }\r\n\r\n        return bordered = _bordered;\r\n\r\n    } //set_bordered\r\n\r\n    function set_grab( _grab:Bool ) : Bool {\r\n\r\n        if(handle != null) {\r\n            manager.platform.grab( this, _grab );\r\n        }\r\n\r\n        return grab = _grab;\r\n\r\n    } //set_grab\r\n\r\n} //Window\r\n","package snow.window;\r\n\r\nimport snow.types.Types;\r\nimport snow.window.Window;\r\nimport snow.utils.Libs;\r\n\r\nimport snow.window.WindowSystem;\r\n\r\n\r\n\r\n/** A window manager, accessed via `app.window` */\r\nclass Windowing {\r\n\r\n        /** The list of windows in this manager */\r\n    public var window_list : Map<Int, Window>;\r\n        /** The list of window handles, pointing to id's in the `window_list` */\r\n    public var window_handles : WindowHandleMap;\r\n        /** The number of windows in this manager */\r\n    public var window_count : Int = 0;\r\n\r\n        /** access to snow for subsystems/windows */\r\n    @:noCompletion public var lib : Snow;\r\n        /** The concrete implementation of the window system */\r\n    @:noCompletion public var platform : WindowSystem;\r\n\r\n\r\n        /** constructed internally, use `app.windowing` */\r\n    @:noCompletion public function new( _lib:Snow ) {\r\n\r\n        lib = _lib;\r\n        window_list = new Map();\r\n        window_handles = new WindowHandleMap();\r\n\r\n        platform = new WindowSystem(this, lib);\r\n\r\n        platform.init();\r\n\r\n    } //new\r\n\r\n//Public facing API\r\n\r\n        /** Create a window with the given config. */\r\n    public function create( _config:WindowConfig ) : Window {\r\n\r\n        var _window = new Window( this, _config );\r\n\r\n            window_list.set( _window.id, _window );\r\n            window_handles.set( _window.handle, _window.id );\r\n            window_count++;\r\n\r\n            //handle any window system specifics that have to happen\r\n            //to this window when creating it, like enter/leave events\r\n        platform.listen( _window );\r\n\r\n            //unless requested not to, give this window to the input\r\n            //system to listen for events and dispatch them as needed\r\n        if(_config.no_input == null || _config.no_input == false) {\r\n            lib.input.listen( _window );\r\n        }\r\n\r\n        return _window;\r\n\r\n    } //create\r\n\r\n        /** Remove a window from the system, stopping events, etc.\r\n            Called from window.destroy()! Don't use manually unless manually controlling the list. */\r\n    @:noCompletion public function remove( _window:Window ) {\r\n\r\n        window_list.remove( _window.id );\r\n        window_handles.remove( _window.handle );\r\n        window_count--;\r\n\r\n        platform.unlisten( _window );\r\n\r\n        if(_window.config.no_input == null || _window.config.no_input == false) {\r\n            lib.input.unlisten( _window );\r\n        }\r\n\r\n    } //remove\r\n\r\n        /** Get a window instance from an window handle. */\r\n    @:noCompletion public function window_from_handle( _handle:WindowHandle ) : Window {\r\n\r\n        if(window_handles.exists(_handle)) {\r\n            var _id = window_handles.get(_handle);\r\n            return window_list.get(_id);\r\n        }\r\n\r\n        return null;\r\n\r\n    } //window_from_handle\r\n\r\n        /** Get a window instance from an ID. */\r\n    @:noCompletion public function window_from_id( _id:Int ) : Window {\r\n\r\n        return window_list.get(_id);\r\n\r\n    } //window_from_id\r\n\r\n//System helpers\r\n\r\n        /** Toggle vertical refresh. This is not window specific but context wide */\r\n    public function enable_vsync( _enable:Bool ) : Int {\r\n\r\n        return platform.system_enable_vsync(_enable);\r\n\r\n    } //enable_vsync\r\n\r\n        /** Toggle the OS cursor. This is not window specific but application wide, when inside a window, the OS cursor is hidden. */\r\n    public function enable_cursor( _enable:Bool ) : Void {\r\n\r\n        platform.system_enable_cursor(_enable);\r\n\r\n    } //enable_cursor\r\n\r\n        /** Lock the OS cursor to the foreground window. This hides the cursor and prevents it from leaving, reporting relative coordinates. */\r\n    public function enable_cursor_lock( _enable:Bool ) : Void {\r\n\r\n        platform.system_lock_cursor(_enable);\r\n\r\n    } //enable_cursor\r\n\r\n//Desktop API\r\n    //note that these only make sense on some platforms but will\r\n    //try and return valid values either way. Use the window itself for info\r\n\r\n        /** Get the number of displays present */\r\n    public function display_count() : Int {\r\n        return platform.display_count();\r\n    } //display_count\r\n\r\n        /** Get the number of display modes present */\r\n    public function display_mode_count( display:Int ) : Int {\r\n        return platform.display_mode_count(display);\r\n    } //display_mode_count\r\n\r\n        /** Get the native mode information of the display by index */\r\n    public function display_native_mode( display:Int ) : DisplayMode {\r\n        return platform.display_native_mode(display);\r\n    } //display_native_mode\r\n\r\n        /** Get the current mode information of the display by index */\r\n    public function display_current_mode( display:Int ) : DisplayMode {\r\n        return platform.display_current_mode(display);\r\n    } //display_current_mode\r\n\r\n        /** Get the information from a specific mode index, the index is obtained by iterating with a `display_mode_count` as the loop value */\r\n    public function display_mode( display:Int, mode_index:Int ) : DisplayMode {\r\n        return platform.display_mode(display, mode_index);\r\n    } //display_mode\r\n\r\n        /** Get the bounds of the display by index */\r\n    public function display_bounds( display:Int ) : { x:Int, y:Int, width:Int, height:Int } {\r\n        return platform.display_bounds(display);\r\n    } //display_bounds\r\n\r\n        /** Get the name of the display by index, where available */\r\n    public function display_name( display:Int ) : String {\r\n        return platform.display_name(display);\r\n    } //display_name\r\n\r\n\r\n//Internal core API\r\n\r\n        /** Called by Snow when a system event is dispatched */\r\n    @:allow(snow.Snow)\r\n    function on_event( _event:SystemEvent ) {\r\n\r\n        if(_event.type == SystemEventType.window) {\r\n\r\n            var _window_event = _event.window;\r\n\r\n            var _window = window_list.get( _window_event.window_id );\r\n\r\n            if(_window != null) {\r\n                _window.on_event( _window_event );\r\n            }\r\n\r\n        } //only window events\r\n\r\n    } //on_event\r\n\r\n        /** Called by Snow, process any window handling */\r\n    @:allow(snow.Snow)\r\n    function update() {\r\n\r\n        platform.process();\r\n\r\n        for(window in window_list) {\r\n            window.update();\r\n        }\r\n\r\n        for(window in window_list) {\r\n            if(window.auto_render) {\r\n                window.render();\r\n            }\r\n        }\r\n\r\n    } //update\r\n\r\n        /** Called by Snow, destroy everything. */\r\n    @:allow(snow.Snow)\r\n    function destroy() {\r\n\r\n        platform.destroy();\r\n\r\n    } //destroy\r\n\r\n\r\n} //Windowing\r\n\r\n\r\n#if snow_web\r\n\r\n    private typedef WindowHandleMap = Map<WindowHandle, Int>;\r\n\r\n#else\r\n\r\n    private class WindowHandleMap extends haxe.ds.BalancedTree<WindowHandle,Int> {\r\n\r\n        override function compare(k1:WindowHandle, k2:WindowHandle) {\r\n            if(k1 == null) return 1;\r\n            if(k2 == null) return 1;\r\n            if(k1 == k2) return 0;\r\n            if(k1 < k2) return -1;\r\n            return 1;\r\n        }\r\n\r\n    } //WindowHandleMap\r\n\r\n#end\r\n","package hxDaedalus.data;\r\n\r\nclass Constants {\r\n    public static inline var EPSILON = 0.01;\r\n    public static inline var EPSILON_SQUARED = 0.0001;\r\n}\r\n/*\r\n@:enum\r\nabstract Constants( Float ) {\r\n    var EPSILON = 0.01;\r\n    var EPSILON_SQUARED = 0.0001;\r\n}\r\n*/"],
"names":[],
"mappings":"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BACA;4BACA;4BACA;4BACA;4BACA;iCACA;sCAaA;mCAGA;6BAKA;iCACA;2BACA;2BACA;2BACA;2BACA;2BACA;2BACA;2BACA;2BACA;2BACA;2BACA;2BACA;2BACA;+BACA;4BACA;4BACA;8BACA;4BACA;6BAGA;4BACA;2BACA;4BACA;6BACA;4BACA;4BACA;gCACA;kCACA;gCAOA;sCACA;sCAGA;sCACA;sCAGA;sCACA;sCACA;sCACA;sCACA;sCACA;sCACA;6BAEA;6BAEA;6BAEA;6BAEA;6BAEA;6BAEA;6BAEA;6BAEA;6BAEA;gCAEA;8BACA;8BACA;6BACA;6BACA;+BACA;iCACA;2BACA;4BACA;kCACA;6BACA;6BACA;6BAEA;8BACA;0CACA;wCACA;oCACA;uCACA;oCACA;qCACA;oCACA;qCACA;8BACA;oCACA;4BACA;4BACA;4BACA;4BACA;4BACA;4BACA;8BACA;gCACA;kCACA;+BACA;kCACA;oCACA;uCACA;sCACA;yCACA;gCACA;+BACA;gCACA;6BACA;iCACA;mCACA;oCACA;mCACA;iCACA;sCACA;sCACA;oCACA;oCACA;gCACA;qCACA;iCACA;gCACA;kCACA;sCACA;6BAEA;8BACA;4BAEA;6BAEA;6BACA;8BACA;4BAEA;6BAEA;4BAKA;iCAOA;iCACA;iCACA;iCACA;iCACA;mCACA;2BACA;4BACA;kCACA;gCACA;iCACA;+BACA;+BACA;kCACA;+BACA;kCACA;oCACA;sCAKA;oCACA;qCAGA;sCAEA;oCACA;kCACA;6BACA;6BACA;4BAEA;4BACA;sCAEH,rCACtC,AAAM,AAAM,AAAM,AAClB,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AAAM,AAAM,AACZ,AACA,AACA,AAAM,AAAM,AAAM,AAAM,AAAM,AAAM,AAAM,AAAM,AAAM,AAAM,AAAM,AAClE,AAAM,AAAM,AAAM,AAAM,AAAM,AAC9B,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AAAM,AAAM,AAAM,AAAM,AAAM,AAAM,AAAM,AAAM,AAAM,AAAM,AAC5D,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AAAM,AACN,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AAAM,AAAM,AAAM,AAAM,AAAM,AAAM,AAAM,AAAM,AAAM,AAAM,AAAM,AAClE,AAAM,AAAM,AAAM,AAAM,AAAM,AAAM,AAAM,AAAM,AAAM,AAAM,AAAM,AAClE,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA;8BAt2BkD;4BAEA;6BACA;gCACA;0BACA;4BACA;8BACA;+BACA;2BACA;8BACA;6BACA;gCACA;4BACA;gCACA;iCACA;+BACA;2BACA;4BACA;4BACA;6BACA;4BACA;4BACA;4BACA;4BACA;4BACA;4BACA;4BACA;4BACA;4BACA;4BACA;4BACA;4BACA;gCACA;2BACA;6BACA;8BACA;+BACA;yBACA;kCAIA;gCACA;mCACA;4BACA;iCACA;gCACA;4BACA;4BACA;4BACA;4BACA;4BACA;4BACA;4BACA;4BACA;4BACA;4BACA;4BACA;4BACA;4BACA;4BACA;4BACA;4BACA;4BACA;4BACA;4BACA;4BACA;4BACA;4BACA;4BACA;4BACA;4BACA;4BACA;+BAEP,9BAAU;yBAEV,xBAAU;yBACV,xBAAU;yBACV,xBAAU;yBACV,xBAAU;yBACV,xBAAU;yBACV,xBAAU;yBACV,xBAAU;yBACV,xBAAU;yBACV,xBAAU;0BACV,zBAAU;0BACV,zBAAU;0BACV,zBAAU;kCAEV,jCAAU;iCACV,hCAAU;4BACV,3BAAU;6BACV,5BAAU;2BACV,1BAAU;6BACV,5BAAU;gCACV;0BACA,zBAAU;+BACV,9BAAU;4BACV,3BAAU;2BACV,1BAAU;2BACV,1BAAU;yBACV,xBAAU;mCAEV,lCAAU;gCACV,/BAAU;kCACV,jCAAU;+BACV,9BAAU;8BACV,7BAAU;+BACV,9BAAU;2BACV,1BAAU;2BACV,1BAAU;2BACV,1BAAU;2BACV,1BAAU;2BACV,1BAAU;2BACV,1BAAU;2BACV,1BAAU;2BACV,1BAAU;2BACV,1BAAU;2BACV,1BAAU;gCACV,/BAAU;kCAEV,jCAAU;4BACV,3BAAU;gCACV,/BAAU;0BACV,zBAAU;0BACV,zBAAU;0BACV,zBAAU;0BACV,zBAAU;0BACV,zBAAU;0BACV,zBAAU;0BACV,zBAAU;0BACV,zBAAU;0BACV,zBAAU;0BACV,zBAAU;0BACV,zBAAU;0BACV,zBAAU;8BACV,7BAAU;2BACV,1BAAU;2BACV,1BAAU;6BACV,5BAAU;2BACV,1BAAU;4BACV,3BAAU;2BACV,1BAAU;0BACV,zBAAU;2BACV,1BAAU;4BACV,3BAAU;2BACV,1BAAU;2BACV,1BAAU;+BACV,9BAAU;iCACV,hCAAU;+BACV,9BAAU;qCACV,pCAAU;+BAEV,9BAAU;6BACV,5BAAU;6BACV,5BAAU;4BACV,3BAAU;4BACV,3BAAU;8BACV,7BAAU;gCACV,/BAAU;0BACV,zBAAU;2BACV,1BAAU;iCACV,hCAAU;4BACV,3BAAU;4BACV,3BAAU;4BAEV,3BAAU;6BACV,5BAAU;yCACV,xCAAU;uCACV,tCAAU;mCACV,lCAAU;sCACV,rCAAU;mCACV,lCAAU;oCACV,nCAAU;mCACV,lCAAU;oCACV,nCAAU;6BACV,5BAAU;mCACV,lCAAU;2BACV,1BAAU;2BACV,1BAAU;2BACV,1BAAU;2BACV,1BAAU;2BACV,1BAAU;2BACV,1BAAU;6BACV,5BAAU;+BACV,9BAAU;iCACV,hCAAU;8BACV,7BAAU;iCACV,hCAAU;mCACV,lCAAU;sCACV,rCAAU;qCACV,pCAAU;wCACV,vCAAU;+BACV,9BAAU;8BACV,7BAAU;+BACV,9BAAU;4BACV,3BAAU;gCACV,/BAAU;kCACV,jCAAU;mCACV,lCAAU;kCACV,jCAAU;gCACV,/BAAU;qCACV,pCAAU;qCACV,pCAAU;mCACV,lCAAU;mCACV,lCAAU;+BACV,9BAAU;oCACV,nCAAU;gCACV,/BAAU;+BACV,9BAAU;iCACV,hCAAU;qCACV,pCAAU;4BAEV,3BAAU;6BACV,5BAAU;2BACV,1BAAU;4BACV,3BAAU;4BACV,3BAAU;6BACV,5BAAU;2BACV,1BAAU;4BACV,3BAAU;2BAEV,1BAAU;gCAEV,/BAAU;gCACV,/BAAU;gCACV,/BAAU;gCACV,/BAAU;gCACV,/BAAU;kCACV,jCAAU;0BACV,zBAAU;2BACV,1BAAU;iCACV,hCAAU;+BACV,9BAAU;gCACV,/BAAU;8BACV,7BAAU;8BACV,7BAAU;iCACV,hCAAU;8BACV,7BAAU;iCACV,hCAAU;mCACV,lCAAU;qCAEV,pCAAU;mCACV,lCAAU;oCACV,nCAAU;qCACV,pCAAU;mCACV,lCAAU;iCACV,hCAAU;4BACV,3BAAU;4BACV,3BAAU;4CchRlB;2CACA;0CACA;+CACA;6CAEA;+CACA;0CACA;2CACA;2CACA;yCACA;4CACA;2CACA;+CACA;6CACA;6CACA;4CAEA;4CACA;2CAEA;2CACA;2CACA;2CACA;2CACA;2CACA;2CACA;2CACA;2CACA;2CACA;kDACA;8CACA;+CACA;iDACA;gDACA;iDACA;yCAEA;yCACA;yCACA;yCACA;yCACA;yCACA;yCACA;yCACA;yCACA;0CACA;0CACA;0CACA;0CACA;0CACA;0CACA;0CACA;0CACA;0CACA;0CACA;0CACA;0CACA;0CACA;0CACA;0CACA;4CAEA;8CACA;+CACA;2CACA;6CACA;8CACA;gDACA;iDACA;gDACA;iDACA;+CACA;2CACA;2CACA;4CACA;gDACA;iDACA;4CACA;gDAEA;iDACA;+CACA;4CAEA;6CACA;4CACA;gDACA;kDACA;mDACA;gDACA;4CACA;2CACA;0DC2NN,zDAAC,AAAe;sDE+BS;wDACA;sDACA;4CAGA;2CACA;+CACA;gDACA;+CACA;oDACA;kDACA;0CAaA;yCACA;+CACA;yDACA;+CACA;yDACA;+CACA;yDACA;+CAKA;yDACA;wDACA;8CAOA;oDACA;wDACA;0DACA;mDAGA;2DACA;mDAGA;mDACA;qDACA;qDACA;oDACA;8DACA;oDACA;8DACA;iDACA;kDAGA;0DACA;0DACA;kEACA;iDAEA;iDACA;kDACA;iDAEA;kDACA;2DAEA;2CAGA;0CACA;oDACA;+CAcA;2CACA;4CACA;kDACA;gDACA;kDACA;yDACA;8DACA;qDACA;8CAGA;kDACA;mDACA;uDACA;mDACA;wCAGA;yCACA;gDAGA;8DACA;8DACA;oDACA;gDACA;iDACA;qDACA;uDACA;gDACA;yDACA;kDACA;kDACA;6DACA;6DACA;iDACA;wDACA;uDACA;uDACA;uDACA;kEACA;kEACA;sDACA;6DACA;4DACA;8CACA;iDACA;uDAEA;qDACA;sDACA;oDACA;sDACA;uDACA;mDACA;8CACA;gDACA;+CACA;gDACA;gDACA;kDACA;0DACA;2DAEA;wDACA;oDACA;6CACA;2DACA;4DACA;gEAQA;+CAGA;6CACA;4CACA;0DAGC;0CAGD;mDACA;2CACA;oDACA;yCACA;kDACA;2CACA;qDAGA;2CACA;yCACA;0CACA;+CACA;qDACA;4DAIA;4DACA;0DACA;qDAGE;mDACA;wDACA;gEACA;yDACA;sEACA;oEACA;6DACA;kEACA;iDACA;mDACA;iDACA;qDACA;sDACA;qDACA;uDACA;8DACA;qDACA;2CAGF;0CACA;2CACA;4CACA;6CACA;8CACA;4CACA;4CACA;0CAIA;6CACA;0CACA;0CACA;4CACA;+CACA;+CACA;4CAGA;8CACA;6CACA;6CAGA;4CACA;4DAKA;2DACA;2DACA;0DACA;wDAGA;wDACA;oDACA;oDACA;gDAGA;6CACA;sDAEA;8DACA;iEACA;iEACA;iEACA;iEACA;iEACA;iEACA;+DACA;8CAGA;8CACA;8CACA;8CACA;8CACA;8CACA;8CACA;8CACA;8CACA;8CACA;+CACA;+CACA;+CACA;+CACA;+CACA;+CACA;+CACA;+CACA;+CACA;+CACA;+CACA;+CACA;+CACA;+CACA;+CACA;+CACA;+CACA;+CACA;+CACA;+CACA;+CACA;+CACA;oDACA;4CAGA;mDACA;qDACA;gDAGA;gDACA;gDACA;8CACA;8CACA;8CACA;0CACA;+CACA;+CACA;+CACA;gDACA;gDACA;gDACA;gDACA;kDACA;iEAGI;8DACA;gEACA;8DACA;oEACA;iEACA;wEACA;+DAGH;kDACA;oDAGD;+CAGA;kDACA;gDACA;6CACA;gDACA;8CACA;iDAGA;kDACA;2CAEA;6CACA;4CACA;uDACA;mDACA;oDACA;mDACA;wDAEA;yDACA;kEACA;2DACA;6DACA;4DACA;6DACA;6DACA;+DACA;wEAEc;wEACA;0EACA;kFACA;uDAEd;sDACA;wDACA;8DACA;0CAEA;0DAEW;uEACA;+EACA;uEACA;6DACA;yDAEX;0DACA;2DACA;mEAEA;yDAGA;oEACA;wDACA;wEACI;2DACJ;4BIldvB;6BACe;kCCrZL;oDO4BhB;uDACG;yDA4DH,xDAAC,AAAE,AAAE,AAAE,AAAE,AAAE,AAAE,AAAE,AAAE,AAAE,AAAE,AAAE,AAAE,AAAE,AAAE,AAAE,AAAE,AAAE,AAAE,AAAE,AAAE,AAAE,AAAE,AAAE,AAAE,AAAE,AAAE,AAAE,AAAE,AAAE,AAAG;uDAChE,tDAAC,AAAE,AAAE,AAAE,AAAE,AAAE,AAAE,AAAE,AAAG,AAAG,AAAG,AAAG,AAAG,AAAG,AAAG,AAAG,AAAG,AAAG,AAAG,AAAG,AAAG,AAAG,AAAG,AAAG,AAAI,AAAI,AAAI,AAAI,AAAI;0DAChF,zDAAC,AAAE,AAAE,AAAE,AAAE,AAAE,AAAE,AAAE,AAAE,AAAE,AAAE,AAAE,AAAE,AAAE,AAAE,AAAE,AAAE,AAAE,AAAE,AAAE,AAAE,AAAE,AAAE,AAAG,AAAG,AAAG,AAAG,AAAG,AAAG,AAAG,AAAG,AAAG;wDAC1E,vDAAC,AAAE,AAAE,AAAE,AAAE,AAAE,AAAE,AAAE,AAAG,AAAG,AAAG,AAAG,AAAG,AAAG,AAAG,AAAI,AAAI,AAAI,AAAI,AAAI,AAAI,AAAK,AAAK,AAAK,AAAK,AAAK,AAAK,AAAK,AAAM,AAAM;uDAC5G,tDAAC,AAAG,AAAG,AAAG,AAAE,AAAE,AAAE,AAAE,AAAE,AAAG,AAAE,AAAG,AAAE,AAAG,AAAE,AAAG,AAAE,AAAG,AAAE;;;;"
}